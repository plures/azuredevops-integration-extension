"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluresVSCodeExtension = void 0;
exports.createPluresExtension = createPluresExtension;
const path = __importStar(require("node:path"));
const node_index_1 = require("../node-index");
const DEFAULT_CONFIG = {
    port: 34567,
    host: "localhost",
    webPort: 34568,
    logLevel: "info",
};
class PluresVSCodeExtension {
    vscode;
    context;
    plures;
    sqlite;
    commandPrefix;
    disposables = [];
    activated = false;
    constructor(vscodeApi, context, options = {}) {
        this.vscode = vscodeApi;
        this.context = context;
        this.commandPrefix = options.commandPrefix ?? "pluresdb";
        const mergedConfig = {
            ...DEFAULT_CONFIG,
            dataDir: path.join(context.globalStorageUri.fsPath, "pluresdb"),
            ...options.config,
        };
        this.plures =
            options.pluresInstance ?? new node_index_1.PluresNode({ config: mergedConfig, autoStart: false });
        this.sqlite =
            options.sqliteInstance ?? new node_index_1.SQLiteCompatibleAPI({ config: mergedConfig, autoStart: false });
        this.setupEventHandlers();
    }
    async activate() {
        if (this.activated) {
            return;
        }
        try {
            await this.plures.start();
            await this.sqlite.start();
            this.registerCommands();
            await this.setupDatabase();
            this.activated = true;
            await this.safeInfo("PluresDB extension activated");
        }
        catch (error) {
            await this.safeError(`Failed to activate PluresDB: ${this.errorMessage(error)}`);
            throw error;
        }
    }
    async deactivate() {
        if (!this.activated) {
            return;
        }
        try {
            await this.sqlite.stop();
            await this.plures.stop();
        }
        finally {
            this.disposeAll();
            this.activated = false;
        }
    }
    getWebUrl() {
        return this.plures.getWebUrl();
    }
    async storeSetting(key, value) {
        return this.sqlite.put(`settings:${key}`, value);
    }
    async getSetting(key) {
        return this.sqlite.getValue(`settings:${key}`);
    }
    async storeDocument(id, content, language, filePath) {
        return this.sqlite.put(`documents:${id}`, {
            content,
            language,
            filePath,
            updatedAt: new Date().toISOString(),
        });
    }
    async searchDocuments(query, limit = 20) {
        return this.sqlite.vectorSearch(query, limit);
    }
    async executeSQL(sql, params = []) {
        return this.sqlite.all(sql, params);
    }
    setupEventHandlers() {
        this.plures.on("started", () => {
            this.safeInfo("PluresDB database started");
        });
        this.plures.on("stopped", () => {
            this.safeInfo("PluresDB database stopped");
        });
        this.plures.on("error", (error) => {
            this.safeError(`PluresDB error: ${this.errorMessage(error)}`);
        });
        this.plures.on("stderr", (output) => {
            const trimmed = output.trim();
            if (trimmed.length > 0) {
                this.safeError(trimmed);
            }
        });
        this.plures.on("stdout", (output) => {
            const trimmed = output.trim();
            if (trimmed.length > 0) {
                this.safeInfo(trimmed);
            }
        });
    }
    registerCommands() {
        const register = (name, factory) => {
            const disposable = this.vscode.commands.registerCommand(`${this.commandPrefix}.${name}`, () => factory());
            this.context.subscriptions.push(disposable);
            this.disposables.push(disposable);
        };
        register("openWebUI", async () => {
            const webUrl = this.getWebUrl();
            await this.vscode.env.openExternal(this.vscode.Uri.parse(webUrl));
        });
        register("executeQuery", async () => {
            const sql = await this.vscode.window.showInputBox({
                prompt: "Enter SQL query",
                placeHolder: "SELECT * FROM users",
            });
            if (!sql)
                return;
            try {
                const result = await this.sqlite.all(sql);
                const doc = await this.vscode.workspace.openTextDocument({
                    content: JSON.stringify(result, null, 2),
                    language: "json",
                });
                await this.vscode.window.showTextDocument(doc);
            }
            catch (error) {
                await this.safeError(`Query failed: ${this.errorMessage(error)}`);
            }
        });
        register("vectorSearch", async () => {
            const query = await this.vscode.window.showInputBox({
                prompt: "Enter search query",
                placeHolder: "machine learning",
            });
            if (!query)
                return;
            try {
                const results = await this.sqlite.vectorSearch(query, 10);
                const doc = await this.vscode.workspace.openTextDocument({
                    content: JSON.stringify(results, null, 2),
                    language: "json",
                });
                await this.vscode.window.showTextDocument(doc);
            }
            catch (error) {
                await this.safeError(`Vector search failed: ${this.errorMessage(error)}`);
            }
        });
        register("storeData", async () => {
            const key = await this.vscode.window.showInputBox({
                prompt: "Enter key",
                placeHolder: "user:123",
            });
            if (!key)
                return;
            const json = await this.vscode.window.showInputBox({
                prompt: "Enter value (JSON)",
                placeHolder: '{"name": "Ada", "email": "ada@example.com"}',
            });
            if (!json)
                return;
            try {
                const value = JSON.parse(json);
                await this.sqlite.put(key, value);
                await this.safeInfo(`Stored data for key: ${key}`);
            }
            catch (error) {
                await this.safeError(`Failed to store data: ${this.errorMessage(error)}`);
            }
        });
        register("retrieveData", async () => {
            const key = await this.vscode.window.showInputBox({
                prompt: "Enter key to retrieve",
                placeHolder: "user:123",
            });
            if (!key)
                return;
            try {
                const value = await this.sqlite.getValue(key);
                if (value) {
                    const doc = await this.vscode.workspace.openTextDocument({
                        content: JSON.stringify(value, null, 2),
                        language: "json",
                    });
                    await this.vscode.window.showTextDocument(doc);
                }
                else {
                    await this.safeInfo("Key not found");
                }
            }
            catch (error) {
                await this.safeError(`Failed to retrieve data: ${this.errorMessage(error)}`);
            }
        });
    }
    async setupDatabase() {
        const statements = [
            `CREATE TABLE IF NOT EXISTS settings (
        key TEXT PRIMARY KEY,
        value TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )`,
            `CREATE TABLE IF NOT EXISTS documents (
        id TEXT PRIMARY KEY,
        content TEXT,
        language TEXT,
        file_path TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )`,
            `CREATE TABLE IF NOT EXISTS search_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        query TEXT,
        results_count INTEGER,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )`,
        ];
        for (const sql of statements) {
            try {
                await this.sqlite.exec(sql);
            }
            catch (error) {
                await this.safeError(`Failed to initialize database: ${this.errorMessage(error)}`);
            }
        }
    }
    disposeAll() {
        for (const disposable of this.disposables.splice(0)) {
            try {
                disposable.dispose();
            }
            catch (_error) {
                // ignore
            }
        }
    }
    async safeInfo(message) {
        try {
            await this.vscode.window.showInformationMessage(message);
        }
        catch (_error) {
            // ignore message failures in headless tests
        }
    }
    async safeError(message) {
        try {
            await this.vscode.window.showErrorMessage(message);
        }
        catch (_error) {
            // ignore message failures in headless tests
        }
    }
    errorMessage(error) {
        if (error instanceof Error) {
            return error.message;
        }
        return String(error);
    }
}
exports.PluresVSCodeExtension = PluresVSCodeExtension;
function createPluresExtension(vscodeApi, context, options = {}) {
    return new PluresVSCodeExtension(vscodeApi, context, options);
}
//# sourceMappingURL=extension.js.map
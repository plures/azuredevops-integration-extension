"use strict";
/**
 * Node.js Entry Point for PluresDB
 * This provides a clean API for VSCode extensions and other Node.js applications
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPluresExtension = exports.PluresVSCodeExtension = exports.default = exports.SQLiteCompatibleAPI = exports.PluresNode = void 0;
const node_events_1 = require("node:events");
const node_child_process_1 = require("node:child_process");
const path = __importStar(require("node:path"));
const fs = __importStar(require("node:fs"));
const os = __importStar(require("node:os"));
const node_process_1 = __importDefault(require("node:process"));
const packageRoot = typeof __dirname !== "undefined" ? path.resolve(__dirname, "..") : node_process_1.default.cwd();
class PluresNode extends node_events_1.EventEmitter {
    process = null;
    config;
    denoPath;
    isRunning = false;
    apiUrl = "";
    constructor(options = {}) {
        super();
        this.config = {
            port: 34567,
            host: "localhost",
            dataDir: path.join(os.homedir(), ".pluresdb"),
            webPort: 34568,
            logLevel: "info",
            ...options.config,
        };
        this.denoPath = options.denoPath || this.findDenoPath();
        if (options.autoStart !== false) {
            this.start();
        }
    }
    findDenoPath() {
        // Try to find Deno in common locations
        const possiblePaths = [
            "deno", // In PATH
            path.join(os.homedir(), ".deno", "bin", "deno"),
            path.join(os.homedir(), ".local", "bin", "deno"),
            "/usr/local/bin/deno",
            "/opt/homebrew/bin/deno",
            "C:\\Users\\" + os.userInfo().username + "\\.deno\\bin\\deno.exe",
            "C:\\Program Files\\deno\\deno.exe",
        ];
        for (const denoPath of possiblePaths) {
            try {
                if (fs.existsSync(denoPath) || this.isCommandAvailable(denoPath)) {
                    return denoPath;
                }
            }
            catch (error) {
                // Continue to next path
            }
        }
        throw new Error("Deno not found. Please install Deno from https://deno.land/");
    }
    isCommandAvailable(command) {
        try {
            require("child_process").execSync(`"${command}" --version`, { stdio: "ignore" });
            return true;
        }
        catch {
            return false;
        }
    }
    async start() {
        if (this.isRunning) {
            return;
        }
        return new Promise((resolve, reject) => {
            try {
                // Ensure data directory exists
                if (!fs.existsSync(this.config.dataDir)) {
                    fs.mkdirSync(this.config.dataDir, { recursive: true });
                }
                const kvPath = path.join(this.config.dataDir, "pluresdb.kv");
                // Find the main.ts file
                const mainTsPath = path.join(packageRoot, "src", "main.ts");
                if (!fs.existsSync(mainTsPath)) {
                    throw new Error("PluresDB main.ts not found. Please ensure the package is properly installed.");
                }
                // Start the Deno process
                const args = [
                    "run",
                    "-A",
                    "--unstable-kv",
                    "--no-lock",
                    mainTsPath,
                    "serve",
                    "--port",
                    this.config.port.toString(),
                    "--host",
                    this.config.host,
                    "--kv",
                    kvPath,
                ];
                this.process = (0, node_child_process_1.spawn)(this.denoPath, args, {
                    stdio: ["pipe", "pipe", "pipe"],
                    cwd: packageRoot,
                });
                this.apiUrl = `http://${this.config.host}:${this.config.port}`;
                // Handle process events
                this.process.on("error", (error) => {
                    this.emit("error", error);
                    reject(error);
                });
                this.process.on("exit", (code) => {
                    this.isRunning = false;
                    this.emit("exit", code);
                });
                // Wait for server to start
                this.waitForServer()
                    .then(() => {
                    this.isRunning = true;
                    this.emit("started");
                    resolve();
                })
                    .catch(reject);
                // Handle stdout/stderr
                this.process.stdout?.on("data", (data) => {
                    const output = data.toString();
                    this.emit("stdout", output);
                });
                this.process.stderr?.on("data", (data) => {
                    const output = data.toString();
                    this.emit("stderr", output);
                });
            }
            catch (error) {
                reject(error);
            }
        });
    }
    async waitForServer(timeout = 20000) {
        const startTime = Date.now();
        while (Date.now() - startTime < timeout) {
            try {
                const response = await fetch(`${this.apiUrl}/api/config`);
                if (response.ok) {
                    return;
                }
            }
            catch (error) {
                // Server not ready yet
            }
            await new Promise((resolve) => setTimeout(resolve, 100));
        }
        throw new Error("Server failed to start within timeout");
    }
    async stop() {
        if (!this.isRunning || !this.process) {
            return;
        }
        return new Promise((resolve) => {
            this.process.kill("SIGTERM");
            this.process.on("exit", () => {
                this.isRunning = false;
                this.emit("stopped");
                resolve();
            });
            // Force kill after 5 seconds
            setTimeout(() => {
                if (this.process && this.isRunning) {
                    this.process.kill("SIGKILL");
                }
                resolve();
            }, 5000);
        });
    }
    getApiUrl() {
        return this.apiUrl;
    }
    getWebUrl() {
        return `http://${this.config.host}:${this.config.webPort}`;
    }
    isServerRunning() {
        return this.isRunning;
    }
    // SQLite-compatible API methods
    async query(sql, params = []) {
        const response = await fetch(`${this.apiUrl}/api/query`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ sql, params }),
        });
        if (!response.ok) {
            throw new Error(`Query failed: ${response.statusText}`);
        }
        return response.json();
    }
    async put(key, value) {
        const response = await fetch(`${this.apiUrl}/api/data`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ key, value }),
        });
        if (!response.ok) {
            throw new Error(`Put failed: ${response.statusText}`);
        }
    }
    async get(key) {
        const response = await fetch(`${this.apiUrl}/api/data/${encodeURIComponent(key)}`);
        if (!response.ok) {
            if (response.status === 404) {
                return null;
            }
            throw new Error(`Get failed: ${response.statusText}`);
        }
        return response.json();
    }
    async delete(key) {
        const response = await fetch(`${this.apiUrl}/api/data/${encodeURIComponent(key)}`, {
            method: "DELETE",
        });
        if (!response.ok) {
            throw new Error(`Delete failed: ${response.statusText}`);
        }
    }
    async vectorSearch(query, limit = 10) {
        const response = await fetch(`${this.apiUrl}/api/vsearch`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ query, limit }),
        });
        if (!response.ok) {
            throw new Error(`Vector search failed: ${response.statusText}`);
        }
        return response.json();
    }
    async list(prefix) {
        const url = prefix
            ? `${this.apiUrl}/api/list?prefix=${encodeURIComponent(prefix)}`
            : `${this.apiUrl}/api/list`;
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`List failed: ${response.statusText}`);
        }
        return response.json();
    }
    async getConfig() {
        const response = await fetch(`${this.apiUrl}/api/config`);
        if (!response.ok) {
            throw new Error(`Get config failed: ${response.statusText}`);
        }
        return response.json();
    }
    async setConfig(config) {
        const response = await fetch(`${this.apiUrl}/api/config`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(config),
        });
        if (!response.ok) {
            throw new Error(`Set config failed: ${response.statusText}`);
        }
    }
}
exports.PluresNode = PluresNode;
exports.default = PluresNode;
// SQLite-compatible API for easy migration
class SQLiteCompatibleAPI {
    plures;
    constructor(options) {
        this.plures = new PluresNode(options);
    }
    async start() {
        await this.plures.start();
    }
    async stop() {
        await this.plures.stop();
    }
    // SQLite-compatible methods
    async run(sql, params = []) {
        return this.plures.query(sql, params);
    }
    async get(sql, params = []) {
        const result = await this.plures.query(sql, params);
        return result.rows?.[0] || null;
    }
    async all(sql, params = []) {
        const result = await this.plures.query(sql, params);
        return result.rows || [];
    }
    async exec(sql) {
        return this.plures.query(sql);
    }
    // Additional PluresDB specific methods
    async put(key, value) {
        return this.plures.put(key, value);
    }
    async getValue(key) {
        return this.plures.get(key);
    }
    async delete(key) {
        return this.plures.delete(key);
    }
    async vectorSearch(query, limit = 10) {
        return this.plures.vectorSearch(query, limit);
    }
    async list(prefix) {
        return this.plures.list(prefix);
    }
    getApiUrl() {
        return this.plures.getApiUrl();
    }
    getWebUrl() {
        return this.plures.getWebUrl();
    }
    isRunning() {
        return this.plures.isServerRunning();
    }
}
exports.SQLiteCompatibleAPI = SQLiteCompatibleAPI;
__exportStar(require("./types/node-types"), exports);
var extension_1 = require("./vscode/extension");
Object.defineProperty(exports, "PluresVSCodeExtension", { enumerable: true, get: function () { return extension_1.PluresVSCodeExtension; } });
Object.defineProperty(exports, "createPluresExtension", { enumerable: true, get: function () { return extension_1.createPluresExtension; } });
//# sourceMappingURL=node-index.js.map
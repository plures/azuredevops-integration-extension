"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/integrations/svelte.ts
var svelte_exports = {};
__export(svelte_exports, {
  HistoryStateManager: () => HistoryStateManager,
  ReactiveLogicEngine: () => ReactiveLogicEngine,
  createContextStore: () => createContextStore,
  createDerivedStore: () => createDerivedStore,
  createHistoryEngine: () => createHistoryEngine,
  createPraxisStore: () => createPraxisStore,
  createReactiveEngine: () => createReactiveEngine,
  usePraxisContext: () => usePraxisContext,
  usePraxisEngine: () => usePraxisEngine,
  usePraxisSubscription: () => usePraxisSubscription
});
module.exports = __toCommonJS(svelte_exports);

// src/core/reactive-engine.svelte.ts
var $ = __toESM(require("svelte/internal/client"), 1);

// src/core/rules.ts
var PraxisRegistry = class {
  rules = /* @__PURE__ */ new Map();
  constraints = /* @__PURE__ */ new Map();
  /**
   * Register a rule
   */
  registerRule(descriptor) {
    if (this.rules.has(descriptor.id)) {
      throw new Error(`Rule with id "${descriptor.id}" already registered`);
    }
    this.rules.set(descriptor.id, descriptor);
  }
  /**
   * Register a constraint
   */
  registerConstraint(descriptor) {
    if (this.constraints.has(descriptor.id)) {
      throw new Error(`Constraint with id "${descriptor.id}" already registered`);
    }
    this.constraints.set(descriptor.id, descriptor);
  }
  /**
   * Register a module (all its rules and constraints)
   */
  registerModule(module2) {
    for (const rule of module2.rules) {
      this.registerRule(rule);
    }
    for (const constraint of module2.constraints) {
      this.registerConstraint(constraint);
    }
  }
  /**
   * Get a rule by ID
   */
  getRule(id) {
    return this.rules.get(id);
  }
  /**
   * Get a constraint by ID
   */
  getConstraint(id) {
    return this.constraints.get(id);
  }
  /**
   * Get all registered rule IDs
   */
  getRuleIds() {
    return Array.from(this.rules.keys());
  }
  /**
   * Get all registered constraint IDs
   */
  getConstraintIds() {
    return Array.from(this.constraints.keys());
  }
  /**
   * Get all rules
   */
  getAllRules() {
    return Array.from(this.rules.values());
  }
  /**
   * Get all constraints
   */
  getAllConstraints() {
    return Array.from(this.constraints.values());
  }
};

// src/core/protocol.ts
var PRAXIS_PROTOCOL_VERSION = "1.0.0";

// src/core/engine.ts
function safeClone(value) {
  if (value === null || typeof value !== "object") {
    return value;
  }
  if (typeof globalThis.structuredClone === "function") {
    try {
      return globalThis.structuredClone(value);
    } catch {
    }
  }
  if (Array.isArray(value)) {
    return [...value];
  }
  return { ...value };
}
var LogicEngine = class {
  state;
  registry;
  constructor(options) {
    this.registry = options.registry;
    this.state = {
      context: options.initialContext,
      facts: options.initialFacts ?? [],
      meta: options.initialMeta ?? {},
      protocolVersion: PRAXIS_PROTOCOL_VERSION
    };
  }
  /**
   * Get the current state (immutable copy)
   */
  getState() {
    return {
      context: safeClone(this.state.context),
      facts: [...this.state.facts],
      meta: this.state.meta ? safeClone(this.state.meta) : void 0,
      protocolVersion: this.state.protocolVersion
    };
  }
  /**
   * Get the current context
   */
  getContext() {
    return safeClone(this.state.context);
  }
  /**
   * Get current facts
   */
  getFacts() {
    return [...this.state.facts];
  }
  /**
   * Process events through the engine.
   * Applies all registered rules and checks all registered constraints.
   *
   * @param events Events to process
   * @returns Result with new state and diagnostics
   */
  step(events) {
    const config = {
      ruleIds: this.registry.getRuleIds(),
      constraintIds: this.registry.getConstraintIds()
    };
    return this.stepWithConfig(events, config);
  }
  /**
   * Process events with specific rule and constraint configuration.
   *
   * @param events Events to process
   * @param config Step configuration
   * @returns Result with new state and diagnostics
   */
  stepWithConfig(events, config) {
    const diagnostics = [];
    let newState = { ...this.state };
    const newFacts = [];
    for (const ruleId of config.ruleIds) {
      const rule = this.registry.getRule(ruleId);
      if (!rule) {
        diagnostics.push({
          kind: "rule-error",
          message: `Rule "${ruleId}" not found in registry`,
          data: { ruleId }
        });
        continue;
      }
      try {
        const ruleFacts = rule.impl(newState, events);
        newFacts.push(...ruleFacts);
      } catch (error) {
        diagnostics.push({
          kind: "rule-error",
          message: `Error executing rule "${ruleId}": ${error instanceof Error ? error.message : String(error)}`,
          data: { ruleId, error }
        });
      }
    }
    newState = {
      ...newState,
      facts: [...newState.facts, ...newFacts]
    };
    for (const constraintId of config.constraintIds) {
      const constraint = this.registry.getConstraint(constraintId);
      if (!constraint) {
        diagnostics.push({
          kind: "constraint-violation",
          message: `Constraint "${constraintId}" not found in registry`,
          data: { constraintId }
        });
        continue;
      }
      try {
        const result = constraint.impl(newState);
        if (result === false) {
          diagnostics.push({
            kind: "constraint-violation",
            message: `Constraint "${constraintId}" violated`,
            data: { constraintId, description: constraint.description }
          });
        } else if (typeof result === "string") {
          diagnostics.push({
            kind: "constraint-violation",
            message: result,
            data: { constraintId, description: constraint.description }
          });
        }
      } catch (error) {
        diagnostics.push({
          kind: "constraint-violation",
          message: `Error checking constraint "${constraintId}": ${error instanceof Error ? error.message : String(error)}`,
          data: { constraintId, error }
        });
      }
    }
    this.state = newState;
    return {
      state: newState,
      diagnostics
    };
  }
  /**
   * Update the context directly (for exceptional cases).
   * Generally, context should be updated through rules.
   *
   * @param updater Function that produces new context from old context
   */
  updateContext(updater) {
    this.state = {
      ...this.state,
      context: updater(this.state.context)
    };
  }
  /**
   * Add facts directly (for exceptional cases).
   * Generally, facts should be added through rules.
   *
   * @param facts Facts to add
   */
  addFacts(facts) {
    this.state = {
      ...this.state,
      facts: [...this.state.facts, ...facts]
    };
  }
  /**
   * Clear all facts
   */
  clearFacts() {
    this.state = {
      ...this.state,
      facts: []
    };
  }
  /**
   * Reset the engine to initial state
   */
  reset(options) {
    this.state = {
      context: options.initialContext,
      facts: options.initialFacts ?? [],
      meta: options.initialMeta ?? {},
      protocolVersion: PRAXIS_PROTOCOL_VERSION
    };
  }
};
function createPraxisEngine(options) {
  return new LogicEngine(options);
}

// src/core/reactive-engine.svelte.ts
var ReactiveLogicEngine = class {
  #state = (
    // Use Svelte's $state rune for automatic reactivity
    $.state($.proxy({ context: {}, facts: [], meta: {} }))
  );
  get state() {
    return $.get(this.#state);
  }
  set state(value) {
    $.set(this.#state, value, true);
  }
  _engine;
  constructor(options) {
    this.state.context = options.initialContext;
    this.state.facts = options.initialFacts ?? [];
    this.state.meta = options.initialMeta ?? {};
    if (options.registry) {
      this._engine = createPraxisEngine({
        initialContext: options.initialContext,
        registry: options.registry
      });
    } else {
      this._engine = createPraxisEngine({
        initialContext: options.initialContext,
        registry: new PraxisRegistry()
      });
    }
  }
  /**
   * Access the reactive context.
   * In Svelte 5 components, changes to this object will automatically trigger updates.
   */
  get context() {
    return this.state.context;
  }
  /**
   * Access the reactive facts list.
   */
  get facts() {
    return this.state.facts;
  }
  /**
   * Access the reactive metadata.
   */
  get meta() {
    return this.state.meta;
  }
  /**
   * Apply a mutation to the state.
   * Changes will automatically trigger Svelte reactivity.
   * 
   * @param mutator A function that receives the state and modifies it.
   */
  apply(mutator) {
    mutator(this.state);
  }
  /**
   * Process events through the logic engine and update reactive state.
   * 
   * @param events Events to process
   */
  step(events) {
    const result = this._engine.step(events);
    this.state.context = result.state.context;
    this.state.facts = result.state.facts;
    this.state.meta = result.state.meta ?? {};
  }
};
function createReactiveEngine(options) {
  return new ReactiveLogicEngine(options);
}

// src/integrations/svelte.ts
function createPraxisStore(engine) {
  let currentState = engine.getState();
  const subscribers = /* @__PURE__ */ new Set();
  const notify = () => {
    currentState = engine.getState();
    subscribers.forEach((sub) => sub(currentState));
  };
  return {
    subscribe(run) {
      subscribers.add(run);
      run(currentState);
      return () => {
        subscribers.delete(run);
      };
    },
    dispatch(events) {
      engine.step(events);
      notify();
    }
  };
}
function createContextStore(engine) {
  let currentContext = engine.getContext();
  const subscribers = /* @__PURE__ */ new Set();
  const notify = () => {
    currentContext = engine.getContext();
    subscribers.forEach((sub) => sub(currentContext));
  };
  return {
    subscribe(run) {
      subscribers.add(run);
      run(currentContext);
      return () => {
        subscribers.delete(run);
      };
    },
    dispatch(events) {
      engine.step(events);
      notify();
    }
  };
}
function createDerivedStore(engine, selector) {
  let currentValue = selector(engine.getContext());
  const subscribers = /* @__PURE__ */ new Set();
  const notify = () => {
    const newValue = selector(engine.getContext());
    if (newValue !== currentValue) {
      currentValue = newValue;
      subscribers.forEach((sub) => sub(currentValue));
    }
  };
  return {
    subscribe(run) {
      subscribers.add(run);
      run(currentValue);
      return () => {
        subscribers.delete(run);
      };
    },
    dispatch(events) {
      engine.step(events);
      notify();
    }
  };
}
function usePraxisEngine(engine, options = {}) {
  const { enableHistory = false, maxHistorySize = 50 } = options;
  let currentState = engine.getState();
  let snapshots = [];
  let historyIndex = -1;
  if (enableHistory) {
    snapshots.push({
      timestamp: Date.now(),
      state: currentState,
      events: []
    });
    historyIndex = 0;
  }
  const dispatch = (events) => {
    if (enableHistory && historyIndex < snapshots.length - 1) {
      snapshots = snapshots.slice(0, historyIndex + 1);
    }
    engine.step(events);
    currentState = engine.getState();
    if (enableHistory) {
      snapshots.push({
        timestamp: Date.now(),
        state: currentState,
        events
      });
      if (snapshots.length > maxHistorySize) {
        snapshots.shift();
      } else {
        historyIndex++;
      }
    }
  };
  const goToSnapshot = (index) => {
    if (!enableHistory) {
      console.warn("History is not enabled for this engine");
      return;
    }
    if (index < 0 || index >= snapshots.length) {
      console.warn(`Invalid snapshot index: ${index}`);
      return;
    }
    historyIndex = index;
    currentState = snapshots[index].state;
  };
  const undo = () => {
    if (historyIndex > 0) {
      goToSnapshot(historyIndex - 1);
    }
  };
  const redo = () => {
    if (historyIndex < snapshots.length - 1) {
      goToSnapshot(historyIndex + 1);
    }
  };
  return {
    get state() {
      return currentState;
    },
    get context() {
      return currentState.context;
    },
    get facts() {
      return currentState.facts;
    },
    dispatch,
    get snapshots() {
      return snapshots;
    },
    goToSnapshot,
    undo,
    redo,
    get canUndo() {
      return enableHistory && historyIndex > 0;
    },
    get canRedo() {
      return enableHistory && historyIndex < snapshots.length - 1;
    },
    get historyIndex() {
      return historyIndex;
    }
  };
}
function usePraxisContext(engine, selector) {
  let currentValue = selector(engine.getContext());
  return currentValue;
}
function usePraxisSubscription(engine, callback) {
  const store = createPraxisStore(engine);
  const unsubscribe = store.subscribe(callback);
  return unsubscribe;
}
var HistoryStateManager = class {
  history = [];
  currentIndex = -1;
  maxSize;
  idCounter = 0;
  constructor(maxSize = 50) {
    this.maxSize = maxSize;
  }
  /**
   * Record a new history entry
   */
  record(state2, events, label) {
    if (this.currentIndex < this.history.length - 1) {
      this.history = this.history.slice(0, this.currentIndex + 1);
    }
    this.history.push({
      id: `history-${++this.idCounter}`,
      timestamp: Date.now(),
      state: state2,
      events,
      label
    });
    if (this.history.length > this.maxSize) {
      this.history.shift();
    } else {
      this.currentIndex++;
    }
  }
  /**
   * Navigate to a specific history entry
   */
  goTo(index) {
    if (index < 0 || index >= this.history.length) {
      return null;
    }
    this.currentIndex = index;
    return this.history[index];
  }
  /**
   * Go back to previous state
   */
  back() {
    if (!this.canGoBack()) {
      return null;
    }
    return this.goTo(this.currentIndex - 1);
  }
  /**
   * Go forward to next state
   */
  forward() {
    if (!this.canGoForward()) {
      return null;
    }
    return this.goTo(this.currentIndex + 1);
  }
  /**
   * Check if can go back
   */
  canGoBack() {
    return this.currentIndex > 0;
  }
  /**
   * Check if can go forward
   */
  canGoForward() {
    return this.currentIndex < this.history.length - 1;
  }
  /**
   * Get current history entry
   */
  current() {
    if (this.currentIndex < 0 || this.currentIndex >= this.history.length) {
      return null;
    }
    return this.history[this.currentIndex];
  }
  /**
   * Get all history entries
   */
  getHistory() {
    return [...this.history];
  }
  /**
   * Get current index in history
   */
  getCurrentIndex() {
    return this.currentIndex;
  }
  /**
   * Clear all history
   */
  clear() {
    this.history = [];
    this.currentIndex = -1;
  }
};
function createHistoryEngine(engine, options = {}) {
  const history = new HistoryStateManager(options.maxHistorySize);
  history.record(engine.getState(), [], options.initialLabel || "Initial");
  const dispatch = (events, label) => {
    engine.step(events);
    history.record(engine.getState(), events, label);
  };
  const undo = () => {
    const entry = history.back();
    if (entry) {
      return true;
    }
    return false;
  };
  const redo = () => {
    const entry = history.forward();
    if (entry) {
      return true;
    }
    return false;
  };
  return {
    engine,
    dispatch,
    undo,
    redo,
    canUndo: () => history.canGoBack(),
    canRedo: () => history.canGoForward(),
    getHistory: () => history.getHistory(),
    goToHistory: (index) => history.goTo(index) !== null,
    clearHistory: () => history.clear()
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HistoryStateManager,
  ReactiveLogicEngine,
  createContextStore,
  createDerivedStore,
  createHistoryEngine,
  createPraxisStore,
  createReactiveEngine,
  usePraxisContext,
  usePraxisEngine,
  usePraxisSubscription
});

import {
  InMemoryPraxisDB,
  PluresDBPraxisAdapter,
  createInMemoryDB,
  createPluresDB
} from "./chunk-JQ64KMLN.js";
import {
  StateDocsGenerator,
  createStateDocsGenerator,
  generateDocs
} from "./chunk-S54337I5.js";
import {
  canvasToMermaid,
  canvasToSchema,
  canvasToYaml,
  createCanvasEditor,
  schemaToCanvas,
  validateWithGuardian
} from "./chunk-SRM3OPPM.js";
import {
  PraxisRegistry,
  ReactiveLogicEngine,
  createReactiveEngine
} from "./chunk-LE2ZJYFC.js";
import {
  TerminalAdapter,
  createMockExecutor,
  createTerminalAdapter,
  runTerminalCommand
} from "./chunk-N5Y37EUV.js";
import {
  PluresDBGenerator,
  createPluresDBGenerator
} from "./chunk-RJMWCNHR.js";
import {
  loadSchema,
  loadSchemaFromFile,
  loadSchemaFromJson,
  loadSchemaFromYaml,
  validateForGeneration
} from "./chunk-UY7YEBE2.js";
import {
  createSchemaTemplate,
  validateSchema
} from "./chunk-UATVJBNV.js";
import {
  LogicEngine,
  PRAXIS_PROTOCOL_VERSION,
  createPraxisEngine
} from "./chunk-VOMLVI6V.js";
import "./chunk-QGM4M3NI.js";

// src/core/reactive-engine.ts
var ReactiveLogicEngine2 = class _ReactiveLogicEngine {
  _state;
  _subscribers = /* @__PURE__ */ new Set();
  _contextProxy;
  _factsProxy;
  _metaProxy;
  _batchDepth = 0;
  _pendingNotification = false;
  _proxyCache = /* @__PURE__ */ new WeakMap();
  // Array methods that mutate the array
  static ARRAY_MUTATORS = ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"];
  constructor(options) {
    this._state = {
      context: options.initialContext,
      facts: options.initialFacts ?? [],
      meta: options.initialMeta ?? {}
    };
    this._contextProxy = this._createReactiveProxy(this._state.context);
    this._factsProxy = this._createReactiveProxy(this._state.facts);
    this._metaProxy = this._createReactiveProxy(this._state.meta);
  }
  /**
   * Create a reactive proxy that notifies subscribers on changes.
   * Uses a WeakMap cache to avoid creating multiple proxies for the same object.
   */
  _createReactiveProxy(target) {
    const cached = this._proxyCache.get(target);
    if (cached) {
      return cached;
    }
    const self = this;
    const handler = {
      get(obj, prop) {
        const value = Reflect.get(obj, prop);
        if (value && typeof value === "object") {
          return self._createReactiveProxy(value);
        }
        if (Array.isArray(obj) && typeof value === "function") {
          if (_ReactiveLogicEngine.ARRAY_MUTATORS.includes(prop)) {
            return function(...args) {
              const result = value.apply(obj, args);
              self._notify();
              return result;
            };
          }
        }
        return value;
      },
      set(obj, prop, value) {
        const oldValue = obj[prop];
        const result = Reflect.set(obj, prop, value);
        if (oldValue !== value) {
          self._notify();
        }
        return result;
      },
      deleteProperty(obj, prop) {
        const result = Reflect.deleteProperty(obj, prop);
        self._notify();
        return result;
      }
    };
    const proxy = new Proxy(target, handler);
    this._proxyCache.set(target, proxy);
    return proxy;
  }
  /**
   * Notify all subscribers of state changes
   */
  _notify() {
    if (this._batchDepth > 0) {
      this._pendingNotification = true;
      return;
    }
    const currentState = {
      context: this._contextProxy,
      facts: this._factsProxy,
      meta: this._metaProxy
    };
    this._subscribers.forEach((callback) => {
      try {
        callback(currentState);
      } catch (error) {
        console.error("Error in reactive engine subscriber:", error);
      }
    });
  }
  /**
   * Get the full state object
   */
  get state() {
    return {
      context: this._contextProxy,
      facts: this._factsProxy,
      meta: this._metaProxy
    };
  }
  /**
   * Access the reactive context.
   * Changes to this object will trigger subscriber notifications.
   */
  get context() {
    return this._contextProxy;
  }
  /**
   * Access the reactive facts list.
   * Changes to this array will trigger subscriber notifications.
   */
  get facts() {
    return this._factsProxy;
  }
  /**
   * Access the reactive metadata.
   * Changes to this object will trigger subscriber notifications.
   */
  get meta() {
    return this._metaProxy;
  }
  /**
   * Apply a mutation to the state.
   * This is the "Action" or "Rule" equivalent.
   * Mutations are batched - notifications only happen once per apply call.
   * 
   * @param mutator A function that receives the state and modifies it.
   */
  apply(mutator) {
    this._batchDepth++;
    try {
      mutator({
        context: this._contextProxy,
        facts: this._factsProxy,
        meta: this._metaProxy
      });
    } finally {
      this._batchDepth--;
      if (this._batchDepth === 0 && this._pendingNotification) {
        this._pendingNotification = false;
        this._notify();
      }
    }
  }
  /**
   * Subscribe to state changes.
   * Returns an unsubscribe function.
   * 
   * @param callback Function to call when state changes
   * @returns Unsubscribe function
   */
  subscribe(callback) {
    this._subscribers.add(callback);
    try {
      callback({
        context: this._contextProxy,
        facts: this._factsProxy,
        meta: this._metaProxy
      });
    } catch (error) {
      console.error("Error in reactive engine subscriber:", error);
    }
    return () => {
      this._subscribers.delete(callback);
    };
  }
  /**
   * Create a derived/computed value from the state.
   * The selector function will be called whenever the state changes.
   * 
   * @param selector Function to extract derived value from state
   * @returns Object with subscribe method for reactive updates
   */
  $derived(selector) {
    const subscribers = /* @__PURE__ */ new Set();
    let currentValue = selector({
      context: this._contextProxy,
      facts: this._factsProxy,
      meta: this._metaProxy
    });
    this.subscribe(() => {
      const newValue = selector({
        context: this._contextProxy,
        facts: this._factsProxy,
        meta: this._metaProxy
      });
      if (newValue !== currentValue) {
        currentValue = newValue;
        subscribers.forEach((callback) => {
          try {
            callback(currentValue);
          } catch (error) {
            console.error("Error in derived value subscriber:", error);
          }
        });
      }
    });
    return {
      subscribe: (callback) => {
        subscribers.add(callback);
        try {
          callback(currentValue);
        } catch (error) {
          console.error("Error in derived value subscriber:", error);
        }
        return () => {
          subscribers.delete(callback);
        };
      }
    };
  }
};
function createReactiveEngine2(options) {
  return new ReactiveLogicEngine2(options);
}

// src/core/actors.ts
var ActorManager = class {
  actors = /* @__PURE__ */ new Map();
  activeActors = /* @__PURE__ */ new Set();
  engine = null;
  /**
   * Register an actor
   */
  register(actor) {
    if (this.actors.has(actor.id)) {
      throw new Error(`Actor with id "${actor.id}" already registered`);
    }
    this.actors.set(actor.id, actor);
  }
  /**
   * Unregister an actor
   */
  unregister(actorId) {
    if (this.activeActors.has(actorId)) {
      throw new Error(`Cannot unregister active actor "${actorId}". Stop it first.`);
    }
    this.actors.delete(actorId);
  }
  /**
   * Attach the actor manager to an engine
   */
  attachEngine(engine) {
    this.engine = engine;
  }
  /**
   * Start an actor
   */
  async start(actorId) {
    const actor = this.actors.get(actorId);
    if (!actor) {
      throw new Error(`Actor "${actorId}" not found`);
    }
    if (this.activeActors.has(actorId)) {
      throw new Error(`Actor "${actorId}" is already started`);
    }
    if (!this.engine) {
      throw new Error("Actor manager not attached to an engine");
    }
    this.activeActors.add(actorId);
    if (actor.onStart) {
      await actor.onStart(this.engine);
    }
  }
  /**
   * Stop an actor
   */
  async stop(actorId) {
    const actor = this.actors.get(actorId);
    if (!actor) {
      throw new Error(`Actor "${actorId}" not found`);
    }
    if (!this.activeActors.has(actorId)) {
      return;
    }
    this.activeActors.delete(actorId);
    if (actor.onStop) {
      await actor.onStop();
    }
  }
  /**
   * Start all registered actors
   */
  async startAll() {
    const actorIds = Array.from(this.actors.keys());
    for (const actorId of actorIds) {
      if (!this.activeActors.has(actorId)) {
        await this.start(actorId);
      }
    }
  }
  /**
   * Stop all active actors
   */
  async stopAll() {
    const activeIds = Array.from(this.activeActors);
    for (const actorId of activeIds) {
      await this.stop(actorId);
    }
  }
  /**
   * Notify active actors of a state change
   */
  async notifyStateChange(state) {
    if (!this.engine) {
      return;
    }
    const promises = [];
    for (const actorId of this.activeActors) {
      const actor = this.actors.get(actorId);
      if (actor?.onStateChange) {
        const result = actor.onStateChange(state, this.engine);
        if (result instanceof Promise) {
          promises.push(result);
        }
      }
    }
    await Promise.all(promises);
  }
  /**
   * Get all registered actor IDs
   */
  getActorIds() {
    return Array.from(this.actors.keys());
  }
  /**
   * Get all active actor IDs
   */
  getActiveActorIds() {
    return Array.from(this.activeActors);
  }
  /**
   * Check if an actor is active
   */
  isActive(actorId) {
    return this.activeActors.has(actorId);
  }
};
function createTimerActor(id, intervalMs, createEvent) {
  let timerId = null;
  return {
    id,
    description: `Timer actor (${intervalMs}ms) - ${id}`,
    onStart: (engine) => {
      timerId = setInterval(() => {
        engine.step([createEvent()]);
      }, intervalMs);
    },
    onStop: () => {
      if (timerId) {
        clearInterval(timerId);
        timerId = null;
      }
    }
  };
}

// src/core/introspection.ts
var RegistryIntrospector = class {
  constructor(registry) {
    this.registry = registry;
  }
  /**
   * Get basic statistics about the registry
   */
  getStats() {
    return {
      ruleCount: this.registry.getRuleIds().length,
      constraintCount: this.registry.getConstraintIds().length,
      moduleCount: 0,
      // Modules are flattened in registry
      rulesById: this.registry.getRuleIds(),
      constraintsById: this.registry.getConstraintIds()
    };
  }
  /**
   * Generate a JSON schema representation of the registry
   */
  generateSchema(protocolVersion) {
    const rules = this.registry.getAllRules().map((rule) => ({
      id: rule.id,
      description: rule.description,
      type: "rule",
      meta: rule.meta
    }));
    const constraints = this.registry.getAllConstraints().map((constraint) => ({
      id: constraint.id,
      description: constraint.description,
      type: "constraint",
      meta: constraint.meta
    }));
    return {
      protocolVersion,
      rules,
      constraints,
      meta: {
        ruleCount: rules.length,
        constraintCount: constraints.length
      }
    };
  }
  /**
   * Generate a graph representation of the registry
   *
   * This creates nodes for rules and constraints.
   * Edges can be inferred from metadata if rules/constraints
   * document their dependencies.
   */
  generateGraph() {
    const nodes = [];
    const edges = [];
    for (const rule of this.registry.getAllRules()) {
      nodes.push({
        id: rule.id,
        type: "rule",
        description: rule.description,
        meta: rule.meta
      });
      if (rule.meta?.dependsOn) {
        const deps = Array.isArray(rule.meta.dependsOn) ? rule.meta.dependsOn : [rule.meta.dependsOn];
        for (const dep of deps) {
          edges.push({
            from: String(dep),
            to: rule.id,
            type: "depends-on"
          });
        }
      }
    }
    for (const constraint of this.registry.getAllConstraints()) {
      nodes.push({
        id: constraint.id,
        type: "constraint",
        description: constraint.description,
        meta: constraint.meta
      });
      if (constraint.meta?.constrains) {
        const targets = Array.isArray(constraint.meta.constrains) ? constraint.meta.constrains : [constraint.meta.constrains];
        for (const target of targets) {
          edges.push({
            from: constraint.id,
            to: String(target),
            type: "constrains"
          });
        }
      }
    }
    return {
      nodes,
      edges,
      meta: {
        nodeCount: nodes.length,
        ruleCount: nodes.filter((n) => n.type === "rule").length,
        constraintCount: nodes.filter((n) => n.type === "constraint").length
      }
    };
  }
  /**
   * Export graph in DOT format (Graphviz)
   *
   * This can be rendered with Graphviz tools or online services.
   */
  exportDOT() {
    const graph = this.generateGraph();
    const lines = [];
    lines.push("digraph PraxisRegistry {");
    lines.push("  rankdir=TB;");
    lines.push("  node [shape=box, style=rounded];");
    lines.push("");
    for (const node of graph.nodes) {
      const shape = node.type === "rule" ? "box" : "diamond";
      const color = node.type === "rule" ? "lightblue" : "lightcoral";
      const label = `${node.id}\\n${node.description}`;
      lines.push(
        `  "${node.id}" [label="${label}", shape=${shape}, style=filled, fillcolor=${color}];`
      );
    }
    lines.push("");
    for (const edge of graph.edges) {
      const style = edge.type === "constrains" ? "dashed" : "solid";
      lines.push(`  "${edge.from}" -> "${edge.to}" [label="${edge.type}", style=${style}];`);
    }
    lines.push("}");
    return lines.join("\n");
  }
  /**
   * Export graph in Mermaid format
   *
   * Mermaid is a markdown-friendly diagramming language.
   */
  exportMermaid() {
    const graph = this.generateGraph();
    const lines = [];
    lines.push("graph TB");
    for (const node of graph.nodes) {
      const shape = node.type === "rule" ? "[" : "{";
      const endShape = node.type === "rule" ? "]" : "}";
      const label = `${node.id}<br/>${node.description}`;
      lines.push(`  ${node.id}${shape}"${label}"${endShape}`);
    }
    lines.push("");
    for (const edge of graph.edges) {
      const arrow = edge.type === "constrains" ? "-.->|constrains|" : "-->|" + edge.type + "|";
      lines.push(`  ${edge.from} ${arrow} ${edge.to}`);
    }
    return lines.join("\n");
  }
  /**
   * Get detailed information about a specific rule
   */
  getRuleInfo(ruleId) {
    return this.registry.getRule(ruleId);
  }
  /**
   * Get detailed information about a specific constraint
   */
  getConstraintInfo(constraintId) {
    return this.registry.getConstraint(constraintId);
  }
  /**
   * Search for rules by description text
   */
  searchRules(query) {
    const lowerQuery = query.toLowerCase();
    return this.registry.getAllRules().filter(
      (rule) => rule.id.toLowerCase().includes(lowerQuery) || rule.description.toLowerCase().includes(lowerQuery)
    );
  }
  /**
   * Search for constraints by description text
   */
  searchConstraints(query) {
    const lowerQuery = query.toLowerCase();
    return this.registry.getAllConstraints().filter(
      (constraint) => constraint.id.toLowerCase().includes(lowerQuery) || constraint.description.toLowerCase().includes(lowerQuery)
    );
  }
};
function createIntrospector(registry) {
  return new RegistryIntrospector(registry);
}

// src/dsl/index.ts
function defineFact(tag) {
  return {
    tag,
    create(payload) {
      return { tag, payload };
    },
    is(fact) {
      return fact.tag === tag;
    }
  };
}
function defineEvent(tag) {
  return {
    tag,
    create(payload) {
      return { tag, payload };
    },
    is(event) {
      return event.tag === tag;
    }
  };
}
function defineRule(options) {
  return {
    id: options.id,
    description: options.description,
    impl: options.impl,
    meta: options.meta
  };
}
function defineConstraint(options) {
  return {
    id: options.id,
    description: options.description,
    impl: options.impl,
    meta: options.meta
  };
}
function defineModule(options) {
  return {
    rules: options.rules ?? [],
    constraints: options.constraints ?? [],
    meta: options.meta
  };
}
function filterEvents(events, definition) {
  return events.filter(definition.is);
}
function filterFacts(facts, definition) {
  return facts.filter(definition.is);
}
function findEvent(events, definition) {
  return events.find(definition.is);
}
function findFact(facts, definition) {
  return facts.find(definition.is);
}

// src/core/pluresdb/store.ts
var PRAXIS_PATHS = {
  /** Base path for all Praxis data */
  BASE: "/_praxis",
  /** Path for facts storage */
  FACTS: "/_praxis/facts",
  /** Path for events storage */
  EVENTS: "/_praxis/events",
  /** Path for schema registry */
  SCHEMAS: "/_praxis/schemas"
};
function getFactPath(factTag, id) {
  if (id) {
    return `${PRAXIS_PATHS.FACTS}/${factTag}/${id}`;
  }
  return `${PRAXIS_PATHS.FACTS}/${factTag}`;
}
function getEventPath(eventTag) {
  return `${PRAXIS_PATHS.EVENTS}/${eventTag}`;
}
function generateId() {
  return `${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
}
var defaultErrorHandler = (ruleId, error) => {
  if (typeof process !== "undefined" && process.env?.NODE_ENV === "development") {
    console.error(`Error executing rule "${ruleId}":`, error);
  }
};
var PraxisDBStore = class {
  db;
  registry;
  context;
  subscriptions = [];
  factWatchers = /* @__PURE__ */ new Map();
  onRuleError;
  constructor(options) {
    this.db = options.db;
    this.registry = options.registry;
    this.context = options.initialContext ?? {};
    this.onRuleError = options.onRuleError ?? defaultErrorHandler;
  }
  /**
   * Store a fact in PluresDB
   *
   * Facts are stored under `/_praxis/facts/<factTag>/<id>`
   * If no id is provided in the payload, a timestamp-based id is used.
   *
   * @param fact The fact to store
   * @returns Promise that resolves when the fact is stored
   */
  async storeFact(fact) {
    const constraintResult = await this.checkConstraints([fact]);
    if (!constraintResult.valid) {
      throw new Error(`Constraint violation: ${constraintResult.errors.join(", ")}`);
    }
    await this.persistFact(fact);
    await this.triggerRules([fact]);
  }
  /**
   * Store multiple facts in PluresDB
   *
   * @param facts The facts to store
   */
  async storeFacts(facts) {
    const constraintResult = await this.checkConstraints(facts);
    if (!constraintResult.valid) {
      throw new Error(`Constraint violation: ${constraintResult.errors.join(", ")}`);
    }
    for (const fact of facts) {
      await this.persistFact(fact);
    }
    await this.triggerRules(facts);
  }
  /**
   * Internal method to persist a fact without constraint checking
   * Used by both storeFact and derived fact storage
   */
  async persistFact(fact) {
    const payload = fact.payload;
    const id = payload?.id ?? generateId();
    const path = getFactPath(fact.tag, id);
    await this.db.set(path, fact);
  }
  /**
   * Get a fact by tag and id
   *
   * @param factTag The fact type tag
   * @param id The fact id
   * @returns The fact or undefined if not found
   */
  async getFact(factTag, id) {
    const path = getFactPath(factTag, id);
    return this.db.get(path);
  }
  /**
   * Append an event to the event stream
   *
   * Events are stored as append-only streams under `/_praxis/events/<eventTag>`
   *
   * @param event The event to append
   */
  async appendEvent(event) {
    const path = getEventPath(event.tag);
    const existingEvents = await this.db.get(path) ?? [];
    const entry = {
      event,
      timestamp: Date.now(),
      sequence: existingEvents.length
    };
    const newEvents = [...existingEvents, entry];
    await this.db.set(path, newEvents);
    await this.triggerRulesForEvents([event]);
  }
  /**
   * Append multiple events to their respective streams
   *
   * @param events The events to append
   */
  async appendEvents(events) {
    const eventsByTag = /* @__PURE__ */ new Map();
    for (const event of events) {
      const existing = eventsByTag.get(event.tag) ?? [];
      eventsByTag.set(event.tag, [...existing, event]);
    }
    for (const [tag, tagEvents] of eventsByTag) {
      const path = getEventPath(tag);
      const existingEvents = await this.db.get(path) ?? [];
      let sequence = existingEvents.length;
      const newEntries = tagEvents.map((event) => ({
        event,
        timestamp: Date.now(),
        sequence: sequence++
      }));
      await this.db.set(path, [...existingEvents, ...newEntries]);
    }
    await this.triggerRulesForEvents(events);
  }
  /**
   * Get events from a stream
   *
   * @param eventTag The event type tag
   * @param options Query options
   * @returns Array of event stream entries
   */
  async getEvents(eventTag, options) {
    const path = getEventPath(eventTag);
    const events = await this.db.get(path) ?? [];
    let result = events;
    if (options?.since !== void 0) {
      const sinceTimestamp = options.since;
      result = result.filter((e) => e.timestamp > sinceTimestamp);
    }
    if (options?.limit !== void 0) {
      result = result.slice(-options.limit);
    }
    return result;
  }
  /**
   * Watch a fact path for changes
   *
   * @param factTag The fact type tag to watch
   * @param callback Called when facts of this type change
   * @returns Unsubscribe function
   */
  watchFacts(factTag, callback) {
    const path = getFactPath(factTag);
    if (!this.factWatchers.has(factTag)) {
      this.factWatchers.set(factTag, /* @__PURE__ */ new Set());
    }
    const watchers = this.factWatchers.get(factTag);
    if (watchers) {
      watchers.add(callback);
    }
    const unsubscribe = this.db.watch(path, (fact) => {
      callback([fact]);
    });
    this.subscriptions.push(unsubscribe);
    return () => {
      unsubscribe();
      this.factWatchers.get(factTag)?.delete(callback);
    };
  }
  /**
   * Check constraints against the current state with new facts
   */
  async checkConstraints(newFacts) {
    const constraints = this.registry.getAllConstraints();
    const errors = [];
    const state = {
      context: this.context,
      facts: newFacts,
      meta: {}
    };
    for (const constraint of constraints) {
      try {
        const result = constraint.impl(state);
        if (result === false) {
          errors.push(`Constraint "${constraint.id}" violated`);
        } else if (typeof result === "string") {
          errors.push(result);
        }
      } catch (error) {
        errors.push(
          `Error checking constraint "${constraint.id}": ${error instanceof Error ? error.message : String(error)}`
        );
      }
    }
    return {
      valid: errors.length === 0,
      errors
    };
  }
  /**
   * Trigger rules when new facts are added
   *
   * This method is called after facts are stored. It can be extended
   * for derived fact computation where rules generate new facts based
   * on existing facts. Currently implemented as a hook point for future
   * enhancements.
   *
   * @param _newFacts The newly stored facts (unused in current implementation)
   */
  async triggerRules(_newFacts) {
  }
  /**
   * Trigger rules when events are appended
   */
  async triggerRulesForEvents(events) {
    const rules = this.registry.getAllRules();
    const state = {
      context: this.context,
      facts: [],
      meta: {}
    };
    const derivedFacts = [];
    for (const rule of rules) {
      try {
        const facts = rule.impl(state, events);
        derivedFacts.push(...facts);
      } catch (error) {
        this.onRuleError(rule.id, error);
      }
    }
    if (derivedFacts.length > 0) {
      const constraintResult = await this.checkConstraints(derivedFacts);
      if (constraintResult.valid) {
        for (const fact of derivedFacts) {
          await this.persistFact(fact);
        }
      }
    }
  }
  /**
   * Update the context
   */
  updateContext(context) {
    this.context = context;
  }
  /**
   * Get the current context
   */
  getContext() {
    return this.context;
  }
  /**
   * Dispose of all subscriptions
   */
  dispose() {
    for (const unsubscribe of this.subscriptions) {
      unsubscribe();
    }
    this.subscriptions = [];
    this.factWatchers.clear();
  }
};
function createPraxisDBStore(db, registry, initialContext, onRuleError) {
  return new PraxisDBStore({ db, registry, initialContext, onRuleError });
}

// src/core/pluresdb/schema-registry.ts
function getSchemaPath(schemaName) {
  return `${PRAXIS_PATHS.SCHEMAS}/${schemaName}`;
}
var PraxisSchemaRegistry = class {
  db;
  constructor(db) {
    this.db = db;
  }
  /**
   * Register a schema in PluresDB
   *
   * @param schema The schema to register
   */
  async register(schema) {
    const path = getSchemaPath(schema.name);
    const storedSchema = {
      schema,
      registeredAt: Date.now(),
      version: schema.version
    };
    await this.db.set(path, storedSchema);
  }
  /**
   * Get a schema by name
   *
   * @param schemaName The schema name
   * @returns The stored schema or undefined if not found
   */
  async get(schemaName) {
    const path = getSchemaPath(schemaName);
    return this.db.get(path);
  }
  /**
   * Check if a schema is registered
   *
   * @param schemaName The schema name
   * @returns True if the schema exists
   */
  async exists(schemaName) {
    const stored = await this.get(schemaName);
    return stored !== void 0;
  }
  /**
   * Update a schema (replaces existing)
   *
   * @param schema The updated schema
   */
  async update(schema) {
    await this.register(schema);
  }
  /**
   * List all registered schema names
   *
   * Implementation note: This method uses an index stored at `/_praxis/schemas/_index`.
   * When using InMemoryPraxisDB, schemas must be registered using `registerWithIndex()`
   * for them to appear in this listing. When using a full PluresDB implementation,
   * native listing capabilities should be used instead.
   *
   * @returns Array of registered schema names
   */
  async list() {
    const indexPath = `${PRAXIS_PATHS.SCHEMAS}/_index`;
    const index = await this.db.get(indexPath);
    return index ?? [];
  }
  /**
   * Register a schema and update the index
   *
   * @param schema The schema to register
   */
  async registerWithIndex(schema) {
    await this.register(schema);
    const indexPath = `${PRAXIS_PATHS.SCHEMAS}/_index`;
    const existingIndex = await this.db.get(indexPath) ?? [];
    if (!existingIndex.includes(schema.name)) {
      await this.db.set(indexPath, [...existingIndex, schema.name]);
    }
  }
};
async function registerSchema(db, schema) {
  const registry = new PraxisSchemaRegistry(db);
  await registry.registerWithIndex(schema);
}
function createSchemaRegistry(db) {
  return new PraxisSchemaRegistry(db);
}

// src/integrations/pluresdb.ts
function createPluresDBAdapter(options) {
  const store = createPraxisDBStore(options.db, options.registry, options.initialContext);
  const subscriptions = [];
  return {
    async persistEvents(events) {
      await store.appendEvents(events);
    },
    async persistFacts(facts) {
      await store.storeFacts(facts);
    },
    async loadEvents(query) {
      if (!query?.tag) {
        return [];
      }
      const entries = await store.getEvents(query.tag, {
        since: query.since,
        limit: query.limit
      });
      return entries.map((e) => e.event);
    },
    subscribeToEvents(callback, query) {
      if (!query?.tag) {
        return () => {
        };
      }
      const unsubscribe = store.watchFacts(query.tag, (facts) => {
        const events = facts.map((f) => ({
          tag: f.tag,
          payload: f.payload
        }));
        callback(events);
      });
      subscriptions.push(unsubscribe);
      return unsubscribe;
    },
    attachEngine(engine) {
      store.updateContext(engine.getContext());
    },
    dispose() {
      for (const unsub of subscriptions) {
        unsub();
      }
      subscriptions.length = 0;
      store.dispose();
    }
  };
}
function attachToEngine(store, engine) {
  store.updateContext(engine.getContext());
  return () => {
    store.dispose();
  };
}

// src/integrations/unum.ts
async function createUnumAdapter(config) {
  const { db, realtime = true } = config;
  let currentIdentity = null;
  const channels = /* @__PURE__ */ new Map();
  const subscriptions = /* @__PURE__ */ new Set();
  if (config.identity) {
    currentIdentity = {
      ...config.identity,
      id: config.identity.id || generateId2(),
      createdAt: Date.now()
    };
    await db.set(`unum/identities/${currentIdentity.id}`, currentIdentity);
  }
  async function setIdentity(identity) {
    currentIdentity = {
      ...identity,
      id: generateId2(),
      createdAt: Date.now()
    };
    await db.set(`unum/identities/${currentIdentity.id}`, currentIdentity);
    return currentIdentity;
  }
  async function getIdentity(id) {
    return await db.get(`unum/identities/${id}`);
  }
  async function createChannel(name, members) {
    const channelId = generateId2();
    const channelData = {
      id: channelId,
      name,
      members: members || [],
      createdAt: Date.now(),
      createdBy: currentIdentity?.id
    };
    await db.set(`unum/channels/${channelId}`, channelData);
    const channel = createChannelInstance(channelId, name);
    channels.set(channelId, channel);
    return channel;
  }
  async function joinChannel(channelId) {
    const existing = channels.get(channelId);
    if (existing) return existing;
    const channelData = await db.get(`unum/channels/${channelId}`);
    if (!channelData) {
      throw new Error(`Channel ${channelId} not found`);
    }
    const channel = createChannelInstance(channelData.id, channelData.name);
    channels.set(channelId, channel);
    return channel;
  }
  async function listChannels() {
    return Array.from(channels.values());
  }
  function createChannelInstance(id, name) {
    const handlers = /* @__PURE__ */ new Set();
    return {
      id,
      name,
      subscribe(handler) {
        handlers.add(handler);
        if (realtime) {
          const unsub = db.watch(`unum/channels/${id}/messages`, (data) => {
            if (data) {
              handler(data);
            }
          });
          subscriptions.add(unsub);
        }
        return () => {
          handlers.delete(handler);
        };
      },
      async publish(message) {
        const fullMessage = {
          ...message,
          id: message.id || generateId2(),
          channelId: id,
          timestamp: Date.now()
        };
        await db.set(`unum/channels/${id}/messages/${fullMessage.id}`, fullMessage);
        handlers.forEach((h) => h(fullMessage));
      },
      async getMembers() {
        const channelData = await db.get(`unum/channels/${id}`);
        if (!channelData?.members) return [];
        const members = [];
        for (const memberId of channelData.members) {
          const identity = await getIdentity(memberId);
          if (identity) members.push(identity);
        }
        return members;
      },
      async leave() {
        channels.delete(id);
      }
    };
  }
  async function broadcastEvent(channelId, event) {
    const channel = channels.get(channelId);
    if (!channel) {
      throw new Error(`Not joined to channel ${channelId}`);
    }
    await channel.publish({
      id: generateId2(),
      sender: currentIdentity || { id: "anonymous", createdAt: Date.now() },
      content: event,
      type: "event"
    });
  }
  async function broadcastFact(channelId, fact) {
    const channel = channels.get(channelId);
    if (!channel) {
      throw new Error(`Not joined to channel ${channelId}`);
    }
    await channel.publish({
      id: generateId2(),
      sender: currentIdentity || { id: "anonymous", createdAt: Date.now() },
      content: fact,
      type: "fact"
    });
  }
  function subscribeToEvents(channelId, handler) {
    const channel = channels.get(channelId);
    if (!channel) {
      throw new Error(`Not joined to channel ${channelId}`);
    }
    return channel.subscribe((message) => {
      if (message.type === "event") {
        handler(message.content);
      }
    });
  }
  function subscribeToFacts(channelId, handler) {
    const channel = channels.get(channelId);
    if (!channel) {
      throw new Error(`Not joined to channel ${channelId}`);
    }
    return channel.subscribe((message) => {
      if (message.type === "fact") {
        handler(message.content);
      }
    });
  }
  async function disconnect() {
    subscriptions.forEach((unsub) => unsub());
    subscriptions.clear();
    for (const channel of channels.values()) {
      await channel.leave();
    }
    channels.clear();
    currentIdentity = null;
  }
  return {
    get identity() {
      return currentIdentity;
    },
    setIdentity,
    getIdentity,
    createChannel,
    joinChannel,
    listChannels,
    broadcastEvent,
    broadcastFact,
    subscribeToEvents,
    subscribeToFacts,
    disconnect
  };
}
function generateId2() {
  return `${Date.now().toString(36)}-${Math.random().toString(36).substr(2, 9)}`;
}
function attachUnumToEngine(_engine, _adapter, _channelId) {
  return () => {
  };
}

// src/integrations/tauri.ts
function createMockTauriBridge() {
  const eventHandlers = /* @__PURE__ */ new Map();
  const storage = /* @__PURE__ */ new Map();
  return {
    app: {
      name: "Mock App",
      version: "0.0.0",
      tauriVersion: "mock"
    },
    fs: {
      async readFile(path) {
        const data = storage.get(path);
        if (data instanceof Uint8Array) return data;
        throw new Error(`File not found: ${path}`);
      },
      async readTextFile(path) {
        const data = storage.get(path);
        if (typeof data === "string") return data;
        throw new Error(`File not found: ${path}`);
      },
      async writeFile(path, data) {
        storage.set(path, data);
      },
      async writeTextFile(path, data) {
        storage.set(path, data);
      },
      async exists(path) {
        return storage.has(path);
      },
      async mkdir(_path, _options) {
      },
      async remove(path, _options) {
        storage.delete(path);
      },
      async rename(oldPath, newPath) {
        const data = storage.get(oldPath);
        if (data !== void 0) {
          storage.set(newPath, data);
          storage.delete(oldPath);
        }
      },
      async readDir(_path) {
        return [];
      }
    },
    tray: {
      async setIcon(_icon) {
      },
      async setTooltip(_tooltip) {
      },
      async setMenu(_menu) {
      },
      async show() {
      },
      async hide() {
      }
    },
    notification: {
      async send(options) {
        console.log("Mock notification:", options.title, options.body);
      },
      async requestPermission() {
        return "granted";
      },
      async checkPermission() {
        return "granted";
      }
    },
    async invoke(cmd, payload) {
      console.log("Mock invoke:", cmd, payload);
      return null;
    },
    async listen(event, handler) {
      if (!eventHandlers.has(event)) {
        eventHandlers.set(event, /* @__PURE__ */ new Set());
      }
      eventHandlers.get(event).add(handler);
      return () => {
        eventHandlers.get(event)?.delete(handler);
      };
    },
    async emit(event, payload) {
      const handlers = eventHandlers.get(event);
      if (handlers) {
        const tauriEvent = { event, payload };
        handlers.forEach((h) => h(tauriEvent));
      }
    },
    window: {
      async minimize() {
      },
      async maximize() {
      },
      async unmaximize() {
      },
      async close() {
      },
      async toggleFullscreen() {
      },
      async setTitle(_title) {
      },
      async show() {
      },
      async hide() {
      },
      async focus() {
      }
    },
    async checkForUpdates() {
      return null;
    },
    async installUpdate() {
    }
  };
}
function createTauriPraxisAdapter(options) {
  const { bridge, statePath = "praxis-state.json", eventsPath = "praxis-events.json" } = options;
  return {
    async saveState(state) {
      const json = JSON.stringify(state, null, 2);
      await bridge.fs.writeTextFile(statePath, json);
    },
    async loadState() {
      try {
        const exists = await bridge.fs.exists(statePath);
        if (!exists) return null;
        const json = await bridge.fs.readTextFile(statePath);
        return JSON.parse(json);
      } catch {
        return null;
      }
    },
    async saveEvents(events) {
      const json = JSON.stringify(events, null, 2);
      await bridge.fs.writeTextFile(eventsPath, json);
    },
    async loadEvents() {
      try {
        const exists = await bridge.fs.exists(eventsPath);
        if (!exists) return [];
        const json = await bridge.fs.readTextFile(eventsPath);
        return JSON.parse(json);
      } catch {
        return [];
      }
    },
    async watchStateFile(_handler) {
      console.log("File watching not implemented in mock");
      return () => {
      };
    },
    getStatePath() {
      return statePath;
    },
    getEventsPath() {
      return eventsPath;
    }
  };
}
function attachTauriToEngine(engine, adapter, options = {}) {
  const { autoSave = true, saveInterval = 5e3 } = options;
  const cleanupFns = [];
  if (autoSave) {
    let saveTimer = null;
    let pendingSave = false;
    const debouncedSave = async () => {
      pendingSave = true;
      if (saveTimer) clearTimeout(saveTimer);
      saveTimer = setTimeout(async () => {
        if (pendingSave) {
          await adapter.saveState(engine.getContext());
          pendingSave = false;
        }
      }, saveInterval);
    };
    cleanupFns.push(() => {
      if (saveTimer) clearTimeout(saveTimer);
    });
    void debouncedSave;
  }
  return () => {
    cleanupFns.forEach((fn) => fn());
  };
}
function generateTauriConfig(config) {
  return {
    $schema: "https://raw.githubusercontent.com/tauri-apps/tauri/tauri-v2.0.0/core/tauri-config-schema/schema.json",
    productName: config.name,
    version: config.version,
    identifier: config.identifier,
    app: {
      windows: [
        {
          title: config.window?.title || config.name,
          width: config.window?.width || 800,
          height: config.window?.height || 600,
          minWidth: config.window?.minWidth,
          minHeight: config.window?.minHeight,
          resizable: config.window?.resizable ?? true,
          fullscreen: config.window?.fullscreen ?? false,
          decorations: config.window?.decorations ?? true,
          transparent: config.window?.transparent ?? false,
          alwaysOnTop: config.window?.alwaysOnTop ?? false,
          center: config.window?.center ?? true
        }
      ],
      security: {
        csp: config.security?.csp || "default-src 'self'",
        devtools: config.security?.devTools ?? false
      }
    },
    build: {
      devUrl: "http://localhost:5173",
      frontendDist: "../dist"
    },
    plugins: Object.fromEntries((config.plugins || []).map((p) => [p.name, p.config || {}]))
  };
}

// src/integrations/unified.ts
async function createUnifiedApp(config) {
  const { createPraxisEngine: createPraxisEngine2 } = await import("./engine-2DQBKBJC.js");
  const { createInMemoryDB: createInMemoryDB2 } = await import("./adapter-K6DOX6XS.js");
  const db = config.db || createInMemoryDB2();
  const pluresdb = createPluresDBAdapter({
    db,
    registry: config.registry,
    initialContext: config.initialContext
  });
  const engine = createPraxisEngine2({
    initialContext: config.initialContext,
    registry: config.registry
  });
  pluresdb.attachEngine(engine);
  const disposers = [];
  let unum;
  let channel;
  if (config.enableUnum) {
    const fullIdentity = config.unumIdentity ? {
      ...config.unumIdentity,
      id: generateId(),
      createdAt: Date.now()
    } : void 0;
    unum = await createUnumAdapter({
      db,
      identity: fullIdentity,
      realtime: true
    });
    channel = await unum.createChannel(
      config.unumIdentity?.name || "praxis-app",
      []
    );
    const unumDisposer = attachUnumToEngine(engine, unum, channel.id);
    disposers.push(unumDisposer);
  }
  let docs;
  let generateDocs2;
  if (config.enableDocs && config.docsConfig) {
    docs = createStateDocsGenerator({
      projectTitle: config.docsConfig.projectTitle,
      target: config.docsConfig.target || "./docs"
    });
    generateDocs2 = () => {
      const module = {
        rules: config.registry.getAllRules(),
        constraints: config.registry.getAllConstraints()
      };
      return docs.generateFromModule(module);
    };
  }
  let canvas;
  if (config.schema) {
    canvas = schemaToCanvas(config.schema, { layout: "hierarchical" });
  }
  return {
    engine,
    pluresdb,
    unum,
    channel,
    docs,
    canvas,
    generateDocs: generateDocs2,
    dispose: () => {
      pluresdb.dispose();
      if (unum) {
        unum.disconnect().catch((err) => {
          console.warn("Warning: Error during Unum disconnect:", err);
        });
      }
      for (const disposer of disposers) {
        disposer();
      }
    }
  };
}
async function attachAllIntegrations(engine, registry, options = {}) {
  const { createInMemoryDB: createInMemoryDB2 } = await import("./adapter-K6DOX6XS.js");
  const db = options.db || createInMemoryDB2();
  const pluresdb = createPluresDBAdapter({
    db,
    registry,
    initialContext: engine.getContext()
  });
  pluresdb.attachEngine(engine);
  const disposers = [];
  let unum;
  let channel;
  if (options.enableUnum) {
    const fullIdentity = options.unumIdentity ? {
      ...options.unumIdentity,
      id: generateId(),
      createdAt: Date.now()
    } : void 0;
    unum = await createUnumAdapter({
      db,
      identity: fullIdentity,
      realtime: true
    });
    channel = await unum.createChannel(
      options.unumIdentity?.name || "praxis-app",
      []
    );
    const unumDisposer = attachUnumToEngine(engine, unum, channel.id);
    disposers.push(unumDisposer);
  }
  let docs;
  if (options.enableDocs && options.docsConfig) {
    docs = createStateDocsGenerator({
      projectTitle: options.docsConfig.projectTitle,
      target: options.docsConfig.target || "./docs"
    });
  }
  return {
    pluresdb,
    unum,
    channel,
    docs,
    dispose: () => {
      pluresdb.dispose();
      if (unum) {
        unum.disconnect().catch((err) => {
          console.warn("Warning: Error during Unum disconnect:", err);
        });
      }
      for (const disposer of disposers) {
        disposer();
      }
    }
  };
}
export {
  ActorManager,
  ReactiveLogicEngine2 as FrameworkAgnosticReactiveEngine,
  InMemoryPraxisDB,
  LogicEngine,
  PRAXIS_PATHS,
  PRAXIS_PROTOCOL_VERSION,
  PluresDBGenerator,
  PluresDBPraxisAdapter,
  PraxisDBStore,
  PraxisRegistry,
  PraxisSchemaRegistry,
  ReactiveLogicEngine,
  RegistryIntrospector,
  StateDocsGenerator,
  TerminalAdapter,
  attachAllIntegrations,
  attachTauriToEngine,
  attachToEngine,
  attachUnumToEngine,
  canvasToMermaid,
  canvasToSchema,
  canvasToYaml,
  createCanvasEditor,
  createReactiveEngine2 as createFrameworkAgnosticReactiveEngine,
  createInMemoryDB,
  createIntrospector,
  createMockExecutor,
  createMockTauriBridge,
  createPluresDB,
  createPluresDBAdapter,
  createPluresDBGenerator,
  createPraxisDBStore,
  createPraxisEngine,
  createReactiveEngine,
  createSchemaRegistry,
  createSchemaTemplate,
  createStateDocsGenerator,
  createTauriPraxisAdapter,
  createTerminalAdapter,
  createTimerActor,
  createUnifiedApp,
  createUnumAdapter,
  defineConstraint,
  defineEvent,
  defineFact,
  defineModule,
  defineRule,
  filterEvents,
  filterFacts,
  findEvent,
  findFact,
  generateDocs,
  generateId,
  generateTauriConfig,
  getEventPath,
  getFactPath,
  getSchemaPath,
  loadSchema,
  loadSchemaFromFile,
  loadSchemaFromJson,
  loadSchemaFromYaml,
  registerSchema,
  runTerminalCommand,
  schemaToCanvas,
  validateForGeneration,
  validateSchema,
  validateWithGuardian
};

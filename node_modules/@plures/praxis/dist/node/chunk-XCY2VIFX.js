// src/cloud/client.ts
function createCloudRelay(config) {
  let status = {
    connected: false,
    endpoint: config.endpoint,
    appId: config.appId
  };
  let syncTimer = null;
  const vectorClock = {};
  return {
    async connect() {
      if (!config.endpoint) {
        throw new Error("Cloud relay endpoint is required");
      }
      try {
        const response = await fetch(`${config.endpoint}/health`, {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            ...config.authToken && {
              Authorization: `Bearer ${config.authToken}`
            }
          }
        });
        if (!response.ok) {
          throw new Error(`Health check failed: ${response.statusText}`);
        }
        status.connected = true;
        status.lastSync = Date.now();
        if (config.autoSync) {
          const interval = config.syncInterval || 5e3;
          syncTimer = setInterval(() => {
            status.lastSync = Date.now();
          }, interval);
        }
      } catch (error) {
        status.connected = false;
        throw new Error(
          `Failed to connect to cloud relay: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    },
    async disconnect() {
      if (syncTimer) {
        clearInterval(syncTimer);
        syncTimer = null;
      }
      status.connected = false;
    },
    async sync(message) {
      if (!status.connected) {
        throw new Error("Not connected to cloud relay");
      }
      vectorClock[config.appId] = (vectorClock[config.appId] || 0) + 1;
      message.clock = { ...vectorClock };
      try {
        const response = await fetch(`${config.endpoint}/sync`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            ...config.authToken && {
              Authorization: `Bearer ${config.authToken}`
            }
          },
          body: JSON.stringify(message)
        });
        if (!response.ok) {
          throw new Error(`Sync failed: ${response.statusText}`);
        }
        status.lastSync = Date.now();
        const result = await response.json();
        if (result.clock) {
          Object.entries(result.clock).forEach(([key, value]) => {
            vectorClock[key] = Math.max(vectorClock[key] || 0, value);
          });
        }
      } catch (error) {
        throw new Error(
          `Failed to sync: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    },
    async getUsage() {
      if (!status.connected) {
        throw new Error("Not connected to cloud relay");
      }
      try {
        const response = await fetch(`${config.endpoint}/usage?appId=${config.appId}`, {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            ...config.authToken && {
              Authorization: `Bearer ${config.authToken}`
            }
          }
        });
        if (!response.ok) {
          throw new Error(`Failed to get usage: ${response.statusText}`);
        }
        return await response.json();
      } catch (error) {
        throw new Error(
          `Failed to get usage metrics: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    },
    async getHealth() {
      try {
        const response = await fetch(`${config.endpoint}/health`, {
          method: "GET",
          headers: {
            "Content-Type": "application/json"
          }
        });
        if (!response.ok) {
          throw new Error(`Health check failed: ${response.statusText}`);
        }
        return await response.json();
      } catch (error) {
        throw new Error(
          `Failed to get health status: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    },
    getStatus() {
      return { ...status };
    }
  };
}
async function connectRelay(endpoint, options = { appId: "default" }) {
  const config = {
    endpoint,
    ...options
  };
  const client = createCloudRelay(config);
  await client.connect();
  return client;
}

export {
  createCloudRelay,
  connectRelay
};

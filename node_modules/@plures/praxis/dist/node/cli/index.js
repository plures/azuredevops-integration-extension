#!/usr/bin/env node
import {
  createPluresDBGenerator
} from "../chunk-RJMWCNHR.js";
import {
  loadSchemaFromFile,
  validateForGeneration
} from "../chunk-UY7YEBE2.js";
import "../chunk-UATVJBNV.js";
import {
  createComponentGenerator
} from "../chunk-YXH4Y7ZZ.js";
import "../chunk-QGM4M3NI.js";

// src/cli/index.ts
import { Command } from "commander";

// src/cli/commands/generate.ts
import { mkdir, writeFile } from "fs/promises";
import { dirname, resolve } from "path";

// src/core/schema/normalize.ts
function normalizeSchema(schema, options = {}) {
  const schemaPrefix = options.schemaPrefix || schema.name;
  const normalizedModels = normalizeModels(schema.models || [], schemaPrefix, options);
  const modelMap = new Map(normalizedModels.map((model) => [model.name, model]));
  const normalizedComponents = normalizeComponents(
    schema.components || [],
    schemaPrefix,
    modelMap,
    options
  );
  const normalizedLogic = normalizeLogic(schema.logic || [], schemaPrefix, options);
  return {
    ...schema,
    models: normalizedModels,
    components: normalizedComponents,
    logic: normalizedLogic
  };
}
function normalizeModels(models, schemaPrefix, _options) {
  return models.map((model) => {
    const fullName = `${schemaPrefix}.${model.name}`;
    const dependencies = extractModelDependencies(model);
    const allFields = [...model.fields];
    return {
      ...model,
      fullName,
      allFields,
      dependencies
    };
  });
}
function extractModelDependencies(model) {
  const dependencies = /* @__PURE__ */ new Set();
  for (const field of model.fields) {
    if (typeof field.type === "object" && "reference" in field.type) {
      dependencies.add(field.type.reference);
    }
  }
  if (model.relationships) {
    for (const rel of model.relationships) {
      dependencies.add(rel.target);
    }
  }
  return Array.from(dependencies);
}
function normalizeComponents(components, schemaPrefix, modelMap, _options) {
  return components.map((component) => {
    const fullName = `${schemaPrefix}.${component.name}`;
    const resolvedModel = component.model ? modelMap.get(component.model) : void 0;
    return {
      ...component,
      fullName,
      resolvedModel
    };
  });
}
function normalizeLogic(logic, schemaPrefix, _options) {
  return logic.map((logicDef) => {
    const fullId = `${schemaPrefix}.${logicDef.id}`;
    return {
      ...logicDef,
      fullId
    };
  });
}

// src/core/logic/generator.ts
var LogicGenerator = class {
  options;
  constructor(options) {
    this.options = {
      typescript: true,
      includeDocs: true,
      ...options
    };
  }
  /**
   * Generate all logic files from schema
   */
  generateLogic(schema) {
    const files = [];
    const allLogic = schema.logic || [];
    if (allLogic.length === 0) {
      files.push(this.generateFactsFile([]));
      files.push(this.generateEventsFile([]));
      files.push(this.generateRulesFile([]));
      files.push(this.generateEngineFile(schema));
      files.push(this.generateIndexFile());
      return files;
    }
    const allFacts = allLogic.flatMap((logic) => logic.facts || []);
    const allEvents = allLogic.flatMap((logic) => logic.events || []);
    const allRules = allLogic.flatMap((logic) => logic.rules || []);
    files.push(this.generateFactsFile(allFacts));
    files.push(this.generateEventsFile(allEvents));
    files.push(this.generateRulesFile(allRules));
    files.push(this.generateEngineFile(schema));
    files.push(this.generateIndexFile());
    return files;
  }
  /**
   * Generate facts.ts file
   */
  generateFactsFile(facts) {
    const ext = this.options.typescript ? "ts" : "js";
    const lines = [];
    lines.push("import { defineFact } from '@plures/praxis';");
    lines.push("");
    if (this.options.includeDocs) {
      lines.push("/**");
      lines.push(" * Fact definitions");
      lines.push(" */");
      lines.push("");
    }
    if (facts.length === 0) {
      lines.push("// No facts defined in schema");
      lines.push("// Example:");
      lines.push(
        '// export const UserCreated = defineFact<"UserCreated", { userId: string }>("UserCreated");'
      );
    } else {
      for (const fact of facts) {
        if (this.options.includeDocs && fact.description) {
          lines.push(`/** ${fact.description} */`);
        }
        const payloadType = this.generatePayloadType(fact.payload);
        lines.push(
          `export const ${fact.tag} = defineFact<"${fact.tag}", ${payloadType}>("${fact.tag}");`
        );
        lines.push("");
      }
    }
    return {
      path: `${this.options.outputDir}/facts.${ext}`,
      content: lines.join("\n"),
      type: "facts"
    };
  }
  /**
   * Generate events.ts file
   */
  generateEventsFile(events) {
    const ext = this.options.typescript ? "ts" : "js";
    const lines = [];
    lines.push("import { defineEvent } from '@plures/praxis';");
    lines.push("");
    if (this.options.includeDocs) {
      lines.push("/**");
      lines.push(" * Event definitions");
      lines.push(" */");
      lines.push("");
    }
    if (events.length === 0) {
      lines.push("// No events defined in schema");
      lines.push("// Example:");
      lines.push(
        '// export const CreateUser = defineEvent<"CREATE_USER", { name: string; email: string }>("CREATE_USER");'
      );
    } else {
      for (const event of events) {
        if (this.options.includeDocs && event.description) {
          lines.push(`/** ${event.description} */`);
        }
        const payloadType = this.generatePayloadType(event.payload);
        lines.push(
          `export const ${event.tag} = defineEvent<"${event.tag}", ${payloadType}>("${event.tag}");`
        );
        lines.push("");
      }
    }
    return {
      path: `${this.options.outputDir}/events.${ext}`,
      content: lines.join("\n"),
      type: "events"
    };
  }
  /**
   * Generate rules.ts file
   */
  generateRulesFile(rules) {
    const ext = this.options.typescript ? "ts" : "js";
    const lines = [];
    lines.push("import { defineRule } from '@plures/praxis';");
    lines.push("import * as Facts from './facts.js';");
    lines.push("import * as Events from './events.js';");
    lines.push("");
    if (this.options.includeDocs) {
      lines.push("/**");
      lines.push(" * Rule definitions");
      lines.push(" */");
      lines.push("");
    }
    if (rules.length === 0) {
      lines.push("// No rules defined in schema");
      lines.push("// Example:");
      lines.push("// export const createUserRule = defineRule({");
      lines.push("//   id: 'user.create',");
      lines.push("//   description: 'Create user on CREATE_USER event',");
      lines.push("//   impl: (state, events) => {");
      lines.push("//     const event = events.find(Events.CreateUser.is);");
      lines.push("//     if (event) {");
      lines.push('//       return [Facts.UserCreated.create({ userId: "new-id" })];');
      lines.push("//     }");
      lines.push("//     return [];");
      lines.push("//   },");
      lines.push("// });");
      lines.push("");
      lines.push("export const rules = [];");
    } else {
      for (const rule of rules) {
        if (this.options.includeDocs && rule.description) {
          lines.push(`/** ${rule.description} */`);
        }
        lines.push(`export const ${this.sanitizeIdentifier(rule.id)}Rule = defineRule({`);
        lines.push(`  id: '${rule.id}',`);
        lines.push(`  description: '${rule.description}',`);
        if (rule.priority !== void 0) {
          lines.push(`  priority: ${rule.priority},`);
        }
        const eventTriggers = rule.on || [];
        const condition = rule.when || "true";
        const action = rule.then;
        lines.push("  impl: (state, events) => {");
        if (eventTriggers.length > 0) {
          lines.push(`    // Filter for triggering events: ${eventTriggers.join(", ")}`);
          lines.push(`    const triggerEvents = events.filter(e => `);
          lines.push(`      [${eventTriggers.map((e) => `'${e}'`).join(", ")}].includes(e.tag)`);
          lines.push("    );");
          lines.push("    if (triggerEvents.length === 0) return [];");
          lines.push("");
        }
        if (condition && condition !== "true") {
          lines.push(`    // Condition: ${condition}`);
          lines.push(`    // Implement condition logic here`);
          lines.push("");
        }
        lines.push(`    // Action: ${action}`);
        const factMatch = action.match(/emit\s*\(\s*['"](\w+)['"]/);
        if (factMatch) {
          const factName = factMatch[1];
          lines.push(`    return [{ tag: '${factName}', payload: {} }];`);
        } else if (action.includes("return")) {
          lines.push(`    ${action}`);
        } else {
          lines.push("    return [];");
        }
        lines.push("  },");
        lines.push("});");
        lines.push("");
      }
      lines.push("export const rules = [");
      for (const rule of rules) {
        lines.push(`  ${this.sanitizeIdentifier(rule.id)}Rule,`);
      }
      lines.push("];");
    }
    return {
      path: `${this.options.outputDir}/rules.${ext}`,
      content: lines.join("\n"),
      type: "rules"
    };
  }
  /**
   * Generate engine.ts file
   */
  generateEngineFile(schema) {
    const ext = this.options.typescript ? "ts" : "js";
    const lines = [];
    lines.push("import { createPraxisEngine, PraxisRegistry } from '@plures/praxis';");
    lines.push("import { rules } from './rules.js';");
    lines.push("");
    if (this.options.includeDocs) {
      lines.push("/**");
      lines.push(` * ${schema.name} Logic Engine`);
      if (schema.description) {
        lines.push(` * ${schema.description}`);
      }
      lines.push(" */");
      lines.push("");
    }
    if (this.options.typescript) {
      lines.push("/**");
      lines.push(" * Application context type");
      lines.push(" */");
      lines.push("export interface AppContext {");
      if (schema.models && schema.models.length > 0) {
        for (const model of schema.models) {
          lines.push(`  ${model.name.toLowerCase()}s: ${model.name}[];`);
        }
      } else {
        lines.push("  // Add your context properties here");
      }
      lines.push("}");
      lines.push("");
      if (schema.models && schema.models.length > 0) {
        for (const model of schema.models) {
          lines.push(`export interface ${model.name} {`);
          for (const field of model.fields) {
            const optional = field.optional ? "?" : "";
            const type = this.mapFieldType(field.type);
            lines.push(`  ${field.name}${optional}: ${type};`);
          }
          lines.push("}");
          lines.push("");
        }
      }
    }
    lines.push("/**");
    lines.push(" * Create the logic engine");
    lines.push(" */");
    lines.push("export function createEngine() {");
    lines.push("  const registry = new PraxisRegistry<AppContext>();");
    lines.push("");
    lines.push("  // Register all rules");
    lines.push("  for (const rule of rules) {");
    lines.push("    registry.registerRule(rule);");
    lines.push("  }");
    lines.push("");
    lines.push("  // Create engine with initial context");
    lines.push("  const initialContext: AppContext = {");
    if (schema.models && schema.models.length > 0) {
      for (const model of schema.models) {
        lines.push(`    ${model.name.toLowerCase()}s: [],`);
      }
    } else {
      lines.push("    // Initialize your context here");
    }
    lines.push("  };");
    lines.push("");
    lines.push("  return createPraxisEngine({");
    lines.push("    initialContext,");
    lines.push("    registry,");
    lines.push("  });");
    lines.push("}");
    return {
      path: `${this.options.outputDir}/engine.${ext}`,
      content: lines.join("\n"),
      type: "engine"
    };
  }
  /**
   * Generate index.ts file
   */
  generateIndexFile() {
    const ext = this.options.typescript ? "ts" : "js";
    const lines = [];
    lines.push("export * from './facts.js';");
    lines.push("export * from './events.js';");
    lines.push("export * from './rules.js';");
    lines.push("export * from './engine.js';");
    return {
      path: `${this.options.outputDir}/index.${ext}`,
      content: lines.join("\n"),
      type: "index"
    };
  }
  /**
   * Generate TypeScript type from payload definition
   */
  generatePayloadType(payload) {
    const fields = Object.entries(payload).map(([key, type]) => `${key}: ${type}`).join("; ");
    return `{ ${fields} }`;
  }
  /**
   * Map field type to TypeScript type
   */
  mapFieldType(type) {
    if (typeof type === "string") {
      switch (type) {
        case "string":
          return "string";
        case "number":
          return "number";
        case "boolean":
          return "boolean";
        case "date":
          return "Date";
        case "array":
          return "unknown[]";
        case "object":
          return "Record<string, unknown>";
        default:
          return "unknown";
      }
    }
    if (typeof type === "object") {
      if ("array" in type) {
        const innerType = this.mapFieldType(type.array);
        return `${innerType}[]`;
      }
      if ("reference" in type) {
        return type.reference;
      }
    }
    return "unknown";
  }
  /**
   * Sanitize identifier for variable names
   */
  sanitizeIdentifier(id) {
    return id.replace(/[^a-zA-Z0-9_]/g, "_");
  }
};
function createLogicGenerator(outputDir, options) {
  return new LogicGenerator({
    outputDir,
    ...options
  });
}

// src/cli/commands/generate.ts
async function generate(options) {
  try {
    const schemaPath = options.schema || "./praxis.schema.js";
    const resolvedSchemaPath = resolve(process.cwd(), schemaPath);
    console.log(`Loading schema from: ${resolvedSchemaPath}`);
    const loadResult = await loadSchemaFromFile(resolvedSchemaPath, {
      validate: true
    });
    if (loadResult.errors.length > 0) {
      console.error("\u274C Failed to load schema:");
      loadResult.errors.forEach((error) => console.error(`  - ${error}`));
      process.exit(1);
    }
    if (!loadResult.schema) {
      console.error("\u274C No schema found");
      process.exit(1);
    }
    const generationValidation = validateForGeneration(loadResult.schema);
    if (!generationValidation.valid) {
      console.error("\u274C Schema validation failed:");
      generationValidation.errors.forEach((error) => console.error(`  - ${error.message}`));
      process.exit(1);
    }
    console.log("\u2713 Schema loaded successfully");
    console.log("Normalizing schema...");
    const normalizedSchema = normalizeSchema(loadResult.schema);
    console.log("\u2713 Schema normalized");
    const outputDir = options.output || "./generated";
    const resolvedOutputDir = resolve(process.cwd(), outputDir);
    const target = options.target || "all";
    let generatedFiles = 0;
    if (target === "all" || target === "logic") {
      console.log("\nGenerating logic module...");
      const logicOutputDir = `${resolvedOutputDir}/logic`;
      await generateLogic(normalizedSchema, logicOutputDir);
      generatedFiles += 5;
      console.log(`\u2713 Logic module generated in ${logicOutputDir}`);
    }
    if (target === "all" || target === "components") {
      console.log("\nGenerating components...");
      const componentsOutputDir = `${resolvedOutputDir}/components`;
      const componentCount = await generateComponents(normalizedSchema, componentsOutputDir);
      generatedFiles += componentCount;
      console.log(`\u2713 ${componentCount} components generated in ${componentsOutputDir}`);
    }
    if (target === "all" || target === "pluresdb") {
      console.log("\nGenerating PluresDB configuration...");
      const dbOutputDir = resolvedOutputDir;
      await generatePluresDB(normalizedSchema, dbOutputDir, options.autoIndex);
      generatedFiles += 1;
      console.log(`\u2713 PluresDB config generated in ${dbOutputDir}`);
    }
    console.log(`
\u2705 Generation complete! ${generatedFiles} files generated.`);
    if (options.watch) {
      console.log("\n\u{1F440} Watching for changes...");
      console.log("(Watch mode not yet implemented)");
    }
  } catch (error) {
    console.error("\u274C Generation failed:");
    if (error instanceof Error) {
      console.error(error.message);
      if (process.env.DEBUG) {
        console.error(error.stack);
      }
    } else {
      console.error("Unknown error");
    }
    process.exit(1);
  }
}
async function generateLogic(schema, outputDir) {
  const generator = createLogicGenerator(outputDir);
  const files = generator.generateLogic(schema);
  for (const file of files) {
    await ensureDir(dirname(file.path));
    await writeFile(file.path, file.content, "utf-8");
  }
}
async function generateComponents(schema, outputDir) {
  if (!schema.components || schema.components.length === 0) {
    console.log("  No components defined in schema");
    return 0;
  }
  const generator = createComponentGenerator(outputDir, {
    typescript: true,
    includeTests: false,
    includeDocs: true
  });
  let fileCount = 0;
  for (const component of schema.components) {
    const model = component.resolvedModel || void 0;
    const result = generator.generateComponent(component, model);
    if (!result.success) {
      console.error(`  \u26A0\uFE0F  Failed to generate ${component.name}:`);
      result.errors.forEach((error) => console.error(`    - ${error.message}`));
      continue;
    }
    for (const file of result.files) {
      await ensureDir(dirname(file.path));
      await writeFile(file.path, file.content, "utf-8");
      fileCount++;
    }
  }
  return fileCount;
}
async function generatePluresDB(schema, outputDir, autoIndex) {
  const generator = createPluresDBGenerator(outputDir, {
    dbName: schema.name.toLowerCase(),
    enableSync: false,
    autoIndex: autoIndex || "all"
  });
  const files = generator.generateConfig(schema);
  for (const file of files) {
    await ensureDir(dirname(file.path));
    await writeFile(file.path, file.content, "utf-8");
  }
}
async function ensureDir(dir) {
  try {
    await mkdir(dir, { recursive: true });
  } catch (error) {
    if (error.code !== "EEXIST") {
      throw error;
    }
  }
}

// src/cli/index.ts
var program = new Command();
program.name("praxis").description("Praxis Framework - Full-stack application development").version("0.2.1");
program.command("login").description("Authenticate with GitHub for Praxis Cloud access").option("--token <token>", "Use a personal access token instead of device flow").action(async (options) => {
  try {
    const { loginCommand } = await import("../auth-STARLY7I.js");
    await loginCommand(options);
  } catch (error) {
    console.error("Error during login:", error);
    process.exit(1);
  }
});
program.command("logout").description("Log out from Praxis Cloud").action(async () => {
  try {
    const { logoutCommand } = await import("../auth-STARLY7I.js");
    await logoutCommand();
  } catch (error) {
    console.error("Error during logout:", error);
    process.exit(1);
  }
});
program.command("whoami").description("Show current authenticated user").action(async () => {
  try {
    const { whoamiCommand } = await import("../auth-STARLY7I.js");
    await whoamiCommand();
  } catch (error) {
    console.error("Error checking authentication:", error);
    process.exit(1);
  }
});
program.command("create <type> [name]").description("Create a new Praxis project or component").option("-t, --template <template>", "Template to use", "basic").option("-d, --directory <dir>", "Output directory").option("--features <features...>", "Features to include").action(async (type, name, options) => {
  try {
    const { create } = await import("../create-TRLSVCNQ.js");
    await create(type, name, options);
  } catch (error) {
    console.error("Error creating:", error);
    process.exit(1);
  }
});
program.command("generate").description("Generate code from schemas").option("-s, --schema <file>", "Schema file path").option("-t, --target <target>", "Generation target (all, logic, components, pluresdb)", "all").option("-o, --output <dir>", "Output directory", "./generated").option("-w, --watch", "Watch for changes").option(
  "--auto-index <strategy>",
  "Auto-indexing strategy for PluresDB (all, explicit, none)",
  "all"
).action(async (options) => {
  await generate(options);
});
program.command("docs [schema]").description("Generate documentation from schemas or registries").option("-o, --output <dir>", "Output directory", "./docs").option("--title <title>", "Documentation title").option("--format <format>", "Diagram format (mermaid, dot)", "mermaid").option("--no-toc", "Disable table of contents").option("--no-timestamp", "Disable timestamp").option("--from-registry", "Generate from registry instead of schema").option("--header <content>", "Custom header content").option("--footer <content>", "Custom footer content").action(async (schema, options) => {
  try {
    const { docs } = await import("../docs-JFNYTOJA.js");
    await docs(schema, options);
  } catch (error) {
    console.error("Error generating documentation:", error);
    process.exit(1);
  }
});
program.command("canvas [schema]").description("Open CodeCanvas for visual editing").option("-p, --port <port>", "Port for Canvas server", "3000").option("-m, --mode <mode>", "Mode (edit, view, present)", "edit").option("-e, --export <format>", "Export format (yaml, mermaid, json)").option("-o, --output <file>", "Output file for export").action(async (schema, options) => {
  try {
    const { canvas } = await import("../canvas-UERZHJYW.js");
    await canvas(schema, options);
  } catch (error) {
    console.error("Error with canvas:", error);
    process.exit(1);
  }
});
program.command("orchestrate").description("Manage orchestration and distributed coordination").option("-c, --config <file>", "Orchestration configuration file").option("-n, --nodes <count>", "Number of nodes", "1").option("-a, --action <action>", "Action (init, start, stop, status)", "status").action(async (options) => {
  try {
    const { orchestrate } = await import("../orchestrate-737TCL5H.js");
    await orchestrate(options);
  } catch (error) {
    console.error("Error with orchestration:", error);
    process.exit(1);
  }
});
program.command("dev").description("Start development server").option("-p, --port <port>", "Port number", "5173").option("-h, --host <host>", "Host to bind to", "localhost").option("-o, --open", "Open browser").action(async (options) => {
  try {
    const { dev } = await import("../dev-PMJZUYGE.js");
    await dev(options);
  } catch (error) {
    console.error("Error starting dev server:", error);
    process.exit(1);
  }
});
program.command("build").description("Build application for production").option("-o, --output <dir>", "Output directory", "./dist").option("--target <target>", "Build target (web, desktop, mobile)", "web").option("--minify", "Minify output", true).option("--sourcemap", "Generate source maps", false).action(async (options) => {
  try {
    const { build } = await import("../build-Y7OT5VBF.js");
    await build(options);
  } catch (error) {
    console.error("Error building:", error);
    process.exit(1);
  }
});
var cloudCmd = program.command("cloud").description("Manage Praxis Cloud connection and synchronization");
cloudCmd.command("init").description("Connect to Praxis Cloud (setup wizard)").option("-e, --endpoint <url>", "Azure Function App endpoint URL").option("-a, --app-id <id>", "Application identifier").option("--auto-sync", "Enable automatic synchronization", false).option("--interval <ms>", "Sync interval in milliseconds", "5000").action(async (options) => {
  try {
    const { cloudInit } = await import("../cloud-AXOK4PSN.js");
    await cloudInit(options);
  } catch (error) {
    console.error("Error initializing cloud connection:", error);
    process.exit(1);
  }
});
cloudCmd.command("status").description("Check Praxis Cloud connection status").action(async () => {
  try {
    const { cloudStatus } = await import("../cloud-AXOK4PSN.js");
    await cloudStatus();
  } catch (error) {
    console.error("Error checking cloud status:", error);
    process.exit(1);
  }
});
cloudCmd.command("sync").description("Manually trigger cloud synchronization").action(async () => {
  try {
    const { cloudSync } = await import("../cloud-AXOK4PSN.js");
    await cloudSync();
  } catch (error) {
    console.error("Error syncing to cloud:", error);
    process.exit(1);
  }
});
cloudCmd.command("usage").description("View cloud usage metrics").action(async () => {
  try {
    const { cloudUsage } = await import("../cloud-AXOK4PSN.js");
    await cloudUsage();
  } catch (error) {
    console.error("Error retrieving usage metrics:", error);
    process.exit(1);
  }
});
program.command("verify <type>").description("Verify project implementation (e.g., implementation)").option("-d, --detailed", "Show detailed analysis").action(async (type, options) => {
  try {
    const { verify } = await import("../verify-QRYKRIDU.js");
    await verify(type, options);
  } catch (error) {
    console.error("Error verifying:", error);
    process.exit(1);
  }
});
program.parse();

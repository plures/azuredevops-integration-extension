// src/core/schema/types.ts
function validateSchema(schema) {
  const errors = [];
  if (!schema.version) {
    errors.push({ path: "version", message: "Schema version is required" });
  }
  if (!schema.name) {
    errors.push({ path: "name", message: "Schema name is required" });
  }
  if (schema.models) {
    schema.models.forEach((model, index) => {
      if (!model.name) {
        errors.push({
          path: `models[${index}].name`,
          message: "Model name is required"
        });
      }
      if (!model.fields || model.fields.length === 0) {
        errors.push({
          path: `models[${index}].fields`,
          message: "Model must have at least one field"
        });
      }
    });
  }
  if (schema.components) {
    schema.components.forEach((component, index) => {
      if (!component.name) {
        errors.push({
          path: `components[${index}].name`,
          message: "Component name is required"
        });
      }
      if (!component.type) {
        errors.push({
          path: `components[${index}].type`,
          message: "Component type is required"
        });
      }
    });
  }
  if (schema.logic) {
    schema.logic.forEach((logic, logicIndex) => {
      if (logic.facts) {
        logic.facts.forEach((fact, factIndex) => {
          if (!fact.tag) {
            errors.push({
              path: `logic[${logicIndex}].facts[${factIndex}].tag`,
              message: "Fact tag is required"
            });
          } else if (!isValidIdentifier(fact.tag)) {
            errors.push({
              path: `logic[${logicIndex}].facts[${factIndex}].tag`,
              message: `Fact tag "${fact.tag}" is not a valid JavaScript identifier. Use only letters, numbers, underscores, and dollar signs, and do not start with a number.`
            });
          }
        });
      }
      if (logic.events) {
        logic.events.forEach((event, eventIndex) => {
          if (!event.tag) {
            errors.push({
              path: `logic[${logicIndex}].events[${eventIndex}].tag`,
              message: "Event tag is required"
            });
          } else if (!isValidIdentifier(event.tag)) {
            errors.push({
              path: `logic[${logicIndex}].events[${eventIndex}].tag`,
              message: `Event tag "${event.tag}" is not a valid JavaScript identifier. Use only letters, numbers, underscores, and dollar signs, and do not start with a number.`
            });
          }
        });
      }
    });
  }
  if (schema.orchestration?.nodes) {
    schema.orchestration.nodes.forEach((node, index) => {
      if (!node.id) {
        errors.push({
          path: `orchestration.nodes[${index}].id`,
          message: "Node id is required"
        });
      }
      if (!node.type) {
        errors.push({
          path: `orchestration.nodes[${index}].type`,
          message: "Node type is required"
        });
      }
      if (node.type === "terminal" && node.props) {
        const props = node.props;
        if (props.inputMode && !["text", "widget"].includes(props.inputMode)) {
          errors.push({
            path: `orchestration.nodes[${index}].props.inputMode`,
            message: 'Terminal node inputMode must be "text" or "widget"'
          });
        }
        if (props.history && !Array.isArray(props.history)) {
          errors.push({
            path: `orchestration.nodes[${index}].props.history`,
            message: "Terminal node history must be an array"
          });
        }
      }
    });
  }
  return {
    valid: errors.length === 0,
    errors
  };
}
function isValidIdentifier(str) {
  const identifierRegex = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;
  const reservedKeywords = [
    "break",
    "case",
    "catch",
    "class",
    "const",
    "continue",
    "debugger",
    "default",
    "delete",
    "do",
    "else",
    "export",
    "extends",
    "finally",
    "for",
    "function",
    "if",
    "import",
    "in",
    "instanceof",
    "new",
    "return",
    "super",
    "switch",
    "this",
    "throw",
    "try",
    "typeof",
    "var",
    "void",
    "while",
    "with",
    "yield",
    "let",
    "static",
    "enum",
    "await",
    "implements",
    "interface",
    "package",
    "private",
    "protected",
    "public"
  ];
  return identifierRegex.test(str) && !reservedKeywords.includes(str);
}
function createSchemaTemplate(name) {
  return {
    version: "1.0.0",
    name,
    description: `Schema for ${name}`,
    models: [],
    components: [],
    logic: []
  };
}

export {
  validateSchema,
  createSchemaTemplate
};

import {
  connectRelay,
  createCloudRelay
} from "../chunk-XCY2VIFX.js";
import {
  BillingProvider,
  GitHubSponsorsClient,
  SubscriptionStatus,
  SubscriptionTier,
  TIER_LIMITS,
  checkUsageLimits,
  createFreeSubscription,
  createSponsorSubscription,
  createSponsorsClient,
  hasAccessToTier
} from "../chunk-DSDC2JWZ.js";
import {
  GitHubOAuth,
  authenticateWithDeviceFlow,
  createGitHubOAuth
} from "../chunk-FXQZXAWF.js";
import "../chunk-QGM4M3NI.js";

// src/cloud/marketplace.ts
var MARKETPLACE_PLANS = {
  solo: {
    name: "Praxis Cloud Solo",
    description: "For individual developers",
    monthlyPriceInCents: 500,
    // $5/month
    yearlyPriceInCents: 5e3,
    // $50/year (2 months free)
    features: ["50,000 syncs/month", "1 GB storage", "10 apps/projects", "Standard support"]
  },
  team: {
    name: "Praxis Cloud Team",
    description: "For small teams",
    monthlyPriceInCents: 2e3,
    // $20/month
    yearlyPriceInCents: 2e4,
    // $200/year (2 months free)
    features: [
      "500,000 syncs/month",
      "10 GB storage",
      "50 apps/projects",
      "Up to 10 team members",
      "Standard support"
    ]
  },
  enterprise: {
    name: "Praxis Cloud Enterprise",
    description: "For large teams and organizations",
    monthlyPriceInCents: 5e3,
    // $50/month
    yearlyPriceInCents: 5e4,
    // $500/year (2 months free)
    features: [
      "5,000,000 syncs/month",
      "100 GB storage",
      "1,000 apps/projects",
      "Unlimited team members",
      "Priority support",
      "SLA guarantees"
    ]
  }
};
var GitHubMarketplaceClient = class {
  token;
  constructor(token) {
    this.token = token;
  }
  /**
   * Get accounts for the authenticated user
   */
  async getAccounts() {
    try {
      const response = await fetch("https://api.github.com/marketplace_listing/accounts", {
        headers: {
          Authorization: `Bearer ${this.token}`,
          Accept: "application/vnd.github.v3+json"
        }
      });
      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.statusText}`);
      }
      return await response.json();
    } catch (error) {
      console.error("Failed to get marketplace accounts:", error);
      return [];
    }
  }
  /**
   * Get subscription from marketplace account
   */
  async getSubscription(accountId) {
    const accounts = await this.getAccounts();
    const account = accounts.find((a) => a.id === accountId);
    if (!account) {
      return null;
    }
    let tier = "free" /* FREE */;
    if (account.plan.monthlyPriceInCents >= 5e3) {
      tier = "enterprise" /* ENTERPRISE */;
    } else if (account.plan.monthlyPriceInCents >= 2e3) {
      tier = "team" /* TEAM */;
    } else if (account.plan.monthlyPriceInCents >= 500) {
      tier = "solo" /* SOLO */;
    }
    return {
      tier,
      status: "active" /* ACTIVE */,
      provider: "marketplace" /* MARKETPLACE */,
      marketplacePlanId: account.plan.id,
      startDate: account.onFreeTrial && account.freeTrialEndsOn ? new Date(account.freeTrialEndsOn).getTime() : Date.now(),
      periodEnd: account.nextBillingDate ? new Date(account.nextBillingDate).getTime() : void 0,
      autoRenew: true,
      limits: TIER_LIMITS[tier]
    };
  }
  /**
   * Handle marketplace webhook event
   */
  handleWebhookEvent(event) {
    const account = event.marketplacePurchase.account;
    if (event.action === "cancelled") {
      return null;
    }
    let tier = "free" /* FREE */;
    if (account.plan.monthlyPriceInCents >= 5e3) {
      tier = "enterprise" /* ENTERPRISE */;
    } else if (account.plan.monthlyPriceInCents >= 2e3) {
      tier = "team" /* TEAM */;
    } else if (account.plan.monthlyPriceInCents >= 500) {
      tier = "solo" /* SOLO */;
    }
    return {
      userId: account.id,
      userLogin: account.login,
      subscription: {
        tier,
        status: "active" /* ACTIVE */,
        provider: "marketplace" /* MARKETPLACE */,
        marketplacePlanId: account.plan.id,
        startDate: Date.now(),
        periodEnd: event.marketplacePurchase.nextBillingDate ? new Date(event.marketplacePurchase.nextBillingDate).getTime() : void 0,
        autoRenew: true,
        limits: TIER_LIMITS[tier]
      }
    };
  }
};
function createMarketplaceClient(token) {
  return new GitHubMarketplaceClient(token);
}

// src/cloud/provisioning.ts
function generateStorageNamespace(githubLogin, userId) {
  const sanitized = githubLogin.toLowerCase().replace(/[^a-z0-9]/g, "-");
  const hash = userId.toString(36).padStart(6, "0");
  return `gh-${sanitized}-${hash}`;
}
function generateTenantId(githubUser) {
  return `github-${githubUser.id}`;
}
function createTenant(githubUser, subscription) {
  const tenantId = generateTenantId(githubUser);
  const storageNamespace = generateStorageNamespace(githubUser.login, githubUser.id);
  return {
    id: tenantId,
    githubUserId: githubUser.id,
    githubLogin: githubUser.login,
    type: "user",
    // Could be "organization" if checking org membership
    subscription,
    storageNamespace,
    createdAt: Date.now(),
    lastAccessedAt: Date.now()
  };
}
function validateStorageNamespace(namespace) {
  if (namespace.length < 3 || namespace.length > 63) {
    return {
      valid: false,
      error: "Namespace must be 3-63 characters"
    };
  }
  if (!/^[a-z0-9]/.test(namespace)) {
    return {
      valid: false,
      error: "Namespace must start with a letter or number"
    };
  }
  if (!/^[a-z0-9-]+$/.test(namespace)) {
    return {
      valid: false,
      error: "Namespace can only contain lowercase letters, numbers, and hyphens"
    };
  }
  if (/--/.test(namespace)) {
    return {
      valid: false,
      error: "Namespace cannot contain consecutive hyphens"
    };
  }
  return { valid: true };
}
function getAppStorageContainer(tenantNamespace, appId) {
  const sanitizedAppId = appId.toLowerCase().replace(/[^a-z0-9]/g, "-");
  return `${tenantNamespace}-${sanitizedAppId}`;
}
async function provisionTenant(githubUser, subscription) {
  try {
    const tenant = createTenant(githubUser, subscription);
    const validation = validateStorageNamespace(tenant.storageNamespace);
    if (!validation.valid) {
      return {
        success: false,
        error: validation.error
      };
    }
    console.log(`Provisioned tenant: ${tenant.id}`);
    console.log(`Storage namespace: ${tenant.storageNamespace}`);
    return {
      success: true,
      tenant
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error)
    };
  }
}
async function getOrCreateTenant(githubUser, subscription, tenantLookup) {
  const tenantId = generateTenantId(githubUser);
  const existing = await tenantLookup(tenantId);
  if (existing) {
    existing.lastAccessedAt = Date.now();
    return existing;
  }
  const result = await provisionTenant(githubUser, subscription);
  if (!result.success || !result.tenant) {
    throw new Error(`Failed to provision tenant: ${result.error}`);
  }
  return result.tenant;
}

// src/cloud/relay/endpoints.ts
var storage = {
  syncs: /* @__PURE__ */ new Map(),
  usage: /* @__PURE__ */ new Map()
};
async function healthEndpoint(context, _req) {
  context.log("Health check requested");
  const response = {
    status: "healthy",
    timestamp: Date.now(),
    version: "0.1.0",
    services: {
      relay: true,
      eventGrid: true,
      storage: true,
      auth: true
    }
  };
  return {
    status: 200,
    headers: { "Content-Type": "application/json" },
    body: response
  };
}
async function syncEndpoint(context, req) {
  context.log("Sync request received");
  if (req.method !== "POST") {
    return {
      status: 405,
      body: { error: "Method not allowed" }
    };
  }
  const message = req.body;
  if (!message || !message.appId) {
    return {
      status: 400,
      body: { error: "Invalid sync message" }
    };
  }
  const appSyncs = storage.syncs.get(message.appId) || [];
  appSyncs.push(message);
  storage.syncs.set(message.appId, appSyncs);
  const usage = storage.usage.get(message.appId) || {
    appId: message.appId,
    syncCount: 0,
    eventCount: 0,
    factCount: 0,
    storageBytes: 0,
    periodStart: Date.now(),
    periodEnd: Date.now()
  };
  usage.syncCount++;
  usage.eventCount += message.events?.length || 0;
  usage.factCount += message.facts?.length || 0;
  usage.storageBytes += JSON.stringify(message).length;
  usage.periodEnd = Date.now();
  storage.usage.set(message.appId, usage);
  context.log(`Synced for app ${message.appId}: ${usage.syncCount} total syncs`);
  return {
    status: 200,
    headers: { "Content-Type": "application/json" },
    body: {
      success: true,
      clock: message.clock,
      timestamp: Date.now()
    }
  };
}
async function usageEndpoint(context, req) {
  context.log("Usage metrics requested");
  const appId = req.query.appId;
  if (!appId) {
    return {
      status: 400,
      body: { error: "appId query parameter is required" }
    };
  }
  const usage = storage.usage.get(appId);
  if (!usage) {
    return {
      status: 404,
      body: { error: "No usage data found for this app" }
    };
  }
  return {
    status: 200,
    headers: { "Content-Type": "application/json" },
    body: usage
  };
}
async function statsEndpoint(context, req) {
  context.log("Stats requested");
  const appId = req.query.appId;
  if (!appId) {
    return {
      status: 400,
      body: { error: "appId query parameter is required" }
    };
  }
  const usage = storage.usage.get(appId);
  const syncs = storage.syncs.get(appId) || [];
  return {
    status: 200,
    headers: { "Content-Type": "application/json" },
    body: {
      appId,
      totalSyncs: syncs.length,
      usage: usage || null,
      lastSync: syncs.length > 0 ? syncs[syncs.length - 1].timestamp : null
    }
  };
}
async function eventsEndpoint(context, req) {
  context.log("Event forwarding requested");
  if (req.method !== "POST") {
    return {
      status: 405,
      body: { error: "Method not allowed" }
    };
  }
  const { appId, events } = req.body;
  if (!appId || !events) {
    return {
      status: 400,
      body: { error: "Invalid event forwarding request" }
    };
  }
  context.log(`Forwarding ${events.length} events for app ${appId}`);
  return {
    status: 200,
    headers: { "Content-Type": "application/json" },
    body: {
      success: true,
      forwarded: events.length,
      timestamp: Date.now()
    }
  };
}
async function schemaEndpoint(context, req) {
  context.log("Schema registry requested");
  if (req.method === "POST") {
    const { appId: appId2, schema } = req.body;
    if (!appId2 || !schema) {
      return {
        status: 400,
        body: { error: "Invalid schema registration request" }
      };
    }
    context.log(`Schema registered for app ${appId2}`);
    return {
      status: 200,
      headers: { "Content-Type": "application/json" },
      body: {
        success: true,
        schemaId: `${appId2}-${Date.now()}`,
        timestamp: Date.now()
      }
    };
  }
  const appId = req.query.appId;
  if (!appId) {
    return {
      status: 400,
      body: { error: "appId query parameter is required" }
    };
  }
  return {
    status: 200,
    headers: { "Content-Type": "application/json" },
    body: {
      appId,
      schema: null,
      message: "Schema not found"
    }
  };
}
export {
  BillingProvider,
  GitHubMarketplaceClient,
  GitHubOAuth,
  GitHubSponsorsClient,
  MARKETPLACE_PLANS,
  SubscriptionStatus,
  SubscriptionTier,
  TIER_LIMITS,
  authenticateWithDeviceFlow,
  checkUsageLimits,
  connectRelay,
  createCloudRelay,
  createFreeSubscription,
  createGitHubOAuth,
  createMarketplaceClient,
  createSponsorSubscription,
  createSponsorsClient,
  createTenant,
  eventsEndpoint,
  generateStorageNamespace,
  generateTenantId,
  getAppStorageContainer,
  getOrCreateTenant,
  hasAccessToTier,
  healthEndpoint,
  provisionTenant,
  schemaEndpoint,
  statsEndpoint,
  syncEndpoint,
  usageEndpoint,
  validateStorageNamespace
};

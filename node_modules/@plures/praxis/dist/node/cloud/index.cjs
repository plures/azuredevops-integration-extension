"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/cloud/index.ts
var cloud_exports = {};
__export(cloud_exports, {
  BillingProvider: () => BillingProvider,
  GitHubMarketplaceClient: () => GitHubMarketplaceClient,
  GitHubOAuth: () => GitHubOAuth,
  GitHubSponsorsClient: () => GitHubSponsorsClient,
  MARKETPLACE_PLANS: () => MARKETPLACE_PLANS,
  SubscriptionStatus: () => SubscriptionStatus,
  SubscriptionTier: () => SubscriptionTier,
  TIER_LIMITS: () => TIER_LIMITS,
  authenticateWithDeviceFlow: () => authenticateWithDeviceFlow,
  checkUsageLimits: () => checkUsageLimits,
  connectRelay: () => connectRelay,
  createCloudRelay: () => createCloudRelay,
  createFreeSubscription: () => createFreeSubscription,
  createGitHubOAuth: () => createGitHubOAuth,
  createMarketplaceClient: () => createMarketplaceClient,
  createSponsorSubscription: () => createSponsorSubscription,
  createSponsorsClient: () => createSponsorsClient,
  createTenant: () => createTenant,
  eventsEndpoint: () => eventsEndpoint,
  generateStorageNamespace: () => generateStorageNamespace,
  generateTenantId: () => generateTenantId,
  getAppStorageContainer: () => getAppStorageContainer,
  getOrCreateTenant: () => getOrCreateTenant,
  hasAccessToTier: () => hasAccessToTier,
  healthEndpoint: () => healthEndpoint,
  provisionTenant: () => provisionTenant,
  schemaEndpoint: () => schemaEndpoint,
  statsEndpoint: () => statsEndpoint,
  syncEndpoint: () => syncEndpoint,
  usageEndpoint: () => usageEndpoint,
  validateStorageNamespace: () => validateStorageNamespace
});
module.exports = __toCommonJS(cloud_exports);

// src/cloud/client.ts
function createCloudRelay(config) {
  let status = {
    connected: false,
    endpoint: config.endpoint,
    appId: config.appId
  };
  let syncTimer = null;
  const vectorClock = {};
  return {
    async connect() {
      if (!config.endpoint) {
        throw new Error("Cloud relay endpoint is required");
      }
      try {
        const response = await fetch(`${config.endpoint}/health`, {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            ...config.authToken && {
              Authorization: `Bearer ${config.authToken}`
            }
          }
        });
        if (!response.ok) {
          throw new Error(`Health check failed: ${response.statusText}`);
        }
        status.connected = true;
        status.lastSync = Date.now();
        if (config.autoSync) {
          const interval = config.syncInterval || 5e3;
          syncTimer = setInterval(() => {
            status.lastSync = Date.now();
          }, interval);
        }
      } catch (error) {
        status.connected = false;
        throw new Error(
          `Failed to connect to cloud relay: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    },
    async disconnect() {
      if (syncTimer) {
        clearInterval(syncTimer);
        syncTimer = null;
      }
      status.connected = false;
    },
    async sync(message) {
      if (!status.connected) {
        throw new Error("Not connected to cloud relay");
      }
      vectorClock[config.appId] = (vectorClock[config.appId] || 0) + 1;
      message.clock = { ...vectorClock };
      try {
        const response = await fetch(`${config.endpoint}/sync`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            ...config.authToken && {
              Authorization: `Bearer ${config.authToken}`
            }
          },
          body: JSON.stringify(message)
        });
        if (!response.ok) {
          throw new Error(`Sync failed: ${response.statusText}`);
        }
        status.lastSync = Date.now();
        const result = await response.json();
        if (result.clock) {
          Object.entries(result.clock).forEach(([key, value]) => {
            vectorClock[key] = Math.max(vectorClock[key] || 0, value);
          });
        }
      } catch (error) {
        throw new Error(
          `Failed to sync: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    },
    async getUsage() {
      if (!status.connected) {
        throw new Error("Not connected to cloud relay");
      }
      try {
        const response = await fetch(`${config.endpoint}/usage?appId=${config.appId}`, {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            ...config.authToken && {
              Authorization: `Bearer ${config.authToken}`
            }
          }
        });
        if (!response.ok) {
          throw new Error(`Failed to get usage: ${response.statusText}`);
        }
        return await response.json();
      } catch (error) {
        throw new Error(
          `Failed to get usage metrics: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    },
    async getHealth() {
      try {
        const response = await fetch(`${config.endpoint}/health`, {
          method: "GET",
          headers: {
            "Content-Type": "application/json"
          }
        });
        if (!response.ok) {
          throw new Error(`Health check failed: ${response.statusText}`);
        }
        return await response.json();
      } catch (error) {
        throw new Error(
          `Failed to get health status: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    },
    getStatus() {
      return { ...status };
    }
  };
}
async function connectRelay(endpoint, options = { appId: "default" }) {
  const config = {
    endpoint,
    ...options
  };
  const client = createCloudRelay(config);
  await client.connect();
  return client;
}

// src/cloud/auth.ts
var GitHubOAuth = class {
  config;
  constructor(config) {
    this.config = config;
  }
  /**
   * Get the OAuth authorization URL
   */
  getAuthorizationUrl(state) {
    const params = new URLSearchParams({
      client_id: this.config.clientId,
      scope: this.config.scope || "read:user user:email",
      state: state || this.generateState()
    });
    if (this.config.redirectUri) {
      params.set("redirect_uri", this.config.redirectUri);
    }
    return `https://github.com/login/oauth/authorize?${params.toString()}`;
  }
  /**
   * Exchange authorization code for access token
   */
  async exchangeCode(code) {
    if (!this.config.clientSecret) {
      throw new Error("Client secret is required for code exchange");
    }
    try {
      const response = await fetch("https://github.com/login/oauth/access_token", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json"
        },
        body: JSON.stringify({
          client_id: this.config.clientId,
          client_secret: this.config.clientSecret,
          code
        })
      });
      if (!response.ok) {
        throw new Error(`Token exchange failed: ${response.statusText}`);
      }
      const data = await response.json();
      if (data.error) {
        throw new Error(`GitHub OAuth error: ${data.error_description || data.error}`);
      }
      const user = await this.getUserInfo(data.access_token);
      return {
        success: true,
        token: data.access_token,
        user,
        expiresAt: data.expires_in ? Date.now() + data.expires_in * 1e3 : void 0
      };
    } catch (error) {
      return {
        success: false
      };
    }
  }
  /**
   * Get user information from GitHub
   */
  async getUserInfo(token) {
    const response = await fetch("https://api.github.com/user", {
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github.v3+json"
      }
    });
    if (!response.ok) {
      throw new Error(`Failed to get user info: ${response.statusText}`);
    }
    const data = await response.json();
    return {
      id: data.id,
      login: data.login,
      email: data.email,
      name: data.name,
      avatarUrl: data.avatar_url
    };
  }
  /**
   * Verify a token is valid
   */
  async verifyToken(token) {
    try {
      await this.getUserInfo(token);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Generate a random state parameter for CSRF protection
   */
  generateState() {
    const array = new Uint8Array(16);
    if (typeof crypto !== "undefined" && crypto.getRandomValues) {
      crypto.getRandomValues(array);
    } else {
      for (let i = 0; i < array.length; i++) {
        array[i] = Math.floor(Math.random() * 256);
      }
    }
    return Array.from(array, (byte) => byte.toString(16).padStart(2, "0")).join("");
  }
};
function createGitHubOAuth(config) {
  return new GitHubOAuth(config);
}
async function authenticateWithDeviceFlow(clientId) {
  try {
    const deviceResponse = await fetch("https://github.com/login/device/code", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      },
      body: JSON.stringify({
        client_id: clientId,
        scope: "read:user user:email"
      })
    });
    if (!deviceResponse.ok) {
      throw new Error(`Device flow initiation failed: ${deviceResponse.statusText}`);
    }
    const deviceData = await deviceResponse.json();
    console.log("\nTo authenticate with GitHub:");
    console.log(`1. Visit: ${deviceData.verification_uri}`);
    console.log(`2. Enter code: ${deviceData.user_code}`);
    console.log("\nWaiting for authentication...\n");
    const interval = deviceData.interval * 1e3 || 5e3;
    const expiresAt = Date.now() + deviceData.expires_in * 1e3;
    while (Date.now() < expiresAt) {
      await new Promise((resolve) => setTimeout(resolve, interval));
      const tokenResponse = await fetch("https://github.com/login/oauth/access_token", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json"
        },
        body: JSON.stringify({
          client_id: clientId,
          device_code: deviceData.device_code,
          grant_type: "urn:ietf:params:oauth:grant-type:device_code"
        })
      });
      const tokenData = await tokenResponse.json();
      if (tokenData.access_token) {
        const oauth = new GitHubOAuth({ clientId });
        const user = await oauth.getUserInfo(tokenData.access_token);
        return {
          success: true,
          token: tokenData.access_token,
          user
        };
      }
      if (tokenData.error && tokenData.error !== "authorization_pending") {
        throw new Error(`Authentication failed: ${tokenData.error_description || tokenData.error}`);
      }
    }
    throw new Error("Authentication timeout");
  } catch (error) {
    return {
      success: false
    };
  }
}

// src/cloud/billing.ts
var SubscriptionTier = /* @__PURE__ */ ((SubscriptionTier2) => {
  SubscriptionTier2["FREE"] = "free";
  SubscriptionTier2["SOLO"] = "solo";
  SubscriptionTier2["TEAM"] = "team";
  SubscriptionTier2["ENTERPRISE"] = "enterprise";
  return SubscriptionTier2;
})(SubscriptionTier || {});
var BillingProvider = /* @__PURE__ */ ((BillingProvider2) => {
  BillingProvider2["SPONSORS"] = "sponsors";
  BillingProvider2["MARKETPLACE"] = "marketplace";
  BillingProvider2["NONE"] = "none";
  return BillingProvider2;
})(BillingProvider || {});
var SubscriptionStatus = /* @__PURE__ */ ((SubscriptionStatus2) => {
  SubscriptionStatus2["ACTIVE"] = "active";
  SubscriptionStatus2["CANCELLED"] = "cancelled";
  SubscriptionStatus2["EXPIRED"] = "expired";
  SubscriptionStatus2["NONE"] = "none";
  return SubscriptionStatus2;
})(SubscriptionStatus || {});
var TIER_LIMITS = {
  ["free" /* FREE */]: {
    maxSyncsPerMonth: 1e3,
    maxStorageBytes: 10 * 1024 * 1024,
    // 10 MB
    maxTeamMembers: 1,
    maxApps: 1,
    supportLevel: "community"
  },
  ["solo" /* SOLO */]: {
    maxSyncsPerMonth: 5e4,
    maxStorageBytes: 1024 * 1024 * 1024,
    // 1 GB
    maxTeamMembers: 1,
    maxApps: 10,
    supportLevel: "standard"
  },
  ["team" /* TEAM */]: {
    maxSyncsPerMonth: 5e5,
    maxStorageBytes: 10 * 1024 * 1024 * 1024,
    // 10 GB
    maxTeamMembers: 10,
    maxApps: 50,
    supportLevel: "standard"
  },
  ["enterprise" /* ENTERPRISE */]: {
    maxSyncsPerMonth: 5e6,
    maxStorageBytes: 100 * 1024 * 1024 * 1024,
    // 100 GB
    maxTeamMembers: null,
    // unlimited
    maxApps: 1e3,
    supportLevel: "priority"
  }
};
function hasAccessToTier(subscription, requiredTier) {
  if (subscription.status !== "active" /* ACTIVE */) {
    return false;
  }
  const tierOrder = [
    "free" /* FREE */,
    "solo" /* SOLO */,
    "team" /* TEAM */,
    "enterprise" /* ENTERPRISE */
  ];
  const currentTierIndex = tierOrder.indexOf(subscription.tier);
  const requiredTierIndex = tierOrder.indexOf(requiredTier);
  return currentTierIndex >= requiredTierIndex;
}
function checkUsageLimits(subscription, usage) {
  const violations = [];
  if (usage.syncCount > subscription.limits.maxSyncsPerMonth) {
    violations.push(
      `Sync limit exceeded: ${usage.syncCount}/${subscription.limits.maxSyncsPerMonth}`
    );
  }
  if (usage.storageBytes > subscription.limits.maxStorageBytes) {
    violations.push(
      `Storage limit exceeded: ${(usage.storageBytes / 1024 / 1024).toFixed(2)}MB/${(subscription.limits.maxStorageBytes / 1024 / 1024).toFixed(2)}MB`
    );
  }
  if (subscription.limits.maxTeamMembers !== null && usage.teamMembers > subscription.limits.maxTeamMembers) {
    violations.push(
      `Team member limit exceeded: ${usage.teamMembers}/${subscription.limits.maxTeamMembers}`
    );
  }
  if (usage.appCount > subscription.limits.maxApps) {
    violations.push(`App limit exceeded: ${usage.appCount}/${subscription.limits.maxApps}`);
  }
  return {
    withinLimits: violations.length === 0,
    violations
  };
}
function createFreeSubscription() {
  return {
    tier: "free" /* FREE */,
    status: "active" /* ACTIVE */,
    provider: "none" /* NONE */,
    startDate: Date.now(),
    autoRenew: true,
    limits: TIER_LIMITS["free" /* FREE */]
  };
}
function createSponsorSubscription(tierName, monthlyPriceInCents) {
  let tier = "free" /* FREE */;
  if (monthlyPriceInCents >= 5e3) {
    tier = "enterprise" /* ENTERPRISE */;
  } else if (monthlyPriceInCents >= 2e3) {
    tier = "team" /* TEAM */;
  } else if (monthlyPriceInCents >= 500) {
    tier = "solo" /* SOLO */;
  }
  return {
    tier,
    status: "active" /* ACTIVE */,
    provider: "sponsors" /* SPONSORS */,
    sponsorTierId: tierName,
    startDate: Date.now(),
    autoRenew: true,
    limits: TIER_LIMITS[tier]
  };
}

// src/cloud/sponsors.ts
var GitHubSponsorsClient = class {
  token;
  accountLogin;
  constructor(token, accountLogin) {
    this.token = token;
    this.accountLogin = accountLogin;
  }
  /**
   * Get current user's sponsorship of the Praxis account
   */
  async getSponsorship(userLogin) {
    try {
      const query = `
        query($accountLogin: String!, $userLogin: String!) {
          user(login: $userLogin) {
            sponsorshipForViewerAsSponsor(activeOnly: true) {
              tier {
                id
                name
                monthlyPriceInCents
                description
                isOneTime
              }
              createdAt
              isActive
            }
            sponsorshipsAsSponsor(first: 100, activeOnly: true) {
              nodes {
                sponsorable {
                  ... on User {
                    login
                  }
                  ... on Organization {
                    login
                  }
                }
                tier {
                  id
                  name
                  monthlyPriceInCents
                  description
                  isOneTime
                }
                createdAt
                isActive
              }
            }
          }
        }
      `;
      const response = await fetch("https://api.github.com/graphql", {
        method: "POST",
        headers: {
          Authorization: `Bearer ${this.token}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          query,
          variables: {
            accountLogin: this.accountLogin,
            userLogin
          }
        })
      });
      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.statusText}`);
      }
      const data = await response.json();
      if (data.errors) {
        throw new Error(`GraphQL error: ${JSON.stringify(data.errors)}`);
      }
      const sponsorships = data.data?.user?.sponsorshipsAsSponsor?.nodes || [];
      const praxisSponsorship = sponsorships.find(
        (s) => s.sponsorable?.login === this.accountLogin
      );
      if (!praxisSponsorship) {
        return null;
      }
      return {
        sponsorLogin: userLogin,
        sponsorId: data.data.user.id,
        tier: {
          id: praxisSponsorship.tier.id,
          name: praxisSponsorship.tier.name,
          monthlyPriceInCents: praxisSponsorship.tier.monthlyPriceInCents,
          description: praxisSponsorship.tier.description,
          isOneTime: praxisSponsorship.tier.isOneTime
        },
        createdAt: praxisSponsorship.createdAt,
        isActive: praxisSponsorship.isActive
      };
    } catch (error) {
      console.error("Failed to get sponsorship:", error);
      return null;
    }
  }
  /**
   * Get subscription from sponsorship
   */
  async getSubscription(userLogin) {
    const sponsorship = await this.getSponsorship(userLogin);
    if (!sponsorship || !sponsorship.isActive) {
      return createFreeSubscription();
    }
    return createSponsorSubscription(sponsorship.tier.name, sponsorship.tier.monthlyPriceInCents);
  }
  /**
   * Check if user is a sponsor
   */
  async isSponsor(userLogin) {
    const sponsorship = await this.getSponsorship(userLogin);
    return sponsorship !== null && sponsorship.isActive;
  }
};
function createSponsorsClient(token, accountLogin = "plures") {
  return new GitHubSponsorsClient(token, accountLogin);
}

// src/cloud/marketplace.ts
var MARKETPLACE_PLANS = {
  solo: {
    name: "Praxis Cloud Solo",
    description: "For individual developers",
    monthlyPriceInCents: 500,
    // $5/month
    yearlyPriceInCents: 5e3,
    // $50/year (2 months free)
    features: ["50,000 syncs/month", "1 GB storage", "10 apps/projects", "Standard support"]
  },
  team: {
    name: "Praxis Cloud Team",
    description: "For small teams",
    monthlyPriceInCents: 2e3,
    // $20/month
    yearlyPriceInCents: 2e4,
    // $200/year (2 months free)
    features: [
      "500,000 syncs/month",
      "10 GB storage",
      "50 apps/projects",
      "Up to 10 team members",
      "Standard support"
    ]
  },
  enterprise: {
    name: "Praxis Cloud Enterprise",
    description: "For large teams and organizations",
    monthlyPriceInCents: 5e3,
    // $50/month
    yearlyPriceInCents: 5e4,
    // $500/year (2 months free)
    features: [
      "5,000,000 syncs/month",
      "100 GB storage",
      "1,000 apps/projects",
      "Unlimited team members",
      "Priority support",
      "SLA guarantees"
    ]
  }
};
var GitHubMarketplaceClient = class {
  token;
  constructor(token) {
    this.token = token;
  }
  /**
   * Get accounts for the authenticated user
   */
  async getAccounts() {
    try {
      const response = await fetch("https://api.github.com/marketplace_listing/accounts", {
        headers: {
          Authorization: `Bearer ${this.token}`,
          Accept: "application/vnd.github.v3+json"
        }
      });
      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.statusText}`);
      }
      return await response.json();
    } catch (error) {
      console.error("Failed to get marketplace accounts:", error);
      return [];
    }
  }
  /**
   * Get subscription from marketplace account
   */
  async getSubscription(accountId) {
    const accounts = await this.getAccounts();
    const account = accounts.find((a) => a.id === accountId);
    if (!account) {
      return null;
    }
    let tier = "free" /* FREE */;
    if (account.plan.monthlyPriceInCents >= 5e3) {
      tier = "enterprise" /* ENTERPRISE */;
    } else if (account.plan.monthlyPriceInCents >= 2e3) {
      tier = "team" /* TEAM */;
    } else if (account.plan.monthlyPriceInCents >= 500) {
      tier = "solo" /* SOLO */;
    }
    return {
      tier,
      status: "active" /* ACTIVE */,
      provider: "marketplace" /* MARKETPLACE */,
      marketplacePlanId: account.plan.id,
      startDate: account.onFreeTrial && account.freeTrialEndsOn ? new Date(account.freeTrialEndsOn).getTime() : Date.now(),
      periodEnd: account.nextBillingDate ? new Date(account.nextBillingDate).getTime() : void 0,
      autoRenew: true,
      limits: TIER_LIMITS[tier]
    };
  }
  /**
   * Handle marketplace webhook event
   */
  handleWebhookEvent(event) {
    const account = event.marketplacePurchase.account;
    if (event.action === "cancelled") {
      return null;
    }
    let tier = "free" /* FREE */;
    if (account.plan.monthlyPriceInCents >= 5e3) {
      tier = "enterprise" /* ENTERPRISE */;
    } else if (account.plan.monthlyPriceInCents >= 2e3) {
      tier = "team" /* TEAM */;
    } else if (account.plan.monthlyPriceInCents >= 500) {
      tier = "solo" /* SOLO */;
    }
    return {
      userId: account.id,
      userLogin: account.login,
      subscription: {
        tier,
        status: "active" /* ACTIVE */,
        provider: "marketplace" /* MARKETPLACE */,
        marketplacePlanId: account.plan.id,
        startDate: Date.now(),
        periodEnd: event.marketplacePurchase.nextBillingDate ? new Date(event.marketplacePurchase.nextBillingDate).getTime() : void 0,
        autoRenew: true,
        limits: TIER_LIMITS[tier]
      }
    };
  }
};
function createMarketplaceClient(token) {
  return new GitHubMarketplaceClient(token);
}

// src/cloud/provisioning.ts
function generateStorageNamespace(githubLogin, userId) {
  const sanitized = githubLogin.toLowerCase().replace(/[^a-z0-9]/g, "-");
  const hash = userId.toString(36).padStart(6, "0");
  return `gh-${sanitized}-${hash}`;
}
function generateTenantId(githubUser) {
  return `github-${githubUser.id}`;
}
function createTenant(githubUser, subscription) {
  const tenantId = generateTenantId(githubUser);
  const storageNamespace = generateStorageNamespace(githubUser.login, githubUser.id);
  return {
    id: tenantId,
    githubUserId: githubUser.id,
    githubLogin: githubUser.login,
    type: "user",
    // Could be "organization" if checking org membership
    subscription,
    storageNamespace,
    createdAt: Date.now(),
    lastAccessedAt: Date.now()
  };
}
function validateStorageNamespace(namespace) {
  if (namespace.length < 3 || namespace.length > 63) {
    return {
      valid: false,
      error: "Namespace must be 3-63 characters"
    };
  }
  if (!/^[a-z0-9]/.test(namespace)) {
    return {
      valid: false,
      error: "Namespace must start with a letter or number"
    };
  }
  if (!/^[a-z0-9-]+$/.test(namespace)) {
    return {
      valid: false,
      error: "Namespace can only contain lowercase letters, numbers, and hyphens"
    };
  }
  if (/--/.test(namespace)) {
    return {
      valid: false,
      error: "Namespace cannot contain consecutive hyphens"
    };
  }
  return { valid: true };
}
function getAppStorageContainer(tenantNamespace, appId) {
  const sanitizedAppId = appId.toLowerCase().replace(/[^a-z0-9]/g, "-");
  return `${tenantNamespace}-${sanitizedAppId}`;
}
async function provisionTenant(githubUser, subscription) {
  try {
    const tenant = createTenant(githubUser, subscription);
    const validation = validateStorageNamespace(tenant.storageNamespace);
    if (!validation.valid) {
      return {
        success: false,
        error: validation.error
      };
    }
    console.log(`Provisioned tenant: ${tenant.id}`);
    console.log(`Storage namespace: ${tenant.storageNamespace}`);
    return {
      success: true,
      tenant
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error)
    };
  }
}
async function getOrCreateTenant(githubUser, subscription, tenantLookup) {
  const tenantId = generateTenantId(githubUser);
  const existing = await tenantLookup(tenantId);
  if (existing) {
    existing.lastAccessedAt = Date.now();
    return existing;
  }
  const result = await provisionTenant(githubUser, subscription);
  if (!result.success || !result.tenant) {
    throw new Error(`Failed to provision tenant: ${result.error}`);
  }
  return result.tenant;
}

// src/cloud/relay/endpoints.ts
var storage = {
  syncs: /* @__PURE__ */ new Map(),
  usage: /* @__PURE__ */ new Map()
};
async function healthEndpoint(context, _req) {
  context.log("Health check requested");
  const response = {
    status: "healthy",
    timestamp: Date.now(),
    version: "0.1.0",
    services: {
      relay: true,
      eventGrid: true,
      storage: true,
      auth: true
    }
  };
  return {
    status: 200,
    headers: { "Content-Type": "application/json" },
    body: response
  };
}
async function syncEndpoint(context, req) {
  context.log("Sync request received");
  if (req.method !== "POST") {
    return {
      status: 405,
      body: { error: "Method not allowed" }
    };
  }
  const message = req.body;
  if (!message || !message.appId) {
    return {
      status: 400,
      body: { error: "Invalid sync message" }
    };
  }
  const appSyncs = storage.syncs.get(message.appId) || [];
  appSyncs.push(message);
  storage.syncs.set(message.appId, appSyncs);
  const usage = storage.usage.get(message.appId) || {
    appId: message.appId,
    syncCount: 0,
    eventCount: 0,
    factCount: 0,
    storageBytes: 0,
    periodStart: Date.now(),
    periodEnd: Date.now()
  };
  usage.syncCount++;
  usage.eventCount += message.events?.length || 0;
  usage.factCount += message.facts?.length || 0;
  usage.storageBytes += JSON.stringify(message).length;
  usage.periodEnd = Date.now();
  storage.usage.set(message.appId, usage);
  context.log(`Synced for app ${message.appId}: ${usage.syncCount} total syncs`);
  return {
    status: 200,
    headers: { "Content-Type": "application/json" },
    body: {
      success: true,
      clock: message.clock,
      timestamp: Date.now()
    }
  };
}
async function usageEndpoint(context, req) {
  context.log("Usage metrics requested");
  const appId = req.query.appId;
  if (!appId) {
    return {
      status: 400,
      body: { error: "appId query parameter is required" }
    };
  }
  const usage = storage.usage.get(appId);
  if (!usage) {
    return {
      status: 404,
      body: { error: "No usage data found for this app" }
    };
  }
  return {
    status: 200,
    headers: { "Content-Type": "application/json" },
    body: usage
  };
}
async function statsEndpoint(context, req) {
  context.log("Stats requested");
  const appId = req.query.appId;
  if (!appId) {
    return {
      status: 400,
      body: { error: "appId query parameter is required" }
    };
  }
  const usage = storage.usage.get(appId);
  const syncs = storage.syncs.get(appId) || [];
  return {
    status: 200,
    headers: { "Content-Type": "application/json" },
    body: {
      appId,
      totalSyncs: syncs.length,
      usage: usage || null,
      lastSync: syncs.length > 0 ? syncs[syncs.length - 1].timestamp : null
    }
  };
}
async function eventsEndpoint(context, req) {
  context.log("Event forwarding requested");
  if (req.method !== "POST") {
    return {
      status: 405,
      body: { error: "Method not allowed" }
    };
  }
  const { appId, events } = req.body;
  if (!appId || !events) {
    return {
      status: 400,
      body: { error: "Invalid event forwarding request" }
    };
  }
  context.log(`Forwarding ${events.length} events for app ${appId}`);
  return {
    status: 200,
    headers: { "Content-Type": "application/json" },
    body: {
      success: true,
      forwarded: events.length,
      timestamp: Date.now()
    }
  };
}
async function schemaEndpoint(context, req) {
  context.log("Schema registry requested");
  if (req.method === "POST") {
    const { appId: appId2, schema } = req.body;
    if (!appId2 || !schema) {
      return {
        status: 400,
        body: { error: "Invalid schema registration request" }
      };
    }
    context.log(`Schema registered for app ${appId2}`);
    return {
      status: 200,
      headers: { "Content-Type": "application/json" },
      body: {
        success: true,
        schemaId: `${appId2}-${Date.now()}`,
        timestamp: Date.now()
      }
    };
  }
  const appId = req.query.appId;
  if (!appId) {
    return {
      status: 400,
      body: { error: "appId query parameter is required" }
    };
  }
  return {
    status: 200,
    headers: { "Content-Type": "application/json" },
    body: {
      appId,
      schema: null,
      message: "Schema not found"
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BillingProvider,
  GitHubMarketplaceClient,
  GitHubOAuth,
  GitHubSponsorsClient,
  MARKETPLACE_PLANS,
  SubscriptionStatus,
  SubscriptionTier,
  TIER_LIMITS,
  authenticateWithDeviceFlow,
  checkUsageLimits,
  connectRelay,
  createCloudRelay,
  createFreeSubscription,
  createGitHubOAuth,
  createMarketplaceClient,
  createSponsorSubscription,
  createSponsorsClient,
  createTenant,
  eventsEndpoint,
  generateStorageNamespace,
  generateTenantId,
  getAppStorageContainer,
  getOrCreateTenant,
  hasAccessToTier,
  healthEndpoint,
  provisionTenant,
  schemaEndpoint,
  statsEndpoint,
  syncEndpoint,
  usageEndpoint,
  validateStorageNamespace
});

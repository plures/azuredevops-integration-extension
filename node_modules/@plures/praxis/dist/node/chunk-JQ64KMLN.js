// src/core/pluresdb/adapter.ts
var InMemoryPraxisDB = class {
  store = /* @__PURE__ */ new Map();
  watchers = /* @__PURE__ */ new Map();
  async get(key) {
    return this.store.get(key);
  }
  async set(key, value) {
    this.store.set(key, value);
    const keyWatchers = this.watchers.get(key);
    if (keyWatchers) {
      for (const callback of keyWatchers) {
        callback(value);
      }
    }
  }
  watch(key, callback) {
    if (!this.watchers.has(key)) {
      this.watchers.set(key, /* @__PURE__ */ new Set());
    }
    const watchers = this.watchers.get(key);
    const wrappedCallback = (val) => callback(val);
    watchers.add(wrappedCallback);
    return () => {
      watchers.delete(wrappedCallback);
      if (watchers.size === 0) {
        this.watchers.delete(key);
      }
    };
  }
  /**
   * Get all keys (for testing/debugging)
   */
  keys() {
    return Array.from(this.store.keys());
  }
  /**
   * Clear all data (for testing)
   */
  clear() {
    this.store.clear();
    this.watchers.clear();
  }
};
function createInMemoryDB() {
  return new InMemoryPraxisDB();
}
var PluresDBPraxisAdapter = class {
  db;
  watchers = /* @__PURE__ */ new Map();
  pollIntervals = /* @__PURE__ */ new Map();
  lastValues = /* @__PURE__ */ new Map();
  pollInterval;
  constructor(config) {
    if ("get" in config && "put" in config) {
      this.db = config;
      this.pollInterval = 1e3;
    } else {
      this.db = config.db;
      this.pollInterval = config.pollInterval ?? 1e3;
    }
  }
  async get(key) {
    try {
      const value = await this.db.get(key);
      return value;
    } catch (error) {
      return void 0;
    }
  }
  async set(key, value) {
    await this.db.put(key, value);
    this.lastValues.set(key, value);
    const keyWatchers = this.watchers.get(key);
    if (keyWatchers) {
      for (const callback of keyWatchers) {
        callback(value);
      }
    }
  }
  watch(key, callback) {
    if (!this.watchers.has(key)) {
      this.watchers.set(key, /* @__PURE__ */ new Set());
    }
    const watchers = this.watchers.get(key);
    const wrappedCallback = (val) => callback(val);
    watchers.add(wrappedCallback);
    if (!this.pollIntervals.has(key)) {
      const interval = setInterval(async () => {
        try {
          const value = await this.db.get(key);
          const lastValue = this.lastValues.get(key);
          if (JSON.stringify(value) !== JSON.stringify(lastValue)) {
            this.lastValues.set(key, value);
            const currentWatchers = this.watchers.get(key);
            if (currentWatchers) {
              for (const cb of currentWatchers) {
                cb(value);
              }
            }
          }
        } catch (error) {
        }
      }, this.pollInterval);
      this.pollIntervals.set(key, interval);
    }
    return () => {
      watchers.delete(wrappedCallback);
      if (watchers.size === 0) {
        this.watchers.delete(key);
        const interval = this.pollIntervals.get(key);
        if (interval) {
          clearInterval(interval);
          this.pollIntervals.delete(key);
        }
        this.lastValues.delete(key);
      }
    };
  }
  /**
   * Clean up all resources
   */
  dispose() {
    for (const interval of this.pollIntervals.values()) {
      clearInterval(interval);
    }
    this.pollIntervals.clear();
    this.watchers.clear();
    this.lastValues.clear();
  }
};
function createPluresDB(config) {
  return new PluresDBPraxisAdapter(config);
}

export {
  InMemoryPraxisDB,
  createInMemoryDB,
  PluresDBPraxisAdapter,
  createPluresDB
};

import {
  createStateDocsGenerator
} from "./chunk-S54337I5.js";
import {
  loadSchemaFromFile
} from "./chunk-UY7YEBE2.js";
import "./chunk-UATVJBNV.js";
import "./chunk-QGM4M3NI.js";

// src/cli/commands/docs.ts
import * as fs from "fs";
import * as path from "path";
async function docs(schemaOrRegistryPath, options) {
  console.log("\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557");
  console.log("\u2551   Praxis Documentation Generator                 \u2551");
  console.log("\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D\n");
  if (!schemaOrRegistryPath || !fs.existsSync(schemaOrRegistryPath)) {
    console.error("Error: Schema or registry file required");
    console.log("Usage: praxis docs <schema-file> [options]");
    console.log("\nOptions:");
    console.log("  --output <dir>       Output directory (default: ./docs)");
    console.log("  --title <title>      Documentation title");
    console.log("  --format <format>    Diagram format: mermaid (default) or dot");
    console.log("  --no-toc            Disable table of contents");
    console.log("  --no-timestamp      Disable timestamp");
    console.log("  --from-registry      Generate from registry instead of schema");
    process.exit(1);
  }
  const outputDir = options.output || "./docs";
  const title = options.title || "Praxis Application";
  const generator = createStateDocsGenerator({
    projectTitle: title,
    target: outputDir,
    visualization: {
      format: options.format || "mermaid",
      exportPng: false
    },
    template: {
      toc: options.toc !== false,
      timestamp: options.timestamp !== false,
      header: options.header,
      footer: options.footer
    }
  });
  console.log(`Source: ${schemaOrRegistryPath}`);
  console.log(`Output: ${outputDir}
`);
  try {
    let generatedDocs;
    if (options.fromRegistry) {
      console.log("Loading registry module...");
      const module = await import(path.resolve(schemaOrRegistryPath));
      const registry = module.registry || module.default || module;
      if (!registry || typeof registry.getAllRules !== "function") {
        console.error("Error: Invalid registry module");
        console.log("Expected: export const registry = new PraxisRegistry()");
        process.exit(1);
      }
      console.log("Generating documentation from registry...");
      const praxisModule = {
        rules: registry.getAllRules(),
        constraints: registry.getAllConstraints()
      };
      generatedDocs = generator.generateFromModule(praxisModule);
    } else {
      console.log("Loading schema...");
      const result = await loadSchemaFromFile(schemaOrRegistryPath);
      if (result.errors.length > 0 || !result.schema) {
        console.error(`Error loading schema: ${result.errors.join(", ")}`);
        process.exit(1);
      }
      console.log("Generating documentation from schema...");
      generatedDocs = generator.generateFromSchema(result.schema);
    }
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    console.log("\nWriting documentation files:\n");
    for (const doc of generatedDocs) {
      const fullPath = path.resolve(doc.path);
      const dir = path.dirname(fullPath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      fs.writeFileSync(fullPath, doc.content);
      console.log(`  \u2713 ${doc.path} (${doc.type})`);
    }
    console.log(`
\u2713 Generated ${generatedDocs.length} documentation file(s)`);
    console.log(`
View your documentation: ${path.resolve(outputDir, "README.md")}`);
  } catch (error) {
    console.error(`Error generating documentation: ${error}`);
    if (error instanceof Error) {
      console.error(error.stack);
    }
    process.exit(1);
  }
}
export {
  docs
};

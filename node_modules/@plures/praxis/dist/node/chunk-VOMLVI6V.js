// src/core/protocol.ts
var PRAXIS_PROTOCOL_VERSION = "1.0.0";

// src/core/engine.ts
function safeClone(value) {
  if (value === null || typeof value !== "object") {
    return value;
  }
  if (typeof globalThis.structuredClone === "function") {
    try {
      return globalThis.structuredClone(value);
    } catch {
    }
  }
  if (Array.isArray(value)) {
    return [...value];
  }
  return { ...value };
}
var LogicEngine = class {
  state;
  registry;
  constructor(options) {
    this.registry = options.registry;
    this.state = {
      context: options.initialContext,
      facts: options.initialFacts ?? [],
      meta: options.initialMeta ?? {},
      protocolVersion: PRAXIS_PROTOCOL_VERSION
    };
  }
  /**
   * Get the current state (immutable copy)
   */
  getState() {
    return {
      context: safeClone(this.state.context),
      facts: [...this.state.facts],
      meta: this.state.meta ? safeClone(this.state.meta) : void 0,
      protocolVersion: this.state.protocolVersion
    };
  }
  /**
   * Get the current context
   */
  getContext() {
    return safeClone(this.state.context);
  }
  /**
   * Get current facts
   */
  getFacts() {
    return [...this.state.facts];
  }
  /**
   * Process events through the engine.
   * Applies all registered rules and checks all registered constraints.
   *
   * @param events Events to process
   * @returns Result with new state and diagnostics
   */
  step(events) {
    const config = {
      ruleIds: this.registry.getRuleIds(),
      constraintIds: this.registry.getConstraintIds()
    };
    return this.stepWithConfig(events, config);
  }
  /**
   * Process events with specific rule and constraint configuration.
   *
   * @param events Events to process
   * @param config Step configuration
   * @returns Result with new state and diagnostics
   */
  stepWithConfig(events, config) {
    const diagnostics = [];
    let newState = { ...this.state };
    const newFacts = [];
    for (const ruleId of config.ruleIds) {
      const rule = this.registry.getRule(ruleId);
      if (!rule) {
        diagnostics.push({
          kind: "rule-error",
          message: `Rule "${ruleId}" not found in registry`,
          data: { ruleId }
        });
        continue;
      }
      try {
        const ruleFacts = rule.impl(newState, events);
        newFacts.push(...ruleFacts);
      } catch (error) {
        diagnostics.push({
          kind: "rule-error",
          message: `Error executing rule "${ruleId}": ${error instanceof Error ? error.message : String(error)}`,
          data: { ruleId, error }
        });
      }
    }
    newState = {
      ...newState,
      facts: [...newState.facts, ...newFacts]
    };
    for (const constraintId of config.constraintIds) {
      const constraint = this.registry.getConstraint(constraintId);
      if (!constraint) {
        diagnostics.push({
          kind: "constraint-violation",
          message: `Constraint "${constraintId}" not found in registry`,
          data: { constraintId }
        });
        continue;
      }
      try {
        const result = constraint.impl(newState);
        if (result === false) {
          diagnostics.push({
            kind: "constraint-violation",
            message: `Constraint "${constraintId}" violated`,
            data: { constraintId, description: constraint.description }
          });
        } else if (typeof result === "string") {
          diagnostics.push({
            kind: "constraint-violation",
            message: result,
            data: { constraintId, description: constraint.description }
          });
        }
      } catch (error) {
        diagnostics.push({
          kind: "constraint-violation",
          message: `Error checking constraint "${constraintId}": ${error instanceof Error ? error.message : String(error)}`,
          data: { constraintId, error }
        });
      }
    }
    this.state = newState;
    return {
      state: newState,
      diagnostics
    };
  }
  /**
   * Update the context directly (for exceptional cases).
   * Generally, context should be updated through rules.
   *
   * @param updater Function that produces new context from old context
   */
  updateContext(updater) {
    this.state = {
      ...this.state,
      context: updater(this.state.context)
    };
  }
  /**
   * Add facts directly (for exceptional cases).
   * Generally, facts should be added through rules.
   *
   * @param facts Facts to add
   */
  addFacts(facts) {
    this.state = {
      ...this.state,
      facts: [...this.state.facts, ...facts]
    };
  }
  /**
   * Clear all facts
   */
  clearFacts() {
    this.state = {
      ...this.state,
      facts: []
    };
  }
  /**
   * Reset the engine to initial state
   */
  reset(options) {
    this.state = {
      context: options.initialContext,
      facts: options.initialFacts ?? [],
      meta: options.initialMeta ?? {},
      protocolVersion: PRAXIS_PROTOCOL_VERSION
    };
  }
};
function createPraxisEngine(options) {
  return new LogicEngine(options);
}

export {
  PRAXIS_PROTOCOL_VERSION,
  LogicEngine,
  createPraxisEngine
};

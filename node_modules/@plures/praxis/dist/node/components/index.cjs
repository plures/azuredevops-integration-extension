"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/components/index.ts
var components_exports = {};
__export(components_exports, {
  createTerminalAdapter: () => createTerminalAdapter
});
module.exports = __toCommonJS(components_exports);

// src/runtime/terminal-adapter.ts
async function defaultExecutor(command, options) {
  try {
    const { exec } = await import("child_process");
    const { promisify } = await import("util");
    const execAsync = promisify(exec);
    const processEnv = typeof process !== "undefined" ? process.env : {};
    const result = await execAsync(command, {
      cwd: options.cwd,
      env: { ...processEnv, ...options.env },
      maxBuffer: 10 * 1024 * 1024,
      // 10MB buffer
      timeout: 6e4
      // 60 second timeout
    });
    return {
      output: result.stdout + (result.stderr ? `
${result.stderr}` : ""),
      exitCode: 0
    };
  } catch (error) {
    const execError = error;
    return {
      output: (execError.stdout || "") + (execError.stderr || ""),
      exitCode: execError.code || 1,
      error: execError.message || "Command execution failed"
    };
  }
}
var TerminalAdapter = class {
  state;
  inputPath;
  outputPath;
  db;
  executor;
  constructor(options) {
    this.state = {
      nodeId: options.nodeId,
      inputMode: options.props?.inputMode || "text",
      history: options.props?.history || [],
      lastOutput: options.props?.lastOutput || null,
      cwd: options.cwd,
      env: options.env
    };
    this.inputPath = options.inputPath;
    this.outputPath = options.outputPath;
    this.db = options.db;
    this.executor = options.executor || defaultExecutor;
  }
  /**
   * Execute a terminal command
   *
   * @param command - Command to execute
   * @returns Execution result
   */
  async executeCommand(command) {
    this.state.history.push(command);
    const timestamp = Date.now();
    const { output, exitCode, error } = await this.executor(command, {
      cwd: this.state.cwd,
      env: this.state.env
    });
    const result = {
      command,
      output,
      exitCode,
      timestamp,
      error
    };
    this.state.lastOutput = output;
    if (this.db && this.outputPath) {
      await this.syncToPluresDB(this.outputPath, result);
    }
    return result;
  }
  /**
   * Get current terminal state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Update terminal props
   */
  updateProps(props) {
    this.state = {
      ...this.state,
      ...props
    };
  }
  /**
   * Set working directory
   */
  setCwd(cwd) {
    this.state.cwd = cwd;
  }
  /**
   * Set environment variables
   */
  setEnv(env) {
    this.state.env = { ...this.state.env, ...env };
  }
  /**
   * Clear command history
   */
  clearHistory() {
    this.state.history = [];
  }
  /**
   * Get command history
   */
  getHistory() {
    return [...this.state.history];
  }
  /**
   * Sync state to PluresDB
   *
   * @param path - PluresDB path for storing results
   * @param data - Data to sync
   */
  async syncToPluresDB(path, data) {
    if (!this.db) return;
    try {
      await this.db.set(path, {
        ...data,
        nodeId: this.state.nodeId,
        syncedAt: Date.now()
      });
      const historyPath = `${path}/history`;
      const historyKey = `${historyPath}/${data.timestamp}`;
      await this.db.set(historyKey, data);
    } catch (error) {
      console.warn("Failed to sync to PluresDB:", error);
    }
  }
  /**
   * Load state from PluresDB
   */
  async loadFromPluresDB() {
    if (!this.db || !this.inputPath) return;
    try {
      const data = await this.db.get(this.inputPath);
      if (data && typeof data === "object") {
        const savedState = data;
        if (savedState.history) {
          this.state.history = savedState.history;
        }
        if (savedState.lastOutput !== void 0) {
          this.state.lastOutput = savedState.lastOutput;
        }
        if (savedState.cwd) {
          this.state.cwd = savedState.cwd;
        }
        if (savedState.env) {
          this.state.env = savedState.env;
        }
      }
    } catch (error) {
      console.warn("Failed to load from PluresDB:", error);
    }
  }
  /**
   * Subscribe to input changes from PluresDB
   */
  watchInput(callback) {
    if (!this.db || !this.inputPath) return null;
    return this.db.watch(this.inputPath, (data) => {
      if (data && typeof data === "object" && "command" in data) {
        callback(data.command);
      }
    });
  }
};
function createTerminalAdapter(options) {
  return new TerminalAdapter(options);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createTerminalAdapter
});

import {
  canvasToMermaid,
  canvasToYaml,
  createCanvasEditor,
  schemaToCanvas
} from "./chunk-SRM3OPPM.js";
import {
  loadSchemaFromFile
} from "./chunk-UY7YEBE2.js";
import "./chunk-UATVJBNV.js";
import "./chunk-QGM4M3NI.js";

// src/cli/commands/canvas.ts
import * as fs from "fs";
import * as path from "path";
import * as http from "http";
import { spawn } from "child_process";
async function canvas(schemaPath, options) {
  const port = parseInt(options.port || "3000", 10);
  console.log("\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557");
  console.log("\u2551   CodeCanvas Visual Editor                        \u2551");
  console.log("\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D\n");
  if (options.export) {
    await exportCanvas(schemaPath, options);
    return;
  }
  let schema;
  if (schemaPath && fs.existsSync(schemaPath)) {
    try {
      const result = await loadSchemaFromFile(schemaPath);
      if (result.errors.length > 0) {
        console.error(`Error loading schema: ${result.errors.join(", ")}`);
        process.exit(1);
      }
      const loadedSchema = result.schema;
      console.log("Loaded schema keys:", Object.keys(loadedSchema));
      console.log("Has logic:", !!loadedSchema.logic);
      console.log("Has events:", !!loadedSchema.events);
      if (loadedSchema.logic && !loadedSchema.events) {
        console.log("Converting legacy schema to PSF format...");
        console.log(`Found ${loadedSchema.logic.length} logic groups.`);
        const rules = [];
        const flows = [];
        loadedSchema.logic.forEach((l) => {
          const flowId = l.id || "default-flow";
          console.log(`Processing flow: ${flowId}`);
          flows.push({
            id: flowId,
            name: l.description || flowId,
            type: "sequence",
            steps: [],
            // Populated implicitly by rules for now
            description: l.description
          });
          (l.rules || []).forEach((r) => {
            rules.push({
              ...r,
              id: r.id || r.name,
              triggers: r.on,
              meta: { ...r.meta, flowId }
            });
          });
        });
        const facts = loadedSchema.logic.flatMap((l) => l.facts || []).map((f) => ({
          ...f,
          id: f.id || f.name
        }));
        const inferredModels = /* @__PURE__ */ new Map();
        inferredModels.set("Connection", {
          id: "Connection",
          name: "Connection",
          description: "Azure DevOps Connection",
          properties: [
            { name: "id", type: "string" },
            { name: "name", type: "string" },
            { name: "orgUrl", type: "string" },
            { name: "project", type: "string" },
            { name: "token", type: "string" }
          ]
        });
        inferredModels.set("WorkItem", {
          id: "WorkItem",
          name: "WorkItem",
          description: "Azure DevOps Work Item",
          properties: [
            { name: "id", type: "number" },
            { name: "title", type: "string" },
            { name: "state", type: "string" },
            { name: "type", type: "string" },
            { name: "assignedTo", type: "string" }
          ]
        });
        const eventSet = /* @__PURE__ */ new Set();
        loadedSchema.logic.forEach((l) => {
          (l.events || []).forEach((e) => eventSet.add(typeof e === "string" ? e : e.name));
        });
        rules.forEach((r) => {
          (r.on || []).forEach((e) => eventSet.add(e));
          if (r.logic && r.logic.events) {
            r.logic.events.forEach((e) => eventSet.add(e));
          }
        });
        const connections = [];
        const factMap = new Map(facts.map((f) => [f.name, f.id]));
        rules.forEach((r) => {
          (r.on || []).forEach((e) => {
            connections.push({
              id: `conn_evt_${e}_${r.id}`,
              source: e,
              target: r.id,
              type: "event",
              label: "triggers"
            });
          });
          if (r.do) {
            const doStrs = Array.isArray(r.do) ? r.do : [r.do];
            doStrs.forEach((action) => {
              factMap.forEach((factId, factName) => {
                if (typeof action === "string" && action.includes(factName)) {
                  connections.push({
                    id: `conn_act_${r.id}_${factId}`,
                    source: r.id,
                    target: factId,
                    type: "control",
                    label: "updates"
                  });
                }
              });
            });
          }
        });
        schema = {
          $version: loadedSchema.version || "1.0.0",
          id: loadedSchema.name || "schema",
          name: loadedSchema.name,
          description: loadedSchema.description,
          models: [...loadedSchema.models || [], ...inferredModels.values()],
          components: loadedSchema.components || [],
          events: Array.from(eventSet).map((name) => ({
            id: name,
            tag: name,
            name,
            payload: { type: "object", properties: {} }
          })),
          facts,
          rules,
          constraints: loadedSchema.logic.flatMap((l) => l.constraints || []),
          flows,
          canvas: {
            connections
          },
          metadata: loadedSchema.metadata
        };
      } else {
        schema = loadedSchema;
      }
      console.log(`\u2713 Loaded schema: ${schemaPath}`);
    } catch (error) {
      console.error(`Error loading schema: ${error}`);
      process.exit(1);
    }
  }
  const editor = createCanvasEditor({ schema, layout: "hierarchical" });
  console.log(`
Starting Canvas API server on http://localhost:${port}`);
  const server = http.createServer((req, res) => {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type");
    if (req.method === "OPTIONS") {
      res.writeHead(200);
      res.end();
      return;
    }
    if (req.url === "/api/canvas") {
      res.writeHead(200, { "Content-Type": "application/json" });
      res.end(JSON.stringify(editor.document));
    } else if (req.url === "/api/mermaid") {
      res.writeHead(200, { "Content-Type": "text/plain" });
      res.end(editor.toMermaid());
    } else if (req.url === "/api/yaml") {
      res.writeHead(200, { "Content-Type": "text/yaml" });
      res.end(editor.toYaml());
    } else if (req.url === "/api/schema") {
      res.writeHead(200, { "Content-Type": "application/json" });
      res.end(JSON.stringify(editor.toSchema()));
    } else {
      res.writeHead(404);
      res.end("Not found");
    }
  });
  server.listen(port, () => {
    console.log("Canvas API server running!");
    console.log("Starting UI...");
    const vitePort = 5173;
    const isWin = process.platform === "win32";
    const cmd = isWin ? "cmd.exe" : "npm";
    const args = isWin ? [
      "/d",
      "/s",
      "/c",
      "npm",
      "exec",
      "--prefix",
      "praxis",
      "vite",
      "praxis/ui/canvas",
      "--",
      "--port",
      vitePort.toString()
    ] : [
      "exec",
      "--prefix",
      "praxis",
      "vite",
      "praxis/ui/canvas",
      "--",
      "--port",
      vitePort.toString()
    ];
    const vite = spawn(cmd, args, {
      stdio: "inherit",
      shell: false,
      env: { ...process.env, API_URL: `http://localhost:${port}` }
    });
    console.log(`
  UI:      http://localhost:${vitePort}`);
    console.log(`  API:     http://localhost:${port}/api/canvas`);
    console.log("Press Ctrl+C to stop.\n");
    vite.on("close", (code) => {
      console.log(`UI process exited with code ${code}`);
      server.close();
      process.exit(code || 0);
    });
  });
  process.on("SIGINT", () => {
    console.log("\nShutting down Canvas server...");
    server.close();
    process.exit(0);
  });
}
async function exportCanvas(schemaPath, options) {
  if (!schemaPath || !fs.existsSync(schemaPath)) {
    console.error("Error: Schema file required for export");
    console.log("Usage: praxis canvas <schema-file> --export yaml --output schema.canvas.yaml");
    process.exit(1);
  }
  const result = await loadSchemaFromFile(schemaPath);
  if (result.errors.length > 0 || !result.schema) {
    console.error(`Error loading schema: ${result.errors.join(", ")}`);
    process.exit(1);
  }
  const loadedSchema = result.schema;
  let schema;
  if (loadedSchema.logic && !loadedSchema.events) {
    console.log("Converting legacy schema to PSF format...");
    const rules = [];
    const flows = [];
    loadedSchema.logic.forEach((l) => {
      const flowId = l.id || "default-flow";
      flows.push({
        id: flowId,
        name: l.description || flowId,
        type: "sequence",
        steps: [],
        // Populated implicitly by rules for now
        description: l.description
      });
      (l.rules || []).forEach((r) => {
        rules.push({
          ...r,
          id: r.id || r.name,
          triggers: r.on,
          meta: { ...r.meta, flowId }
        });
      });
    });
    const facts = loadedSchema.logic.flatMap((l) => l.facts || []).map((f) => ({
      ...f,
      id: f.id || f.name
    }));
    const inferredModels = /* @__PURE__ */ new Map();
    inferredModels.set("Connection", {
      id: "Connection",
      name: "Connection",
      description: "Azure DevOps Connection",
      properties: [
        { name: "id", type: "string" },
        { name: "name", type: "string" },
        { name: "orgUrl", type: "string" },
        { name: "project", type: "string" },
        { name: "token", type: "string" }
      ]
    });
    inferredModels.set("WorkItem", {
      id: "WorkItem",
      name: "WorkItem",
      description: "Azure DevOps Work Item",
      properties: [
        { name: "id", type: "number" },
        { name: "title", type: "string" },
        { name: "state", type: "string" },
        { name: "type", type: "string" },
        { name: "assignedTo", type: "string" }
      ]
    });
    const eventSet = /* @__PURE__ */ new Set();
    loadedSchema.logic.forEach((l) => {
      (l.events || []).forEach((e) => eventSet.add(typeof e === "string" ? e : e.name));
    });
    rules.forEach((r) => {
      (r.on || []).forEach((e) => eventSet.add(e));
      if (r.logic && r.logic.events) {
        r.logic.events.forEach((e) => eventSet.add(e));
      }
    });
    schema = {
      $version: loadedSchema.version || "1.0.0",
      id: loadedSchema.name || "schema",
      name: loadedSchema.name,
      description: loadedSchema.description,
      models: [...loadedSchema.models || [], ...inferredModels.values()],
      components: loadedSchema.components || [],
      events: Array.from(eventSet).map((name) => ({
        id: name,
        tag: name,
        name,
        payload: { type: "object", properties: {} }
      })),
      facts,
      rules,
      constraints: loadedSchema.logic.flatMap((l) => l.constraints || []),
      flows,
      metadata: loadedSchema.metadata
    };
  } else {
    schema = loadedSchema;
  }
  const canvas2 = schemaToCanvas(schema);
  let output;
  let ext;
  switch (options.export) {
    case "yaml":
      output = canvasToYaml(canvas2);
      ext = "yaml";
      break;
    case "mermaid":
      output = canvasToMermaid(canvas2);
      ext = "mmd";
      break;
    case "json":
    default:
      output = JSON.stringify(canvas2, null, 2);
      ext = "json";
  }
  const outputPath = options.output || `${path.basename(schemaPath, path.extname(schemaPath))}.canvas.${ext}`;
  fs.writeFileSync(outputPath, output);
  console.log(`\u2713 Exported canvas to: ${outputPath}`);
}
export {
  canvas
};

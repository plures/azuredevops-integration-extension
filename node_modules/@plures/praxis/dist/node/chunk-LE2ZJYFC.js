import {
  createPraxisEngine
} from "./chunk-VOMLVI6V.js";

// src/core/rules.ts
var PraxisRegistry = class {
  rules = /* @__PURE__ */ new Map();
  constraints = /* @__PURE__ */ new Map();
  /**
   * Register a rule
   */
  registerRule(descriptor) {
    if (this.rules.has(descriptor.id)) {
      throw new Error(`Rule with id "${descriptor.id}" already registered`);
    }
    this.rules.set(descriptor.id, descriptor);
  }
  /**
   * Register a constraint
   */
  registerConstraint(descriptor) {
    if (this.constraints.has(descriptor.id)) {
      throw new Error(`Constraint with id "${descriptor.id}" already registered`);
    }
    this.constraints.set(descriptor.id, descriptor);
  }
  /**
   * Register a module (all its rules and constraints)
   */
  registerModule(module) {
    for (const rule of module.rules) {
      this.registerRule(rule);
    }
    for (const constraint of module.constraints) {
      this.registerConstraint(constraint);
    }
  }
  /**
   * Get a rule by ID
   */
  getRule(id) {
    return this.rules.get(id);
  }
  /**
   * Get a constraint by ID
   */
  getConstraint(id) {
    return this.constraints.get(id);
  }
  /**
   * Get all registered rule IDs
   */
  getRuleIds() {
    return Array.from(this.rules.keys());
  }
  /**
   * Get all registered constraint IDs
   */
  getConstraintIds() {
    return Array.from(this.constraints.keys());
  }
  /**
   * Get all rules
   */
  getAllRules() {
    return Array.from(this.rules.values());
  }
  /**
   * Get all constraints
   */
  getAllConstraints() {
    return Array.from(this.constraints.values());
  }
};

// src/core/reactive-engine.svelte.ts
import * as $ from "svelte/internal/client";
var ReactiveLogicEngine = class {
  #state = (
    // Use Svelte's $state rune for automatic reactivity
    $.state($.proxy({ context: {}, facts: [], meta: {} }))
  );
  get state() {
    return $.get(this.#state);
  }
  set state(value) {
    $.set(this.#state, value, true);
  }
  _engine;
  constructor(options) {
    this.state.context = options.initialContext;
    this.state.facts = options.initialFacts ?? [];
    this.state.meta = options.initialMeta ?? {};
    if (options.registry) {
      this._engine = createPraxisEngine({
        initialContext: options.initialContext,
        registry: options.registry
      });
    } else {
      this._engine = createPraxisEngine({
        initialContext: options.initialContext,
        registry: new PraxisRegistry()
      });
    }
  }
  /**
   * Access the reactive context.
   * In Svelte 5 components, changes to this object will automatically trigger updates.
   */
  get context() {
    return this.state.context;
  }
  /**
   * Access the reactive facts list.
   */
  get facts() {
    return this.state.facts;
  }
  /**
   * Access the reactive metadata.
   */
  get meta() {
    return this.state.meta;
  }
  /**
   * Apply a mutation to the state.
   * Changes will automatically trigger Svelte reactivity.
   * 
   * @param mutator A function that receives the state and modifies it.
   */
  apply(mutator) {
    mutator(this.state);
  }
  /**
   * Process events through the logic engine and update reactive state.
   * 
   * @param events Events to process
   */
  step(events) {
    const result = this._engine.step(events);
    this.state.context = result.state.context;
    this.state.facts = result.state.facts;
    this.state.meta = result.state.meta ?? {};
  }
};
function createReactiveEngine(options) {
  return new ReactiveLogicEngine(options);
}

export {
  PraxisRegistry,
  ReactiveLogicEngine,
  createReactiveEngine
};

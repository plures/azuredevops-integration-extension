// src/integrations/code-canvas.ts
function schemaToCanvas(schema, _options = {}) {
  const nodes = [];
  const edges = [];
  let nodeId = 0;
  let yOffset = 0;
  const xSpacing = 200;
  const ySpacing = 100;
  if (schema.models) {
    schema.models.forEach((model, index) => {
      const pos = model.position && (model.position.x !== 0 || model.position.y !== 0) ? model.position : { x: 50, y: yOffset + index * ySpacing };
      const node = {
        id: model.id || `model-${nodeId++}`,
        type: "model",
        label: model.name,
        x: pos.x,
        y: pos.y,
        width: 150,
        height: 60,
        data: model,
        style: {
          backgroundColor: "#e3f2fd",
          borderColor: "#1976d2"
        }
      };
      nodes.push(node);
    });
    yOffset += schema.models.length * ySpacing + 50;
  }
  if (schema.components) {
    schema.components.forEach((component, index) => {
      const pos = component.position && (component.position.x !== 0 || component.position.y !== 0) ? component.position : { x: 50 + xSpacing, y: yOffset + index * ySpacing };
      const node = {
        id: component.id || `component-${nodeId++}`,
        type: "component",
        label: component.name,
        x: pos.x,
        y: pos.y,
        width: 150,
        height: 60,
        data: component,
        style: {
          backgroundColor: "#e8f5e9",
          borderColor: "#388e3c"
        }
      };
      nodes.push(node);
      if (component.model) {
        const modelNode = nodes.find((n) => n.type === "model" && n.label === component.model);
        if (modelNode) {
          edges.push({
            id: `edge-${edges.length}`,
            source: node.id,
            target: modelNode.id,
            type: "reference",
            label: "uses"
          });
        }
      }
    });
    yOffset += schema.components.length * ySpacing + 50;
  }
  if (schema.events) {
    schema.events.forEach((event, index) => {
      const pos = event.position && (event.position.x !== 0 || event.position.y !== 0) ? event.position : { x: 50 + xSpacing * 2, y: yOffset + index * ySpacing };
      const node = {
        id: event.id || `event-${nodeId++}`,
        type: "event",
        label: event.tag,
        x: pos.x,
        y: pos.y,
        width: 150,
        height: 50,
        data: event,
        style: {
          backgroundColor: "#fff3e0",
          borderColor: "#f57c00"
        }
      };
      nodes.push(node);
    });
    yOffset += schema.events.length * ySpacing + 30;
  }
  if (schema.facts) {
    schema.facts.forEach((fact, index) => {
      const pos = fact.position && (fact.position.x !== 0 || fact.position.y !== 0) ? fact.position : { x: 50 + xSpacing * 3, y: yOffset + index * ySpacing };
      const node = {
        id: fact.id || `fact-${nodeId++}`,
        type: "fact",
        label: fact.tag,
        x: pos.x,
        y: pos.y,
        width: 150,
        height: 50,
        data: fact,
        style: {
          backgroundColor: "#fce4ec",
          borderColor: "#c2185b"
        }
      };
      nodes.push(node);
    });
    yOffset += schema.facts.length * ySpacing + 30;
  }
  if (schema.rules) {
    schema.rules.forEach((rule, index) => {
      const pos = rule.position && (rule.position.x !== 0 || rule.position.y !== 0) ? rule.position : { x: 50 + xSpacing * 4, y: yOffset + index * ySpacing };
      const node = {
        id: rule.id || `rule-${nodeId++}`,
        type: "rule",
        label: rule.id,
        x: pos.x,
        y: pos.y,
        width: 150,
        height: 50,
        data: rule,
        style: {
          backgroundColor: "#e1f5fe",
          borderColor: "#0288d1"
        }
      };
      nodes.push(node);
      if (rule.triggers) {
        rule.triggers.forEach((trigger) => {
          const eventNode = nodes.find((n) => n.type === "event" && n.label === trigger);
          if (eventNode) {
            edges.push({
              id: `edge-${edges.length}`,
              source: eventNode.id,
              target: node.id,
              type: "event",
              label: "triggers"
            });
          }
        });
      }
    });
    yOffset += schema.rules.length * ySpacing + 30;
  }
  if (schema.constraints) {
    schema.constraints.forEach((constraint, index) => {
      const pos = constraint.position && (constraint.position.x !== 0 || constraint.position.y !== 0) ? constraint.position : { x: 50 + xSpacing * 5, y: yOffset + index * ySpacing };
      const node = {
        id: constraint.id || `constraint-${nodeId++}`,
        type: "constraint",
        label: constraint.id,
        x: pos.x,
        y: pos.y,
        width: 150,
        height: 50,
        data: constraint,
        style: {
          backgroundColor: "#ffebee",
          borderColor: "#c62828"
        }
      };
      nodes.push(node);
    });
  }
  return {
    id: `canvas-${Date.now()}`,
    name: schema.name || "Praxis Schema",
    version: schema.$version || "1.0.0",
    nodes,
    edges,
    flows: schema.flows || [],
    metadata: {
      created: Date.now(),
      modified: Date.now(),
      description: schema.description
    },
    viewport: { x: 0, y: 0, zoom: 1 }
  };
}
function canvasToSchema(canvas) {
  const models = [];
  const components = [];
  const events = [];
  const facts = [];
  const rules = [];
  const constraints = [];
  for (const node of canvas.nodes) {
    const position = { x: node.x, y: node.y };
    switch (node.type) {
      case "model":
        if (node.data) {
          models.push({ ...node.data, position });
        }
        break;
      case "component":
        if (node.data) {
          components.push({ ...node.data, position });
        }
        break;
      case "event":
        if (node.data) {
          events.push({ ...node.data, position });
        }
        break;
      case "fact":
        if (node.data) {
          facts.push({ ...node.data, position });
        }
        break;
      case "rule":
        if (node.data) {
          rules.push({ ...node.data, position });
        }
        break;
      case "constraint":
        if (node.data) {
          constraints.push({ ...node.data, position });
        }
        break;
    }
  }
  return {
    $version: "1.0.0",
    id: canvas.id,
    name: canvas.name,
    description: canvas.metadata?.description,
    models,
    components,
    events,
    facts,
    rules,
    constraints,
    flows: canvas.flows || [],
    metadata: canvas.metadata
  };
}
function canvasToYaml(canvas) {
  const lines = [
    `# ${canvas.name}`,
    `# Generated by Praxis CodeCanvas Integration`,
    `# Version: ${canvas.version}`,
    "",
    "nodes:"
  ];
  for (const node of canvas.nodes) {
    lines.push(`  - id: "${node.id}"`);
    lines.push(`    type: "${node.type}"`);
    lines.push(`    label: "${node.label}"`);
    lines.push(`    x: ${node.x}`);
    lines.push(`    y: ${node.y}`);
    lines.push(`    width: ${node.width}`);
    lines.push(`    height: ${node.height}`);
    if (node.fsmState) {
      lines.push(`    fsmState: "${node.fsmState}"`);
    }
    lines.push("");
  }
  lines.push("edges:");
  for (const edge of canvas.edges) {
    lines.push(`  - id: "${edge.id}"`);
    lines.push(`    source: "${edge.source}"`);
    lines.push(`    target: "${edge.target}"`);
    if (edge.label) {
      lines.push(`    label: "${edge.label}"`);
    }
    if (edge.type) {
      lines.push(`    type: "${edge.type}"`);
    }
    lines.push("");
  }
  return lines.join("\n");
}
function canvasToMermaid(canvas) {
  const lines = ["graph TD"];
  for (const node of canvas.nodes) {
    let shape;
    switch (node.type) {
      case "model":
        shape = `[${node.label}]`;
        break;
      case "component":
        shape = `(${node.label})`;
        break;
      case "event":
        shape = `{{${node.label}}}`;
        break;
      case "fact":
        shape = `((${node.label}))`;
        break;
      case "rule":
        shape = `[/${node.label}/]`;
        break;
      case "constraint":
        shape = `[\\${node.label}\\]`;
        break;
      default:
        shape = `[${node.label}]`;
    }
    lines.push(`    ${node.id}${shape}`);
  }
  lines.push("");
  for (const edge of canvas.edges) {
    const label = edge.label ? `|${edge.label}|` : "";
    lines.push(`    ${edge.source} -->${label} ${edge.target}`);
  }
  return lines.join("\n");
}
function validateWithGuardian(files, activity, lifecycle) {
  const errors = [];
  const warnings = [];
  const currentState = lifecycle.find((s) => s.id === activity.activity);
  if (!currentState) {
    errors.push({
      code: "INVALID_ACTIVITY",
      message: `Activity "${activity.activity}" is not a valid lifecycle state`,
      rule: "lifecycle-state"
    });
  }
  if (activity.allowedPaths) {
    for (const file of files) {
      const allowed = activity.allowedPaths.some((pattern) => {
        const regex = new RegExp("^" + pattern.replace(/\*/g, ".*") + "$");
        return regex.test(file);
      });
      if (!allowed) {
        errors.push({
          code: "PATH_NOT_ALLOWED",
          message: `File "${file}" is not allowed during "${activity.activity}" activity`,
          file,
          rule: "allowed-paths"
        });
      }
    }
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings,
    filesChecked: files,
    activity
  };
}
function createCanvasEditor(config) {
  const document = config.document || (config.schema ? schemaToCanvas(config.schema, { layout: config.layout }) : {
    id: `canvas-${Date.now()}`,
    name: "New Canvas",
    version: "1.0.0",
    nodes: [],
    edges: [],
    metadata: { created: Date.now(), modified: Date.now() },
    viewport: { x: 0, y: 0, zoom: 1 }
  });
  let nodeIdCounter = document.nodes.length;
  let edgeIdCounter = document.edges.length;
  return {
    document,
    addNode(node) {
      const fullNode = {
        ...node,
        id: `node-${nodeIdCounter++}`
      };
      document.nodes.push(fullNode);
      document.metadata.modified = Date.now();
      return fullNode;
    },
    removeNode(id) {
      const index = document.nodes.findIndex((n) => n.id === id);
      if (index !== -1) {
        document.nodes.splice(index, 1);
        document.edges = document.edges.filter((e) => e.source !== id && e.target !== id);
        document.metadata.modified = Date.now();
      }
    },
    addEdge(edge) {
      const fullEdge = {
        ...edge,
        id: `edge-${edgeIdCounter++}`
      };
      document.edges.push(fullEdge);
      document.metadata.modified = Date.now();
      return fullEdge;
    },
    removeEdge(id) {
      const index = document.edges.findIndex((e) => e.id === id);
      if (index !== -1) {
        document.edges.splice(index, 1);
        document.metadata.modified = Date.now();
      }
    },
    toSchema() {
      return canvasToSchema(document);
    },
    toYaml() {
      return canvasToYaml(document);
    },
    toMermaid() {
      return canvasToMermaid(document);
    }
  };
}

export {
  schemaToCanvas,
  canvasToSchema,
  canvasToYaml,
  canvasToMermaid,
  validateWithGuardian,
  createCanvasEditor
};

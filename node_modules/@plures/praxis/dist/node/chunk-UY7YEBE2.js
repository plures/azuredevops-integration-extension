import {
  validateSchema
} from "./chunk-UATVJBNV.js";

// src/core/schema/loader.common.ts
import { load as yamlLoad } from "js-yaml";
function loadSchemaFromJson(json, options = {}) {
  const errors = [];
  try {
    const schema = JSON.parse(json);
    let validation;
    if (options.validate !== false) {
      validation = validateSchema(schema);
      if (!validation.valid) {
        errors.push("Schema validation failed:");
        validation.errors.forEach((error) => {
          errors.push(`  ${error.path}: ${error.message}`);
        });
      }
    }
    return {
      schema,
      validation,
      errors
    };
  } catch (error) {
    if (error instanceof Error) {
      errors.push(`Failed to parse JSON: ${error.message}`);
    } else {
      errors.push("Failed to parse JSON: Unknown error");
    }
    return { errors };
  }
}
function loadSchemaFromYaml(yaml, options = {}) {
  const errors = [];
  try {
    const schema = yamlLoad(yaml);
    let validation;
    if (options.validate !== false) {
      validation = validateSchema(schema);
      if (!validation.valid) {
        errors.push("Schema validation failed:");
        validation.errors.forEach((error) => {
          errors.push(`  ${error.path}: ${error.message}`);
        });
      }
    }
    return {
      schema,
      validation,
      errors
    };
  } catch (error) {
    if (error instanceof Error) {
      errors.push(`Failed to parse YAML: ${error.message}`);
    } else {
      errors.push("Failed to parse YAML: Unknown error");
    }
    return { errors };
  }
}
function validateForGeneration(schema) {
  const errors = [];
  if (!schema.models || schema.models.length === 0) {
    errors.push("Schema must define at least one model for generation");
  }
  schema.models?.forEach((model, index) => {
    if (!model.fields || model.fields.length === 0) {
      errors.push(`Model "${model.name}" at index ${index} must have at least one field`);
    }
    model.fields?.forEach((field, fieldIndex) => {
      if (!field.name) {
        errors.push(`Field at index ${fieldIndex} in model "${model.name}" must have a name`);
      }
      if (!field.type) {
        errors.push(`Field "${field.name}" in model "${model.name}" must have a type`);
      }
    });
  });
  return {
    valid: errors.length === 0,
    errors: errors.map((message) => ({ path: "schema", message }))
  };
}

// src/core/schema/loader.ts
import { readFile } from "fs/promises";
import { pathToFileURL } from "url";
async function loadSchema(filePath, options = {}) {
  const errors = [];
  try {
    let fileUrl = pathToFileURL(filePath).href;
    const module = await import(fileUrl);
    let schema;
    if (module.default) {
      schema = module.default;
    } else if (module.schema) {
      schema = module.schema;
    } else if (module.appSchema) {
      schema = module.appSchema;
    } else {
      const exports = Object.values(module);
      const possibleSchema = exports.find(
        (exp) => typeof exp === "object" && exp !== null && "version" in exp && "name" in exp
      );
      if (possibleSchema) {
        schema = possibleSchema;
      }
    }
    if (!schema) {
      errors.push(
        "Schema file must export a PraxisSchema object (as default, schema, or appSchema)"
      );
      return { errors };
    }
    let validation;
    if (options.validate !== false) {
      validation = validateSchema(schema);
      if (!validation.valid) {
        errors.push("Schema validation failed:");
        validation.errors.forEach((error) => {
          errors.push(`  ${error.path}: ${error.message}`);
        });
      }
    }
    return {
      schema,
      validation,
      errors
    };
  } catch (error) {
    if (error instanceof Error) {
      errors.push(`Failed to load schema: ${error.message}`);
    } else {
      errors.push("Failed to load schema: Unknown error");
    }
    return { errors };
  }
}
async function loadSchemaFromFile(filePath, options = {}) {
  if (filePath.endsWith(".json")) {
    const content = await readFile(filePath, "utf-8");
    return loadSchemaFromJson(content, options);
  } else if (filePath.endsWith(".yaml") || filePath.endsWith(".yml")) {
    const content = await readFile(filePath, "utf-8");
    return loadSchemaFromYaml(content, options);
  } else {
    return loadSchema(filePath, options);
  }
}

export {
  loadSchemaFromJson,
  loadSchemaFromYaml,
  validateForGeneration,
  loadSchema,
  loadSchemaFromFile
};

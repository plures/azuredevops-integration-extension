"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/core/component/generator.ts
var generator_exports = {};
__export(generator_exports, {
  ComponentGenerator: () => ComponentGenerator,
  createComponentGenerator: () => createComponentGenerator
});
module.exports = __toCommonJS(generator_exports);
var ComponentGenerator = class {
  config;
  constructor(config) {
    this.config = config;
  }
  /**
   * Generate component from definition
   */
  generateComponent(component, model) {
    const files = [];
    const errors = [];
    try {
      const componentFile = this.generateComponentFile(component, model);
      files.push(componentFile);
      if (this.config.typescript) {
        const typesFile = this.generateTypesFile(component, model);
        files.push(typesFile);
      }
      if (this.config.includeTests) {
        const testFile = this.generateTestFile(component);
        files.push(testFile);
      }
      if (this.config.includeDocs) {
        const docsFile = this.generateDocsFile(component);
        files.push(docsFile);
      }
    } catch (error) {
      errors.push({
        message: error instanceof Error ? error.message : "Unknown error",
        component: component.name
      });
    }
    return {
      success: errors.length === 0,
      files,
      errors
    };
  }
  /**
   * Generate component file
   */
  generateComponentFile(component, model) {
    const content = this.generateSvelteComponent(component, model);
    return {
      path: `${this.config.outputDir}/${component.name}.svelte`,
      content,
      type: "component"
    };
  }
  /**
   * Generate Svelte component code
   */
  generateSvelteComponent(component, model) {
    const script = this.generateScript(component, model);
    const template = this.generateTemplate(component, model);
    const styles = this.generateStyles(component);
    return `<script${this.config.typescript ? ' lang="ts"' : ""}>
${script}
</script>

${template}

${styles ? `<style>
${styles}
</style>` : ""}`;
  }
  /**
   * Generate component script
   */
  generateScript(component, _model) {
    const lines = [];
    lines.push(`  import { createPraxisStore } from '@plures/praxis/svelte';`);
    lines.push("");
    if (component.props && component.props.length > 0) {
      component.props.forEach((prop) => {
        const typeAnnotation = this.config.typescript ? `: ${prop.type}` : "";
        const defaultValue = prop.default !== void 0 ? ` = ${JSON.stringify(prop.default)}` : "";
        lines.push(`  export let ${prop.name}${typeAnnotation}${defaultValue};`);
      });
      lines.push("");
    }
    switch (component.type) {
      case "form":
        lines.push("  // Form handling logic");
        lines.push('  import { createEventDispatcher } from "svelte";');
        lines.push("  const dispatch = createEventDispatcher();");
        lines.push("");
        lines.push("  function handleSubmit() {");
        lines.push('    dispatch("submit", data);');
        lines.push("  }");
        lines.push("");
        lines.push("  function handleReset() {");
        lines.push("    data = { ...initialData };");
        lines.push("  }");
        break;
      case "list":
        lines.push("  // List handling logic");
        lines.push('  import { createEventDispatcher } from "svelte";');
        lines.push("  const dispatch = createEventDispatcher();");
        lines.push("");
        lines.push("  function handleSelect(item) {");
        lines.push('    dispatch("select", item);');
        lines.push("  }");
        lines.push("");
        lines.push("  function handleDelete(item) {");
        lines.push('    dispatch("delete", item);');
        lines.push("  }");
        break;
      case "display":
        lines.push("  // Display component - reactive to data changes");
        lines.push('  $: formattedData = data ? JSON.stringify(data, null, 2) : "No data";');
        break;
      case "navigation":
        lines.push("  // Navigation handling");
        lines.push('  import { createEventDispatcher } from "svelte";');
        lines.push("  const dispatch = createEventDispatcher();");
        lines.push("");
        lines.push("  function navigate(path) {");
        lines.push('    dispatch("navigate", { path });');
        lines.push("  }");
        break;
      default:
        lines.push("  // Component logic");
        lines.push('  $: console.log("Component data updated:", data);');
    }
    return lines.join("\n");
  }
  /**
   * Generate component template
   */
  generateTemplate(component, model) {
    switch (component.type) {
      case "form":
        return this.generateFormTemplate(component, model);
      case "display":
        return this.generateDisplayTemplate(component, model);
      case "list":
        return this.generateListTemplate(component, model);
      case "navigation":
        return this.generateNavigationTemplate(component);
      default:
        return `<div class="${component.name.toLowerCase()}">
  <!-- ${component.description || component.name} -->
  <p>Component: ${component.name}</p>
</div>`;
    }
  }
  /**
   * Generate form template
   */
  generateFormTemplate(component, model) {
    const fields = model?.fields || [];
    const formFields = fields.map((field) => {
      return `  <label>
    ${field.name}
    <input type="text" bind:value={data.${field.name}} />
  </label>`;
    }).join("\n");
    return `<form class="${component.name.toLowerCase()}">
${formFields}
  <button type="submit">Submit</button>
</form>`;
  }
  /**
   * Generate display template
   */
  generateDisplayTemplate(component, model) {
    const fields = model?.fields || [];
    const displayFields = fields.map((field) => {
      return `  <div class="field">
    <strong>${field.name}:</strong> {data.${field.name}}
  </div>`;
    }).join("\n");
    return `<div class="${component.name.toLowerCase()}">
${displayFields}
</div>`;
  }
  /**
   * Generate list template
   */
  generateListTemplate(component, _model) {
    return `<div class="${component.name.toLowerCase()}">
  {#each items as item}
    <div class="item">{item.name}</div>
  {/each}
</div>`;
  }
  /**
   * Generate navigation template
   */
  generateNavigationTemplate(component) {
    return `<nav class="${component.name.toLowerCase()}">
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/about">About</a></li>
  </ul>
</nav>`;
  }
  /**
   * Generate component styles
   */
  generateStyles(component) {
    if (!component.styling) {
      return "";
    }
    const lines = [];
    const styles = component.styling.styles || {};
    Object.entries(styles).forEach(([key, value]) => {
      lines.push(`  ${key}: ${value};`);
    });
    return lines.length > 0 ? lines.join("\n") : "";
  }
  /**
   * Generate types file
   */
  generateTypesFile(component, model) {
    const lines = [];
    if (component.props && component.props.length > 0) {
      lines.push(`export interface ${component.name}Props {`);
      component.props.forEach((prop) => {
        const optional = prop.required ? "" : "?";
        lines.push(`  ${prop.name}${optional}: ${prop.type};`);
      });
      lines.push("}");
      lines.push("");
    }
    if (model) {
      lines.push(`export interface ${model.name} {`);
      model.fields.forEach((field) => {
        const optional = field.optional ? "?" : "";
        lines.push(`  ${field.name}${optional}: ${this.mapFieldType(field.type)};`);
      });
      lines.push("}");
    }
    return {
      path: `${this.config.outputDir}/${component.name}.types.ts`,
      content: lines.join("\n"),
      type: "types"
    };
  }
  /**
   * Map field type to TypeScript type
   */
  mapFieldType(type) {
    if (typeof type === "string") {
      switch (type) {
        case "string":
          return "string";
        case "number":
          return "number";
        case "boolean":
          return "boolean";
        case "date":
          return "Date";
        case "array":
          return "unknown[]";
        case "object":
          return "Record<string, unknown>";
        default:
          return "unknown";
      }
    }
    return "unknown";
  }
  /**
   * Generate test file
   */
  generateTestFile(component) {
    const content = `import { describe, it, expect } from 'vitest';
import { render } from '@testing-library/svelte';
import ${component.name} from './${component.name}.svelte';

describe('${component.name}', () => {
  it('renders correctly', () => {
    const { container } = render(${component.name});
    expect(container).toBeTruthy();
  });

  // TODO: Add more tests based on component behavior
});
`;
    return {
      path: `${this.config.outputDir}/${component.name}.test.ts`,
      content,
      type: "test"
    };
  }
  /**
   * Generate documentation file
   */
  generateDocsFile(component) {
    const lines = [];
    lines.push(`# ${component.name}`);
    lines.push("");
    if (component.description) {
      lines.push(component.description);
      lines.push("");
    }
    lines.push("## Props");
    lines.push("");
    if (component.props && component.props.length > 0) {
      component.props.forEach((prop) => {
        lines.push(
          `- \`${prop.name}\`: ${prop.type}${prop.required ? " (required)" : " (optional)"}`
        );
        if (prop.description) {
          lines.push(`  - ${prop.description}`);
        }
      });
    } else {
      lines.push("No props defined.");
    }
    lines.push("");
    lines.push("## Events");
    lines.push("");
    if (component.events && component.events.length > 0) {
      component.events.forEach((event) => {
        lines.push(`- \`${event.name}\`: ${event.payload || "void"}`);
        if (event.description) {
          lines.push(`  - ${event.description}`);
        }
      });
    } else {
      lines.push("No events defined.");
    }
    return {
      path: `${this.config.outputDir}/${component.name}.md`,
      content: lines.join("\n"),
      type: "docs"
    };
  }
};
function createComponentGenerator(outputDir, options) {
  const config = {
    outputDir,
    framework: "svelte",
    typescript: true,
    includeTests: false,
    includeDocs: false,
    ...options
  };
  return new ComponentGenerator(config);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ComponentGenerator,
  createComponentGenerator
});

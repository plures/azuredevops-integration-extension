// src/runtime/terminal-adapter.ts
async function defaultExecutor(command, options) {
  try {
    const { exec } = await import("child_process");
    const { promisify } = await import("util");
    const execAsync = promisify(exec);
    const processEnv = typeof process !== "undefined" ? process.env : {};
    const result = await execAsync(command, {
      cwd: options.cwd,
      env: { ...processEnv, ...options.env },
      maxBuffer: 10 * 1024 * 1024,
      // 10MB buffer
      timeout: 6e4
      // 60 second timeout
    });
    return {
      output: result.stdout + (result.stderr ? `
${result.stderr}` : ""),
      exitCode: 0
    };
  } catch (error) {
    const execError = error;
    return {
      output: (execError.stdout || "") + (execError.stderr || ""),
      exitCode: execError.code || 1,
      error: execError.message || "Command execution failed"
    };
  }
}
var TerminalAdapter = class {
  state;
  inputPath;
  outputPath;
  db;
  executor;
  constructor(options) {
    this.state = {
      nodeId: options.nodeId,
      inputMode: options.props?.inputMode || "text",
      history: options.props?.history || [],
      lastOutput: options.props?.lastOutput || null,
      cwd: options.cwd,
      env: options.env
    };
    this.inputPath = options.inputPath;
    this.outputPath = options.outputPath;
    this.db = options.db;
    this.executor = options.executor || defaultExecutor;
  }
  /**
   * Execute a terminal command
   *
   * @param command - Command to execute
   * @returns Execution result
   */
  async executeCommand(command) {
    this.state.history.push(command);
    const timestamp = Date.now();
    const { output, exitCode, error } = await this.executor(command, {
      cwd: this.state.cwd,
      env: this.state.env
    });
    const result = {
      command,
      output,
      exitCode,
      timestamp,
      error
    };
    this.state.lastOutput = output;
    if (this.db && this.outputPath) {
      await this.syncToPluresDB(this.outputPath, result);
    }
    return result;
  }
  /**
   * Get current terminal state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Update terminal props
   */
  updateProps(props) {
    this.state = {
      ...this.state,
      ...props
    };
  }
  /**
   * Set working directory
   */
  setCwd(cwd) {
    this.state.cwd = cwd;
  }
  /**
   * Set environment variables
   */
  setEnv(env) {
    this.state.env = { ...this.state.env, ...env };
  }
  /**
   * Clear command history
   */
  clearHistory() {
    this.state.history = [];
  }
  /**
   * Get command history
   */
  getHistory() {
    return [...this.state.history];
  }
  /**
   * Sync state to PluresDB
   *
   * @param path - PluresDB path for storing results
   * @param data - Data to sync
   */
  async syncToPluresDB(path, data) {
    if (!this.db) return;
    try {
      await this.db.set(path, {
        ...data,
        nodeId: this.state.nodeId,
        syncedAt: Date.now()
      });
      const historyPath = `${path}/history`;
      const historyKey = `${historyPath}/${data.timestamp}`;
      await this.db.set(historyKey, data);
    } catch (error) {
      console.warn("Failed to sync to PluresDB:", error);
    }
  }
  /**
   * Load state from PluresDB
   */
  async loadFromPluresDB() {
    if (!this.db || !this.inputPath) return;
    try {
      const data = await this.db.get(this.inputPath);
      if (data && typeof data === "object") {
        const savedState = data;
        if (savedState.history) {
          this.state.history = savedState.history;
        }
        if (savedState.lastOutput !== void 0) {
          this.state.lastOutput = savedState.lastOutput;
        }
        if (savedState.cwd) {
          this.state.cwd = savedState.cwd;
        }
        if (savedState.env) {
          this.state.env = savedState.env;
        }
      }
    } catch (error) {
      console.warn("Failed to load from PluresDB:", error);
    }
  }
  /**
   * Subscribe to input changes from PluresDB
   */
  watchInput(callback) {
    if (!this.db || !this.inputPath) return null;
    return this.db.watch(this.inputPath, (data) => {
      if (data && typeof data === "object" && "command" in data) {
        callback(data.command);
      }
    });
  }
};
function createTerminalAdapter(options) {
  return new TerminalAdapter(options);
}
async function runTerminalCommand(nodeId, command, options) {
  const adapter = createTerminalAdapter({
    nodeId,
    cwd: options?.cwd,
    env: options?.env,
    db: options?.db,
    executor: options?.executor
  });
  return adapter.executeCommand(command);
}
function createMockExecutor(responses) {
  return async (command) => {
    const response = responses[command] || responses["*"] || {
      output: `Mock output for: ${command}`,
      exitCode: 0
    };
    return response;
  };
}

export {
  TerminalAdapter,
  createTerminalAdapter,
  runTerminalCommand,
  createMockExecutor
};

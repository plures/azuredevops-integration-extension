import {
  PraxisRegistry,
  ReactiveLogicEngine,
  createReactiveEngine
} from "./chunk-LE2ZJYFC.js";
import {
  LogicEngine,
  PRAXIS_PROTOCOL_VERSION,
  createPraxisEngine
} from "./chunk-VOMLVI6V.js";
import {
  InMemoryPraxisDB,
  PluresDBPraxisAdapter,
  createInMemoryDB,
  createPluresDB
} from "./chunk-JQ64KMLN.js";

// src/core/reactive-engine.ts
var ReactiveLogicEngine2 = class _ReactiveLogicEngine {
  _state;
  _subscribers = /* @__PURE__ */ new Set();
  _contextProxy;
  _factsProxy;
  _metaProxy;
  _batchDepth = 0;
  _pendingNotification = false;
  _proxyCache = /* @__PURE__ */ new WeakMap();
  // Array methods that mutate the array
  static ARRAY_MUTATORS = ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"];
  constructor(options) {
    this._state = {
      context: options.initialContext,
      facts: options.initialFacts ?? [],
      meta: options.initialMeta ?? {}
    };
    this._contextProxy = this._createReactiveProxy(this._state.context);
    this._factsProxy = this._createReactiveProxy(this._state.facts);
    this._metaProxy = this._createReactiveProxy(this._state.meta);
  }
  /**
   * Create a reactive proxy that notifies subscribers on changes.
   * Uses a WeakMap cache to avoid creating multiple proxies for the same object.
   */
  _createReactiveProxy(target) {
    const cached = this._proxyCache.get(target);
    if (cached) {
      return cached;
    }
    const self = this;
    const handler = {
      get(obj, prop) {
        const value = Reflect.get(obj, prop);
        if (value && typeof value === "object") {
          return self._createReactiveProxy(value);
        }
        if (Array.isArray(obj) && typeof value === "function") {
          if (_ReactiveLogicEngine.ARRAY_MUTATORS.includes(prop)) {
            return function(...args) {
              const result = value.apply(obj, args);
              self._notify();
              return result;
            };
          }
        }
        return value;
      },
      set(obj, prop, value) {
        const oldValue = obj[prop];
        const result = Reflect.set(obj, prop, value);
        if (oldValue !== value) {
          self._notify();
        }
        return result;
      },
      deleteProperty(obj, prop) {
        const result = Reflect.deleteProperty(obj, prop);
        self._notify();
        return result;
      }
    };
    const proxy = new Proxy(target, handler);
    this._proxyCache.set(target, proxy);
    return proxy;
  }
  /**
   * Notify all subscribers of state changes
   */
  _notify() {
    if (this._batchDepth > 0) {
      this._pendingNotification = true;
      return;
    }
    const currentState = {
      context: this._contextProxy,
      facts: this._factsProxy,
      meta: this._metaProxy
    };
    this._subscribers.forEach((callback) => {
      try {
        callback(currentState);
      } catch (error) {
        console.error("Error in reactive engine subscriber:", error);
      }
    });
  }
  /**
   * Get the full state object
   */
  get state() {
    return {
      context: this._contextProxy,
      facts: this._factsProxy,
      meta: this._metaProxy
    };
  }
  /**
   * Access the reactive context.
   * Changes to this object will trigger subscriber notifications.
   */
  get context() {
    return this._contextProxy;
  }
  /**
   * Access the reactive facts list.
   * Changes to this array will trigger subscriber notifications.
   */
  get facts() {
    return this._factsProxy;
  }
  /**
   * Access the reactive metadata.
   * Changes to this object will trigger subscriber notifications.
   */
  get meta() {
    return this._metaProxy;
  }
  /**
   * Apply a mutation to the state.
   * This is the "Action" or "Rule" equivalent.
   * Mutations are batched - notifications only happen once per apply call.
   * 
   * @param mutator A function that receives the state and modifies it.
   */
  apply(mutator) {
    this._batchDepth++;
    try {
      mutator({
        context: this._contextProxy,
        facts: this._factsProxy,
        meta: this._metaProxy
      });
    } finally {
      this._batchDepth--;
      if (this._batchDepth === 0 && this._pendingNotification) {
        this._pendingNotification = false;
        this._notify();
      }
    }
  }
  /**
   * Subscribe to state changes.
   * Returns an unsubscribe function.
   * 
   * @param callback Function to call when state changes
   * @returns Unsubscribe function
   */
  subscribe(callback) {
    this._subscribers.add(callback);
    try {
      callback({
        context: this._contextProxy,
        facts: this._factsProxy,
        meta: this._metaProxy
      });
    } catch (error) {
      console.error("Error in reactive engine subscriber:", error);
    }
    return () => {
      this._subscribers.delete(callback);
    };
  }
  /**
   * Create a derived/computed value from the state.
   * The selector function will be called whenever the state changes.
   * 
   * @param selector Function to extract derived value from state
   * @returns Object with subscribe method for reactive updates
   */
  $derived(selector) {
    const subscribers = /* @__PURE__ */ new Set();
    let currentValue = selector({
      context: this._contextProxy,
      facts: this._factsProxy,
      meta: this._metaProxy
    });
    this.subscribe(() => {
      const newValue = selector({
        context: this._contextProxy,
        facts: this._factsProxy,
        meta: this._metaProxy
      });
      if (newValue !== currentValue) {
        currentValue = newValue;
        subscribers.forEach((callback) => {
          try {
            callback(currentValue);
          } catch (error) {
            console.error("Error in derived value subscriber:", error);
          }
        });
      }
    });
    return {
      subscribe: (callback) => {
        subscribers.add(callback);
        try {
          callback(currentValue);
        } catch (error) {
          console.error("Error in derived value subscriber:", error);
        }
        return () => {
          subscribers.delete(callback);
        };
      }
    };
  }
};
function createReactiveEngine2(options) {
  return new ReactiveLogicEngine2(options);
}

// src/core/actors.ts
var ActorManager = class {
  actors = /* @__PURE__ */ new Map();
  activeActors = /* @__PURE__ */ new Set();
  engine = null;
  /**
   * Register an actor
   */
  register(actor) {
    if (this.actors.has(actor.id)) {
      throw new Error(`Actor with id "${actor.id}" already registered`);
    }
    this.actors.set(actor.id, actor);
  }
  /**
   * Unregister an actor
   */
  unregister(actorId) {
    if (this.activeActors.has(actorId)) {
      throw new Error(`Cannot unregister active actor "${actorId}". Stop it first.`);
    }
    this.actors.delete(actorId);
  }
  /**
   * Attach the actor manager to an engine
   */
  attachEngine(engine) {
    this.engine = engine;
  }
  /**
   * Start an actor
   */
  async start(actorId) {
    const actor = this.actors.get(actorId);
    if (!actor) {
      throw new Error(`Actor "${actorId}" not found`);
    }
    if (this.activeActors.has(actorId)) {
      throw new Error(`Actor "${actorId}" is already started`);
    }
    if (!this.engine) {
      throw new Error("Actor manager not attached to an engine");
    }
    this.activeActors.add(actorId);
    if (actor.onStart) {
      await actor.onStart(this.engine);
    }
  }
  /**
   * Stop an actor
   */
  async stop(actorId) {
    const actor = this.actors.get(actorId);
    if (!actor) {
      throw new Error(`Actor "${actorId}" not found`);
    }
    if (!this.activeActors.has(actorId)) {
      return;
    }
    this.activeActors.delete(actorId);
    if (actor.onStop) {
      await actor.onStop();
    }
  }
  /**
   * Start all registered actors
   */
  async startAll() {
    const actorIds = Array.from(this.actors.keys());
    for (const actorId of actorIds) {
      if (!this.activeActors.has(actorId)) {
        await this.start(actorId);
      }
    }
  }
  /**
   * Stop all active actors
   */
  async stopAll() {
    const activeIds = Array.from(this.activeActors);
    for (const actorId of activeIds) {
      await this.stop(actorId);
    }
  }
  /**
   * Notify active actors of a state change
   */
  async notifyStateChange(state) {
    if (!this.engine) {
      return;
    }
    const promises = [];
    for (const actorId of this.activeActors) {
      const actor = this.actors.get(actorId);
      if (actor?.onStateChange) {
        const result = actor.onStateChange(state, this.engine);
        if (result instanceof Promise) {
          promises.push(result);
        }
      }
    }
    await Promise.all(promises);
  }
  /**
   * Get all registered actor IDs
   */
  getActorIds() {
    return Array.from(this.actors.keys());
  }
  /**
   * Get all active actor IDs
   */
  getActiveActorIds() {
    return Array.from(this.activeActors);
  }
  /**
   * Check if an actor is active
   */
  isActive(actorId) {
    return this.activeActors.has(actorId);
  }
};
function createTimerActor(id, intervalMs, createEvent) {
  let timerId = null;
  return {
    id,
    description: `Timer actor (${intervalMs}ms) - ${id}`,
    onStart: (engine) => {
      timerId = setInterval(() => {
        engine.step([createEvent()]);
      }, intervalMs);
    },
    onStop: () => {
      if (timerId) {
        clearInterval(timerId);
        timerId = null;
      }
    }
  };
}

// src/core/introspection.ts
var RegistryIntrospector = class {
  constructor(registry) {
    this.registry = registry;
  }
  /**
   * Get basic statistics about the registry
   */
  getStats() {
    return {
      ruleCount: this.registry.getRuleIds().length,
      constraintCount: this.registry.getConstraintIds().length,
      moduleCount: 0,
      // Modules are flattened in registry
      rulesById: this.registry.getRuleIds(),
      constraintsById: this.registry.getConstraintIds()
    };
  }
  /**
   * Generate a JSON schema representation of the registry
   */
  generateSchema(protocolVersion) {
    const rules = this.registry.getAllRules().map((rule) => ({
      id: rule.id,
      description: rule.description,
      type: "rule",
      meta: rule.meta
    }));
    const constraints = this.registry.getAllConstraints().map((constraint) => ({
      id: constraint.id,
      description: constraint.description,
      type: "constraint",
      meta: constraint.meta
    }));
    return {
      protocolVersion,
      rules,
      constraints,
      meta: {
        ruleCount: rules.length,
        constraintCount: constraints.length
      }
    };
  }
  /**
   * Generate a graph representation of the registry
   *
   * This creates nodes for rules and constraints.
   * Edges can be inferred from metadata if rules/constraints
   * document their dependencies.
   */
  generateGraph() {
    const nodes = [];
    const edges = [];
    for (const rule of this.registry.getAllRules()) {
      nodes.push({
        id: rule.id,
        type: "rule",
        description: rule.description,
        meta: rule.meta
      });
      if (rule.meta?.dependsOn) {
        const deps = Array.isArray(rule.meta.dependsOn) ? rule.meta.dependsOn : [rule.meta.dependsOn];
        for (const dep of deps) {
          edges.push({
            from: String(dep),
            to: rule.id,
            type: "depends-on"
          });
        }
      }
    }
    for (const constraint of this.registry.getAllConstraints()) {
      nodes.push({
        id: constraint.id,
        type: "constraint",
        description: constraint.description,
        meta: constraint.meta
      });
      if (constraint.meta?.constrains) {
        const targets = Array.isArray(constraint.meta.constrains) ? constraint.meta.constrains : [constraint.meta.constrains];
        for (const target of targets) {
          edges.push({
            from: constraint.id,
            to: String(target),
            type: "constrains"
          });
        }
      }
    }
    return {
      nodes,
      edges,
      meta: {
        nodeCount: nodes.length,
        ruleCount: nodes.filter((n) => n.type === "rule").length,
        constraintCount: nodes.filter((n) => n.type === "constraint").length
      }
    };
  }
  /**
   * Export graph in DOT format (Graphviz)
   *
   * This can be rendered with Graphviz tools or online services.
   */
  exportDOT() {
    const graph = this.generateGraph();
    const lines = [];
    lines.push("digraph PraxisRegistry {");
    lines.push("  rankdir=TB;");
    lines.push("  node [shape=box, style=rounded];");
    lines.push("");
    for (const node of graph.nodes) {
      const shape = node.type === "rule" ? "box" : "diamond";
      const color = node.type === "rule" ? "lightblue" : "lightcoral";
      const label = `${node.id}\\n${node.description}`;
      lines.push(
        `  "${node.id}" [label="${label}", shape=${shape}, style=filled, fillcolor=${color}];`
      );
    }
    lines.push("");
    for (const edge of graph.edges) {
      const style = edge.type === "constrains" ? "dashed" : "solid";
      lines.push(`  "${edge.from}" -> "${edge.to}" [label="${edge.type}", style=${style}];`);
    }
    lines.push("}");
    return lines.join("\n");
  }
  /**
   * Export graph in Mermaid format
   *
   * Mermaid is a markdown-friendly diagramming language.
   */
  exportMermaid() {
    const graph = this.generateGraph();
    const lines = [];
    lines.push("graph TB");
    for (const node of graph.nodes) {
      const shape = node.type === "rule" ? "[" : "{";
      const endShape = node.type === "rule" ? "]" : "}";
      const label = `${node.id}<br/>${node.description}`;
      lines.push(`  ${node.id}${shape}"${label}"${endShape}`);
    }
    lines.push("");
    for (const edge of graph.edges) {
      const arrow = edge.type === "constrains" ? "-.->|constrains|" : "-->|" + edge.type + "|";
      lines.push(`  ${edge.from} ${arrow} ${edge.to}`);
    }
    return lines.join("\n");
  }
  /**
   * Get detailed information about a specific rule
   */
  getRuleInfo(ruleId) {
    return this.registry.getRule(ruleId);
  }
  /**
   * Get detailed information about a specific constraint
   */
  getConstraintInfo(constraintId) {
    return this.registry.getConstraint(constraintId);
  }
  /**
   * Search for rules by description text
   */
  searchRules(query) {
    const lowerQuery = query.toLowerCase();
    return this.registry.getAllRules().filter(
      (rule) => rule.id.toLowerCase().includes(lowerQuery) || rule.description.toLowerCase().includes(lowerQuery)
    );
  }
  /**
   * Search for constraints by description text
   */
  searchConstraints(query) {
    const lowerQuery = query.toLowerCase();
    return this.registry.getAllConstraints().filter(
      (constraint) => constraint.id.toLowerCase().includes(lowerQuery) || constraint.description.toLowerCase().includes(lowerQuery)
    );
  }
};
function createIntrospector(registry) {
  return new RegistryIntrospector(registry);
}

// src/dsl/index.ts
function defineFact(tag) {
  return {
    tag,
    create(payload) {
      return { tag, payload };
    },
    is(fact) {
      return fact.tag === tag;
    }
  };
}
function defineEvent(tag) {
  return {
    tag,
    create(payload) {
      return { tag, payload };
    },
    is(event) {
      return event.tag === tag;
    }
  };
}
function defineRule(options) {
  return {
    id: options.id,
    description: options.description,
    impl: options.impl,
    meta: options.meta
  };
}
function defineConstraint(options) {
  return {
    id: options.id,
    description: options.description,
    impl: options.impl,
    meta: options.meta
  };
}
function defineModule(options) {
  return {
    rules: options.rules ?? [],
    constraints: options.constraints ?? [],
    meta: options.meta
  };
}
function filterEvents(events, definition) {
  return events.filter(definition.is);
}
function filterFacts(facts, definition) {
  return facts.filter(definition.is);
}
function findEvent(events, definition) {
  return events.find(definition.is);
}
function findFact(facts, definition) {
  return facts.find(definition.is);
}

// src/core/schema/types.ts
function validateSchema(schema) {
  const errors = [];
  if (!schema.version) {
    errors.push({ path: "version", message: "Schema version is required" });
  }
  if (!schema.name) {
    errors.push({ path: "name", message: "Schema name is required" });
  }
  if (schema.models) {
    schema.models.forEach((model, index) => {
      if (!model.name) {
        errors.push({
          path: `models[${index}].name`,
          message: "Model name is required"
        });
      }
      if (!model.fields || model.fields.length === 0) {
        errors.push({
          path: `models[${index}].fields`,
          message: "Model must have at least one field"
        });
      }
    });
  }
  if (schema.components) {
    schema.components.forEach((component, index) => {
      if (!component.name) {
        errors.push({
          path: `components[${index}].name`,
          message: "Component name is required"
        });
      }
      if (!component.type) {
        errors.push({
          path: `components[${index}].type`,
          message: "Component type is required"
        });
      }
    });
  }
  if (schema.logic) {
    schema.logic.forEach((logic, logicIndex) => {
      if (logic.facts) {
        logic.facts.forEach((fact, factIndex) => {
          if (!fact.tag) {
            errors.push({
              path: `logic[${logicIndex}].facts[${factIndex}].tag`,
              message: "Fact tag is required"
            });
          } else if (!isValidIdentifier(fact.tag)) {
            errors.push({
              path: `logic[${logicIndex}].facts[${factIndex}].tag`,
              message: `Fact tag "${fact.tag}" is not a valid JavaScript identifier. Use only letters, numbers, underscores, and dollar signs, and do not start with a number.`
            });
          }
        });
      }
      if (logic.events) {
        logic.events.forEach((event, eventIndex) => {
          if (!event.tag) {
            errors.push({
              path: `logic[${logicIndex}].events[${eventIndex}].tag`,
              message: "Event tag is required"
            });
          } else if (!isValidIdentifier(event.tag)) {
            errors.push({
              path: `logic[${logicIndex}].events[${eventIndex}].tag`,
              message: `Event tag "${event.tag}" is not a valid JavaScript identifier. Use only letters, numbers, underscores, and dollar signs, and do not start with a number.`
            });
          }
        });
      }
    });
  }
  if (schema.orchestration?.nodes) {
    schema.orchestration.nodes.forEach((node, index) => {
      if (!node.id) {
        errors.push({
          path: `orchestration.nodes[${index}].id`,
          message: "Node id is required"
        });
      }
      if (!node.type) {
        errors.push({
          path: `orchestration.nodes[${index}].type`,
          message: "Node type is required"
        });
      }
      if (node.type === "terminal" && node.props) {
        const props = node.props;
        if (props.inputMode && !["text", "widget"].includes(props.inputMode)) {
          errors.push({
            path: `orchestration.nodes[${index}].props.inputMode`,
            message: 'Terminal node inputMode must be "text" or "widget"'
          });
        }
        if (props.history && !Array.isArray(props.history)) {
          errors.push({
            path: `orchestration.nodes[${index}].props.history`,
            message: "Terminal node history must be an array"
          });
        }
      }
    });
  }
  return {
    valid: errors.length === 0,
    errors
  };
}
function isValidIdentifier(str) {
  const identifierRegex = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;
  const reservedKeywords = [
    "break",
    "case",
    "catch",
    "class",
    "const",
    "continue",
    "debugger",
    "default",
    "delete",
    "do",
    "else",
    "export",
    "extends",
    "finally",
    "for",
    "function",
    "if",
    "import",
    "in",
    "instanceof",
    "new",
    "return",
    "super",
    "switch",
    "this",
    "throw",
    "try",
    "typeof",
    "var",
    "void",
    "while",
    "with",
    "yield",
    "let",
    "static",
    "enum",
    "await",
    "implements",
    "interface",
    "package",
    "private",
    "protected",
    "public"
  ];
  return identifierRegex.test(str) && !reservedKeywords.includes(str);
}
function createSchemaTemplate(name) {
  return {
    version: "1.0.0",
    name,
    description: `Schema for ${name}`,
    models: [],
    components: [],
    logic: []
  };
}

// src/core/schema/loader.common.ts
import { load as yamlLoad } from "js-yaml";
function createSchema(name) {
  return {
    version: "1.0.0",
    name,
    description: `Schema for ${name}`,
    models: [],
    components: [],
    logic: []
  };
}
function loadSchemaFromJson(json, options = {}) {
  const errors = [];
  try {
    const schema = JSON.parse(json);
    let validation;
    if (options.validate !== false) {
      validation = validateSchema(schema);
      if (!validation.valid) {
        errors.push("Schema validation failed:");
        validation.errors.forEach((error) => {
          errors.push(`  ${error.path}: ${error.message}`);
        });
      }
    }
    return {
      schema,
      validation,
      errors
    };
  } catch (error) {
    if (error instanceof Error) {
      errors.push(`Failed to parse JSON: ${error.message}`);
    } else {
      errors.push("Failed to parse JSON: Unknown error");
    }
    return { errors };
  }
}
function loadSchemaFromYaml(yaml, options = {}) {
  const errors = [];
  try {
    const schema = yamlLoad(yaml);
    let validation;
    if (options.validate !== false) {
      validation = validateSchema(schema);
      if (!validation.valid) {
        errors.push("Schema validation failed:");
        validation.errors.forEach((error) => {
          errors.push(`  ${error.path}: ${error.message}`);
        });
      }
    }
    return {
      schema,
      validation,
      errors
    };
  } catch (error) {
    if (error instanceof Error) {
      errors.push(`Failed to parse YAML: ${error.message}`);
    } else {
      errors.push("Failed to parse YAML: Unknown error");
    }
    return { errors };
  }
}
function validateForGeneration(schema) {
  const errors = [];
  if (!schema.models || schema.models.length === 0) {
    errors.push("Schema must define at least one model for generation");
  }
  schema.models?.forEach((model, index) => {
    if (!model.fields || model.fields.length === 0) {
      errors.push(`Model "${model.name}" at index ${index} must have at least one field`);
    }
    model.fields?.forEach((field, fieldIndex) => {
      if (!field.name) {
        errors.push(`Field at index ${fieldIndex} in model "${model.name}" must have a name`);
      }
      if (!field.type) {
        errors.push(`Field "${field.name}" in model "${model.name}" must have a type`);
      }
    });
  });
  return {
    valid: errors.length === 0,
    errors: errors.map((message) => ({ path: "schema", message }))
  };
}

// src/core/pluresdb/store.ts
var PRAXIS_PATHS = {
  /** Base path for all Praxis data */
  BASE: "/_praxis",
  /** Path for facts storage */
  FACTS: "/_praxis/facts",
  /** Path for events storage */
  EVENTS: "/_praxis/events",
  /** Path for schema registry */
  SCHEMAS: "/_praxis/schemas"
};
function getFactPath(factTag, id) {
  if (id) {
    return `${PRAXIS_PATHS.FACTS}/${factTag}/${id}`;
  }
  return `${PRAXIS_PATHS.FACTS}/${factTag}`;
}
function getEventPath(eventTag) {
  return `${PRAXIS_PATHS.EVENTS}/${eventTag}`;
}
function generateId() {
  return `${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
}
var defaultErrorHandler = (ruleId, error) => {
  if (typeof process !== "undefined" && true) {
    console.error(`Error executing rule "${ruleId}":`, error);
  }
};
var PraxisDBStore = class {
  db;
  registry;
  context;
  subscriptions = [];
  factWatchers = /* @__PURE__ */ new Map();
  onRuleError;
  constructor(options) {
    this.db = options.db;
    this.registry = options.registry;
    this.context = options.initialContext ?? {};
    this.onRuleError = options.onRuleError ?? defaultErrorHandler;
  }
  /**
   * Store a fact in PluresDB
   *
   * Facts are stored under `/_praxis/facts/<factTag>/<id>`
   * If no id is provided in the payload, a timestamp-based id is used.
   *
   * @param fact The fact to store
   * @returns Promise that resolves when the fact is stored
   */
  async storeFact(fact) {
    const constraintResult = await this.checkConstraints([fact]);
    if (!constraintResult.valid) {
      throw new Error(`Constraint violation: ${constraintResult.errors.join(", ")}`);
    }
    await this.persistFact(fact);
    await this.triggerRules([fact]);
  }
  /**
   * Store multiple facts in PluresDB
   *
   * @param facts The facts to store
   */
  async storeFacts(facts) {
    const constraintResult = await this.checkConstraints(facts);
    if (!constraintResult.valid) {
      throw new Error(`Constraint violation: ${constraintResult.errors.join(", ")}`);
    }
    for (const fact of facts) {
      await this.persistFact(fact);
    }
    await this.triggerRules(facts);
  }
  /**
   * Internal method to persist a fact without constraint checking
   * Used by both storeFact and derived fact storage
   */
  async persistFact(fact) {
    const payload = fact.payload;
    const id = payload?.id ?? generateId();
    const path = getFactPath(fact.tag, id);
    await this.db.set(path, fact);
  }
  /**
   * Get a fact by tag and id
   *
   * @param factTag The fact type tag
   * @param id The fact id
   * @returns The fact or undefined if not found
   */
  async getFact(factTag, id) {
    const path = getFactPath(factTag, id);
    return this.db.get(path);
  }
  /**
   * Append an event to the event stream
   *
   * Events are stored as append-only streams under `/_praxis/events/<eventTag>`
   *
   * @param event The event to append
   */
  async appendEvent(event) {
    const path = getEventPath(event.tag);
    const existingEvents = await this.db.get(path) ?? [];
    const entry = {
      event,
      timestamp: Date.now(),
      sequence: existingEvents.length
    };
    const newEvents = [...existingEvents, entry];
    await this.db.set(path, newEvents);
    await this.triggerRulesForEvents([event]);
  }
  /**
   * Append multiple events to their respective streams
   *
   * @param events The events to append
   */
  async appendEvents(events) {
    const eventsByTag = /* @__PURE__ */ new Map();
    for (const event of events) {
      const existing = eventsByTag.get(event.tag) ?? [];
      eventsByTag.set(event.tag, [...existing, event]);
    }
    for (const [tag, tagEvents] of eventsByTag) {
      const path = getEventPath(tag);
      const existingEvents = await this.db.get(path) ?? [];
      let sequence = existingEvents.length;
      const newEntries = tagEvents.map((event) => ({
        event,
        timestamp: Date.now(),
        sequence: sequence++
      }));
      await this.db.set(path, [...existingEvents, ...newEntries]);
    }
    await this.triggerRulesForEvents(events);
  }
  /**
   * Get events from a stream
   *
   * @param eventTag The event type tag
   * @param options Query options
   * @returns Array of event stream entries
   */
  async getEvents(eventTag, options) {
    const path = getEventPath(eventTag);
    const events = await this.db.get(path) ?? [];
    let result = events;
    if (options?.since !== void 0) {
      const sinceTimestamp = options.since;
      result = result.filter((e) => e.timestamp > sinceTimestamp);
    }
    if (options?.limit !== void 0) {
      result = result.slice(-options.limit);
    }
    return result;
  }
  /**
   * Watch a fact path for changes
   *
   * @param factTag The fact type tag to watch
   * @param callback Called when facts of this type change
   * @returns Unsubscribe function
   */
  watchFacts(factTag, callback) {
    const path = getFactPath(factTag);
    if (!this.factWatchers.has(factTag)) {
      this.factWatchers.set(factTag, /* @__PURE__ */ new Set());
    }
    const watchers = this.factWatchers.get(factTag);
    if (watchers) {
      watchers.add(callback);
    }
    const unsubscribe = this.db.watch(path, (fact) => {
      callback([fact]);
    });
    this.subscriptions.push(unsubscribe);
    return () => {
      unsubscribe();
      this.factWatchers.get(factTag)?.delete(callback);
    };
  }
  /**
   * Check constraints against the current state with new facts
   */
  async checkConstraints(newFacts) {
    const constraints = this.registry.getAllConstraints();
    const errors = [];
    const state = {
      context: this.context,
      facts: newFacts,
      meta: {}
    };
    for (const constraint of constraints) {
      try {
        const result = constraint.impl(state);
        if (result === false) {
          errors.push(`Constraint "${constraint.id}" violated`);
        } else if (typeof result === "string") {
          errors.push(result);
        }
      } catch (error) {
        errors.push(
          `Error checking constraint "${constraint.id}": ${error instanceof Error ? error.message : String(error)}`
        );
      }
    }
    return {
      valid: errors.length === 0,
      errors
    };
  }
  /**
   * Trigger rules when new facts are added
   *
   * This method is called after facts are stored. It can be extended
   * for derived fact computation where rules generate new facts based
   * on existing facts. Currently implemented as a hook point for future
   * enhancements.
   *
   * @param _newFacts The newly stored facts (unused in current implementation)
   */
  async triggerRules(_newFacts) {
  }
  /**
   * Trigger rules when events are appended
   */
  async triggerRulesForEvents(events) {
    const rules = this.registry.getAllRules();
    const state = {
      context: this.context,
      facts: [],
      meta: {}
    };
    const derivedFacts = [];
    for (const rule of rules) {
      try {
        const facts = rule.impl(state, events);
        derivedFacts.push(...facts);
      } catch (error) {
        this.onRuleError(rule.id, error);
      }
    }
    if (derivedFacts.length > 0) {
      const constraintResult = await this.checkConstraints(derivedFacts);
      if (constraintResult.valid) {
        for (const fact of derivedFacts) {
          await this.persistFact(fact);
        }
      }
    }
  }
  /**
   * Update the context
   */
  updateContext(context) {
    this.context = context;
  }
  /**
   * Get the current context
   */
  getContext() {
    return this.context;
  }
  /**
   * Dispose of all subscriptions
   */
  dispose() {
    for (const unsubscribe of this.subscriptions) {
      unsubscribe();
    }
    this.subscriptions = [];
    this.factWatchers.clear();
  }
};
function createPraxisDBStore(db, registry, initialContext, onRuleError) {
  return new PraxisDBStore({ db, registry, initialContext, onRuleError });
}

// src/core/pluresdb/schema-registry.ts
function getSchemaPath(schemaName) {
  return `${PRAXIS_PATHS.SCHEMAS}/${schemaName}`;
}
var PraxisSchemaRegistry = class {
  db;
  constructor(db) {
    this.db = db;
  }
  /**
   * Register a schema in PluresDB
   *
   * @param schema The schema to register
   */
  async register(schema) {
    const path = getSchemaPath(schema.name);
    const storedSchema = {
      schema,
      registeredAt: Date.now(),
      version: schema.version
    };
    await this.db.set(path, storedSchema);
  }
  /**
   * Get a schema by name
   *
   * @param schemaName The schema name
   * @returns The stored schema or undefined if not found
   */
  async get(schemaName) {
    const path = getSchemaPath(schemaName);
    return this.db.get(path);
  }
  /**
   * Check if a schema is registered
   *
   * @param schemaName The schema name
   * @returns True if the schema exists
   */
  async exists(schemaName) {
    const stored = await this.get(schemaName);
    return stored !== void 0;
  }
  /**
   * Update a schema (replaces existing)
   *
   * @param schema The updated schema
   */
  async update(schema) {
    await this.register(schema);
  }
  /**
   * List all registered schema names
   *
   * Implementation note: This method uses an index stored at `/_praxis/schemas/_index`.
   * When using InMemoryPraxisDB, schemas must be registered using `registerWithIndex()`
   * for them to appear in this listing. When using a full PluresDB implementation,
   * native listing capabilities should be used instead.
   *
   * @returns Array of registered schema names
   */
  async list() {
    const indexPath = `${PRAXIS_PATHS.SCHEMAS}/_index`;
    const index = await this.db.get(indexPath);
    return index ?? [];
  }
  /**
   * Register a schema and update the index
   *
   * @param schema The schema to register
   */
  async registerWithIndex(schema) {
    await this.register(schema);
    const indexPath = `${PRAXIS_PATHS.SCHEMAS}/_index`;
    const existingIndex = await this.db.get(indexPath) ?? [];
    if (!existingIndex.includes(schema.name)) {
      await this.db.set(indexPath, [...existingIndex, schema.name]);
    }
  }
};
async function registerSchema(db, schema) {
  const registry = new PraxisSchemaRegistry(db);
  await registry.registerWithIndex(schema);
}
function createSchemaRegistry(db) {
  return new PraxisSchemaRegistry(db);
}

// src/core/pluresdb/generator.ts
var PluresDBGenerator = class {
  options;
  constructor(options) {
    this.options = {
      dbVersion: 1,
      enableSync: false,
      autoIndex: "all",
      // Default to indexing all fields for backward compatibility
      ...options
    };
  }
  /**
   * Generate PluresDB configuration from schema
   */
  generateConfig(schema) {
    const files = [];
    files.push(this.generateConfigFile(schema));
    return files;
  }
  /**
   * Generate pluresdb-config.ts file
   */
  generateConfigFile(schema) {
    const lines = [];
    const dbName = this.options.dbName || schema.name.toLowerCase();
    lines.push("/**");
    lines.push(` * PluresDB Configuration for ${schema.name}`);
    lines.push(" * Generated from Praxis schema");
    lines.push(" */");
    lines.push("");
    lines.push("// import { createPluresDB } from '@plures/pluresdb';");
    lines.push("");
    lines.push("/**");
    lines.push(" * Database store configuration");
    lines.push(" * ");
    const autoIndexStrategy = this.options.autoIndex || "all";
    if (autoIndexStrategy === "all") {
      lines.push(" * Indexing: All string, number, and date fields are auto-indexed by default.");
      lines.push(' * For large datasets, consider using autoIndex: "explicit" to only index');
      lines.push(" * fields explicitly defined in the schema.");
    } else if (autoIndexStrategy === "explicit") {
      lines.push(" * Indexing: Only fields explicitly defined in schema indexes are indexed.");
    } else if (autoIndexStrategy === "none") {
      lines.push(" * Indexing: Auto-indexing disabled. Only explicit schema indexes are used.");
    }
    lines.push(" */");
    lines.push("export const stores = {");
    if (schema.models && schema.models.length > 0) {
      for (const model of schema.models) {
        const storeName = model.name.toLowerCase() + "s";
        const storeConfig = this.generateStoreConfig(model);
        lines.push(`  ${storeName}: {`);
        lines.push(`    keyPath: '${storeConfig.keyPath}',`);
        if (storeConfig.indexes.length > 0) {
          lines.push(`    indexes: [${storeConfig.indexes.map((idx) => `'${idx}'`).join(", ")}],`);
        }
        lines.push("  },");
      }
    } else {
      lines.push("  // No models defined in schema");
    }
    lines.push("};");
    lines.push("");
    lines.push("/**");
    lines.push(" * Database configuration");
    lines.push(" */");
    lines.push("export const dbConfig = {");
    lines.push(`  name: '${dbName}',`);
    lines.push(`  version: ${this.options.dbVersion},`);
    lines.push("  stores,");
    if (this.options.enableSync) {
      lines.push("  sync: {");
      lines.push("    enabled: true,");
      if (this.options.syncEndpoint) {
        lines.push(`    endpoint: '${this.options.syncEndpoint}',`);
      } else {
        lines.push("    endpoint: 'ws://localhost:8080/sync',");
      }
      lines.push("    conflictResolution: 'last-write-wins',");
      lines.push("  },");
    }
    lines.push("};");
    lines.push("");
    lines.push("/**");
    lines.push(" * Initialize PluresDB");
    lines.push(" * @returns Configured PluresDB instance");
    lines.push(" */");
    lines.push("export function initDB() {");
    lines.push("  // Create and configure PluresDB instance");
    lines.push("  const db = createInMemoryDB();");
    lines.push("  ");
    lines.push("  // Initialize stores based on configuration");
    lines.push("  for (const storeDef of dbConfig.stores) {");
    lines.push("    // Pre-create store paths");
    lines.push("    db.set(`stores/${storeDef.name}/_meta`, {");
    lines.push("      keyPath: storeDef.keyPath,");
    lines.push("      indexes: storeDef.indexes,");
    lines.push("      createdAt: Date.now(),");
    lines.push("    });");
    lines.push("  }");
    lines.push("  ");
    lines.push("  console.log(`PluresDB initialized: ${dbConfig.name}`);");
    lines.push("  return db;");
    lines.push("}");
    lines.push("");
    lines.push("/**");
    lines.push(" * Get store by name");
    lines.push(" */");
    lines.push(
      "export function getStore(db: ReturnType<typeof createInMemoryDB>, storeName: string) {"
    );
    lines.push("  const storeDef = dbConfig.stores.find(s => s.name === storeName);");
    lines.push("  if (!storeDef) {");
    lines.push('    throw new Error(`Store "${storeName}" not found in configuration`);');
    lines.push("  }");
    lines.push("  return {");
    lines.push("    get: (key: string) => db.get(`stores/${storeName}/${key}`),");
    lines.push(
      "    set: (key: string, value: unknown) => db.set(`stores/${storeName}/${key}`, value),"
    );
    lines.push("    delete: (key: string) => db.delete(`stores/${storeName}/${key}`),");
    lines.push("    watch: (key: string, callback: (data: unknown) => void) => ");
    lines.push("      db.watch(`stores/${storeName}/${key}`, callback),");
    lines.push("  };");
    lines.push("}");
    return {
      path: `${this.options.outputDir}/pluresdb-config.ts`,
      content: lines.join("\n"),
      type: "config"
    };
  }
  /**
   * Generate store configuration for a model
   */
  generateStoreConfig(model) {
    const idField = model.fields.find((f) => f.name === "id" || f.name === "_id");
    const keyPath = idField ? idField.name : "id";
    const indexes = [];
    const autoIndexStrategy = this.options.autoIndex || "all";
    if (autoIndexStrategy === "all") {
      for (const field of model.fields) {
        if (field.name !== keyPath) {
          if (field.type === "string" || field.type === "number" || field.type === "date") {
            indexes.push(field.name);
          }
        }
      }
    }
    if (model.indexes) {
      for (const indexDef of model.indexes) {
        for (const fieldName of indexDef.fields) {
          if (!indexes.includes(fieldName) && fieldName !== keyPath) {
            indexes.push(fieldName);
          }
        }
      }
    }
    return {
      keyPath,
      indexes
    };
  }
};
function createPluresDBGenerator(outputDir, options) {
  return new PluresDBGenerator({
    outputDir,
    ...options
  });
}

// src/integrations/pluresdb.ts
function createPluresDBAdapter(options) {
  const store = createPraxisDBStore(options.db, options.registry, options.initialContext);
  const subscriptions = [];
  return {
    async persistEvents(events) {
      await store.appendEvents(events);
    },
    async persistFacts(facts) {
      await store.storeFacts(facts);
    },
    async loadEvents(query) {
      if (!query?.tag) {
        return [];
      }
      const entries = await store.getEvents(query.tag, {
        since: query.since,
        limit: query.limit
      });
      return entries.map((e) => e.event);
    },
    subscribeToEvents(callback, query) {
      if (!query?.tag) {
        return () => {
        };
      }
      const unsubscribe = store.watchFacts(query.tag, (facts) => {
        const events = facts.map((f) => ({
          tag: f.tag,
          payload: f.payload
        }));
        callback(events);
      });
      subscriptions.push(unsubscribe);
      return unsubscribe;
    },
    attachEngine(engine) {
      store.updateContext(engine.getContext());
    },
    dispose() {
      for (const unsub of subscriptions) {
        unsub();
      }
      subscriptions.length = 0;
      store.dispose();
    }
  };
}
function attachToEngine(store, engine) {
  store.updateContext(engine.getContext());
  return () => {
    store.dispose();
  };
}

// src/integrations/unum.ts
async function createUnumAdapter(config) {
  const { db, realtime = true } = config;
  let currentIdentity = null;
  const channels = /* @__PURE__ */ new Map();
  const subscriptions = /* @__PURE__ */ new Set();
  if (config.identity) {
    currentIdentity = {
      ...config.identity,
      id: config.identity.id || generateId2(),
      createdAt: Date.now()
    };
    await db.set(`unum/identities/${currentIdentity.id}`, currentIdentity);
  }
  async function setIdentity(identity) {
    currentIdentity = {
      ...identity,
      id: generateId2(),
      createdAt: Date.now()
    };
    await db.set(`unum/identities/${currentIdentity.id}`, currentIdentity);
    return currentIdentity;
  }
  async function getIdentity(id) {
    return await db.get(`unum/identities/${id}`);
  }
  async function createChannel(name, members) {
    const channelId = generateId2();
    const channelData = {
      id: channelId,
      name,
      members: members || [],
      createdAt: Date.now(),
      createdBy: currentIdentity?.id
    };
    await db.set(`unum/channels/${channelId}`, channelData);
    const channel = createChannelInstance(channelId, name);
    channels.set(channelId, channel);
    return channel;
  }
  async function joinChannel(channelId) {
    const existing = channels.get(channelId);
    if (existing) return existing;
    const channelData = await db.get(`unum/channels/${channelId}`);
    if (!channelData) {
      throw new Error(`Channel ${channelId} not found`);
    }
    const channel = createChannelInstance(channelData.id, channelData.name);
    channels.set(channelId, channel);
    return channel;
  }
  async function listChannels() {
    return Array.from(channels.values());
  }
  function createChannelInstance(id, name) {
    const handlers = /* @__PURE__ */ new Set();
    return {
      id,
      name,
      subscribe(handler) {
        handlers.add(handler);
        if (realtime) {
          const unsub = db.watch(`unum/channels/${id}/messages`, (data) => {
            if (data) {
              handler(data);
            }
          });
          subscriptions.add(unsub);
        }
        return () => {
          handlers.delete(handler);
        };
      },
      async publish(message) {
        const fullMessage = {
          ...message,
          id: message.id || generateId2(),
          channelId: id,
          timestamp: Date.now()
        };
        await db.set(`unum/channels/${id}/messages/${fullMessage.id}`, fullMessage);
        handlers.forEach((h) => h(fullMessage));
      },
      async getMembers() {
        const channelData = await db.get(`unum/channels/${id}`);
        if (!channelData?.members) return [];
        const members = [];
        for (const memberId of channelData.members) {
          const identity = await getIdentity(memberId);
          if (identity) members.push(identity);
        }
        return members;
      },
      async leave() {
        channels.delete(id);
      }
    };
  }
  async function broadcastEvent(channelId, event) {
    const channel = channels.get(channelId);
    if (!channel) {
      throw new Error(`Not joined to channel ${channelId}`);
    }
    await channel.publish({
      id: generateId2(),
      sender: currentIdentity || { id: "anonymous", createdAt: Date.now() },
      content: event,
      type: "event"
    });
  }
  async function broadcastFact(channelId, fact) {
    const channel = channels.get(channelId);
    if (!channel) {
      throw new Error(`Not joined to channel ${channelId}`);
    }
    await channel.publish({
      id: generateId2(),
      sender: currentIdentity || { id: "anonymous", createdAt: Date.now() },
      content: fact,
      type: "fact"
    });
  }
  function subscribeToEvents(channelId, handler) {
    const channel = channels.get(channelId);
    if (!channel) {
      throw new Error(`Not joined to channel ${channelId}`);
    }
    return channel.subscribe((message) => {
      if (message.type === "event") {
        handler(message.content);
      }
    });
  }
  function subscribeToFacts(channelId, handler) {
    const channel = channels.get(channelId);
    if (!channel) {
      throw new Error(`Not joined to channel ${channelId}`);
    }
    return channel.subscribe((message) => {
      if (message.type === "fact") {
        handler(message.content);
      }
    });
  }
  async function disconnect() {
    subscriptions.forEach((unsub) => unsub());
    subscriptions.clear();
    for (const channel of channels.values()) {
      await channel.leave();
    }
    channels.clear();
    currentIdentity = null;
  }
  return {
    get identity() {
      return currentIdentity;
    },
    setIdentity,
    getIdentity,
    createChannel,
    joinChannel,
    listChannels,
    broadcastEvent,
    broadcastFact,
    subscribeToEvents,
    subscribeToFacts,
    disconnect
  };
}
function generateId2() {
  return `${Date.now().toString(36)}-${Math.random().toString(36).substr(2, 9)}`;
}
function attachUnumToEngine(_engine, _adapter, _channelId) {
  return () => {
  };
}

// src/integrations/code-canvas.ts
function schemaToCanvas(schema, _options = {}) {
  const nodes = [];
  const edges = [];
  let nodeId = 0;
  let yOffset = 0;
  const xSpacing = 200;
  const ySpacing = 100;
  if (schema.models) {
    schema.models.forEach((model, index) => {
      const pos = model.position && (model.position.x !== 0 || model.position.y !== 0) ? model.position : { x: 50, y: yOffset + index * ySpacing };
      const node = {
        id: model.id || `model-${nodeId++}`,
        type: "model",
        label: model.name,
        x: pos.x,
        y: pos.y,
        width: 150,
        height: 60,
        data: model,
        style: {
          backgroundColor: "#e3f2fd",
          borderColor: "#1976d2"
        }
      };
      nodes.push(node);
    });
    yOffset += schema.models.length * ySpacing + 50;
  }
  if (schema.components) {
    schema.components.forEach((component, index) => {
      const pos = component.position && (component.position.x !== 0 || component.position.y !== 0) ? component.position : { x: 50 + xSpacing, y: yOffset + index * ySpacing };
      const node = {
        id: component.id || `component-${nodeId++}`,
        type: "component",
        label: component.name,
        x: pos.x,
        y: pos.y,
        width: 150,
        height: 60,
        data: component,
        style: {
          backgroundColor: "#e8f5e9",
          borderColor: "#388e3c"
        }
      };
      nodes.push(node);
      if (component.model) {
        const modelNode = nodes.find((n) => n.type === "model" && n.label === component.model);
        if (modelNode) {
          edges.push({
            id: `edge-${edges.length}`,
            source: node.id,
            target: modelNode.id,
            type: "reference",
            label: "uses"
          });
        }
      }
    });
    yOffset += schema.components.length * ySpacing + 50;
  }
  if (schema.events) {
    schema.events.forEach((event, index) => {
      const pos = event.position && (event.position.x !== 0 || event.position.y !== 0) ? event.position : { x: 50 + xSpacing * 2, y: yOffset + index * ySpacing };
      const node = {
        id: event.id || `event-${nodeId++}`,
        type: "event",
        label: event.tag,
        x: pos.x,
        y: pos.y,
        width: 150,
        height: 50,
        data: event,
        style: {
          backgroundColor: "#fff3e0",
          borderColor: "#f57c00"
        }
      };
      nodes.push(node);
    });
    yOffset += schema.events.length * ySpacing + 30;
  }
  if (schema.facts) {
    schema.facts.forEach((fact, index) => {
      const pos = fact.position && (fact.position.x !== 0 || fact.position.y !== 0) ? fact.position : { x: 50 + xSpacing * 3, y: yOffset + index * ySpacing };
      const node = {
        id: fact.id || `fact-${nodeId++}`,
        type: "fact",
        label: fact.tag,
        x: pos.x,
        y: pos.y,
        width: 150,
        height: 50,
        data: fact,
        style: {
          backgroundColor: "#fce4ec",
          borderColor: "#c2185b"
        }
      };
      nodes.push(node);
    });
    yOffset += schema.facts.length * ySpacing + 30;
  }
  if (schema.rules) {
    schema.rules.forEach((rule, index) => {
      const pos = rule.position && (rule.position.x !== 0 || rule.position.y !== 0) ? rule.position : { x: 50 + xSpacing * 4, y: yOffset + index * ySpacing };
      const node = {
        id: rule.id || `rule-${nodeId++}`,
        type: "rule",
        label: rule.id,
        x: pos.x,
        y: pos.y,
        width: 150,
        height: 50,
        data: rule,
        style: {
          backgroundColor: "#e1f5fe",
          borderColor: "#0288d1"
        }
      };
      nodes.push(node);
      if (rule.triggers) {
        rule.triggers.forEach((trigger) => {
          const eventNode = nodes.find((n) => n.type === "event" && n.label === trigger);
          if (eventNode) {
            edges.push({
              id: `edge-${edges.length}`,
              source: eventNode.id,
              target: node.id,
              type: "event",
              label: "triggers"
            });
          }
        });
      }
    });
    yOffset += schema.rules.length * ySpacing + 30;
  }
  if (schema.constraints) {
    schema.constraints.forEach((constraint, index) => {
      const pos = constraint.position && (constraint.position.x !== 0 || constraint.position.y !== 0) ? constraint.position : { x: 50 + xSpacing * 5, y: yOffset + index * ySpacing };
      const node = {
        id: constraint.id || `constraint-${nodeId++}`,
        type: "constraint",
        label: constraint.id,
        x: pos.x,
        y: pos.y,
        width: 150,
        height: 50,
        data: constraint,
        style: {
          backgroundColor: "#ffebee",
          borderColor: "#c62828"
        }
      };
      nodes.push(node);
    });
  }
  return {
    id: `canvas-${Date.now()}`,
    name: schema.name || "Praxis Schema",
    version: schema.$version || "1.0.0",
    nodes,
    edges,
    flows: schema.flows || [],
    metadata: {
      created: Date.now(),
      modified: Date.now(),
      description: schema.description
    },
    viewport: { x: 0, y: 0, zoom: 1 }
  };
}
function canvasToSchema(canvas) {
  const models = [];
  const components = [];
  const events = [];
  const facts = [];
  const rules = [];
  const constraints = [];
  for (const node of canvas.nodes) {
    const position = { x: node.x, y: node.y };
    switch (node.type) {
      case "model":
        if (node.data) {
          models.push({ ...node.data, position });
        }
        break;
      case "component":
        if (node.data) {
          components.push({ ...node.data, position });
        }
        break;
      case "event":
        if (node.data) {
          events.push({ ...node.data, position });
        }
        break;
      case "fact":
        if (node.data) {
          facts.push({ ...node.data, position });
        }
        break;
      case "rule":
        if (node.data) {
          rules.push({ ...node.data, position });
        }
        break;
      case "constraint":
        if (node.data) {
          constraints.push({ ...node.data, position });
        }
        break;
    }
  }
  return {
    $version: "1.0.0",
    id: canvas.id,
    name: canvas.name,
    description: canvas.metadata?.description,
    models,
    components,
    events,
    facts,
    rules,
    constraints,
    flows: canvas.flows || [],
    metadata: canvas.metadata
  };
}
function canvasToYaml(canvas) {
  const lines = [
    `# ${canvas.name}`,
    `# Generated by Praxis CodeCanvas Integration`,
    `# Version: ${canvas.version}`,
    "",
    "nodes:"
  ];
  for (const node of canvas.nodes) {
    lines.push(`  - id: "${node.id}"`);
    lines.push(`    type: "${node.type}"`);
    lines.push(`    label: "${node.label}"`);
    lines.push(`    x: ${node.x}`);
    lines.push(`    y: ${node.y}`);
    lines.push(`    width: ${node.width}`);
    lines.push(`    height: ${node.height}`);
    if (node.fsmState) {
      lines.push(`    fsmState: "${node.fsmState}"`);
    }
    lines.push("");
  }
  lines.push("edges:");
  for (const edge of canvas.edges) {
    lines.push(`  - id: "${edge.id}"`);
    lines.push(`    source: "${edge.source}"`);
    lines.push(`    target: "${edge.target}"`);
    if (edge.label) {
      lines.push(`    label: "${edge.label}"`);
    }
    if (edge.type) {
      lines.push(`    type: "${edge.type}"`);
    }
    lines.push("");
  }
  return lines.join("\n");
}
function canvasToMermaid(canvas) {
  const lines = ["graph TD"];
  for (const node of canvas.nodes) {
    let shape;
    switch (node.type) {
      case "model":
        shape = `[${node.label}]`;
        break;
      case "component":
        shape = `(${node.label})`;
        break;
      case "event":
        shape = `{{${node.label}}}`;
        break;
      case "fact":
        shape = `((${node.label}))`;
        break;
      case "rule":
        shape = `[/${node.label}/]`;
        break;
      case "constraint":
        shape = `[\\${node.label}\\]`;
        break;
      default:
        shape = `[${node.label}]`;
    }
    lines.push(`    ${node.id}${shape}`);
  }
  lines.push("");
  for (const edge of canvas.edges) {
    const label = edge.label ? `|${edge.label}|` : "";
    lines.push(`    ${edge.source} -->${label} ${edge.target}`);
  }
  return lines.join("\n");
}
function validateWithGuardian(files, activity, lifecycle) {
  const errors = [];
  const warnings = [];
  const currentState = lifecycle.find((s) => s.id === activity.activity);
  if (!currentState) {
    errors.push({
      code: "INVALID_ACTIVITY",
      message: `Activity "${activity.activity}" is not a valid lifecycle state`,
      rule: "lifecycle-state"
    });
  }
  if (activity.allowedPaths) {
    for (const file of files) {
      const allowed = activity.allowedPaths.some((pattern) => {
        const regex = new RegExp("^" + pattern.replace(/\*/g, ".*") + "$");
        return regex.test(file);
      });
      if (!allowed) {
        errors.push({
          code: "PATH_NOT_ALLOWED",
          message: `File "${file}" is not allowed during "${activity.activity}" activity`,
          file,
          rule: "allowed-paths"
        });
      }
    }
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings,
    filesChecked: files,
    activity
  };
}
function createCanvasEditor(config) {
  const document = config.document || (config.schema ? schemaToCanvas(config.schema, { layout: config.layout }) : {
    id: `canvas-${Date.now()}`,
    name: "New Canvas",
    version: "1.0.0",
    nodes: [],
    edges: [],
    metadata: { created: Date.now(), modified: Date.now() },
    viewport: { x: 0, y: 0, zoom: 1 }
  });
  let nodeIdCounter = document.nodes.length;
  let edgeIdCounter = document.edges.length;
  return {
    document,
    addNode(node) {
      const fullNode = {
        ...node,
        id: `node-${nodeIdCounter++}`
      };
      document.nodes.push(fullNode);
      document.metadata.modified = Date.now();
      return fullNode;
    },
    removeNode(id) {
      const index = document.nodes.findIndex((n) => n.id === id);
      if (index !== -1) {
        document.nodes.splice(index, 1);
        document.edges = document.edges.filter((e) => e.source !== id && e.target !== id);
        document.metadata.modified = Date.now();
      }
    },
    addEdge(edge) {
      const fullEdge = {
        ...edge,
        id: `edge-${edgeIdCounter++}`
      };
      document.edges.push(fullEdge);
      document.metadata.modified = Date.now();
      return fullEdge;
    },
    removeEdge(id) {
      const index = document.edges.findIndex((e) => e.id === id);
      if (index !== -1) {
        document.edges.splice(index, 1);
        document.metadata.modified = Date.now();
      }
    },
    toSchema() {
      return canvasToSchema(document);
    },
    toYaml() {
      return canvasToYaml(document);
    },
    toMermaid() {
      return canvasToMermaid(document);
    }
  };
}

// src/integrations/state-docs.ts
var StateDocsGenerator = class {
  config;
  constructor(config) {
    this.config = {
      target: "./docs",
      globs: ["**/*.ts", "**/*.js"],
      visualization: {
        format: "mermaid",
        exportPng: false,
        theme: "default"
      },
      template: {
        toc: true,
        timestamp: true
      },
      ...config
    };
  }
  /**
   * Generate documentation from a Praxis schema
   */
  generateFromSchema(schema) {
    const docs = [];
    docs.push(this.generateSchemaReadme(schema));
    if (schema.models && schema.models.length > 0) {
      docs.push(this.generateModelsDoc(schema));
    }
    if (schema.components && schema.components.length > 0) {
      docs.push(this.generateComponentsDoc(schema));
    }
    if (schema.logic && schema.logic.length > 0) {
      for (const logic of schema.logic) {
        docs.push(this.generateLogicDoc(logic));
        docs.push(this.generateLogicDiagram(logic));
      }
    }
    return docs;
  }
  /**
   * Generate documentation from a Praxis registry
   */
  generateFromModule(module) {
    const docs = [];
    const rules = module.rules;
    const constraints = module.constraints;
    docs.push(this.generateRulesDoc(rules));
    docs.push(this.generateConstraintsDoc(constraints));
    docs.push(this.generateRegistryDiagram(rules, constraints));
    return docs;
  }
  /**
   * Generate the main schema README
   */
  generateSchemaReadme(schema) {
    const lines = [];
    if (this.config.template?.header) {
      lines.push(this.config.template.header);
      lines.push("");
    }
    lines.push(`# ${schema.name || this.config.projectTitle}`);
    lines.push("");
    if (schema.description) {
      lines.push(schema.description);
      lines.push("");
    }
    if (this.config.template?.toc) {
      lines.push("## Table of Contents");
      lines.push("");
      lines.push("- [Overview](#overview)");
      if (schema.models && schema.models.length > 0) {
        lines.push("- [Models](#models)");
      }
      if (schema.components && schema.components.length > 0) {
        lines.push("- [Components](#components)");
      }
      if (schema.logic && schema.logic.length > 0) {
        lines.push("- [Logic](#logic)");
      }
      lines.push("");
    }
    lines.push("## Overview");
    lines.push("");
    lines.push(`**Version:** ${schema.version}`);
    lines.push("");
    lines.push("### Statistics");
    lines.push("");
    lines.push("| Category | Count |");
    lines.push("|----------|-------|");
    lines.push(`| Models | ${schema.models?.length || 0} |`);
    lines.push(`| Components | ${schema.components?.length || 0} |`);
    lines.push(`| Logic Modules | ${schema.logic?.length || 0} |`);
    lines.push("");
    if (schema.models && schema.models.length > 0) {
      lines.push("## Models");
      lines.push("");
      for (const model of schema.models) {
        lines.push(`### ${model.name}`);
        lines.push("");
        if (model.description) {
          lines.push(model.description);
          lines.push("");
        }
        lines.push("**Fields:**");
        lines.push("");
        lines.push("| Name | Type | Required |");
        lines.push("|------|------|----------|");
        for (const field of model.fields) {
          const required = field.optional ? "No" : "Yes";
          lines.push(`| ${field.name} | ${field.type} | ${required} |`);
        }
        lines.push("");
      }
    }
    if (schema.components && schema.components.length > 0) {
      lines.push("## Components");
      lines.push("");
      for (const component of schema.components) {
        lines.push(`### ${component.name}`);
        lines.push("");
        lines.push(`**Type:** ${component.type}`);
        lines.push("");
        if (component.description) {
          lines.push(component.description);
          lines.push("");
        }
        if (component.model) {
          lines.push(`**Model:** ${component.model}`);
          lines.push("");
        }
      }
    }
    if (schema.logic && schema.logic.length > 0) {
      lines.push("## Logic");
      lines.push("");
      for (const logic of schema.logic) {
        lines.push(`### ${logic.id}`);
        lines.push("");
        if (logic.description) {
          lines.push(logic.description);
          lines.push("");
        }
        if (logic.events && logic.events.length > 0) {
          lines.push("**Events:**");
          lines.push("");
          for (const event of logic.events) {
            lines.push(`- \`${event.tag}\`: ${event.description || ""}`);
          }
          lines.push("");
        }
        if (logic.facts && logic.facts.length > 0) {
          lines.push("**Facts:**");
          lines.push("");
          for (const fact of logic.facts) {
            lines.push(`- \`${fact.tag}\`: ${fact.description || ""}`);
          }
          lines.push("");
        }
        if (logic.rules && logic.rules.length > 0) {
          lines.push("**Rules:**");
          lines.push("");
          for (const rule of logic.rules) {
            lines.push(`- \`${rule.id}\`: ${rule.description || ""}`);
          }
          lines.push("");
        }
      }
    }
    if (this.config.template?.timestamp) {
      lines.push("---");
      lines.push("");
      lines.push(`*Generated on ${(/* @__PURE__ */ new Date()).toISOString()} by State-Docs*`);
    }
    if (this.config.template?.footer) {
      lines.push("");
      lines.push(this.config.template.footer);
    }
    return {
      path: `${this.config.target}/README.md`,
      content: lines.join("\n"),
      type: "markdown"
    };
  }
  /**
   * Generate models documentation
   */
  generateModelsDoc(schema) {
    const lines = [
      "# Models",
      "",
      "This document describes all data models defined in the schema.",
      ""
    ];
    if (schema.models) {
      for (const model of schema.models) {
        lines.push(`## ${model.name}`);
        lines.push("");
        if (model.description) {
          lines.push(model.description);
          lines.push("");
        }
        lines.push("### Fields");
        lines.push("");
        lines.push("| Name | Type | Required | Description |");
        lines.push("|------|------|----------|-------------|");
        for (const field of model.fields) {
          const required = field.optional ? "No" : "Yes";
          const description = field.description || "-";
          lines.push(`| ${field.name} | \`${field.type}\` | ${required} | ${description} |`);
        }
        lines.push("");
        if (model.indexes && model.indexes.length > 0) {
          lines.push("### Indexes");
          lines.push("");
          for (const index of model.indexes) {
            lines.push(`- **${index.name}**: \`${index.fields.join(", ")}\``);
          }
          lines.push("");
        }
      }
    }
    return {
      path: `${this.config.target}/models.md`,
      content: lines.join("\n"),
      type: "markdown"
    };
  }
  /**
   * Generate components documentation
   */
  generateComponentsDoc(schema) {
    const lines = [
      "# Components",
      "",
      "This document describes all UI components defined in the schema.",
      ""
    ];
    if (schema.components) {
      for (const component of schema.components) {
        lines.push(`## ${component.name}`);
        lines.push("");
        lines.push(`**Type:** ${component.type}`);
        lines.push("");
        if (component.description) {
          lines.push(component.description);
          lines.push("");
        }
        if (component.model) {
          lines.push(
            `**Associated Model:** [${component.model}](./models.md#${component.model.toLowerCase()})`
          );
          lines.push("");
        }
      }
    }
    return {
      path: `${this.config.target}/components.md`,
      content: lines.join("\n"),
      type: "markdown"
    };
  }
  /**
   * Generate logic documentation
   */
  generateLogicDoc(logic) {
    const lines = [`# ${logic.id}`, ""];
    if (logic.description) {
      lines.push(logic.description);
      lines.push("");
    }
    if (logic.events && logic.events.length > 0) {
      lines.push("## Events");
      lines.push("");
      lines.push("| Event | Description | Payload |");
      lines.push("|-------|-------------|---------|");
      for (const event of logic.events) {
        const payload = event.payload ? Object.entries(event.payload).map(([k, v]) => `${k}: ${v}`).join(", ") : "-";
        lines.push(`| \`${event.tag}\` | ${event.description || "-"} | ${payload} |`);
      }
      lines.push("");
    }
    if (logic.facts && logic.facts.length > 0) {
      lines.push("## Facts");
      lines.push("");
      lines.push("| Fact | Description | Payload |");
      lines.push("|------|-------------|---------|");
      for (const fact of logic.facts) {
        const payload = fact.payload ? Object.entries(fact.payload).map(([k, v]) => `${k}: ${v}`).join(", ") : "-";
        lines.push(`| \`${fact.tag}\` | ${fact.description || "-"} | ${payload} |`);
      }
      lines.push("");
    }
    if (logic.rules && logic.rules.length > 0) {
      lines.push("## Rules");
      lines.push("");
      for (const rule of logic.rules) {
        lines.push(`### ${rule.id}`);
        lines.push("");
        if (rule.description) {
          lines.push(rule.description);
          lines.push("");
        }
        if (rule.priority !== void 0) {
          lines.push(`**Priority:** ${rule.priority}`);
          lines.push("");
        }
      }
    }
    if (logic.constraints && logic.constraints.length > 0) {
      lines.push("## Constraints");
      lines.push("");
      for (const constraint of logic.constraints) {
        lines.push(`### ${constraint.id}`);
        lines.push("");
        if (constraint.description) {
          lines.push(constraint.description);
          lines.push("");
        }
        if (constraint.message) {
          lines.push(`**Error Message:** ${constraint.message}`);
          lines.push("");
        }
      }
    }
    return {
      path: `${this.config.target}/logic/${logic.id}.md`,
      content: lines.join("\n"),
      type: "markdown"
    };
  }
  /**
   * Generate Mermaid diagram for logic
   */
  generateLogicDiagram(logic) {
    const lines = ["stateDiagram-v2"];
    if (logic.events && logic.facts) {
      lines.push("    [*] --> Processing");
      for (const event of logic.events) {
        lines.push(`    Processing --> ${event.tag.replace(/[^a-zA-Z0-9]/g, "")}: ${event.tag}`);
      }
      for (const fact of logic.facts) {
        lines.push(`    ${fact.tag.replace(/[^a-zA-Z0-9]/g, "")} --> [*]`);
      }
    }
    return {
      path: `${this.config.target}/logic/${logic.id}.mmd`,
      content: lines.join("\n"),
      type: "mermaid"
    };
  }
  /**
   * Generate rules documentation
   */
  generateRulesDoc(rules) {
    const lines = [
      "# Rules",
      "",
      "This document describes all rules registered in the Praxis engine.",
      ""
    ];
    for (const rule of rules) {
      lines.push(`## ${rule.id}`);
      lines.push("");
      if (rule.description) {
        lines.push(rule.description);
        lines.push("");
      }
      if (rule.meta?.eventType) {
        lines.push(`**Triggers on:** \`${rule.meta.eventType}\``);
        lines.push("");
      }
      if (rule.meta?.priority !== void 0) {
        lines.push(`**Priority:** ${rule.meta.priority}`);
        lines.push("");
      }
    }
    return {
      path: `${this.config.target}/rules.md`,
      content: lines.join("\n"),
      type: "markdown"
    };
  }
  /**
   * Generate constraints documentation
   */
  generateConstraintsDoc(constraints) {
    const lines = [
      "# Constraints",
      "",
      "This document describes all constraints (invariants) registered in the Praxis engine.",
      ""
    ];
    for (const constraint of constraints) {
      lines.push(`## ${constraint.id}`);
      lines.push("");
      if (constraint.description) {
        lines.push(constraint.description);
        lines.push("");
      }
      if (constraint.meta?.errorMessage) {
        lines.push(`**Error Message:** ${constraint.meta.errorMessage}`);
        lines.push("");
      }
    }
    return {
      path: `${this.config.target}/constraints.md`,
      content: lines.join("\n"),
      type: "markdown"
    };
  }
  /**
   * Generate state diagram from registry
   */
  generateRegistryDiagram(rules, constraints) {
    const lines = ["graph TD", "    subgraph Rules"];
    for (const rule of rules) {
      const id = rule.id.replace(/[^a-zA-Z0-9]/g, "_");
      lines.push(`        ${id}["${rule.id}"]`);
    }
    lines.push("    end");
    lines.push("    subgraph Constraints");
    for (const constraint of constraints) {
      const id = constraint.id.replace(/[^a-zA-Z0-9]/g, "_");
      lines.push(`        ${id}["${constraint.id}"]`);
    }
    lines.push("    end");
    return {
      path: `${this.config.target}/state-diagram.mmd`,
      content: lines.join("\n"),
      type: "mermaid"
    };
  }
};
function createStateDocsGenerator(config) {
  return new StateDocsGenerator(config);
}
function generateDocs(schema, config) {
  const generator = createStateDocsGenerator(config);
  return generator.generateFromSchema(schema);
}

// src/integrations/tauri.ts
function createMockTauriBridge() {
  const eventHandlers = /* @__PURE__ */ new Map();
  const storage = /* @__PURE__ */ new Map();
  return {
    app: {
      name: "Mock App",
      version: "0.0.0",
      tauriVersion: "mock"
    },
    fs: {
      async readFile(path) {
        const data = storage.get(path);
        if (data instanceof Uint8Array) return data;
        throw new Error(`File not found: ${path}`);
      },
      async readTextFile(path) {
        const data = storage.get(path);
        if (typeof data === "string") return data;
        throw new Error(`File not found: ${path}`);
      },
      async writeFile(path, data) {
        storage.set(path, data);
      },
      async writeTextFile(path, data) {
        storage.set(path, data);
      },
      async exists(path) {
        return storage.has(path);
      },
      async mkdir(_path, _options) {
      },
      async remove(path, _options) {
        storage.delete(path);
      },
      async rename(oldPath, newPath) {
        const data = storage.get(oldPath);
        if (data !== void 0) {
          storage.set(newPath, data);
          storage.delete(oldPath);
        }
      },
      async readDir(_path) {
        return [];
      }
    },
    tray: {
      async setIcon(_icon) {
      },
      async setTooltip(_tooltip) {
      },
      async setMenu(_menu) {
      },
      async show() {
      },
      async hide() {
      }
    },
    notification: {
      async send(options) {
        console.log("Mock notification:", options.title, options.body);
      },
      async requestPermission() {
        return "granted";
      },
      async checkPermission() {
        return "granted";
      }
    },
    async invoke(cmd, payload) {
      console.log("Mock invoke:", cmd, payload);
      return null;
    },
    async listen(event, handler) {
      if (!eventHandlers.has(event)) {
        eventHandlers.set(event, /* @__PURE__ */ new Set());
      }
      eventHandlers.get(event).add(handler);
      return () => {
        eventHandlers.get(event)?.delete(handler);
      };
    },
    async emit(event, payload) {
      const handlers = eventHandlers.get(event);
      if (handlers) {
        const tauriEvent = { event, payload };
        handlers.forEach((h) => h(tauriEvent));
      }
    },
    window: {
      async minimize() {
      },
      async maximize() {
      },
      async unmaximize() {
      },
      async close() {
      },
      async toggleFullscreen() {
      },
      async setTitle(_title) {
      },
      async show() {
      },
      async hide() {
      },
      async focus() {
      }
    },
    async checkForUpdates() {
      return null;
    },
    async installUpdate() {
    }
  };
}
function createTauriPraxisAdapter(options) {
  const { bridge, statePath = "praxis-state.json", eventsPath = "praxis-events.json" } = options;
  return {
    async saveState(state) {
      const json = JSON.stringify(state, null, 2);
      await bridge.fs.writeTextFile(statePath, json);
    },
    async loadState() {
      try {
        const exists = await bridge.fs.exists(statePath);
        if (!exists) return null;
        const json = await bridge.fs.readTextFile(statePath);
        return JSON.parse(json);
      } catch {
        return null;
      }
    },
    async saveEvents(events) {
      const json = JSON.stringify(events, null, 2);
      await bridge.fs.writeTextFile(eventsPath, json);
    },
    async loadEvents() {
      try {
        const exists = await bridge.fs.exists(eventsPath);
        if (!exists) return [];
        const json = await bridge.fs.readTextFile(eventsPath);
        return JSON.parse(json);
      } catch {
        return [];
      }
    },
    async watchStateFile(_handler) {
      console.log("File watching not implemented in mock");
      return () => {
      };
    },
    getStatePath() {
      return statePath;
    },
    getEventsPath() {
      return eventsPath;
    }
  };
}
function attachTauriToEngine(engine, adapter, options = {}) {
  const { autoSave = true, saveInterval = 5e3 } = options;
  const cleanupFns = [];
  if (autoSave) {
    let saveTimer = null;
    let pendingSave = false;
    const debouncedSave = async () => {
      pendingSave = true;
      if (saveTimer) clearTimeout(saveTimer);
      saveTimer = setTimeout(async () => {
        if (pendingSave) {
          await adapter.saveState(engine.getContext());
          pendingSave = false;
        }
      }, saveInterval);
    };
    cleanupFns.push(() => {
      if (saveTimer) clearTimeout(saveTimer);
    });
    void debouncedSave;
  }
  return () => {
    cleanupFns.forEach((fn) => fn());
  };
}
function generateTauriConfig(config) {
  return {
    $schema: "https://raw.githubusercontent.com/tauri-apps/tauri/tauri-v2.0.0/core/tauri-config-schema/schema.json",
    productName: config.name,
    version: config.version,
    identifier: config.identifier,
    app: {
      windows: [
        {
          title: config.window?.title || config.name,
          width: config.window?.width || 800,
          height: config.window?.height || 600,
          minWidth: config.window?.minWidth,
          minHeight: config.window?.minHeight,
          resizable: config.window?.resizable ?? true,
          fullscreen: config.window?.fullscreen ?? false,
          decorations: config.window?.decorations ?? true,
          transparent: config.window?.transparent ?? false,
          alwaysOnTop: config.window?.alwaysOnTop ?? false,
          center: config.window?.center ?? true
        }
      ],
      security: {
        csp: config.security?.csp || "default-src 'self'",
        devtools: config.security?.devTools ?? false
      }
    },
    build: {
      devUrl: "http://localhost:5173",
      frontendDist: "../dist"
    },
    plugins: Object.fromEntries((config.plugins || []).map((p) => [p.name, p.config || {}]))
  };
}

// src/integrations/unified.ts
async function createUnifiedApp(config) {
  const { createPraxisEngine: createPraxisEngine2 } = await import("./engine-YJZV4SLD.js");
  const { createInMemoryDB: createInMemoryDB2 } = await import("./adapter-TM4IS5KT.js");
  const db = config.db || createInMemoryDB2();
  const pluresdb = createPluresDBAdapter({
    db,
    registry: config.registry,
    initialContext: config.initialContext
  });
  const engine = createPraxisEngine2({
    initialContext: config.initialContext,
    registry: config.registry
  });
  pluresdb.attachEngine(engine);
  const disposers = [];
  let unum;
  let channel;
  if (config.enableUnum) {
    const fullIdentity = config.unumIdentity ? {
      ...config.unumIdentity,
      id: generateId(),
      createdAt: Date.now()
    } : void 0;
    unum = await createUnumAdapter({
      db,
      identity: fullIdentity,
      realtime: true
    });
    channel = await unum.createChannel(
      config.unumIdentity?.name || "praxis-app",
      []
    );
    const unumDisposer = attachUnumToEngine(engine, unum, channel.id);
    disposers.push(unumDisposer);
  }
  let docs;
  let generateDocs2;
  if (config.enableDocs && config.docsConfig) {
    docs = createStateDocsGenerator({
      projectTitle: config.docsConfig.projectTitle,
      target: config.docsConfig.target || "./docs"
    });
    generateDocs2 = () => {
      const module = {
        rules: config.registry.getAllRules(),
        constraints: config.registry.getAllConstraints()
      };
      return docs.generateFromModule(module);
    };
  }
  let canvas;
  if (config.schema) {
    canvas = schemaToCanvas(config.schema, { layout: "hierarchical" });
  }
  return {
    engine,
    pluresdb,
    unum,
    channel,
    docs,
    canvas,
    generateDocs: generateDocs2,
    dispose: () => {
      pluresdb.dispose();
      if (unum) {
        unum.disconnect().catch((err) => {
          console.warn("Warning: Error during Unum disconnect:", err);
        });
      }
      for (const disposer of disposers) {
        disposer();
      }
    }
  };
}
async function attachAllIntegrations(engine, registry, options = {}) {
  const { createInMemoryDB: createInMemoryDB2 } = await import("./adapter-TM4IS5KT.js");
  const db = options.db || createInMemoryDB2();
  const pluresdb = createPluresDBAdapter({
    db,
    registry,
    initialContext: engine.getContext()
  });
  pluresdb.attachEngine(engine);
  const disposers = [];
  let unum;
  let channel;
  if (options.enableUnum) {
    const fullIdentity = options.unumIdentity ? {
      ...options.unumIdentity,
      id: generateId(),
      createdAt: Date.now()
    } : void 0;
    unum = await createUnumAdapter({
      db,
      identity: fullIdentity,
      realtime: true
    });
    channel = await unum.createChannel(
      options.unumIdentity?.name || "praxis-app",
      []
    );
    const unumDisposer = attachUnumToEngine(engine, unum, channel.id);
    disposers.push(unumDisposer);
  }
  let docs;
  if (options.enableDocs && options.docsConfig) {
    docs = createStateDocsGenerator({
      projectTitle: options.docsConfig.projectTitle,
      target: options.docsConfig.target || "./docs"
    });
  }
  return {
    pluresdb,
    unum,
    channel,
    docs,
    dispose: () => {
      pluresdb.dispose();
      if (unum) {
        unum.disconnect().catch((err) => {
          console.warn("Warning: Error during Unum disconnect:", err);
        });
      }
      for (const disposer of disposers) {
        disposer();
      }
    }
  };
}
export {
  ActorManager,
  ReactiveLogicEngine2 as FrameworkAgnosticReactiveEngine,
  InMemoryPraxisDB,
  LogicEngine,
  PRAXIS_PATHS,
  PRAXIS_PROTOCOL_VERSION,
  PluresDBGenerator,
  PluresDBPraxisAdapter,
  PraxisDBStore,
  PraxisRegistry,
  PraxisSchemaRegistry,
  ReactiveLogicEngine,
  RegistryIntrospector,
  StateDocsGenerator,
  attachAllIntegrations,
  attachTauriToEngine,
  attachToEngine,
  attachUnumToEngine,
  canvasToMermaid,
  canvasToSchema,
  canvasToYaml,
  createCanvasEditor,
  createReactiveEngine2 as createFrameworkAgnosticReactiveEngine,
  createInMemoryDB,
  createIntrospector,
  createMockTauriBridge,
  createPluresDB,
  createPluresDBAdapter,
  createPluresDBGenerator,
  createPraxisDBStore,
  createPraxisEngine,
  createReactiveEngine,
  createSchema,
  createSchemaRegistry,
  createSchemaTemplate,
  createStateDocsGenerator,
  createTauriPraxisAdapter,
  createTimerActor,
  createUnifiedApp,
  createUnumAdapter,
  defineConstraint,
  defineEvent,
  defineFact,
  defineModule,
  defineRule,
  filterEvents,
  filterFacts,
  findEvent,
  findFact,
  generateDocs,
  generateId,
  generateTauriConfig,
  getEventPath,
  getFactPath,
  getSchemaPath,
  loadSchemaFromJson,
  loadSchemaFromYaml,
  registerSchema,
  schemaToCanvas,
  validateForGeneration,
  validateSchema,
  validateWithGuardian
};

import {
  ReactiveLogicEngine,
  createReactiveEngine
} from "../chunk-LE2ZJYFC.js";
import "../chunk-VOMLVI6V.js";

// src/integrations/svelte.ts
function createPraxisStore(engine) {
  let currentState = engine.getState();
  const subscribers = /* @__PURE__ */ new Set();
  const notify = () => {
    currentState = engine.getState();
    subscribers.forEach((sub) => sub(currentState));
  };
  return {
    subscribe(run) {
      subscribers.add(run);
      run(currentState);
      return () => {
        subscribers.delete(run);
      };
    },
    dispatch(events) {
      engine.step(events);
      notify();
    }
  };
}
function createContextStore(engine) {
  let currentContext = engine.getContext();
  const subscribers = /* @__PURE__ */ new Set();
  const notify = () => {
    currentContext = engine.getContext();
    subscribers.forEach((sub) => sub(currentContext));
  };
  return {
    subscribe(run) {
      subscribers.add(run);
      run(currentContext);
      return () => {
        subscribers.delete(run);
      };
    },
    dispatch(events) {
      engine.step(events);
      notify();
    }
  };
}
function createDerivedStore(engine, selector) {
  let currentValue = selector(engine.getContext());
  const subscribers = /* @__PURE__ */ new Set();
  const notify = () => {
    const newValue = selector(engine.getContext());
    if (newValue !== currentValue) {
      currentValue = newValue;
      subscribers.forEach((sub) => sub(currentValue));
    }
  };
  return {
    subscribe(run) {
      subscribers.add(run);
      run(currentValue);
      return () => {
        subscribers.delete(run);
      };
    },
    dispatch(events) {
      engine.step(events);
      notify();
    }
  };
}
function usePraxisEngine(engine, options = {}) {
  const { enableHistory = false, maxHistorySize = 50 } = options;
  let currentState = engine.getState();
  let snapshots = [];
  let historyIndex = -1;
  if (enableHistory) {
    snapshots.push({
      timestamp: Date.now(),
      state: currentState,
      events: []
    });
    historyIndex = 0;
  }
  const dispatch = (events) => {
    if (enableHistory && historyIndex < snapshots.length - 1) {
      snapshots = snapshots.slice(0, historyIndex + 1);
    }
    engine.step(events);
    currentState = engine.getState();
    if (enableHistory) {
      snapshots.push({
        timestamp: Date.now(),
        state: currentState,
        events
      });
      if (snapshots.length > maxHistorySize) {
        snapshots.shift();
      } else {
        historyIndex++;
      }
    }
  };
  const goToSnapshot = (index) => {
    if (!enableHistory) {
      console.warn("History is not enabled for this engine");
      return;
    }
    if (index < 0 || index >= snapshots.length) {
      console.warn(`Invalid snapshot index: ${index}`);
      return;
    }
    historyIndex = index;
    currentState = snapshots[index].state;
  };
  const undo = () => {
    if (historyIndex > 0) {
      goToSnapshot(historyIndex - 1);
    }
  };
  const redo = () => {
    if (historyIndex < snapshots.length - 1) {
      goToSnapshot(historyIndex + 1);
    }
  };
  return {
    get state() {
      return currentState;
    },
    get context() {
      return currentState.context;
    },
    get facts() {
      return currentState.facts;
    },
    dispatch,
    get snapshots() {
      return snapshots;
    },
    goToSnapshot,
    undo,
    redo,
    get canUndo() {
      return enableHistory && historyIndex > 0;
    },
    get canRedo() {
      return enableHistory && historyIndex < snapshots.length - 1;
    },
    get historyIndex() {
      return historyIndex;
    }
  };
}
function usePraxisContext(engine, selector) {
  let currentValue = selector(engine.getContext());
  return currentValue;
}
function usePraxisSubscription(engine, callback) {
  const store = createPraxisStore(engine);
  const unsubscribe = store.subscribe(callback);
  return unsubscribe;
}
var HistoryStateManager = class {
  history = [];
  currentIndex = -1;
  maxSize;
  idCounter = 0;
  constructor(maxSize = 50) {
    this.maxSize = maxSize;
  }
  /**
   * Record a new history entry
   */
  record(state, events, label) {
    if (this.currentIndex < this.history.length - 1) {
      this.history = this.history.slice(0, this.currentIndex + 1);
    }
    this.history.push({
      id: `history-${++this.idCounter}`,
      timestamp: Date.now(),
      state,
      events,
      label
    });
    if (this.history.length > this.maxSize) {
      this.history.shift();
    } else {
      this.currentIndex++;
    }
  }
  /**
   * Navigate to a specific history entry
   */
  goTo(index) {
    if (index < 0 || index >= this.history.length) {
      return null;
    }
    this.currentIndex = index;
    return this.history[index];
  }
  /**
   * Go back to previous state
   */
  back() {
    if (!this.canGoBack()) {
      return null;
    }
    return this.goTo(this.currentIndex - 1);
  }
  /**
   * Go forward to next state
   */
  forward() {
    if (!this.canGoForward()) {
      return null;
    }
    return this.goTo(this.currentIndex + 1);
  }
  /**
   * Check if can go back
   */
  canGoBack() {
    return this.currentIndex > 0;
  }
  /**
   * Check if can go forward
   */
  canGoForward() {
    return this.currentIndex < this.history.length - 1;
  }
  /**
   * Get current history entry
   */
  current() {
    if (this.currentIndex < 0 || this.currentIndex >= this.history.length) {
      return null;
    }
    return this.history[this.currentIndex];
  }
  /**
   * Get all history entries
   */
  getHistory() {
    return [...this.history];
  }
  /**
   * Get current index in history
   */
  getCurrentIndex() {
    return this.currentIndex;
  }
  /**
   * Clear all history
   */
  clear() {
    this.history = [];
    this.currentIndex = -1;
  }
};
function createHistoryEngine(engine, options = {}) {
  const history = new HistoryStateManager(options.maxHistorySize);
  history.record(engine.getState(), [], options.initialLabel || "Initial");
  const dispatch = (events, label) => {
    engine.step(events);
    history.record(engine.getState(), events, label);
  };
  const undo = () => {
    const entry = history.back();
    if (entry) {
      return true;
    }
    return false;
  };
  const redo = () => {
    const entry = history.forward();
    if (entry) {
      return true;
    }
    return false;
  };
  return {
    engine,
    dispatch,
    undo,
    redo,
    canUndo: () => history.canGoBack(),
    canRedo: () => history.canGoForward(),
    getHistory: () => history.getHistory(),
    goToHistory: (index) => history.goTo(index) !== null,
    clearHistory: () => history.clear()
  };
}
export {
  HistoryStateManager,
  ReactiveLogicEngine,
  createContextStore,
  createDerivedStore,
  createHistoryEngine,
  createPraxisStore,
  createReactiveEngine,
  usePraxisContext,
  usePraxisEngine,
  usePraxisSubscription
};

import { L as LogicEngine, P as PraxisState, a as PraxisEvent, b as PraxisRegistry, R as RuleDescriptor, C as ConstraintDescriptor, c as PraxisFact, d as RuleFn, e as ConstraintFn, f as PraxisModule } from './reactive-engine.svelte-C9OpcTHf.js';
export { m as ConstraintId, k as PRAXIS_PROTOCOL_VERSION, g as PraxisDiagnostics, n as PraxisEngineOptions, h as PraxisStepConfig, j as PraxisStepFn, i as PraxisStepResult, p as ReactiveEngineOptions, q as ReactiveLogicEngine, l as RuleId, o as createPraxisEngine, r as createReactiveEngine } from './reactive-engine.svelte-C9OpcTHf.js';

/**
 * Praxis Reactive Logic Engine
 *
 * A framework-agnostic reactive implementation of the Praxis Logic Engine.
 * Uses JavaScript Proxies to provide reactivity without Svelte-specific primitives.
 *
 * This implementation provides:
 * - Proxy-based state tracking for automatic reactivity
 * - Subscription-based change notifications
 * - Computed/derived values support
 * - Compatible API with Svelte-based implementation
 */
interface ReactiveEngineOptions<TContext> {
    initialContext: TContext;
    initialFacts?: any[];
    initialMeta?: Record<string, unknown>;
}
/**
 * Callback type for state change subscribers
 */
type StateChangeCallback<TContext> = (state: {
    context: TContext;
    facts: any[];
    meta: Record<string, unknown>;
}) => void;
/**
 * Callback type for unsubscribe function
 */
type UnsubscribeFn$1 = () => void;
/**
 * Framework-agnostic reactive logic engine using JavaScript Proxies
 */
declare class ReactiveLogicEngine<TContext extends object> {
    private _state;
    private _subscribers;
    private _contextProxy;
    private _factsProxy;
    private _metaProxy;
    private _batchDepth;
    private _pendingNotification;
    private _proxyCache;
    private static readonly ARRAY_MUTATORS;
    constructor(options: ReactiveEngineOptions<TContext>);
    /**
     * Create a reactive proxy that notifies subscribers on changes.
     * Uses a WeakMap cache to avoid creating multiple proxies for the same object.
     */
    private _createReactiveProxy;
    /**
     * Notify all subscribers of state changes
     */
    private _notify;
    /**
     * Get the full state object
     */
    get state(): {
        context: TContext;
        facts: any[];
        meta: Record<string, unknown>;
    };
    /**
     * Access the reactive context.
     * Changes to this object will trigger subscriber notifications.
     */
    get context(): TContext;
    /**
     * Access the reactive facts list.
     * Changes to this array will trigger subscriber notifications.
     */
    get facts(): any[];
    /**
     * Access the reactive metadata.
     * Changes to this object will trigger subscriber notifications.
     */
    get meta(): Record<string, unknown>;
    /**
     * Apply a mutation to the state.
     * This is the "Action" or "Rule" equivalent.
     * Mutations are batched - notifications only happen once per apply call.
     *
     * @param mutator A function that receives the state and modifies it.
     */
    apply(mutator: (state: {
        context: TContext;
        facts: any[];
        meta: Record<string, unknown>;
    }) => void): void;
    /**
     * Subscribe to state changes.
     * Returns an unsubscribe function.
     *
     * @param callback Function to call when state changes
     * @returns Unsubscribe function
     */
    subscribe(callback: StateChangeCallback<TContext>): UnsubscribeFn$1;
    /**
     * Create a derived/computed value from the state.
     * The selector function will be called whenever the state changes.
     *
     * @param selector Function to extract derived value from state
     * @returns Object with subscribe method for reactive updates
     */
    $derived<TDerived>(selector: (state: {
        context: TContext;
        facts: any[];
        meta: Record<string, unknown>;
    }) => TDerived): {
        subscribe: (callback: (value: TDerived) => void) => UnsubscribeFn$1;
    };
}
/**
 * Create a new reactive logic engine instance.
 *
 * @param options Configuration options for the reactive engine
 * @returns A new ReactiveLogicEngine instance
 *
 * @example
 * ```typescript
 * const engine = createReactiveEngine({
 *   initialContext: { count: 0 },
 *   initialFacts: [],
 *   initialMeta: {}
 * });
 *
 * // Subscribe to changes
 * engine.subscribe((state) => {
 *   console.log('State changed:', state);
 * });
 *
 * // Mutate state (will trigger subscribers)
 * engine.apply((state) => {
 *   state.context.count++;
 * });
 * ```
 */
declare function createReactiveEngine<TContext extends object>(options: ReactiveEngineOptions<TContext>): ReactiveLogicEngine<TContext>;

/**
 * Actors System
 *
 * Actors are effectful units that:
 * - Observe Praxis logic state
 * - Perform side effects (network I/O, database operations, timers, etc.)
 * - Feed new events/facts back into the engine
 *
 * Actors provide the bridge between pure logic and the effectful world.
 */

/**
 * Actor interface
 *
 * An actor observes state changes and can:
 * - React to state changes (onStateChange)
 * - Perform initialization (onStart)
 * - Perform cleanup (onStop)
 */
interface Actor<TContext = unknown> {
    /** Unique identifier for the actor */
    id: string;
    /** Human-readable description */
    description: string;
    /** Called when the actor is started */
    onStart?: (engine: LogicEngine<TContext>) => void | Promise<void>;
    /** Called when state changes */
    onStateChange?: (state: Readonly<PraxisState & {
        context: TContext;
    }>, engine: LogicEngine<TContext>) => void | Promise<void>;
    /** Called when the actor is stopped */
    onStop?: () => void | Promise<void>;
}
/**
 * Actor manager
 *
 * Manages the lifecycle of actors and coordinates their interaction with the engine.
 */
declare class ActorManager<TContext = unknown> {
    private actors;
    private activeActors;
    private engine;
    /**
     * Register an actor
     */
    register(actor: Actor<TContext>): void;
    /**
     * Unregister an actor
     */
    unregister(actorId: string): void;
    /**
     * Attach the actor manager to an engine
     */
    attachEngine(engine: LogicEngine<TContext>): void;
    /**
     * Start an actor
     */
    start(actorId: string): Promise<void>;
    /**
     * Stop an actor
     */
    stop(actorId: string): Promise<void>;
    /**
     * Start all registered actors
     */
    startAll(): Promise<void>;
    /**
     * Stop all active actors
     */
    stopAll(): Promise<void>;
    /**
     * Notify active actors of a state change
     */
    notifyStateChange(state: Readonly<PraxisState & {
        context: TContext;
    }>): Promise<void>;
    /**
     * Get all registered actor IDs
     */
    getActorIds(): string[];
    /**
     * Get all active actor IDs
     */
    getActiveActorIds(): string[];
    /**
     * Check if an actor is active
     */
    isActive(actorId: string): boolean;
}
/**
 * Helper to create a simple actor that dispatches events on a timer
 */
declare function createTimerActor<TContext = unknown>(id: string, intervalMs: number, createEvent: () => PraxisEvent): Actor<TContext>;

/**
 * Introspection and Visualization Utilities
 *
 * Provides APIs to introspect the registry, generate schemas,
 * and export graph representations for external tools.
 */

/**
 * Graph node representing a rule in the system
 */
interface RuleNode {
    id: string;
    type: 'rule';
    description: string;
    meta?: Record<string, unknown>;
}
/**
 * Graph node representing a constraint in the system
 */
interface ConstraintNode {
    id: string;
    type: 'constraint';
    description: string;
    meta?: Record<string, unknown>;
}
/**
 * Graph edge representing a dependency or relationship
 */
interface GraphEdge {
    from: string;
    to: string;
    type: 'triggers' | 'constrains' | 'depends-on';
}
/**
 * Complete graph representation of the registry
 */
interface RegistryGraph {
    nodes: (RuleNode | ConstraintNode)[];
    edges: GraphEdge[];
    meta: {
        nodeCount: number;
        ruleCount: number;
        constraintCount: number;
    };
}
/**
 * JSON Schema-like representation of a rule
 */
interface RuleSchema {
    id: string;
    description: string;
    type: 'rule';
    meta?: Record<string, unknown>;
}
/**
 * JSON Schema-like representation of a constraint
 */
interface ConstraintSchema {
    id: string;
    description: string;
    type: 'constraint';
    meta?: Record<string, unknown>;
}
/**
 * Complete registry schema
 */
interface RegistrySchema {
    protocolVersion: string;
    rules: RuleSchema[];
    constraints: ConstraintSchema[];
    meta: {
        ruleCount: number;
        constraintCount: number;
    };
}
/**
 * Statistics about the registry
 */
interface RegistryStats {
    ruleCount: number;
    constraintCount: number;
    moduleCount: number;
    rulesById: string[];
    constraintsById: string[];
}
/**
 * Introspection utilities for a Praxis registry
 */
declare class RegistryIntrospector<TContext = unknown> {
    private registry;
    constructor(registry: PraxisRegistry<TContext>);
    /**
     * Get basic statistics about the registry
     */
    getStats(): RegistryStats;
    /**
     * Generate a JSON schema representation of the registry
     */
    generateSchema(protocolVersion: string): RegistrySchema;
    /**
     * Generate a graph representation of the registry
     *
     * This creates nodes for rules and constraints.
     * Edges can be inferred from metadata if rules/constraints
     * document their dependencies.
     */
    generateGraph(): RegistryGraph;
    /**
     * Export graph in DOT format (Graphviz)
     *
     * This can be rendered with Graphviz tools or online services.
     */
    exportDOT(): string;
    /**
     * Export graph in Mermaid format
     *
     * Mermaid is a markdown-friendly diagramming language.
     */
    exportMermaid(): string;
    /**
     * Get detailed information about a specific rule
     */
    getRuleInfo(ruleId: string): RuleDescriptor<TContext> | undefined;
    /**
     * Get detailed information about a specific constraint
     */
    getConstraintInfo(constraintId: string): ConstraintDescriptor<TContext> | undefined;
    /**
     * Search for rules by description text
     */
    searchRules(query: string): RuleDescriptor<TContext>[];
    /**
     * Search for constraints by description text
     */
    searchConstraints(query: string): ConstraintDescriptor<TContext>[];
}
/**
 * Create a registry introspector
 */
declare function createIntrospector<TContext = unknown>(registry: PraxisRegistry<TContext>): RegistryIntrospector<TContext>;

/**
 * DSL Helpers
 *
 * Ergonomic TypeScript helpers for defining facts, events, rules, constraints, and flows.
 * These produce both strongly-typed APIs and serializable descriptors.
 */

/**
 * Strongly typed fact definition
 */
interface FactDefinition$1<TTag extends string, TPayload> {
    tag: TTag;
    create(payload: TPayload): PraxisFact & {
        tag: TTag;
        payload: TPayload;
    };
    is(fact: PraxisFact): fact is PraxisFact & {
        tag: TTag;
        payload: TPayload;
    };
}
/**
 * Define a typed fact
 *
 * @example
 * const UserLoggedIn = defineFact<"UserLoggedIn", { userId: string }>("UserLoggedIn");
 * const fact = UserLoggedIn.create({ userId: "123" });
 * if (UserLoggedIn.is(fact)) {
 *   console.log(fact.payload.userId); // Type-safe!
 * }
 */
declare function defineFact<TTag extends string, TPayload>(tag: TTag): FactDefinition$1<TTag, TPayload>;
/**
 * Strongly typed event definition
 */
interface EventDefinition$1<TTag extends string, TPayload> {
    tag: TTag;
    create(payload: TPayload): PraxisEvent & {
        tag: TTag;
        payload: TPayload;
    };
    is(event: PraxisEvent): event is PraxisEvent & {
        tag: TTag;
        payload: TPayload;
    };
}
/**
 * Define a typed event
 *
 * @example
 * const Login = defineEvent<"LOGIN", { username: string; password: string }>("LOGIN");
 * const event = Login.create({ username: "alice", password: "secret" });
 */
declare function defineEvent<TTag extends string, TPayload>(tag: TTag): EventDefinition$1<TTag, TPayload>;
/**
 * Options for defining a rule
 */
interface DefineRuleOptions<TContext = unknown> {
    id: string;
    description: string;
    impl: RuleFn<TContext>;
    meta?: Record<string, unknown>;
}
/**
 * Define a rule
 *
 * @example
 * const loginRule = defineRule({
 *   id: "auth.login",
 *   description: "Process login event",
 *   impl: (state, events) => {
 *     const loginEvent = events.find(Login.is);
 *     if (loginEvent) {
 *       return [UserLoggedIn.create({ userId: loginEvent.payload.username })];
 *     }
 *     return [];
 *   }
 * });
 */
declare function defineRule<TContext = unknown>(options: DefineRuleOptions<TContext>): RuleDescriptor<TContext>;
/**
 * Options for defining a constraint
 */
interface DefineConstraintOptions<TContext = unknown> {
    id: string;
    description: string;
    impl: ConstraintFn<TContext>;
    meta?: Record<string, unknown>;
}
/**
 * Define a constraint
 *
 * @example
 * const maxCartItems = defineConstraint({
 *   id: "cart.maxItems",
 *   description: "Cart cannot exceed 100 items",
 *   impl: (state) => {
 *     const itemCount = state.context.items?.length ?? 0;
 *     return itemCount <= 100 || `Cart has ${itemCount} items, maximum is 100`;
 *   }
 * });
 */
declare function defineConstraint<TContext = unknown>(options: DefineConstraintOptions<TContext>): ConstraintDescriptor<TContext>;
/**
 * Options for defining a module
 */
interface DefineModuleOptions<TContext = unknown> {
    rules?: RuleDescriptor<TContext>[];
    constraints?: ConstraintDescriptor<TContext>[];
    meta?: Record<string, unknown>;
}
/**
 * Define a module (bundle of rules and constraints)
 *
 * @example
 * const authModule = defineModule({
 *   rules: [loginRule, logoutRule],
 *   constraints: [maxSessionsConstraint],
 *   meta: { version: "1.0.0" }
 * });
 */
declare function defineModule<TContext = unknown>(options: DefineModuleOptions<TContext>): PraxisModule<TContext>;
/**
 * Helper to filter events by definition
 */
declare function filterEvents<TTag extends string, TPayload>(events: PraxisEvent[], definition: EventDefinition$1<TTag, TPayload>): Array<PraxisEvent & {
    tag: TTag;
    payload: TPayload;
}>;
/**
 * Helper to filter facts by definition
 */
declare function filterFacts<TTag extends string, TPayload>(facts: PraxisFact[], definition: FactDefinition$1<TTag, TPayload>): Array<PraxisFact & {
    tag: TTag;
    payload: TPayload;
}>;
/**
 * Helper to find first event matching definition
 */
declare function findEvent<TTag extends string, TPayload>(events: PraxisEvent[], definition: EventDefinition$1<TTag, TPayload>): (PraxisEvent & {
    tag: TTag;
    payload: TPayload;
}) | undefined;
/**
 * Helper to find first fact matching definition
 */
declare function findFact<TTag extends string, TPayload>(facts: PraxisFact[], definition: FactDefinition$1<TTag, TPayload>): (PraxisFact & {
    tag: TTag;
    payload: TPayload;
}) | undefined;

/**
 * Praxis Schema System
 *
 * Declarative schema definitions for generating models, components, logic, and documentation.
 */
/**
 * Base schema definition
 */
interface PraxisSchema {
    /** Schema version (semver) */
    version: string;
    /** Schema name/identifier */
    name: string;
    /** Human-readable description */
    description?: string;
    /** Data models */
    models?: ModelDefinition[];
    /** UI components */
    components?: ComponentDefinition[];
    /** Logic definitions */
    logic?: LogicDefinition[];
    /** Orchestration configuration */
    orchestration?: OrchestrationDefinition;
    /** Additional metadata */
    metadata?: Record<string, unknown>;
}
/**
 * Model definition for data structures
 */
interface ModelDefinition {
    /** Model name */
    name: string;
    /** Model description */
    description?: string;
    /** Model fields */
    fields: FieldDefinition[];
    /** Validation constraints */
    constraints?: ConstraintDefinition[];
    /** Indexes for queries */
    indexes?: IndexDefinition[];
    /** Relationships to other models */
    relationships?: RelationshipDefinition[];
}
/**
 * Field definition within a model
 */
interface FieldDefinition {
    /** Field name */
    name: string;
    /** Field type */
    type: FieldType;
    /** Optional field */
    optional?: boolean;
    /** Default value */
    default?: unknown;
    /** Field description */
    description?: string;
    /** Validation rules */
    validation?: ValidationRule[];
}
/**
 * Supported field types
 */
type FieldType = 'string' | 'number' | 'boolean' | 'date' | 'array' | 'object' | 'reference' | {
    array: FieldType;
} | {
    object: Record<string, FieldDefinition>;
} | {
    reference: string;
};
/**
 * Validation rule for a field
 */
interface ValidationRule {
    /** Validation type */
    type: 'required' | 'min' | 'max' | 'pattern' | 'custom';
    /** Validation value */
    value?: unknown;
    /** Error message */
    message?: string;
}
/**
 * Constraint definition for models
 */
interface ConstraintDefinition {
    /** Constraint identifier */
    id: string;
    /** Constraint description */
    description: string;
    /** Constraint type */
    type: 'unique' | 'check' | 'foreign_key';
    /** Constraint fields */
    fields: string[];
    /** Additional constraint options */
    options?: Record<string, unknown>;
}
/**
 * Index definition for queries
 */
interface IndexDefinition {
    /** Index name */
    name: string;
    /** Indexed fields */
    fields: string[];
    /** Unique index */
    unique?: boolean;
    /** Index type */
    type?: 'btree' | 'hash' | 'fulltext';
}
/**
 * Relationship definition between models
 */
interface RelationshipDefinition {
    /** Relationship name */
    name: string;
    /** Relationship type */
    type: 'one-to-one' | 'one-to-many' | 'many-to-many';
    /** Target model */
    target: string;
    /** Foreign key field */
    foreignKey?: string;
    /** Cascade delete */
    cascadeDelete?: boolean;
}
/**
 * Component definition for UI
 */
interface ComponentDefinition {
    /** Component name */
    name: string;
    /** Component type */
    type: 'form' | 'display' | 'list' | 'navigation' | 'custom';
    /** Component description */
    description?: string;
    /** Model binding */
    model?: string;
    /** Component properties */
    props?: ComponentProp[];
    /** Component events */
    events?: ComponentEvent[];
    /** Component layout */
    layout?: LayoutDefinition;
    /** Component styling */
    styling?: StylingDefinition;
}
/**
 * Component property definition
 */
interface ComponentProp {
    /** Property name */
    name: string;
    /** Property type */
    type: string;
    /** Required property */
    required?: boolean;
    /** Default value */
    default?: unknown;
    /** Property description */
    description?: string;
}
/**
 * Component event definition
 */
interface ComponentEvent {
    /** Event name */
    name: string;
    /** Event payload type */
    payload?: string;
    /** Event description */
    description?: string;
}
/**
 * Layout definition for components
 */
interface LayoutDefinition {
    /** Layout type */
    type: 'stack' | 'grid' | 'flex' | 'absolute';
    /** Layout direction */
    direction?: 'horizontal' | 'vertical';
    /** Layout gap */
    gap?: number;
    /** Layout padding */
    padding?: number;
    /** Layout alignment */
    alignment?: string;
}
/**
 * Styling definition for components
 */
interface StylingDefinition {
    /** CSS classes */
    classes?: string[];
    /** Inline styles */
    styles?: Record<string, string>;
    /** Theme tokens */
    theme?: Record<string, string>;
}
/**
 * Logic definition for business rules
 */
interface LogicDefinition {
    /** Logic identifier */
    id: string;
    /** Logic description */
    description: string;
    /** Facts definitions */
    facts?: FactDefinition[];
    /** Events definitions */
    events?: EventDefinition[];
    /** Rules definitions */
    rules?: RuleDefinition[];
    /** Constraints definitions */
    constraints?: LogicConstraint[];
}
/**
 * Fact definition
 */
interface FactDefinition {
    /** Fact tag */
    tag: string;
    /** Fact payload type */
    payload: Record<string, string>;
    /** Fact description */
    description?: string;
}
/**
 * Event definition
 */
interface EventDefinition {
    /** Event tag */
    tag: string;
    /** Event payload type */
    payload: Record<string, string>;
    /** Event description */
    description?: string;
}
/**
 * Rule definition
 */
interface RuleDefinition {
    /** Rule identifier */
    id: string;
    /** Rule description */
    description: string;
    /** Input events */
    on?: string[];
    /** Rule condition */
    when?: string;
    /** Rule action */
    then: string;
    /** Rule priority */
    priority?: number;
}
/**
 * Logic constraint definition
 */
interface LogicConstraint {
    /** Constraint identifier */
    id: string;
    /** Constraint description */
    description: string;
    /** Constraint check */
    check: string;
    /** Error message */
    message: string;
}
/**
 * Orchestration definition
 */
interface OrchestrationDefinition {
    /** Orchestration type */
    type: 'dsc' | 'mcp' | 'custom';
    /** Node configurations */
    nodes?: NodeDefinition[];
    /** State synchronization */
    sync?: SyncDefinition;
    /** Health checks */
    health?: HealthDefinition;
}
/**
 * Node definition for orchestration
 */
interface NodeDefinition {
    /** Node identifier */
    id: string;
    /** Node type */
    type: string;
    /** Node configuration */
    config: Record<string, unknown>;
    /** Node position (x, y coordinates for canvas) */
    x?: number;
    y?: number;
    /** Node props (type-specific properties) */
    props?: Record<string, unknown>;
    /** Node bindings (connections to pluresdb paths) */
    bindings?: NodeBindings;
}
/**
 * Node bindings for pluresdb path connections
 */
interface NodeBindings {
    /** Output binding to pluresdb path */
    output?: string;
    /** Input binding to pluresdb path */
    input?: string;
    /** Additional custom bindings */
    [key: string]: string | undefined;
}
/**
 * Terminal node specific configuration
 */
interface TerminalNodeProps {
    /** Input mode: text input or widget-based */
    inputMode: 'text' | 'widget';
    /** Command history */
    history: string[];
    /** Last command output */
    lastOutput: string | null;
}
/**
 * Sync definition for state synchronization
 */
interface SyncDefinition {
    /** Sync interval in ms */
    interval: number;
    /** Conflict resolution strategy */
    conflictResolution: 'last-write-wins' | 'merge' | 'custom';
    /** Sync targets */
    targets: string[];
}
/**
 * Health check definition
 */
interface HealthDefinition {
    /** Check interval in ms */
    interval: number;
    /** Health check endpoints */
    endpoints: string[];
    /** Timeout in ms */
    timeout: number;
}
/**
 * Schema validation result
 */
interface ValidationResult {
    /** Validation success */
    valid: boolean;
    /** Validation errors */
    errors: ValidationError[];
}
/**
 * Validation error
 */
interface ValidationError {
    /** Error path in schema */
    path: string;
    /** Error message */
    message: string;
    /** Error code */
    code?: string;
}
/**
 * Validate a Praxis schema
 */
declare function validateSchema(schema: PraxisSchema): ValidationResult;
/**
 * Create a basic schema template
 */
declare function createSchemaTemplate(name: string): PraxisSchema;

/**
 * Praxis Schema Loader (Common/Browser Compatible)
 *
 * Core schema loading and validation functions that don't depend on Node.js APIs.
 */

/**
 * Loader options
 */
interface LoaderOptions {
    /** Validate schema after loading */
    validate?: boolean;
    /** Base directory for resolving relative paths */
    baseDir?: string;
}
/**
 * Loader result
 */
interface LoaderResult {
    /** Loaded schema */
    schema?: PraxisSchema;
    /** Validation result */
    validation?: ValidationResult;
    /** Load errors */
    errors: string[];
}
/**
 * Create a new empty schema
 */
declare function createSchema(name: string): PraxisSchema;
/**
 * Load schema from JSON string
 */
declare function loadSchemaFromJson(json: string, options?: LoaderOptions): LoaderResult;
/**
 * Load schema from YAML string
 */
declare function loadSchemaFromYaml(yaml: string, options?: LoaderOptions): LoaderResult;
/**
 * Validate that a loaded schema has required fields for generation
 */
declare function validateForGeneration(schema: PraxisSchema): ValidationResult;

/**
 * PraxisDB Adapter
 *
 * Provides a minimal adapter layer for PluresDB integration.
 * This module defines the core interface and an in-memory implementation.
 */
/**
 * Function to unsubscribe from a watch
 */
type UnsubscribeFn = () => void;
/**
 * Core database interface for Praxis
 *
 * Provides a minimal API for get/set/watch operations.
 * Can be backed by in-memory storage or PluresDB.
 */
interface PraxisDB {
    /**
     * Get a value by key
     * @param key The key to retrieve
     * @returns The value or undefined if not found
     */
    get<T>(key: string): Promise<T | undefined>;
    /**
     * Set a value by key
     * @param key The key to set
     * @param value The value to store
     */
    set<T>(key: string, value: T): Promise<void>;
    /**
     * Watch a key for changes
     * @param key The key to watch
     * @param callback Called when the value changes
     * @returns Function to unsubscribe from updates
     */
    watch<T>(key: string, callback: (val: T) => void): UnsubscribeFn;
}
/**
 * In-memory implementation of PraxisDB
 *
 * Provides a simple in-memory store for development and testing.
 * Suitable for proxying to PluresDB later.
 */
declare class InMemoryPraxisDB implements PraxisDB {
    private store;
    private watchers;
    get<T>(key: string): Promise<T | undefined>;
    set<T>(key: string, value: T): Promise<void>;
    watch<T>(key: string, callback: (val: T) => void): UnsubscribeFn;
    /**
     * Get all keys (for testing/debugging)
     */
    keys(): string[];
    /**
     * Clear all data (for testing)
     */
    clear(): void;
}
/**
 * Create a new in-memory PraxisDB instance
 *
 * @returns InMemoryPraxisDB instance
 *
 * @example
 * ```typescript
 * const db = createInMemoryDB();
 * await db.set('user:1', { name: 'Alice' });
 * const user = await db.get('user:1');
 * ```
 */
declare function createInMemoryDB(): InMemoryPraxisDB;
/**
 * PluresDB instance type - represents either PluresNode or SQLiteCompatibleAPI
 */
type PluresDBInstance = {
    get(key: string): Promise<any>;
    put(key: string, value: any): Promise<void>;
};
/**
 * Configuration options for PluresDBPraxisAdapter
 */
interface PluresDBAdapterConfig {
    /** PluresDB instance */
    db: PluresDBInstance;
    /** Polling interval in milliseconds for watch functionality (default: 1000ms) */
    pollInterval?: number;
}
/**
 * PluresDB-backed implementation of PraxisDB
 *
 * Wraps the official PluresDB package from NPM to provide
 * the PraxisDB interface for production use.
 */
declare class PluresDBPraxisAdapter implements PraxisDB {
    private db;
    private watchers;
    private pollIntervals;
    private lastValues;
    private pollInterval;
    constructor(config: PluresDBAdapterConfig | PluresDBInstance);
    get<T>(key: string): Promise<T | undefined>;
    set<T>(key: string, value: T): Promise<void>;
    watch<T>(key: string, callback: (val: T) => void): UnsubscribeFn;
    /**
     * Clean up all resources
     */
    dispose(): void;
}
/**
 * Create a PluresDB-backed PraxisDB instance
 *
 * Wraps the official PluresDB package from NPM.
 *
 * @param config PluresDB instance or configuration object
 * @returns PluresDBPraxisAdapter instance
 *
 * @example
 * ```typescript
 * import { PluresNode } from 'pluresdb';
 * import { createPluresDB } from '@plures/praxis';
 *
 * const pluresdb = new PluresNode({ autoStart: true });
 * const db = createPluresDB(pluresdb);
 *
 * await db.set('user:1', { name: 'Alice' });
 * const user = await db.get('user:1');
 * ```
 *
 * @example
 * ```typescript
 * // With custom polling interval
 * const db = createPluresDB({
 *   db: pluresdb,
 *   pollInterval: 500, // Poll every 500ms
 * });
 * ```
 */
declare function createPluresDB(config: PluresDBAdapterConfig | PluresDBInstance): PluresDBPraxisAdapter;

/**
 * PraxisDB Store
 *
 * Connects Praxis Facts, Events, Rules, and Constraints to PluresDB.
 * Provides CRDT-backed storage for facts and append-only event streams.
 */

/**
 * Key paths for Praxis data in PluresDB
 */
declare const PRAXIS_PATHS: {
    /** Base path for all Praxis data */
    readonly BASE: "/_praxis";
    /** Path for facts storage */
    readonly FACTS: "/_praxis/facts";
    /** Path for events storage */
    readonly EVENTS: "/_praxis/events";
    /** Path for schema registry */
    readonly SCHEMAS: "/_praxis/schemas";
};
/**
 * Generate a fact key path
 * @param factTag The fact type tag
 * @param id Optional unique identifier for the fact instance
 */
declare function getFactPath(factTag: string, id?: string): string;
/**
 * Generate an event stream key path
 * @param eventTag The event type tag
 */
declare function getEventPath(eventTag: string): string;
/**
 * Generate a unique ID for facts or events
 * Uses timestamp and random string for uniqueness
 */
declare function generateId(): string;
/**
 * Event stream entry with timestamp
 */
interface EventStreamEntry {
    /** The event data */
    event: PraxisEvent;
    /** Timestamp when the event was appended */
    timestamp: number;
    /** Optional sequence number */
    sequence?: number;
}
/**
 * Options for creating a PraxisDBStore
 */
interface PraxisDBStoreOptions<TContext = unknown> {
    /** The PraxisDB instance to use */
    db: PraxisDB;
    /** The PraxisRegistry for rules and constraints */
    registry: PraxisRegistry<TContext>;
    /** Initial context for rule evaluation */
    initialContext?: TContext;
}
/**
 * PraxisDBStore
 *
 * Manages persistence and reactive updates for Praxis state in PluresDB.
 *
 * - Facts are stored as CRDT-backed documents under `/_praxis/facts/<factTag>/<id>`
 * - Events are stored as append-only streams under `/_praxis/events/<eventTag>`
 * - Rules are triggered automatically when watched keys change
 * - Constraints are run before writing mutated state
 */
/**
 * Error handler callback for rule execution errors
 */
type RuleErrorHandler = (ruleId: string, error: unknown) => void;
declare class PraxisDBStore<TContext = unknown> {
    private db;
    private registry;
    private context;
    private subscriptions;
    private factWatchers;
    private onRuleError;
    constructor(options: PraxisDBStoreOptions<TContext> & {
        onRuleError?: RuleErrorHandler;
    });
    /**
     * Store a fact in PluresDB
     *
     * Facts are stored under `/_praxis/facts/<factTag>/<id>`
     * If no id is provided in the payload, a timestamp-based id is used.
     *
     * @param fact The fact to store
     * @returns Promise that resolves when the fact is stored
     */
    storeFact(fact: PraxisFact): Promise<void>;
    /**
     * Store multiple facts in PluresDB
     *
     * @param facts The facts to store
     */
    storeFacts(facts: PraxisFact[]): Promise<void>;
    /**
     * Internal method to persist a fact without constraint checking
     * Used by both storeFact and derived fact storage
     */
    private persistFact;
    /**
     * Get a fact by tag and id
     *
     * @param factTag The fact type tag
     * @param id The fact id
     * @returns The fact or undefined if not found
     */
    getFact(factTag: string, id: string): Promise<PraxisFact | undefined>;
    /**
     * Append an event to the event stream
     *
     * Events are stored as append-only streams under `/_praxis/events/<eventTag>`
     *
     * @param event The event to append
     */
    appendEvent(event: PraxisEvent): Promise<void>;
    /**
     * Append multiple events to their respective streams
     *
     * @param events The events to append
     */
    appendEvents(events: PraxisEvent[]): Promise<void>;
    /**
     * Get events from a stream
     *
     * @param eventTag The event type tag
     * @param options Query options
     * @returns Array of event stream entries
     */
    getEvents(eventTag: string, options?: {
        since?: number;
        limit?: number;
    }): Promise<EventStreamEntry[]>;
    /**
     * Watch a fact path for changes
     *
     * @param factTag The fact type tag to watch
     * @param callback Called when facts of this type change
     * @returns Unsubscribe function
     */
    watchFacts(factTag: string, callback: (facts: PraxisFact[]) => void): UnsubscribeFn;
    /**
     * Check constraints against the current state with new facts
     */
    private checkConstraints;
    /**
     * Trigger rules when new facts are added
     *
     * This method is called after facts are stored. It can be extended
     * for derived fact computation where rules generate new facts based
     * on existing facts. Currently implemented as a hook point for future
     * enhancements.
     *
     * @param _newFacts The newly stored facts (unused in current implementation)
     */
    private triggerRules;
    /**
     * Trigger rules when events are appended
     */
    private triggerRulesForEvents;
    /**
     * Update the context
     */
    updateContext(context: TContext): void;
    /**
     * Get the current context
     */
    getContext(): TContext;
    /**
     * Dispose of all subscriptions
     */
    dispose(): void;
}
/**
 * Create a new PraxisDBStore
 *
 * @param db The PraxisDB instance to use
 * @param registry The PraxisRegistry for rules and constraints
 * @param initialContext Optional initial context
 * @param onRuleError Optional error handler for rule execution errors
 * @returns PraxisDBStore instance
 *
 * @example
 * ```typescript
 * const db = createInMemoryDB();
 * const registry = new PraxisRegistry();
 * const store = createPraxisDBStore(db, registry);
 *
 * await store.storeFact({ tag: "UserLoggedIn", payload: { userId: "alice" } });
 * await store.appendEvent({ tag: "LOGIN", payload: { username: "alice" } });
 * ```
 */
declare function createPraxisDBStore<TContext = unknown>(db: PraxisDB, registry: PraxisRegistry<TContext>, initialContext?: TContext, onRuleError?: RuleErrorHandler): PraxisDBStore<TContext>;

/**
 * Praxis Schema Registry for PluresDB
 *
 * Registers Praxis schema definitions in PluresDB for type-safe storage
 * and cross-agent schema discovery.
 */

/**
 * Get the path for a schema in PluresDB
 * @param schemaName The schema name
 */
declare function getSchemaPath(schemaName: string): string;
/**
 * Stored schema entry with metadata
 */
interface StoredSchema {
    /** The schema definition */
    schema: PraxisSchema;
    /** When the schema was registered */
    registeredAt: number;
    /** Schema version */
    version: string;
}
/**
 * PraxisSchemaRegistry
 *
 * Manages schema definitions in PluresDB.
 * Schemas are stored under `/_praxis/schemas/<schemaName>`
 */
declare class PraxisSchemaRegistry {
    private db;
    constructor(db: PraxisDB);
    /**
     * Register a schema in PluresDB
     *
     * @param schema The schema to register
     */
    register(schema: PraxisSchema): Promise<void>;
    /**
     * Get a schema by name
     *
     * @param schemaName The schema name
     * @returns The stored schema or undefined if not found
     */
    get(schemaName: string): Promise<StoredSchema | undefined>;
    /**
     * Check if a schema is registered
     *
     * @param schemaName The schema name
     * @returns True if the schema exists
     */
    exists(schemaName: string): Promise<boolean>;
    /**
     * Update a schema (replaces existing)
     *
     * @param schema The updated schema
     */
    update(schema: PraxisSchema): Promise<void>;
    /**
     * List all registered schema names
     *
     * Implementation note: This method uses an index stored at `/_praxis/schemas/_index`.
     * When using InMemoryPraxisDB, schemas must be registered using `registerWithIndex()`
     * for them to appear in this listing. When using a full PluresDB implementation,
     * native listing capabilities should be used instead.
     *
     * @returns Array of registered schema names
     */
    list(): Promise<string[]>;
    /**
     * Register a schema and update the index
     *
     * @param schema The schema to register
     */
    registerWithIndex(schema: PraxisSchema): Promise<void>;
}
/**
 * Register a schema in PluresDB
 *
 * Convenience function for one-off schema registration.
 *
 * @param db The PraxisDB instance
 * @param schema The schema to register
 *
 * @example
 * ```typescript
 * const db = createInMemoryDB();
 * await registerSchema(db, {
 *   version: "1.0.0",
 *   name: "MyApp",
 *   description: "My application schema"
 * });
 * ```
 */
declare function registerSchema(db: PraxisDB, schema: PraxisSchema): Promise<void>;
/**
 * Create a PraxisSchemaRegistry instance
 *
 * @param db The PraxisDB instance
 * @returns PraxisSchemaRegistry instance
 */
declare function createSchemaRegistry(db: PraxisDB): PraxisSchemaRegistry;

/**
 * Praxis Schema Normalizer
 *
 * Expands and normalizes schema definitions for code generation.
 */

/**
 * Normalized schema with expanded and validated definitions
 */
interface NormalizedSchema extends PraxisSchema {
    /** Normalized models with expanded references */
    models: NormalizedModel[];
    /** Normalized components */
    components: NormalizedComponent[];
    /** Normalized logic */
    logic: NormalizedLogic[];
}
/**
 * Normalized model definition
 */
interface NormalizedModel extends ModelDefinition {
    /** Fully qualified name */
    fullName: string;
    /** All fields including inherited ones */
    allFields: FieldDefinition[];
    /** Model dependencies */
    dependencies: string[];
}
/**
 * Normalized component definition
 */
interface NormalizedComponent extends ComponentDefinition {
    /** Fully qualified name */
    fullName: string;
    /** Resolved model reference */
    resolvedModel?: NormalizedModel;
}
/**
 * Normalized logic definition
 */
interface NormalizedLogic extends LogicDefinition {
    /** Fully qualified identifier */
    fullId: string;
}

/**
 * PluresDB Config Generator
 *
 * Generates PluresDB configuration from schema definitions.
 */

/**
 * PluresDB config generation options
 */
interface PluresDBGeneratorOptions {
    /** Output directory */
    outputDir: string;
    /** Database name */
    dbName?: string;
    /** Database version */
    dbVersion?: number;
    /** Enable sync */
    enableSync?: boolean;
    /** Sync endpoint */
    syncEndpoint?: string;
    /** Auto-index strategy: 'all' indexes all string/number/date fields, 'explicit' only indexes fields defined in schema, 'none' disables auto-indexing */
    autoIndex?: 'all' | 'explicit' | 'none';
}
/**
 * Generated PluresDB config file
 */
interface GeneratedPluresDBFile {
    /** File path */
    path: string;
    /** File content */
    content: string;
    /** File type */
    type: 'config' | 'types';
}
/**
 * PluresDB generator class
 */
declare class PluresDBGenerator {
    private options;
    constructor(options: PluresDBGeneratorOptions);
    /**
     * Generate PluresDB configuration from schema
     */
    generateConfig(schema: NormalizedSchema): GeneratedPluresDBFile[];
    /**
     * Generate pluresdb-config.ts file
     */
    private generateConfigFile;
    /**
     * Generate store configuration for a model
     */
    private generateStoreConfig;
}
/**
 * Create a PluresDB generator
 */
declare function createPluresDBGenerator(outputDir: string, options?: Partial<PluresDBGeneratorOptions>): PluresDBGenerator;

/**
 * PluresDB Integration
 *
 * Integration with pluresdb - reactive graph datastore and event source/sink.
 * This module provides adapters for:
 * - Storing Praxis state in pluresdb
 * - Sourcing events from pluresdb
 * - Sinking events to pluresdb
 * - Reactive queries and subscriptions
 */

/**
 * PluresDB adapter interface for engine integration
 *
 * Provides:
 * - Event sourcing (persist events to pluresdb)
 * - State snapshots (persist state to pluresdb)
 * - Event replay (rebuild state from events)
 * - Reactive queries (subscribe to state changes)
 */
interface PluresDBAdapter<TContext = unknown> {
    /**
     * Persist events to pluresdb
     */
    persistEvents(events: PraxisEvent[]): Promise<void>;
    /**
     * Persist facts to pluresdb
     */
    persistFacts(facts: PraxisFact[]): Promise<void>;
    /**
     * Load events from pluresdb
     */
    loadEvents(query?: unknown): Promise<PraxisEvent[]>;
    /**
     * Subscribe to changes for a given tag
     *
     * Note: This watches for derived facts that are created when events are processed.
     * The callback receives the new facts as event-like objects for convenience.
     */
    subscribeToEvents(callback: (events: PraxisEvent[]) => void, query?: unknown): () => void;
    /**
     * Attach the adapter to an engine
     */
    attachEngine(engine: LogicEngine<TContext>): void;
    /**
     * Dispose of resources
     */
    dispose(): void;
}
/**
 * Options for creating a PluresDB adapter
 */
interface PluresDBAdapterOptions<TContext = unknown> {
    /** The PraxisDB instance to use */
    db: PraxisDB;
    /** The PraxisRegistry for rules and constraints */
    registry: PraxisRegistry<TContext>;
    /** Initial context */
    initialContext?: TContext;
}
/**
 * Create a PluresDB adapter with full implementation
 *
 * @example
 * ```typescript
 * const db = createInMemoryDB();
 * const registry = new PraxisRegistry();
 * const adapter = createPluresDBAdapter({ db, registry });
 *
 * const engine = createPraxisEngine({ initialContext: {}, registry });
 * adapter.attachEngine(engine);
 *
 * await adapter.persistFacts([{ tag: "UserLoggedIn", payload: { userId: "alice" } }]);
 * ```
 */
declare function createPluresDBAdapter<TContext = unknown>(options: PluresDBAdapterOptions<TContext>): PluresDBAdapter<TContext>;
/**
 * Attach a PraxisDBStore to a LogicEngine
 *
 * This function creates a bidirectional connection between the store and engine:
 * - Events processed by the engine are persisted to the store
 * - Facts from the store are synchronized to the engine
 *
 * @param store The PraxisDBStore instance
 * @param engine The LogicEngine instance
 * @returns Cleanup function to detach the store
 *
 * @example
 * ```typescript
 * const db = createInMemoryDB();
 * const registry = new PraxisRegistry();
 * const store = createPraxisDBStore(db, registry);
 * const engine = createPraxisEngine({ initialContext: {}, registry });
 *
 * const detach = attachToEngine(store, engine);
 *
 * // Events are now automatically persisted
 * engine.step([{ tag: "LOGIN", payload: { username: "alice" } }]);
 *
 * // Cleanup
 * detach();
 * ```
 */
declare function attachToEngine<TContext = unknown>(store: PraxisDBStore<TContext>, engine: LogicEngine<TContext>): UnsubscribeFn;

/**
 * Unum Integration
 *
 * Integration with plures/unum - A modern Svelte binding library for PluresDB
 * with full Svelte 5 compatibility. Provides identity and channels support.
 *
 * Features:
 * - Svelte 4 & 5 Compatible: Works with both store-based and runes-based reactivity
 * - Type-Safe: Full TypeScript support with proper types
 * - Action-Based: Modern Svelte actions for DOM binding
 * - Store-Based: Writable store implementation for reactive data
 * - Collection Support: Easy handling of PluresDB collections
 *
 * @see https://github.com/plures/unum
 */

/**
 * Unum store interface for reactive PluresDB data
 */
interface UnumStore<T> {
    subscribe(run: (value: T) => void): () => void;
    set(value: T): void;
    update(updater: (value: T) => T): void;
}
/**
 * Unum channel for real-time communication
 */
interface UnumChannel {
    /** Channel identifier */
    id: string;
    /** Channel name */
    name: string;
    /** Subscribe to channel messages */
    subscribe(handler: (message: UnumMessage) => void): () => void;
    /** Publish a message to the channel */
    publish(message: Omit<UnumMessage, 'timestamp' | 'channelId'>): Promise<void>;
    /** Get channel members */
    getMembers(): Promise<UnumIdentity[]>;
    /** Leave the channel */
    leave(): Promise<void>;
}
/**
 * Message sent through a Unum channel
 */
interface UnumMessage {
    /** Message ID */
    id: string;
    /** Channel ID */
    channelId: string;
    /** Sender identity */
    sender: UnumIdentity;
    /** Message content */
    content: unknown;
    /** Message type */
    type: 'text' | 'event' | 'fact' | 'system';
    /** Timestamp */
    timestamp: number;
}
/**
 * Unum identity representing a user or system
 */
interface UnumIdentity {
    /** Unique identifier */
    id: string;
    /** Display name */
    name?: string;
    /** Public key for encryption */
    publicKey?: string;
    /** Identity metadata */
    metadata?: Record<string, unknown>;
    /** Creation timestamp */
    createdAt: number;
    /** Last seen timestamp */
    lastSeen?: number;
}
/**
 * Unum adapter configuration
 */
interface UnumAdapterConfig {
    /** PluresDB instance to use */
    db: PraxisDB;
    /** Current user identity */
    identity?: UnumIdentity;
    /** Whether to enable real-time sync */
    realtime?: boolean;
    /** Sync interval in milliseconds */
    syncInterval?: number;
}
/**
 * Unum adapter for Praxis engine integration
 *
 * Provides identity management and channel-based communication
 * for distributed Praxis applications.
 */
interface UnumAdapter {
    /** Current identity */
    identity: UnumIdentity | null;
    /** Create or update identity */
    setIdentity(identity: Omit<UnumIdentity, 'id' | 'createdAt'>): Promise<UnumIdentity>;
    /** Get identity by ID */
    getIdentity(id: string): Promise<UnumIdentity | null>;
    /** Create a new channel */
    createChannel(name: string, members?: string[]): Promise<UnumChannel>;
    /** Join an existing channel */
    joinChannel(channelId: string): Promise<UnumChannel>;
    /** List available channels */
    listChannels(): Promise<UnumChannel[]>;
    /** Broadcast a Praxis event to a channel */
    broadcastEvent(channelId: string, event: PraxisEvent): Promise<void>;
    /** Broadcast a Praxis fact to a channel */
    broadcastFact(channelId: string, fact: PraxisFact): Promise<void>;
    /** Subscribe to events from a channel */
    subscribeToEvents(channelId: string, handler: (event: PraxisEvent) => void): () => void;
    /** Subscribe to facts from a channel */
    subscribeToFacts(channelId: string, handler: (fact: PraxisFact) => void): () => void;
    /** Disconnect and cleanup */
    disconnect(): Promise<void>;
}
/**
 * Create a Unum adapter for Praxis engine integration
 *
 * @example
 * ```typescript
 * import { createUnumAdapter } from '@plures/praxis/integrations/unum';
 * import { createInMemoryDB } from '@plures/praxis/integrations/pluresdb';
 *
 * const db = createInMemoryDB();
 * const unum = await createUnumAdapter({
 *   db,
 *   identity: {
 *     name: 'Alice',
 *   },
 *   realtime: true,
 * });
 *
 * // Create a channel
 * const channel = await unum.createChannel('my-channel');
 *
 * // Broadcast events to the channel
 * await unum.broadcastEvent(channel.id, myEvent);
 * ```
 */
declare function createUnumAdapter(config: UnumAdapterConfig): Promise<UnumAdapter>;
/**
 * Attach Unum adapter to a Praxis engine
 *
 * Enables automatic event/fact broadcasting to connected channels.
 * This is a placeholder for future integration where the engine
 * would emit events that get broadcast to channels.
 *
 * @param _engine - The Praxis logic engine
 * @param _adapter - The Unum adapter
 * @param _channelId - The channel to broadcast to
 * @returns Cleanup function
 */
declare function attachUnumToEngine<TContext>(_engine: LogicEngine<TContext>, _adapter: UnumAdapter, _channelId: string): () => void;

/**
 * Praxis Schema Format (PSF) Types
 *
 * PSF is the canonical AST format that serves as the single source of truth.
 * All code, canvas, and documentation are derived from or synchronized with PSF.
 *
 * Design principles:
 * - JSON-serializable for persistence and transmission
 * - Supports bidirectional code â†” canvas sync
 * - Complete representation of all Praxis concepts
 * - Extensible with metadata and custom properties
 */
/**
 * PSF Schema version
 */
declare const PSF_VERSION: "1.0.0";
/**
 * Root PSF Schema Document
 */
interface PSFSchema {
    /** PSF format version */
    $version: typeof PSF_VERSION;
    /** Schema identifier */
    id: string;
    /** Human-readable name */
    name: string;
    /** Description */
    description?: string;
    /** Creation timestamp */
    createdAt?: string;
    /** Last modified timestamp */
    modifiedAt?: string;
    /** Facts defined in this schema */
    facts: PSFFact[];
    /** Events defined in this schema */
    events: PSFEvent[];
    /** Rules defined in this schema */
    rules: PSFRule[];
    /** Constraints defined in this schema */
    constraints: PSFConstraint[];
    /** Data models */
    models: PSFModel[];
    /** UI Components */
    components: PSFComponent[];
    /** Flows/Orchestrations */
    flows: PSFFlow[];
    /** Documentation metadata */
    docs?: PSFDocs;
    /** Additional metadata */
    metadata?: Record<string, unknown>;
    /** Canvas layout information for visual editing */
    canvas?: PSFCanvasLayout;
}
/**
 * PSF Fact Definition
 */
interface PSFFact {
    /** Unique identifier */
    id: string;
    /** Fact tag (for type discrimination) */
    tag: string;
    /** Description */
    description?: string;
    /** Payload schema */
    payload: PSFPayloadSchema;
    /** Documentation hints */
    docs?: PSFDocsHint;
    /** Canvas position */
    position?: PSFPosition;
    /** Metadata */
    meta?: Record<string, unknown>;
}
/**
 * PSF Event Definition
 */
interface PSFEvent {
    /** Unique identifier */
    id: string;
    /** Event tag (for type discrimination) */
    tag: string;
    /** Description */
    description?: string;
    /** Payload schema */
    payload: PSFPayloadSchema;
    /** Documentation hints */
    docs?: PSFDocsHint;
    /** Canvas position */
    position?: PSFPosition;
    /** Metadata */
    meta?: Record<string, unknown>;
}
/**
 * PSF Rule Definition
 */
interface PSFRule {
    /** Unique identifier */
    id: string;
    /** Human-readable name */
    name?: string;
    /** Description */
    description: string;
    /** Events that trigger this rule */
    triggers?: string[];
    /** Condition expression (DSL or reference) */
    when?: PSFExpression;
    /** Action expression (DSL or reference) */
    then: PSFExpression;
    /** Priority (higher executes first) */
    priority?: number;
    /** Documentation hints */
    docs?: PSFDocsHint;
    /** Canvas position */
    position?: PSFPosition;
    /** Metadata */
    meta?: Record<string, unknown>;
}
/**
 * PSF Constraint Definition
 */
interface PSFConstraint {
    /** Unique identifier */
    id: string;
    /** Human-readable name */
    name?: string;
    /** Description */
    description: string;
    /** Check expression */
    check: PSFExpression;
    /** Error message when violated */
    errorMessage: string;
    /** Severity level */
    severity?: 'error' | 'warning' | 'info';
    /** Documentation hints */
    docs?: PSFDocsHint;
    /** Canvas position */
    position?: PSFPosition;
    /** Metadata */
    meta?: Record<string, unknown>;
}
/**
 * PSF Data Model
 */
interface PSFModel {
    /** Unique identifier */
    id: string;
    /** Model name */
    name: string;
    /** Description */
    description?: string;
    /** Fields */
    fields: PSFField[];
    /** Relationships to other models */
    relationships?: PSFRelationship[];
    /** Indexes */
    indexes?: PSFIndex[];
    /** Model-level constraints */
    constraints?: PSFModelConstraint[];
    /** Documentation hints */
    docs?: PSFDocsHint;
    /** Canvas position */
    position?: PSFPosition;
    /** Metadata */
    meta?: Record<string, unknown>;
}
/**
 * PSF Model Field
 */
interface PSFField {
    /** Field name */
    name: string;
    /** Field type */
    type: PSFFieldType;
    /** Is optional */
    optional?: boolean;
    /** Default value */
    default?: unknown;
    /** Description */
    description?: string;
    /** Validation rules */
    validation?: PSFValidation[];
    /** UI hints for form generation */
    ui?: PSFUIHint;
}
/**
 * PSF Field Type
 */
type PSFFieldType = 'string' | 'number' | 'boolean' | 'date' | 'datetime' | 'uuid' | {
    array: PSFFieldType;
} | {
    object: Record<string, PSFField>;
} | {
    reference: string;
} | {
    enum: string[];
} | {
    union: PSFFieldType[];
};
/**
 * PSF Validation Rule
 */
interface PSFValidation {
    /** Validation type */
    type: 'required' | 'min' | 'max' | 'minLength' | 'maxLength' | 'pattern' | 'email' | 'url' | 'custom';
    /** Validation value */
    value?: unknown;
    /** Error message */
    message?: string;
}
/**
 * PSF Model Constraint
 */
interface PSFModelConstraint {
    /** Constraint identifier */
    id: string;
    /** Constraint type */
    type: 'unique' | 'check' | 'foreign_key';
    /** Fields involved */
    fields: string[];
    /** Description */
    description?: string;
    /** Additional options */
    options?: Record<string, unknown>;
}
/**
 * PSF Relationship
 */
interface PSFRelationship {
    /** Relationship name */
    name: string;
    /** Relationship type */
    type: 'one-to-one' | 'one-to-many' | 'many-to-many';
    /** Target model */
    target: string;
    /** Foreign key field */
    foreignKey?: string;
    /** Cascade behavior */
    cascade?: boolean;
}
/**
 * PSF Index
 */
interface PSFIndex {
    /** Index name */
    name: string;
    /** Fields to index */
    fields: string[];
    /** Is unique index */
    unique?: boolean;
    /** Index type */
    type?: 'btree' | 'hash' | 'fulltext';
}
/**
 * PSF Component Definition
 */
interface PSFComponent {
    /** Unique identifier */
    id: string;
    /** Component name */
    name: string;
    /** Component type */
    type: 'form' | 'display' | 'list' | 'navigation' | 'editor' | 'custom';
    /** Description */
    description?: string;
    /** Bound model */
    model?: string;
    /** Component properties */
    props: PSFComponentProp[];
    /** Component events */
    events: PSFComponentEvent[];
    /** Layout configuration */
    layout?: PSFLayout;
    /** Styling configuration */
    styling?: PSFStyling;
    /** Documentation hints */
    docs?: PSFDocsHint;
    /** Canvas position */
    position?: PSFPosition;
    /** Metadata */
    meta?: Record<string, unknown>;
}
/**
 * PSF Component Property
 */
interface PSFComponentProp {
    /** Property name */
    name: string;
    /** Property type */
    type: string;
    /** Is required */
    required?: boolean;
    /** Default value */
    default?: unknown;
    /** Description */
    description?: string;
    /** Binding expression */
    binding?: PSFExpression;
}
/**
 * PSF Component Event
 */
interface PSFComponentEvent {
    /** Event name */
    name: string;
    /** Payload type */
    payload?: string;
    /** Description */
    description?: string;
    /** Handler expression */
    handler?: PSFExpression;
}
/**
 * PSF Layout Configuration
 */
interface PSFLayout {
    /** Layout type */
    type: 'stack' | 'grid' | 'flex' | 'absolute';
    /** Direction */
    direction?: 'horizontal' | 'vertical';
    /** Gap between items */
    gap?: number | string;
    /** Padding */
    padding?: number | string;
    /** Alignment */
    align?: 'start' | 'center' | 'end' | 'stretch';
    /** Justify */
    justify?: 'start' | 'center' | 'end' | 'between' | 'around';
}
/**
 * PSF Styling Configuration
 */
interface PSFStyling {
    /** CSS classes */
    classes?: string[];
    /** Inline styles */
    styles?: Record<string, string>;
    /** Theme tokens */
    theme?: Record<string, string>;
    /** Variant */
    variant?: string;
}
/**
 * PSF Flow/Orchestration
 */
interface PSFFlow {
    /** Unique identifier */
    id: string;
    /** Flow name */
    name: string;
    /** Description */
    description?: string;
    /** Flow type */
    type: 'sequence' | 'parallel' | 'state-machine' | 'saga';
    /** Flow steps */
    steps: PSFFlowStep[];
    /** Initial state/step */
    initial?: string;
    /** Error handling */
    errorHandling?: PSFErrorHandling;
    /** Documentation hints */
    docs?: PSFDocsHint;
    /** Canvas position */
    position?: PSFPosition;
    /** Metadata */
    meta?: Record<string, unknown>;
}
/**
 * PSF Flow Step
 */
interface PSFFlowStep {
    /** Step identifier */
    id: string;
    /** Step name */
    name?: string;
    /** Step type */
    type: 'action' | 'condition' | 'wait' | 'parallel' | 'terminal';
    /** Action expression */
    action?: PSFExpression;
    /** Condition expression */
    condition?: PSFExpression;
    /** Next step(s) */
    next?: string | {
        [key: string]: string;
    };
    /** Timeout in milliseconds */
    timeout?: number;
    /** Retry configuration */
    retry?: PSFRetry;
}
/**
 * PSF Retry Configuration
 */
interface PSFRetry {
    /** Maximum retry attempts */
    maxAttempts: number;
    /** Delay between retries (ms) */
    delay: number;
    /** Exponential backoff factor */
    backoff?: number;
}
/**
 * PSF Error Handling
 */
interface PSFErrorHandling {
    /** Global error handler */
    handler?: PSFExpression;
    /** Compensation flow */
    compensation?: string;
    /** Error policy */
    policy: 'fail-fast' | 'continue' | 'compensate';
}
/**
 * PSF Documentation
 */
interface PSFDocs {
    /** Overview */
    overview?: string;
    /** Getting started guide */
    gettingStarted?: string;
    /** Examples */
    examples?: PSFExample[];
    /** Additional sections */
    sections?: PSFDocSection[];
    /** API documentation configuration */
    api?: PSFAPIDoc;
}
/**
 * PSF Documentation Hint (for individual elements)
 */
interface PSFDocsHint {
    /** Brief summary */
    summary?: string;
    /** Detailed description */
    details?: string;
    /** Examples */
    examples?: string[];
    /** See also references */
    seeAlso?: string[];
    /** Tags for categorization */
    tags?: string[];
    /** Deprecation notice */
    deprecated?: string | boolean;
}
/**
 * PSF Example
 */
interface PSFExample {
    /** Example name */
    name: string;
    /** Description */
    description?: string;
    /** Code snippet */
    code: string;
    /** Language */
    language?: string;
}
/**
 * PSF Documentation Section
 */
interface PSFDocSection {
    /** Section title */
    title: string;
    /** Section content (markdown) */
    content: string;
    /** Subsections */
    children?: PSFDocSection[];
}
/**
 * PSF API Documentation Configuration
 */
interface PSFAPIDoc {
    /** Generate API docs */
    generate?: boolean;
    /** Output format */
    format?: 'markdown' | 'html' | 'json';
    /** Include private members */
    includePrivate?: boolean;
}
/**
 * PSF Expression (can be inline or reference)
 */
type PSFExpression = {
    inline: string;
    language?: 'typescript' | 'javascript';
} | {
    ref: string;
};
/**
 * PSF Position (for canvas layout)
 */
interface PSFPosition {
    /** X coordinate */
    x: number;
    /** Y coordinate */
    y: number;
    /** Width (optional) */
    width?: number;
    /** Height (optional) */
    height?: number;
}
/**
 * PSF UI Hint (for form generation)
 */
interface PSFUIHint {
    /** Display label */
    label?: string;
    /** Placeholder text */
    placeholder?: string;
    /** Help text */
    help?: string;
    /** Input type override */
    inputType?: string;
    /** Component to use */
    component?: string;
    /** Hidden from UI */
    hidden?: boolean;
    /** Read-only */
    readonly?: boolean;
    /** Display order */
    order?: number;
}
/**
 * PSF Payload Schema
 */
interface PSFPayloadSchema {
    /** Schema type (usually 'object') */
    type: 'object';
    /** Properties */
    properties: Record<string, PSFPropertySchema>;
    /** Required properties */
    required?: string[];
}
/**
 * PSF Property Schema
 */
interface PSFPropertySchema {
    /** Property type */
    type: PSFFieldType | 'string' | 'number' | 'boolean' | 'array' | 'object';
    /** Description */
    description?: string;
    /** Default value */
    default?: unknown;
    /** Array items schema */
    items?: PSFPropertySchema;
    /** Nested properties (for object type) */
    properties?: Record<string, PSFPropertySchema>;
}
/**
 * PSF Canvas Layout (for visual editor)
 */
interface PSFCanvasLayout {
    /** Viewport settings */
    viewport?: {
        x: number;
        y: number;
        zoom: number;
    };
    /** Grid settings */
    grid?: {
        enabled: boolean;
        size: number;
        snap: boolean;
    };
    /** Node groups */
    groups?: PSFCanvasGroup[];
    /** Connections between nodes */
    connections?: PSFCanvasConnection[];
}
/**
 * PSF Canvas Group
 */
interface PSFCanvasGroup {
    /** Group identifier */
    id: string;
    /** Group name */
    name: string;
    /** Color */
    color?: string;
    /** Collapsed state */
    collapsed?: boolean;
    /** Position */
    position: PSFPosition;
    /** Member node IDs */
    members: string[];
}
/**
 * PSF Canvas Connection
 */
interface PSFCanvasConnection {
    /** Connection identifier */
    id: string;
    /** Source node ID */
    source: string;
    /** Source port */
    sourcePort?: string;
    /** Target node ID */
    target: string;
    /** Target port */
    targetPort?: string;
    /** Connection type */
    type?: 'data' | 'control' | 'event';
    /** Label */
    label?: string;
}

/**
 * CodeCanvas Integration
 *
 * Integration with plures/code-canvas - A visual schema editor and FSM enforcement tool.
 * Provides visual editing capabilities for Praxis schemas and logic flows.
 *
 * Features:
 * - Visual Schema Editor: Drag-and-drop interface for schema design
 * - FSM Visualization: Mermaid and DOT graph generation
 * - State Lifecycle Management: Activity tracking and validation
 * - Canvas Export/Import: YAML and JSON Canvas formats
 * - Guardian Integration: Pre-commit validation and rules enforcement
 *
 * @see https://github.com/plures/code-canvas
 */

/**
 * Canvas node representing a visual element
 */
interface CanvasNode {
    /** Unique node identifier */
    id: string;
    /** Node type */
    type: 'model' | 'component' | 'event' | 'fact' | 'rule' | 'constraint' | 'state' | 'transition';
    /** Node label/name */
    label: string;
    /** X position */
    x: number;
    /** Y position */
    y: number;
    /** Width */
    width: number;
    /** Height */
    height: number;
    /** Node data (model, component, etc.) */
    data?: unknown;
    /** Node style */
    style?: CanvasNodeStyle;
    /** FSM state reference */
    fsmState?: string;
}
/**
 * Canvas edge representing a connection between nodes
 */
interface CanvasEdge {
    /** Unique edge identifier */
    id: string;
    /** Source node ID */
    source: string;
    /** Target node ID */
    target: string;
    /** Edge label */
    label?: string;
    /** Edge type */
    type?: 'dependency' | 'transition' | 'trigger' | 'reference' | 'event';
    /** Edge style */
    style?: CanvasEdgeStyle;
}
/**
 * Node style configuration
 */
interface CanvasNodeStyle {
    /** Background color */
    backgroundColor?: string;
    /** Border color */
    borderColor?: string;
    /** Border width */
    borderWidth?: number;
    /** Text color */
    textColor?: string;
    /** Font size */
    fontSize?: number;
    /** Border radius */
    borderRadius?: number;
}
/**
 * Edge style configuration
 */
interface CanvasEdgeStyle {
    /** Stroke color */
    strokeColor?: string;
    /** Stroke width */
    strokeWidth?: number;
    /** Stroke style */
    strokeDasharray?: string;
    /** Arrow type */
    arrowType?: 'arrow' | 'none' | 'circle';
}
/**
 * Canvas document containing nodes and edges
 */
interface CanvasDocument {
    /** Document identifier */
    id: string;
    /** Document name */
    name: string;
    /** Document version */
    version: string;
    /** All nodes in the canvas */
    nodes: CanvasNode[];
    /** All edges in the canvas */
    edges: CanvasEdge[];
    /** Logic flows */
    flows?: PSFFlow[];
    /** Document metadata */
    metadata?: {
        created: number;
        modified: number;
        author?: string;
        description?: string;
    };
    /** Viewport settings */
    viewport?: {
        x: number;
        y: number;
        zoom: number;
    };
}
/**
 * FSM lifecycle state
 */
interface LifecycleState {
    /** State identifier */
    id: string;
    /** State name */
    name: string;
    /** State description */
    description?: string;
    /** Allowed transitions from this state */
    transitions: string[];
    /** Entry actions */
    onEntry?: string[];
    /** Exit actions */
    onExit?: string[];
    /** Is this an initial state */
    initial?: boolean;
    /** Is this a final state */
    final?: boolean;
}
/**
 * Activity tracking for current work context
 */
interface ActivityState {
    /** Current activity type */
    activity: 'designing' | 'implementing' | 'testing' | 'documenting' | 'reviewing';
    /** Actor performing the activity */
    actor: string;
    /** Current intent/goal */
    intent?: string;
    /** Started timestamp */
    startedAt: number;
    /** Allowed file patterns for this activity */
    allowedPaths?: string[];
}
/**
 * Canvas editor configuration
 */
interface CanvasEditorConfig {
    /** Canvas document to edit */
    document?: CanvasDocument;
    /** Schema to visualize */
    schema?: PSFSchema;
    /** Enable FSM validation */
    enableFSM?: boolean;
    /** Custom node styles by type */
    nodeStyles?: Record<string, CanvasNodeStyle>;
    /** Custom edge styles by type */
    edgeStyles?: Record<string, CanvasEdgeStyle>;
    /** Auto-layout algorithm */
    layout?: 'hierarchical' | 'force' | 'grid' | 'circular';
}
/**
 * Guardian validation result
 */
interface GuardianResult {
    /** Whether validation passed */
    valid: boolean;
    /** Validation errors */
    errors: GuardianError[];
    /** Validation warnings */
    warnings: GuardianWarning[];
    /** Files validated */
    filesChecked: string[];
    /** Current activity state */
    activity?: ActivityState;
}
/**
 * Guardian validation error
 */
interface GuardianError {
    /** Error code */
    code: string;
    /** Error message */
    message: string;
    /** File path (if applicable) */
    file?: string;
    /** Line number (if applicable) */
    line?: number;
    /** Rule that was violated */
    rule?: string;
}
/**
 * Guardian validation warning
 */
interface GuardianWarning {
    /** Warning code */
    code: string;
    /** Warning message */
    message: string;
    /** File path (if applicable) */
    file?: string;
    /** Suggestion for resolution */
    suggestion?: string;
}
/**
 * Create a canvas document from a Praxis schema
 *
 * @example
 * ```typescript
 * import { schemaToCanvas } from '@plures/praxis/integrations/code-canvas';
 *
 * const canvas = schemaToCanvas(mySchema, {
 *   layout: 'hierarchical',
 * });
 *
 * // Export to YAML
 * const yaml = canvasToYaml(canvas);
 * ```
 */
declare function schemaToCanvas(schema: PSFSchema, _options?: {
    layout?: 'hierarchical' | 'force' | 'grid' | 'circular';
}): CanvasDocument;
/**
 * Convert a canvas document back to a Praxis schema
 */
declare function canvasToSchema(canvas: CanvasDocument): PSFSchema;
/**
 * Export canvas to YAML format (compatible with Obsidian Canvas)
 */
declare function canvasToYaml(canvas: CanvasDocument): string;
/**
 * Export canvas to Mermaid diagram format
 */
declare function canvasToMermaid(canvas: CanvasDocument): string;
/**
 * Validate files against FSM lifecycle rules
 *
 * This provides integration with the CodeCanvas Guardian for pre-commit validation.
 */
declare function validateWithGuardian(files: string[], activity: ActivityState, lifecycle: LifecycleState[]): GuardianResult;
/**
 * Create a CodeCanvas editor instance
 *
 * Note: This is a placeholder for the visual editor integration.
 * The actual visual editor requires a browser environment.
 */
declare function createCanvasEditor(config: CanvasEditorConfig): {
    document: CanvasDocument;
    addNode: (node: Omit<CanvasNode, 'id'>) => CanvasNode;
    removeNode: (id: string) => void;
    addEdge: (edge: Omit<CanvasEdge, 'id'>) => CanvasEdge;
    removeEdge: (id: string) => void;
    toSchema: () => PSFSchema;
    toYaml: () => string;
    toMermaid: () => string;
};

/**
 * State-Docs Integration
 *
 * Integration with plures/state-docs - FSM documentation generator for XState projects.
 * Generates Markdown and Mermaid documentation from Praxis state machines and logic.
 *
 * Features:
 * - Auto-generate documentation from Praxis schemas
 * - Markdown output with Mermaid diagrams
 * - State machine visualization
 * - Transition documentation
 * - Integration with Praxis logic engine
 *
 * @see https://github.com/plures/state-docs
 */

/**
 * State-Docs configuration
 */
interface StateDocsConfig {
    /** Project title */
    projectTitle: string;
    /** Source directory containing schemas */
    source?: string;
    /** Target directory for generated docs */
    target?: string;
    /** File patterns to include */
    globs?: string[];
    /** Visualization settings */
    visualization?: {
        /** Output format */
        format?: 'mermaid' | 'dot';
        /** Export as PNG */
        exportPng?: boolean;
        /** Diagram theme */
        theme?: 'default' | 'dark' | 'forest' | 'neutral';
    };
    /** Template settings */
    template?: {
        /** Include table of contents */
        toc?: boolean;
        /** Include timestamp */
        timestamp?: boolean;
        /** Custom header content */
        header?: string;
        /** Custom footer content */
        footer?: string;
    };
}
/**
 * Generated documentation file
 */
interface GeneratedDoc {
    /** File path */
    path: string;
    /** File content */
    content: string;
    /** File type */
    type: 'markdown' | 'mermaid' | 'dot' | 'json';
}
/**
 * State machine representation for documentation
 */
interface StateMachineDoc {
    /** Machine identifier */
    id: string;
    /** Machine name */
    name: string;
    /** Machine description */
    description?: string;
    /** Initial state */
    initial?: string;
    /** All states */
    states: StateDoc[];
    /** All transitions */
    transitions: TransitionDoc[];
    /** Context type description */
    context?: string;
    /** Events that this machine handles */
    events?: string[];
}
/**
 * State documentation
 */
interface StateDoc {
    /** State identifier */
    id: string;
    /** State name */
    name: string;
    /** State description */
    description?: string;
    /** Is this an initial state */
    initial?: boolean;
    /** Is this a final state */
    final?: boolean;
    /** Entry actions */
    onEntry?: string[];
    /** Exit actions */
    onExit?: string[];
    /** State tags */
    tags?: string[];
}
/**
 * Transition documentation
 */
interface TransitionDoc {
    /** Source state */
    from: string;
    /** Target state */
    to: string;
    /** Event that triggers the transition */
    event: string;
    /** Transition guard condition */
    guard?: string;
    /** Actions executed during transition */
    actions?: string[];
    /** Transition description */
    description?: string;
}
/**
 * Documentation generator for Praxis schemas
 */
declare class StateDocsGenerator {
    private config;
    constructor(config: StateDocsConfig);
    /**
     * Generate documentation from a Praxis schema
     */
    generateFromSchema(schema: PraxisSchema): GeneratedDoc[];
    /**
     * Generate documentation from a Praxis registry
     */
    generateFromModule<TContext>(module: PraxisModule<TContext>): GeneratedDoc[];
    /**
     * Generate the main schema README
     */
    private generateSchemaReadme;
    /**
     * Generate models documentation
     */
    private generateModelsDoc;
    /**
     * Generate components documentation
     */
    private generateComponentsDoc;
    /**
     * Generate logic documentation
     */
    private generateLogicDoc;
    /**
     * Generate Mermaid diagram for logic
     */
    private generateLogicDiagram;
    /**
     * Generate rules documentation
     */
    private generateRulesDoc;
    /**
     * Generate constraints documentation
     */
    private generateConstraintsDoc;
    /**
     * Generate state diagram from registry
     */
    private generateRegistryDiagram;
}
/**
 * Create a State-Docs generator instance
 *
 * @example
 * ```typescript
 * import { createStateDocsGenerator } from '@plures/praxis/integrations/state-docs';
 *
 * const generator = createStateDocsGenerator({
 *   projectTitle: 'My Project',
 *   target: './docs/api',
 * });
 *
 * const docs = generator.generateFromSchema(mySchema);
 * for (const doc of docs) {
 *   await writeFile(doc.path, doc.content);
 * }
 * ```
 */
declare function createStateDocsGenerator(config: StateDocsConfig): StateDocsGenerator;
/**
 * Generate documentation from a schema (convenience function)
 */
declare function generateDocs(schema: PraxisSchema, config: StateDocsConfig): GeneratedDoc[];

/**
 * Tauri Integration
 *
 * Integration with plures/svelte-tauri-template for cross-platform desktop applications.
 * Provides Praxis engine integration with Tauri 2 for native desktop capabilities.
 *
 * Features:
 * - Cross-Platform: Windows, macOS, Linux, Android, iOS
 * - Native Integration: File system, system tray, notifications
 * - IPC Bridge: Type-safe communication between Rust and TypeScript
 * - Auto-Updates: Built-in update system
 * - Code Signing: Support for signed releases
 *
 * @see https://github.com/plures/svelte-tauri-template
 */

/**
 * Tauri app configuration
 */
interface TauriAppConfig {
    /** Application name */
    name: string;
    /** Application version */
    version: string;
    /** Application identifier (e.g., com.example.myapp) */
    identifier: string;
    /** Window configuration */
    window?: TauriWindowConfig;
    /** Security configuration */
    security?: TauriSecurityConfig;
    /** Update configuration */
    updates?: TauriUpdateConfig;
    /** Plugins to enable */
    plugins?: TauriPlugin[];
}
/**
 * Window configuration
 */
interface TauriWindowConfig {
    /** Window title */
    title?: string;
    /** Window width */
    width?: number;
    /** Window height */
    height?: number;
    /** Minimum width */
    minWidth?: number;
    /** Minimum height */
    minHeight?: number;
    /** Whether window is resizable */
    resizable?: boolean;
    /** Whether window is fullscreen */
    fullscreen?: boolean;
    /** Whether to show title bar */
    decorations?: boolean;
    /** Whether window is transparent */
    transparent?: boolean;
    /** Whether to always be on top */
    alwaysOnTop?: boolean;
    /** Center window on screen */
    center?: boolean;
}
/**
 * Security configuration
 */
interface TauriSecurityConfig {
    /** Content Security Policy */
    csp?: string;
    /** Allowed domains for fetch */
    allowedDomains?: string[];
    /** Enable dev tools in production */
    devTools?: boolean;
    /** Dangerous features to allow */
    dangerousAllowList?: string[];
}
/**
 * Auto-update configuration
 */
interface TauriUpdateConfig {
    /** Enable auto-updates */
    enabled: boolean;
    /** Update endpoint URL */
    endpoint?: string;
    /** Update check interval (ms) */
    checkInterval?: number;
    /** Whether to install silently */
    silent?: boolean;
    /** Public key for update verification */
    publicKey?: string;
}
/**
 * Tauri plugin definition
 */
interface TauriPlugin {
    /** Plugin name */
    name: string;
    /** Plugin version */
    version?: string;
    /** Plugin configuration */
    config?: Record<string, unknown>;
}
/**
 * IPC message from frontend to backend
 */
interface TauriCommand<T = unknown> {
    /** Command name */
    cmd: string;
    /** Command payload */
    payload?: T;
}
/**
 * IPC event from backend to frontend
 */
interface TauriEvent<T = unknown> {
    /** Event name */
    event: string;
    /** Event payload */
    payload?: T;
    /** Window label that emitted the event */
    windowLabel?: string;
}
/**
 * File system operations
 */
interface TauriFS {
    /** Read a file */
    readFile(path: string): Promise<Uint8Array>;
    /** Read a file as text */
    readTextFile(path: string): Promise<string>;
    /** Write to a file */
    writeFile(path: string, data: Uint8Array): Promise<void>;
    /** Write text to a file */
    writeTextFile(path: string, data: string): Promise<void>;
    /** Check if path exists */
    exists(path: string): Promise<boolean>;
    /** Create directory */
    mkdir(path: string, options?: {
        recursive?: boolean;
    }): Promise<void>;
    /** Remove file or directory */
    remove(path: string, options?: {
        recursive?: boolean;
    }): Promise<void>;
    /** Rename/move file */
    rename(oldPath: string, newPath: string): Promise<void>;
    /** List directory contents */
    readDir(path: string): Promise<TauriFileEntry[]>;
}
/**
 * File entry from directory listing
 */
interface TauriFileEntry {
    /** File name */
    name: string;
    /** Full path */
    path: string;
    /** Is directory */
    isDirectory: boolean;
    /** Is file */
    isFile: boolean;
    /** File size in bytes */
    size?: number;
    /** Last modified timestamp */
    modifiedAt?: number;
}
/**
 * System tray operations
 */
interface TauriTray {
    /** Set tray icon */
    setIcon(icon: string | Uint8Array): Promise<void>;
    /** Set tray tooltip */
    setTooltip(tooltip: string): Promise<void>;
    /** Set tray menu */
    setMenu(menu: TauriMenuItem[]): Promise<void>;
    /** Show tray */
    show(): Promise<void>;
    /** Hide tray */
    hide(): Promise<void>;
}
/**
 * Tray menu item
 */
interface TauriMenuItem {
    /** Item ID */
    id: string;
    /** Item label */
    label: string;
    /** Is item enabled */
    enabled?: boolean;
    /** Is item checked (for checkboxes) */
    checked?: boolean;
    /** Submenu items */
    submenu?: TauriMenuItem[];
    /** Click handler */
    onClick?: () => void;
}
/**
 * Notification API
 */
interface TauriNotification {
    /** Send a notification */
    send(options: TauriNotificationOptions): Promise<void>;
    /** Request notification permission */
    requestPermission(): Promise<'granted' | 'denied' | 'default'>;
    /** Check notification permission */
    checkPermission(): Promise<'granted' | 'denied' | 'default'>;
}
/**
 * Notification options
 */
interface TauriNotificationOptions {
    /** Notification title */
    title: string;
    /** Notification body */
    body?: string;
    /** Notification icon */
    icon?: string;
    /** Sound to play */
    sound?: string;
}
/**
 * Tauri bridge for Praxis integration
 *
 * Provides type-safe access to Tauri APIs from Praxis applications.
 */
interface TauriBridge {
    /** Application info */
    app: {
        name: string;
        version: string;
        tauriVersion: string;
    };
    /** File system operations */
    fs: TauriFS;
    /** System tray operations */
    tray: TauriTray;
    /** Notification operations */
    notification: TauriNotification;
    /** Invoke a Tauri command */
    invoke<T = unknown>(cmd: string, payload?: unknown): Promise<T>;
    /** Listen to a Tauri event */
    listen<T = unknown>(event: string, handler: (event: TauriEvent<T>) => void): Promise<() => void>;
    /** Emit a Tauri event */
    emit(event: string, payload?: unknown): Promise<void>;
    /** Get window operations */
    window: {
        /** Minimize window */
        minimize(): Promise<void>;
        /** Maximize window */
        maximize(): Promise<void>;
        /** Unmaximize window */
        unmaximize(): Promise<void>;
        /** Close window */
        close(): Promise<void>;
        /** Toggle fullscreen */
        toggleFullscreen(): Promise<void>;
        /** Set window title */
        setTitle(title: string): Promise<void>;
        /** Show window */
        show(): Promise<void>;
        /** Hide window */
        hide(): Promise<void>;
        /** Focus window */
        focus(): Promise<void>;
    };
    /** Check for updates */
    checkForUpdates(): Promise<TauriUpdateInfo | null>;
    /** Install update */
    installUpdate(): Promise<void>;
}
/**
 * Update information
 */
interface TauriUpdateInfo {
    /** New version available */
    version: string;
    /** Release date */
    date: string;
    /** Release notes */
    notes?: string;
    /** Download URL */
    url: string;
}
/**
 * Praxis-Tauri adapter for engine persistence
 */
interface TauriPraxisAdapter<TContext = unknown> {
    /** Save engine state to file */
    saveState(state: TContext): Promise<void>;
    /** Load engine state from file */
    loadState(): Promise<TContext | null>;
    /** Save events to file */
    saveEvents(events: PraxisEvent[]): Promise<void>;
    /** Load events from file */
    loadEvents(): Promise<PraxisEvent[]>;
    /** Watch for file changes */
    watchStateFile(handler: (state: TContext) => void): Promise<() => void>;
    /** Get state file path */
    getStatePath(): string;
    /** Get events file path */
    getEventsPath(): string;
}
/**
 * Create a mock Tauri bridge for development/testing
 *
 * This provides a mock implementation that works without Tauri runtime.
 */
declare function createMockTauriBridge(): TauriBridge;
/**
 * Create a Tauri-Praxis adapter for engine persistence
 *
 * @example
 * ```typescript
 * import { createTauriPraxisAdapter } from '@plures/praxis/integrations/tauri';
 *
 * const adapter = createTauriPraxisAdapter({
 *   bridge: tauriBridge,
 *   statePath: 'app-state.json',
 *   eventsPath: 'app-events.json',
 * });
 *
 * // Save state
 * await adapter.saveState(engine.getContext());
 *
 * // Load state
 * const savedState = await adapter.loadState();
 * ```
 */
declare function createTauriPraxisAdapter<TContext = unknown>(options: {
    bridge: TauriBridge;
    statePath?: string;
    eventsPath?: string;
}): TauriPraxisAdapter<TContext>;
/**
 * Attach Tauri bridge to a Praxis engine for auto-save
 *
 * @example
 * ```typescript
 * import { attachTauriToEngine } from '@plures/praxis/integrations/tauri';
 *
 * const cleanup = attachTauriToEngine(engine, adapter, {
 *   autoSave: true,
 *   saveInterval: 5000,
 * });
 *
 * // Later, cleanup subscriptions
 * cleanup();
 * ```
 */
declare function attachTauriToEngine<TContext>(engine: LogicEngine<TContext>, adapter: TauriPraxisAdapter<TContext>, options?: {
    autoSave?: boolean;
    saveInterval?: number;
}): () => void;
/**
 * Generate Tauri configuration from Praxis app config
 */
declare function generateTauriConfig(config: TauriAppConfig): Record<string, unknown>;

/**
 * Unified Integration Helpers
 *
 * Convenience functions for setting up Praxis with all ecosystem integrations
 * (PluresDB, Unum, State-Docs, CodeCanvas) in a single call.
 */

/**
 * Configuration for unified Praxis application
 */
interface UnifiedAppConfig<TContext = unknown> {
    /** Praxis registry with rules and constraints */
    registry: PraxisRegistry<TContext>;
    /** Initial context for the engine */
    initialContext: TContext;
    /** PluresDB instance (if not provided, creates in-memory DB) */
    db?: PraxisDB;
    /** Enable Unum for distributed communication */
    enableUnum?: boolean;
    /** Unum identity configuration (without id and createdAt which are auto-generated) */
    unumIdentity?: Omit<UnumIdentity, 'id' | 'createdAt'>;
    /** Enable State-Docs documentation generation */
    enableDocs?: boolean;
    /** State-Docs configuration */
    docsConfig?: {
        projectTitle: string;
        target?: string;
    };
    /** Praxis schema for CodeCanvas integration */
    schema?: PraxisSchema;
}
/**
 * Unified application instance with all integrations
 */
interface UnifiedApp<TContext = unknown> {
    /** Praxis logic engine */
    engine: LogicEngine<TContext>;
    /** PluresDB adapter for persistence */
    pluresdb: PluresDBAdapter<TContext>;
    /** Unum adapter for distributed communication (if enabled) */
    unum?: UnumAdapter;
    /** Default Unum channel (if Unum enabled) */
    channel?: UnumChannel;
    /** State-Docs generator (if enabled) */
    docs?: StateDocsGenerator;
    /** CodeCanvas document (if schema provided) */
    canvas?: CanvasDocument;
    /** Generate documentation from current state */
    generateDocs?: () => GeneratedDoc[];
    /** Cleanup function to dispose all integrations */
    dispose: () => void;
}
/**
 * Create a unified Praxis application with all integrations
 *
 * This is a convenience function that sets up:
 * - Praxis logic engine
 * - PluresDB for persistence (auto-attaches to engine)
 * - Unum for distributed communication (optional)
 * - State-Docs for documentation generation (optional)
 * - CodeCanvas for visual schema editing (optional)
 *
 * @example
 * ```typescript
 * import { createUnifiedApp } from '@plures/praxis';
 *
 * const app = await createUnifiedApp({
 *   registry: myRegistry,
 *   initialContext: { count: 0 },
 *   enableUnum: true,
 *   unumIdentity: { name: 'node-1' },
 *   enableDocs: true,
 *   docsConfig: { projectTitle: 'My App' },
 *   schema: mySchema,
 * });
 *
 * // Use the engine
 * app.engine.step([myEvent]);
 *
 * // Broadcast to other nodes
 * if (app.channel) {
 *   await app.unum?.broadcastEvent(app.channel.id, myEvent);
 * }
 *
 * // Generate documentation
 * const docs = app.generateDocs?.();
 *
 * // Cleanup
 * app.dispose();
 * ```
 */
declare function createUnifiedApp<TContext = unknown>(config: UnifiedAppConfig<TContext>): Promise<UnifiedApp<TContext>>;
/**
 * Attach all available integrations to an existing Praxis engine
 *
 * This is useful when you already have an engine and want to add integrations.
 *
 * @example
 * ```typescript
 * import { createPraxisEngine, attachAllIntegrations } from '@plures/praxis';
 *
 * const engine = createPraxisEngine({ initialContext: {}, registry });
 *
 * const integrations = await attachAllIntegrations(engine, registry, {
 *   enableUnum: true,
 *   enableDocs: true,
 * });
 *
 * // Later cleanup
 * integrations.dispose();
 * ```
 */
declare function attachAllIntegrations<TContext = unknown>(engine: LogicEngine<TContext>, registry: PraxisRegistry<TContext>, options?: {
    db?: PraxisDB;
    enableUnum?: boolean;
    unumIdentity?: Omit<UnumIdentity, 'id' | 'createdAt'>;
    enableDocs?: boolean;
    docsConfig?: {
        projectTitle: string;
        target?: string;
    };
}): Promise<{
    pluresdb: PluresDBAdapter<TContext>;
    unum?: UnumAdapter;
    channel?: UnumChannel;
    docs?: StateDocsGenerator;
    dispose: () => void;
}>;

export { type ActivityState, type Actor, ActorManager, type CanvasDocument, type CanvasEdge, type CanvasEdgeStyle, type CanvasEditorConfig, type CanvasNode, type CanvasNodeStyle, type ComponentDefinition, ConstraintDescriptor, ConstraintFn, type ConstraintNode, type ConstraintSchema, type DefineConstraintOptions, type DefineModuleOptions, type DefineRuleOptions, type EventDefinition$1 as EventDefinition, type EventStreamEntry, type FactDefinition$1 as FactDefinition, ReactiveLogicEngine as FrameworkAgnosticReactiveEngine, type ReactiveEngineOptions as FrameworkAgnosticReactiveEngineOptions, type GeneratedDoc, type GeneratedPluresDBFile, type GraphEdge, type GuardianError, type GuardianResult, type GuardianWarning, InMemoryPraxisDB, type LifecycleState, type LoaderOptions, type LoaderResult, type LogicDefinition, LogicEngine, type ModelDefinition, type NodeBindings, type NodeDefinition, type OrchestrationDefinition, PRAXIS_PATHS, type PluresDBAdapter, type PluresDBAdapterConfig, type PluresDBAdapterOptions, PluresDBGenerator, type PluresDBGeneratorOptions, type PluresDBInstance, PluresDBPraxisAdapter, type PraxisDB, PraxisDBStore, type PraxisDBStoreOptions, PraxisEvent, PraxisFact, PraxisModule, PraxisRegistry, type PraxisSchema, PraxisSchemaRegistry, PraxisState, type RegistryGraph, RegistryIntrospector, type RegistrySchema, type RegistryStats, RuleDescriptor, RuleFn, type RuleNode, type RuleSchema, type StateChangeCallback, type StateDoc, type StateDocsConfig, StateDocsGenerator, type StateMachineDoc, type StoredSchema, type TauriAppConfig, type TauriBridge, type TauriCommand, type TauriEvent, type TauriFS, type TauriFileEntry, type TauriMenuItem, type TauriNotification, type TauriNotificationOptions, type TauriPlugin, type TauriPraxisAdapter, type TauriSecurityConfig, type TauriTray, type TauriUpdateConfig, type TauriUpdateInfo, type TauriWindowConfig, type TerminalNodeProps, type TransitionDoc, type UnifiedApp, type UnifiedAppConfig, type UnsubscribeFn, type UnumAdapter, type UnumAdapterConfig, type UnumChannel, type UnumIdentity, type UnumMessage, type UnumStore, type ValidationError, type ValidationResult, attachAllIntegrations, attachTauriToEngine, attachToEngine, attachUnumToEngine, canvasToMermaid, canvasToSchema, canvasToYaml, createCanvasEditor, createReactiveEngine as createFrameworkAgnosticReactiveEngine, createInMemoryDB, createIntrospector, createMockTauriBridge, createPluresDB, createPluresDBAdapter, createPluresDBGenerator, createPraxisDBStore, createSchema, createSchemaRegistry, createSchemaTemplate, createStateDocsGenerator, createTauriPraxisAdapter, createTimerActor, createUnifiedApp, createUnumAdapter, defineConstraint, defineEvent, defineFact, defineModule, defineRule, filterEvents, filterFacts, findEvent, findFact, generateDocs, generateId, generateTauriConfig, getEventPath, getFactPath, getSchemaPath, loadSchemaFromJson, loadSchemaFromYaml, registerSchema, schemaToCanvas, validateForGeneration, validateSchema, validateWithGuardian };

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) =>
  typeof require !== 'undefined'
    ? require
    : typeof Proxy !== 'undefined'
      ? new Proxy(x, {
          get: (a, b) => (typeof require !== 'undefined' ? require : a)[b],
        })
      : x)(function (x) {
  if (typeof require !== 'undefined') return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) =>
  function __init() {
    return (fn && (res = (0, fn[__getOwnPropNames(fn)[0]])((fn = 0))), res);
  };
var __commonJS = (cb, mod) =>
  function __require2() {
    return (
      mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod),
      mod.exports
    );
  };
var __export = (target, all3) => {
  for (var name3 in all3) __defProp(target, name3, { get: all3[name3], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if ((from && typeof from === 'object') || typeof from === 'function') {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, {
          get: () => from[key2],
          enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable,
        });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (
  (target = mod != null ? __create(__getProtoOf(mod)) : {}),
  __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule
      ? __defProp(target, 'default', { value: mod, enumerable: true })
      : target,
    mod
  )
);
var __toCommonJS = (mod) => __copyProps(__defProp({}, '__esModule', { value: true }), mod);

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
var init_bind = __esm({
  'node_modules/axios/lib/helpers/bind.js'() {
    'use strict';
  },
});

// node_modules/axios/lib/utils.js
function isBuffer(val) {
  return (
    val !== null &&
    !isUndefined(val) &&
    val.constructor !== null &&
    !isUndefined(val.constructor) &&
    isFunction(val.constructor.isBuffer) &&
    val.constructor.isBuffer(val)
  );
}
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === 'undefined') {
    return;
  }
  let i;
  let l;
  if (typeof obj !== 'object') {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    if (isBuffer(obj)) {
      return;
    }
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key2;
    for (i = 0; i < len; i++) {
      key2 = keys[i];
      fn.call(null, obj[key2], key2, obj);
    }
  }
}
function findKey(obj, key2) {
  if (isBuffer(obj)) {
    return null;
  }
  key2 = key2.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key2 === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
function merge() {
  const { caseless, skipUndefined } = (isContextDefined(this) && this) || {};
  const result = {};
  const assignValue = (val, key2) => {
    const targetKey = (caseless && findKey(result, key2)) || key2;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
function isSpecCompliantForm(thing) {
  return !!(
    thing &&
    isFunction(thing.append) &&
    thing[toStringTag] === 'FormData' &&
    thing[iterator]
  );
}
var toString,
  getPrototypeOf,
  iterator,
  toStringTag,
  kindOf,
  kindOfTest,
  typeOfTest,
  isArray,
  isUndefined,
  isArrayBuffer,
  isString,
  isFunction,
  isNumber,
  isObject,
  isBoolean,
  isPlainObject,
  isEmptyObject,
  isDate,
  isFile,
  isBlob,
  isFileList,
  isStream,
  isFormData,
  isURLSearchParams,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  trim,
  _global,
  isContextDefined,
  extend,
  stripBOM,
  inherits,
  toFlatObject,
  endsWith,
  toArray,
  isTypedArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  toCamelCase,
  hasOwnProperty,
  isRegExp,
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  noop,
  toFiniteNumber,
  toJSONObject,
  isAsyncFn,
  isThenable,
  _setImmediate,
  asap,
  isIterable,
  utils_default;
var init_utils = __esm({
  'node_modules/axios/lib/utils.js'() {
    'use strict';
    init_bind();
    ({ toString } = Object.prototype);
    ({ getPrototypeOf } = Object);
    ({ iterator, toStringTag } = Symbol);
    kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
      const str2 = toString.call(thing);
      return cache2[str2] || (cache2[str2] = str2.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    typeOfTest = (type) => (thing) => typeof thing === type;
    ({ isArray } = Array);
    isUndefined = typeOfTest('undefined');
    isArrayBuffer = kindOfTest('ArrayBuffer');
    isString = typeOfTest('string');
    isFunction = typeOfTest('function');
    isNumber = typeOfTest('number');
    isObject = (thing) => thing !== null && typeof thing === 'object';
    isBoolean = (thing) => thing === true || thing === false;
    isPlainObject = (val) => {
      if (kindOf(val) !== 'object') {
        return false;
      }
      const prototype3 = getPrototypeOf(val);
      return (
        (prototype3 === null ||
          prototype3 === Object.prototype ||
          Object.getPrototypeOf(prototype3) === null) &&
        !(toStringTag in val) &&
        !(iterator in val)
      );
    };
    isEmptyObject = (val) => {
      if (!isObject(val) || isBuffer(val)) {
        return false;
      }
      try {
        return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
      } catch (e) {
        return false;
      }
    };
    isDate = kindOfTest('Date');
    isFile = kindOfTest('File');
    isBlob = kindOfTest('Blob');
    isFileList = kindOfTest('FileList');
    isStream = (val) => isObject(val) && isFunction(val.pipe);
    isFormData = (thing) => {
      let kind;
      return (
        thing &&
        ((typeof FormData === 'function' && thing instanceof FormData) ||
          (isFunction(thing.append) &&
            ((kind = kindOf(thing)) === 'formdata' || // detect form-data instance
              (kind === 'object' &&
                isFunction(thing.toString) &&
                thing.toString() === '[object FormData]'))))
      );
    };
    isURLSearchParams = kindOfTest('URLSearchParams');
    [isReadableStream, isRequest, isResponse, isHeaders] = [
      'ReadableStream',
      'Request',
      'Response',
      'Headers',
    ].map(kindOfTest);
    trim = (str2) =>
      str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    _global = (() => {
      if (typeof globalThis !== 'undefined') return globalThis;
      return typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : global;
    })();
    isContextDefined = (context) => !isUndefined(context) && context !== _global;
    extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(
        b,
        (val, key2) => {
          if (thisArg && isFunction(val)) {
            a[key2] = bind(val, thisArg);
          } else {
            a[key2] = val;
          }
        },
        { allOwnKeys }
      );
      return a;
    };
    stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, 'super', {
        value: superConstructor.prototype,
      });
      props && Object.assign(constructor.prototype, props);
    };
    toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
      let props;
      let i;
      let prop2;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null) return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop2 = props[i];
          if ((!propFilter || propFilter(prop2, sourceObj, destObj)) && !merged[prop2]) {
            destObj[prop2] = sourceObj[prop2];
            merged[prop2] = true;
          }
        }
        sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
      } while (
        sourceObj &&
        (!filter2 || filter2(sourceObj, destObj)) &&
        sourceObj !== Object.prototype
      );
      return destObj;
    };
    endsWith = (str2, searchString, position) => {
      str2 = String(str2);
      if (position === void 0 || position > str2.length) {
        position = str2.length;
      }
      position -= searchString.length;
      const lastIndex = str2.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    toArray = (thing) => {
      if (!thing) return null;
      if (isArray(thing)) return thing;
      let i = thing.length;
      if (!isNumber(i)) return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));
    forEachEntry = (obj, fn) => {
      const generator = obj && obj[iterator];
      const _iterator = generator.call(obj);
      let result;
      while ((result = _iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    matchAll = (regExp, str2) => {
      let matches2;
      const arr = [];
      while ((matches2 = regExp.exec(str2)) !== null) {
        arr.push(matches2);
      }
      return arr;
    };
    isHTMLForm = kindOfTest('HTMLFormElement');
    toCamelCase = (str2) => {
      return str2.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
      });
    };
    hasOwnProperty = (
      ({ hasOwnProperty: hasOwnProperty2 }) =>
      (obj, prop2) =>
        hasOwnProperty2.call(obj, prop2)
    )(Object.prototype);
    isRegExp = kindOfTest('RegExp');
    reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name3) => {
        let ret;
        if ((ret = reducer(descriptor, name3, obj)) !== false) {
          reducedDescriptors[name3] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name3) => {
        if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name3) !== -1) {
          return false;
        }
        const value = obj[name3];
        if (!isFunction(value)) return;
        descriptor.enumerable = false;
        if ('writable' in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name3 + "'");
          };
        }
      });
    };
    toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define2 = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString)
        ? define2(arrayOrString)
        : define2(String(arrayOrString).split(delimiter));
      return obj;
    };
    noop = () => {};
    toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite((value = +value)) ? value : defaultValue;
    };
    toJSONObject = (obj) => {
      const stack2 = new Array(10);
      const visit = (source2, i) => {
        if (isObject(source2)) {
          if (stack2.indexOf(source2) >= 0) {
            return;
          }
          if (isBuffer(source2)) {
            return source2;
          }
          if (!('toJSON' in source2)) {
            stack2[i] = source2;
            const target = isArray(source2) ? [] : {};
            forEach(source2, (value, key2) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key2] = reducedValue);
            });
            stack2[i] = void 0;
            return target;
          }
        }
        return source2;
      };
      return visit(obj, 0);
    };
    isAsyncFn = kindOfTest('AsyncFunction');
    isThenable = (thing) =>
      thing &&
      (isObject(thing) || isFunction(thing)) &&
      isFunction(thing.then) &&
      isFunction(thing.catch);
    _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported
        ? ((token, callbacks) => {
            _global.addEventListener(
              'message',
              ({ source: source2, data }) => {
                if (source2 === _global && data === token) {
                  callbacks.length && callbacks.shift()();
                }
              },
              false
            );
            return (cb) => {
              callbacks.push(cb);
              _global.postMessage(token, '*');
            };
          })(`axios@${Math.random()}`, [])
        : (cb) => setTimeout(cb);
    })(typeof setImmediate === 'function', isFunction(_global.postMessage));
    asap =
      typeof queueMicrotask !== 'undefined'
        ? queueMicrotask.bind(_global)
        : (typeof process !== 'undefined' && process.nextTick) || _setImmediate;
    isIterable = (thing) => thing != null && isFunction(thing[iterator]);
    utils_default = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isEmptyObject,
      isReadableStream,
      isRequest,
      isResponse,
      isHeaders,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap,
      isIterable,
    };
  },
});

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
var prototype, descriptors, AxiosError_default;
var init_AxiosError = __esm({
  'node_modules/axios/lib/core/AxiosError.js'() {
    'use strict';
    init_utils();
    utils_default.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils_default.toJSONObject(this.config),
          code: this.code,
          status: this.status,
        };
      },
    });
    prototype = AxiosError.prototype;
    descriptors = {};
    [
      'ERR_BAD_OPTION_VALUE',
      'ERR_BAD_OPTION',
      'ECONNABORTED',
      'ETIMEDOUT',
      'ERR_NETWORK',
      'ERR_FR_TOO_MANY_REDIRECTS',
      'ERR_DEPRECATED',
      'ERR_BAD_RESPONSE',
      'ERR_BAD_REQUEST',
      'ERR_CANCELED',
      'ERR_NOT_SUPPORT',
      'ERR_INVALID_URL',
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype, 'isAxiosError', { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype);
      utils_default.toFlatObject(
        error,
        axiosError,
        function filter2(obj) {
          return obj !== Error.prototype;
        },
        (prop2) => {
          return prop2 !== 'isAxiosError';
        }
      );
      const msg = error && error.message ? error.message : 'Error';
      const errCode = code == null && error ? error.code : code;
      AxiosError.call(axiosError, msg, errCode, config, request, response);
      if (error && axiosError.cause == null) {
        Object.defineProperty(axiosError, 'cause', { value: error, configurable: true });
      }
      axiosError.name = (error && error.name) || 'Error';
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    AxiosError_default = AxiosError;
  },
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  'node_modules/delayed-stream/lib/delayed_stream.js'(exports, module) {
    var Stream2 = __require('stream').Stream;
    var util3 = __require('util');
    module.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util3.inherits(DelayedStream, Stream2);
    DelayedStream.create = function (source2, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source2;
      var realEmit = source2.emit;
      source2.emit = function () {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source2, arguments);
      };
      source2.on('error', function () {});
      if (delayedStream.pauseStream) {
        source2.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, 'readable', {
      configurable: true,
      enumerable: true,
      get: function () {
        return this.source.readable;
      },
    });
    DelayedStream.prototype.setEncoding = function () {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function () {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function () {
      this.source.pause();
    };
    DelayedStream.prototype.release = function () {
      this._released = true;
      this._bufferedEvents.forEach(
        function (args) {
          this.emit.apply(this, args);
        }.bind(this)
      );
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function () {
      var r = Stream2.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function (args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === 'data') {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function () {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
      this.emit('error', new Error(message));
    };
  },
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  'node_modules/combined-stream/lib/combined_stream.js'(exports, module) {
    var util3 = __require('util');
    var Stream2 = __require('stream').Stream;
    var DelayedStream = require_delayed_stream();
    module.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util3.inherits(CombinedStream, Stream2);
    CombinedStream.create = function (options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function (stream4) {
      return (
        typeof stream4 !== 'function' &&
        typeof stream4 !== 'string' &&
        typeof stream4 !== 'boolean' &&
        typeof stream4 !== 'number' &&
        !Buffer.isBuffer(stream4)
      );
    };
    CombinedStream.prototype.append = function (stream4) {
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        if (!(stream4 instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream4, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams,
          });
          stream4.on('data', this._checkDataSize.bind(this));
          stream4 = newStream;
        }
        this._handleErrors(stream4);
        if (this.pauseStreams) {
          stream4.pause();
        }
      }
      this._streams.push(stream4);
      return this;
    };
    CombinedStream.prototype.pipe = function (dest, options) {
      Stream2.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function () {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function () {
      var stream4 = this._streams.shift();
      if (typeof stream4 == 'undefined') {
        this.end();
        return;
      }
      if (typeof stream4 !== 'function') {
        this._pipeNext(stream4);
        return;
      }
      var getStream = stream4;
      getStream(
        function (stream5) {
          var isStreamLike = CombinedStream.isStreamLike(stream5);
          if (isStreamLike) {
            stream5.on('data', this._checkDataSize.bind(this));
            this._handleErrors(stream5);
          }
          this._pipeNext(stream5);
        }.bind(this)
      );
    };
    CombinedStream.prototype._pipeNext = function (stream4) {
      this._currentStream = stream4;
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        stream4.on('end', this._getNext.bind(this));
        stream4.pipe(this, { end: false });
        return;
      }
      var value = stream4;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function (stream4) {
      var self3 = this;
      stream4.on('error', function (err) {
        self3._emitError(err);
      });
    };
    CombinedStream.prototype.write = function (data) {
      this.emit('data', data);
    };
    CombinedStream.prototype.pause = function () {
      if (!this.pauseStreams) {
        return;
      }
      if (
        this.pauseStreams &&
        this._currentStream &&
        typeof this._currentStream.pause == 'function'
      )
        this._currentStream.pause();
      this.emit('pause');
    };
    CombinedStream.prototype.resume = function () {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (
        this.pauseStreams &&
        this._currentStream &&
        typeof this._currentStream.resume == 'function'
      )
        this._currentStream.resume();
      this.emit('resume');
    };
    CombinedStream.prototype.end = function () {
      this._reset();
      this.emit('end');
    };
    CombinedStream.prototype.destroy = function () {
      this._reset();
      this.emit('close');
    };
    CombinedStream.prototype._reset = function () {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function () {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function () {
      this.dataSize = 0;
      var self3 = this;
      this._streams.forEach(function (stream4) {
        if (!stream4.dataSize) {
          return;
        }
        self3.dataSize += stream4.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function (err) {
      this._reset();
      this.emit('error', err);
    };
  },
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  'node_modules/mime-db/db.json'(exports, module) {
    module.exports = {
      'application/1d-interleaved-parityfec': {
        source: 'iana',
      },
      'application/3gpdash-qoe-report+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/3gpp-ims+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/3gpphal+json': {
        source: 'iana',
        compressible: true,
      },
      'application/3gpphalforms+json': {
        source: 'iana',
        compressible: true,
      },
      'application/a2l': {
        source: 'iana',
      },
      'application/ace+cbor': {
        source: 'iana',
      },
      'application/activemessage': {
        source: 'iana',
      },
      'application/activity+json': {
        source: 'iana',
        compressible: true,
      },
      'application/alto-costmap+json': {
        source: 'iana',
        compressible: true,
      },
      'application/alto-costmapfilter+json': {
        source: 'iana',
        compressible: true,
      },
      'application/alto-directory+json': {
        source: 'iana',
        compressible: true,
      },
      'application/alto-endpointcost+json': {
        source: 'iana',
        compressible: true,
      },
      'application/alto-endpointcostparams+json': {
        source: 'iana',
        compressible: true,
      },
      'application/alto-endpointprop+json': {
        source: 'iana',
        compressible: true,
      },
      'application/alto-endpointpropparams+json': {
        source: 'iana',
        compressible: true,
      },
      'application/alto-error+json': {
        source: 'iana',
        compressible: true,
      },
      'application/alto-networkmap+json': {
        source: 'iana',
        compressible: true,
      },
      'application/alto-networkmapfilter+json': {
        source: 'iana',
        compressible: true,
      },
      'application/alto-updatestreamcontrol+json': {
        source: 'iana',
        compressible: true,
      },
      'application/alto-updatestreamparams+json': {
        source: 'iana',
        compressible: true,
      },
      'application/aml': {
        source: 'iana',
      },
      'application/andrew-inset': {
        source: 'iana',
        extensions: ['ez'],
      },
      'application/applefile': {
        source: 'iana',
      },
      'application/applixware': {
        source: 'apache',
        extensions: ['aw'],
      },
      'application/at+jwt': {
        source: 'iana',
      },
      'application/atf': {
        source: 'iana',
      },
      'application/atfx': {
        source: 'iana',
      },
      'application/atom+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['atom'],
      },
      'application/atomcat+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['atomcat'],
      },
      'application/atomdeleted+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['atomdeleted'],
      },
      'application/atomicmail': {
        source: 'iana',
      },
      'application/atomsvc+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['atomsvc'],
      },
      'application/atsc-dwd+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['dwd'],
      },
      'application/atsc-dynamic-event-message': {
        source: 'iana',
      },
      'application/atsc-held+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['held'],
      },
      'application/atsc-rdt+json': {
        source: 'iana',
        compressible: true,
      },
      'application/atsc-rsat+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['rsat'],
      },
      'application/atxml': {
        source: 'iana',
      },
      'application/auth-policy+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/bacnet-xdd+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/batch-smtp': {
        source: 'iana',
      },
      'application/bdoc': {
        compressible: false,
        extensions: ['bdoc'],
      },
      'application/beep+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/calendar+json': {
        source: 'iana',
        compressible: true,
      },
      'application/calendar+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xcs'],
      },
      'application/call-completion': {
        source: 'iana',
      },
      'application/cals-1840': {
        source: 'iana',
      },
      'application/captive+json': {
        source: 'iana',
        compressible: true,
      },
      'application/cbor': {
        source: 'iana',
      },
      'application/cbor-seq': {
        source: 'iana',
      },
      'application/cccex': {
        source: 'iana',
      },
      'application/ccmp+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/ccxml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['ccxml'],
      },
      'application/cdfx+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['cdfx'],
      },
      'application/cdmi-capability': {
        source: 'iana',
        extensions: ['cdmia'],
      },
      'application/cdmi-container': {
        source: 'iana',
        extensions: ['cdmic'],
      },
      'application/cdmi-domain': {
        source: 'iana',
        extensions: ['cdmid'],
      },
      'application/cdmi-object': {
        source: 'iana',
        extensions: ['cdmio'],
      },
      'application/cdmi-queue': {
        source: 'iana',
        extensions: ['cdmiq'],
      },
      'application/cdni': {
        source: 'iana',
      },
      'application/cea': {
        source: 'iana',
      },
      'application/cea-2018+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/cellml+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/cfw': {
        source: 'iana',
      },
      'application/city+json': {
        source: 'iana',
        compressible: true,
      },
      'application/clr': {
        source: 'iana',
      },
      'application/clue+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/clue_info+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/cms': {
        source: 'iana',
      },
      'application/cnrp+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/coap-group+json': {
        source: 'iana',
        compressible: true,
      },
      'application/coap-payload': {
        source: 'iana',
      },
      'application/commonground': {
        source: 'iana',
      },
      'application/conference-info+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/cose': {
        source: 'iana',
      },
      'application/cose-key': {
        source: 'iana',
      },
      'application/cose-key-set': {
        source: 'iana',
      },
      'application/cpl+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['cpl'],
      },
      'application/csrattrs': {
        source: 'iana',
      },
      'application/csta+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/cstadata+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/csvm+json': {
        source: 'iana',
        compressible: true,
      },
      'application/cu-seeme': {
        source: 'apache',
        extensions: ['cu'],
      },
      'application/cwt': {
        source: 'iana',
      },
      'application/cybercash': {
        source: 'iana',
      },
      'application/dart': {
        compressible: true,
      },
      'application/dash+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['mpd'],
      },
      'application/dash-patch+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['mpp'],
      },
      'application/dashdelta': {
        source: 'iana',
      },
      'application/davmount+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['davmount'],
      },
      'application/dca-rft': {
        source: 'iana',
      },
      'application/dcd': {
        source: 'iana',
      },
      'application/dec-dx': {
        source: 'iana',
      },
      'application/dialog-info+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/dicom': {
        source: 'iana',
      },
      'application/dicom+json': {
        source: 'iana',
        compressible: true,
      },
      'application/dicom+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/dii': {
        source: 'iana',
      },
      'application/dit': {
        source: 'iana',
      },
      'application/dns': {
        source: 'iana',
      },
      'application/dns+json': {
        source: 'iana',
        compressible: true,
      },
      'application/dns-message': {
        source: 'iana',
      },
      'application/docbook+xml': {
        source: 'apache',
        compressible: true,
        extensions: ['dbk'],
      },
      'application/dots+cbor': {
        source: 'iana',
      },
      'application/dskpp+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/dssc+der': {
        source: 'iana',
        extensions: ['dssc'],
      },
      'application/dssc+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xdssc'],
      },
      'application/dvcs': {
        source: 'iana',
      },
      'application/ecmascript': {
        source: 'iana',
        compressible: true,
        extensions: ['es', 'ecma'],
      },
      'application/edi-consent': {
        source: 'iana',
      },
      'application/edi-x12': {
        source: 'iana',
        compressible: false,
      },
      'application/edifact': {
        source: 'iana',
        compressible: false,
      },
      'application/efi': {
        source: 'iana',
      },
      'application/elm+json': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/elm+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/emergencycalldata.cap+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/emergencycalldata.comment+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/emergencycalldata.control+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/emergencycalldata.deviceinfo+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/emergencycalldata.ecall.msd': {
        source: 'iana',
      },
      'application/emergencycalldata.providerinfo+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/emergencycalldata.serviceinfo+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/emergencycalldata.subscriberinfo+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/emergencycalldata.veds+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/emma+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['emma'],
      },
      'application/emotionml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['emotionml'],
      },
      'application/encaprtp': {
        source: 'iana',
      },
      'application/epp+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/epub+zip': {
        source: 'iana',
        compressible: false,
        extensions: ['epub'],
      },
      'application/eshop': {
        source: 'iana',
      },
      'application/exi': {
        source: 'iana',
        extensions: ['exi'],
      },
      'application/expect-ct-report+json': {
        source: 'iana',
        compressible: true,
      },
      'application/express': {
        source: 'iana',
        extensions: ['exp'],
      },
      'application/fastinfoset': {
        source: 'iana',
      },
      'application/fastsoap': {
        source: 'iana',
      },
      'application/fdt+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['fdt'],
      },
      'application/fhir+json': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/fhir+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/fido.trusted-apps+json': {
        compressible: true,
      },
      'application/fits': {
        source: 'iana',
      },
      'application/flexfec': {
        source: 'iana',
      },
      'application/font-sfnt': {
        source: 'iana',
      },
      'application/font-tdpfr': {
        source: 'iana',
        extensions: ['pfr'],
      },
      'application/font-woff': {
        source: 'iana',
        compressible: false,
      },
      'application/framework-attributes+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/geo+json': {
        source: 'iana',
        compressible: true,
        extensions: ['geojson'],
      },
      'application/geo+json-seq': {
        source: 'iana',
      },
      'application/geopackage+sqlite3': {
        source: 'iana',
      },
      'application/geoxacml+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/gltf-buffer': {
        source: 'iana',
      },
      'application/gml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['gml'],
      },
      'application/gpx+xml': {
        source: 'apache',
        compressible: true,
        extensions: ['gpx'],
      },
      'application/gxf': {
        source: 'apache',
        extensions: ['gxf'],
      },
      'application/gzip': {
        source: 'iana',
        compressible: false,
        extensions: ['gz'],
      },
      'application/h224': {
        source: 'iana',
      },
      'application/held+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/hjson': {
        extensions: ['hjson'],
      },
      'application/http': {
        source: 'iana',
      },
      'application/hyperstudio': {
        source: 'iana',
        extensions: ['stk'],
      },
      'application/ibe-key-request+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/ibe-pkg-reply+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/ibe-pp-data': {
        source: 'iana',
      },
      'application/iges': {
        source: 'iana',
      },
      'application/im-iscomposing+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/index': {
        source: 'iana',
      },
      'application/index.cmd': {
        source: 'iana',
      },
      'application/index.obj': {
        source: 'iana',
      },
      'application/index.response': {
        source: 'iana',
      },
      'application/index.vnd': {
        source: 'iana',
      },
      'application/inkml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['ink', 'inkml'],
      },
      'application/iotp': {
        source: 'iana',
      },
      'application/ipfix': {
        source: 'iana',
        extensions: ['ipfix'],
      },
      'application/ipp': {
        source: 'iana',
      },
      'application/isup': {
        source: 'iana',
      },
      'application/its+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['its'],
      },
      'application/java-archive': {
        source: 'apache',
        compressible: false,
        extensions: ['jar', 'war', 'ear'],
      },
      'application/java-serialized-object': {
        source: 'apache',
        compressible: false,
        extensions: ['ser'],
      },
      'application/java-vm': {
        source: 'apache',
        compressible: false,
        extensions: ['class'],
      },
      'application/javascript': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
        extensions: ['js', 'mjs'],
      },
      'application/jf2feed+json': {
        source: 'iana',
        compressible: true,
      },
      'application/jose': {
        source: 'iana',
      },
      'application/jose+json': {
        source: 'iana',
        compressible: true,
      },
      'application/jrd+json': {
        source: 'iana',
        compressible: true,
      },
      'application/jscalendar+json': {
        source: 'iana',
        compressible: true,
      },
      'application/json': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
        extensions: ['json', 'map'],
      },
      'application/json-patch+json': {
        source: 'iana',
        compressible: true,
      },
      'application/json-seq': {
        source: 'iana',
      },
      'application/json5': {
        extensions: ['json5'],
      },
      'application/jsonml+json': {
        source: 'apache',
        compressible: true,
        extensions: ['jsonml'],
      },
      'application/jwk+json': {
        source: 'iana',
        compressible: true,
      },
      'application/jwk-set+json': {
        source: 'iana',
        compressible: true,
      },
      'application/jwt': {
        source: 'iana',
      },
      'application/kpml-request+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/kpml-response+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/ld+json': {
        source: 'iana',
        compressible: true,
        extensions: ['jsonld'],
      },
      'application/lgr+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['lgr'],
      },
      'application/link-format': {
        source: 'iana',
      },
      'application/load-control+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/lost+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['lostxml'],
      },
      'application/lostsync+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/lpf+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/lxf': {
        source: 'iana',
      },
      'application/mac-binhex40': {
        source: 'iana',
        extensions: ['hqx'],
      },
      'application/mac-compactpro': {
        source: 'apache',
        extensions: ['cpt'],
      },
      'application/macwriteii': {
        source: 'iana',
      },
      'application/mads+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['mads'],
      },
      'application/manifest+json': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
        extensions: ['webmanifest'],
      },
      'application/marc': {
        source: 'iana',
        extensions: ['mrc'],
      },
      'application/marcxml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['mrcx'],
      },
      'application/mathematica': {
        source: 'iana',
        extensions: ['ma', 'nb', 'mb'],
      },
      'application/mathml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['mathml'],
      },
      'application/mathml-content+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/mathml-presentation+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/mbms-associated-procedure-description+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/mbms-deregister+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/mbms-envelope+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/mbms-msk+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/mbms-msk-response+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/mbms-protection-description+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/mbms-reception-report+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/mbms-register+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/mbms-register-response+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/mbms-schedule+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/mbms-user-service-description+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/mbox': {
        source: 'iana',
        extensions: ['mbox'],
      },
      'application/media-policy-dataset+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['mpf'],
      },
      'application/media_control+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/mediaservercontrol+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['mscml'],
      },
      'application/merge-patch+json': {
        source: 'iana',
        compressible: true,
      },
      'application/metalink+xml': {
        source: 'apache',
        compressible: true,
        extensions: ['metalink'],
      },
      'application/metalink4+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['meta4'],
      },
      'application/mets+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['mets'],
      },
      'application/mf4': {
        source: 'iana',
      },
      'application/mikey': {
        source: 'iana',
      },
      'application/mipc': {
        source: 'iana',
      },
      'application/missing-blocks+cbor-seq': {
        source: 'iana',
      },
      'application/mmt-aei+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['maei'],
      },
      'application/mmt-usd+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['musd'],
      },
      'application/mods+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['mods'],
      },
      'application/moss-keys': {
        source: 'iana',
      },
      'application/moss-signature': {
        source: 'iana',
      },
      'application/mosskey-data': {
        source: 'iana',
      },
      'application/mosskey-request': {
        source: 'iana',
      },
      'application/mp21': {
        source: 'iana',
        extensions: ['m21', 'mp21'],
      },
      'application/mp4': {
        source: 'iana',
        extensions: ['mp4s', 'm4p'],
      },
      'application/mpeg4-generic': {
        source: 'iana',
      },
      'application/mpeg4-iod': {
        source: 'iana',
      },
      'application/mpeg4-iod-xmt': {
        source: 'iana',
      },
      'application/mrb-consumer+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/mrb-publish+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/msc-ivr+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/msc-mixer+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/msword': {
        source: 'iana',
        compressible: false,
        extensions: ['doc', 'dot'],
      },
      'application/mud+json': {
        source: 'iana',
        compressible: true,
      },
      'application/multipart-core': {
        source: 'iana',
      },
      'application/mxf': {
        source: 'iana',
        extensions: ['mxf'],
      },
      'application/n-quads': {
        source: 'iana',
        extensions: ['nq'],
      },
      'application/n-triples': {
        source: 'iana',
        extensions: ['nt'],
      },
      'application/nasdata': {
        source: 'iana',
      },
      'application/news-checkgroups': {
        source: 'iana',
        charset: 'US-ASCII',
      },
      'application/news-groupinfo': {
        source: 'iana',
        charset: 'US-ASCII',
      },
      'application/news-transmission': {
        source: 'iana',
      },
      'application/nlsml+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/node': {
        source: 'iana',
        extensions: ['cjs'],
      },
      'application/nss': {
        source: 'iana',
      },
      'application/oauth-authz-req+jwt': {
        source: 'iana',
      },
      'application/oblivious-dns-message': {
        source: 'iana',
      },
      'application/ocsp-request': {
        source: 'iana',
      },
      'application/ocsp-response': {
        source: 'iana',
      },
      'application/octet-stream': {
        source: 'iana',
        compressible: false,
        extensions: [
          'bin',
          'dms',
          'lrf',
          'mar',
          'so',
          'dist',
          'distz',
          'pkg',
          'bpk',
          'dump',
          'elc',
          'deploy',
          'exe',
          'dll',
          'deb',
          'dmg',
          'iso',
          'img',
          'msi',
          'msp',
          'msm',
          'buffer',
        ],
      },
      'application/oda': {
        source: 'iana',
        extensions: ['oda'],
      },
      'application/odm+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/odx': {
        source: 'iana',
      },
      'application/oebps-package+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['opf'],
      },
      'application/ogg': {
        source: 'iana',
        compressible: false,
        extensions: ['ogx'],
      },
      'application/omdoc+xml': {
        source: 'apache',
        compressible: true,
        extensions: ['omdoc'],
      },
      'application/onenote': {
        source: 'apache',
        extensions: ['onetoc', 'onetoc2', 'onetmp', 'onepkg'],
      },
      'application/opc-nodeset+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/oscore': {
        source: 'iana',
      },
      'application/oxps': {
        source: 'iana',
        extensions: ['oxps'],
      },
      'application/p21': {
        source: 'iana',
      },
      'application/p21+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/p2p-overlay+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['relo'],
      },
      'application/parityfec': {
        source: 'iana',
      },
      'application/passport': {
        source: 'iana',
      },
      'application/patch-ops-error+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xer'],
      },
      'application/pdf': {
        source: 'iana',
        compressible: false,
        extensions: ['pdf'],
      },
      'application/pdx': {
        source: 'iana',
      },
      'application/pem-certificate-chain': {
        source: 'iana',
      },
      'application/pgp-encrypted': {
        source: 'iana',
        compressible: false,
        extensions: ['pgp'],
      },
      'application/pgp-keys': {
        source: 'iana',
        extensions: ['asc'],
      },
      'application/pgp-signature': {
        source: 'iana',
        extensions: ['asc', 'sig'],
      },
      'application/pics-rules': {
        source: 'apache',
        extensions: ['prf'],
      },
      'application/pidf+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/pidf-diff+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/pkcs10': {
        source: 'iana',
        extensions: ['p10'],
      },
      'application/pkcs12': {
        source: 'iana',
      },
      'application/pkcs7-mime': {
        source: 'iana',
        extensions: ['p7m', 'p7c'],
      },
      'application/pkcs7-signature': {
        source: 'iana',
        extensions: ['p7s'],
      },
      'application/pkcs8': {
        source: 'iana',
        extensions: ['p8'],
      },
      'application/pkcs8-encrypted': {
        source: 'iana',
      },
      'application/pkix-attr-cert': {
        source: 'iana',
        extensions: ['ac'],
      },
      'application/pkix-cert': {
        source: 'iana',
        extensions: ['cer'],
      },
      'application/pkix-crl': {
        source: 'iana',
        extensions: ['crl'],
      },
      'application/pkix-pkipath': {
        source: 'iana',
        extensions: ['pkipath'],
      },
      'application/pkixcmp': {
        source: 'iana',
        extensions: ['pki'],
      },
      'application/pls+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['pls'],
      },
      'application/poc-settings+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/postscript': {
        source: 'iana',
        compressible: true,
        extensions: ['ai', 'eps', 'ps'],
      },
      'application/ppsp-tracker+json': {
        source: 'iana',
        compressible: true,
      },
      'application/problem+json': {
        source: 'iana',
        compressible: true,
      },
      'application/problem+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/provenance+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['provx'],
      },
      'application/prs.alvestrand.titrax-sheet': {
        source: 'iana',
      },
      'application/prs.cww': {
        source: 'iana',
        extensions: ['cww'],
      },
      'application/prs.cyn': {
        source: 'iana',
        charset: '7-BIT',
      },
      'application/prs.hpub+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/prs.nprend': {
        source: 'iana',
      },
      'application/prs.plucker': {
        source: 'iana',
      },
      'application/prs.rdf-xml-crypt': {
        source: 'iana',
      },
      'application/prs.xsf+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/pskc+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['pskcxml'],
      },
      'application/pvd+json': {
        source: 'iana',
        compressible: true,
      },
      'application/qsig': {
        source: 'iana',
      },
      'application/raml+yaml': {
        compressible: true,
        extensions: ['raml'],
      },
      'application/raptorfec': {
        source: 'iana',
      },
      'application/rdap+json': {
        source: 'iana',
        compressible: true,
      },
      'application/rdf+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['rdf', 'owl'],
      },
      'application/reginfo+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['rif'],
      },
      'application/relax-ng-compact-syntax': {
        source: 'iana',
        extensions: ['rnc'],
      },
      'application/remote-printing': {
        source: 'iana',
      },
      'application/reputon+json': {
        source: 'iana',
        compressible: true,
      },
      'application/resource-lists+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['rl'],
      },
      'application/resource-lists-diff+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['rld'],
      },
      'application/rfc+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/riscos': {
        source: 'iana',
      },
      'application/rlmi+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/rls-services+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['rs'],
      },
      'application/route-apd+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['rapd'],
      },
      'application/route-s-tsid+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['sls'],
      },
      'application/route-usd+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['rusd'],
      },
      'application/rpki-ghostbusters': {
        source: 'iana',
        extensions: ['gbr'],
      },
      'application/rpki-manifest': {
        source: 'iana',
        extensions: ['mft'],
      },
      'application/rpki-publication': {
        source: 'iana',
      },
      'application/rpki-roa': {
        source: 'iana',
        extensions: ['roa'],
      },
      'application/rpki-updown': {
        source: 'iana',
      },
      'application/rsd+xml': {
        source: 'apache',
        compressible: true,
        extensions: ['rsd'],
      },
      'application/rss+xml': {
        source: 'apache',
        compressible: true,
        extensions: ['rss'],
      },
      'application/rtf': {
        source: 'iana',
        compressible: true,
        extensions: ['rtf'],
      },
      'application/rtploopback': {
        source: 'iana',
      },
      'application/rtx': {
        source: 'iana',
      },
      'application/samlassertion+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/samlmetadata+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/sarif+json': {
        source: 'iana',
        compressible: true,
      },
      'application/sarif-external-properties+json': {
        source: 'iana',
        compressible: true,
      },
      'application/sbe': {
        source: 'iana',
      },
      'application/sbml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['sbml'],
      },
      'application/scaip+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/scim+json': {
        source: 'iana',
        compressible: true,
      },
      'application/scvp-cv-request': {
        source: 'iana',
        extensions: ['scq'],
      },
      'application/scvp-cv-response': {
        source: 'iana',
        extensions: ['scs'],
      },
      'application/scvp-vp-request': {
        source: 'iana',
        extensions: ['spq'],
      },
      'application/scvp-vp-response': {
        source: 'iana',
        extensions: ['spp'],
      },
      'application/sdp': {
        source: 'iana',
        extensions: ['sdp'],
      },
      'application/secevent+jwt': {
        source: 'iana',
      },
      'application/senml+cbor': {
        source: 'iana',
      },
      'application/senml+json': {
        source: 'iana',
        compressible: true,
      },
      'application/senml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['senmlx'],
      },
      'application/senml-etch+cbor': {
        source: 'iana',
      },
      'application/senml-etch+json': {
        source: 'iana',
        compressible: true,
      },
      'application/senml-exi': {
        source: 'iana',
      },
      'application/sensml+cbor': {
        source: 'iana',
      },
      'application/sensml+json': {
        source: 'iana',
        compressible: true,
      },
      'application/sensml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['sensmlx'],
      },
      'application/sensml-exi': {
        source: 'iana',
      },
      'application/sep+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/sep-exi': {
        source: 'iana',
      },
      'application/session-info': {
        source: 'iana',
      },
      'application/set-payment': {
        source: 'iana',
      },
      'application/set-payment-initiation': {
        source: 'iana',
        extensions: ['setpay'],
      },
      'application/set-registration': {
        source: 'iana',
      },
      'application/set-registration-initiation': {
        source: 'iana',
        extensions: ['setreg'],
      },
      'application/sgml': {
        source: 'iana',
      },
      'application/sgml-open-catalog': {
        source: 'iana',
      },
      'application/shf+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['shf'],
      },
      'application/sieve': {
        source: 'iana',
        extensions: ['siv', 'sieve'],
      },
      'application/simple-filter+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/simple-message-summary': {
        source: 'iana',
      },
      'application/simplesymbolcontainer': {
        source: 'iana',
      },
      'application/sipc': {
        source: 'iana',
      },
      'application/slate': {
        source: 'iana',
      },
      'application/smil': {
        source: 'iana',
      },
      'application/smil+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['smi', 'smil'],
      },
      'application/smpte336m': {
        source: 'iana',
      },
      'application/soap+fastinfoset': {
        source: 'iana',
      },
      'application/soap+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/sparql-query': {
        source: 'iana',
        extensions: ['rq'],
      },
      'application/sparql-results+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['srx'],
      },
      'application/spdx+json': {
        source: 'iana',
        compressible: true,
      },
      'application/spirits-event+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/sql': {
        source: 'iana',
      },
      'application/srgs': {
        source: 'iana',
        extensions: ['gram'],
      },
      'application/srgs+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['grxml'],
      },
      'application/sru+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['sru'],
      },
      'application/ssdl+xml': {
        source: 'apache',
        compressible: true,
        extensions: ['ssdl'],
      },
      'application/ssml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['ssml'],
      },
      'application/stix+json': {
        source: 'iana',
        compressible: true,
      },
      'application/swid+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['swidtag'],
      },
      'application/tamp-apex-update': {
        source: 'iana',
      },
      'application/tamp-apex-update-confirm': {
        source: 'iana',
      },
      'application/tamp-community-update': {
        source: 'iana',
      },
      'application/tamp-community-update-confirm': {
        source: 'iana',
      },
      'application/tamp-error': {
        source: 'iana',
      },
      'application/tamp-sequence-adjust': {
        source: 'iana',
      },
      'application/tamp-sequence-adjust-confirm': {
        source: 'iana',
      },
      'application/tamp-status-query': {
        source: 'iana',
      },
      'application/tamp-status-response': {
        source: 'iana',
      },
      'application/tamp-update': {
        source: 'iana',
      },
      'application/tamp-update-confirm': {
        source: 'iana',
      },
      'application/tar': {
        compressible: true,
      },
      'application/taxii+json': {
        source: 'iana',
        compressible: true,
      },
      'application/td+json': {
        source: 'iana',
        compressible: true,
      },
      'application/tei+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['tei', 'teicorpus'],
      },
      'application/tetra_isi': {
        source: 'iana',
      },
      'application/thraud+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['tfi'],
      },
      'application/timestamp-query': {
        source: 'iana',
      },
      'application/timestamp-reply': {
        source: 'iana',
      },
      'application/timestamped-data': {
        source: 'iana',
        extensions: ['tsd'],
      },
      'application/tlsrpt+gzip': {
        source: 'iana',
      },
      'application/tlsrpt+json': {
        source: 'iana',
        compressible: true,
      },
      'application/tnauthlist': {
        source: 'iana',
      },
      'application/token-introspection+jwt': {
        source: 'iana',
      },
      'application/toml': {
        compressible: true,
        extensions: ['toml'],
      },
      'application/trickle-ice-sdpfrag': {
        source: 'iana',
      },
      'application/trig': {
        source: 'iana',
        extensions: ['trig'],
      },
      'application/ttml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['ttml'],
      },
      'application/tve-trigger': {
        source: 'iana',
      },
      'application/tzif': {
        source: 'iana',
      },
      'application/tzif-leap': {
        source: 'iana',
      },
      'application/ubjson': {
        compressible: false,
        extensions: ['ubj'],
      },
      'application/ulpfec': {
        source: 'iana',
      },
      'application/urc-grpsheet+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/urc-ressheet+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['rsheet'],
      },
      'application/urc-targetdesc+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['td'],
      },
      'application/urc-uisocketdesc+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vcard+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vcard+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vemmi': {
        source: 'iana',
      },
      'application/vividence.scriptfile': {
        source: 'apache',
      },
      'application/vnd.1000minds.decision-model+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['1km'],
      },
      'application/vnd.3gpp-prose+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp-prose-pc3ch+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp-v2x-local-service-information': {
        source: 'iana',
      },
      'application/vnd.3gpp.5gnas': {
        source: 'iana',
      },
      'application/vnd.3gpp.access-transfer-events+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.bsf+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.gmop+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.gtpc': {
        source: 'iana',
      },
      'application/vnd.3gpp.interworking-data': {
        source: 'iana',
      },
      'application/vnd.3gpp.lpp': {
        source: 'iana',
      },
      'application/vnd.3gpp.mc-signalling-ear': {
        source: 'iana',
      },
      'application/vnd.3gpp.mcdata-affiliation-command+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcdata-info+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcdata-payload': {
        source: 'iana',
      },
      'application/vnd.3gpp.mcdata-service-config+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcdata-signalling': {
        source: 'iana',
      },
      'application/vnd.3gpp.mcdata-ue-config+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcdata-user-profile+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcptt-affiliation-command+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcptt-floor-request+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcptt-info+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcptt-location-info+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcptt-mbms-usage-info+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcptt-service-config+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcptt-signed+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcptt-ue-config+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcptt-ue-init-config+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcptt-user-profile+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcvideo-affiliation-command+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcvideo-affiliation-info+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcvideo-info+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcvideo-location-info+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcvideo-mbms-usage-info+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcvideo-service-config+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcvideo-transmission-request+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcvideo-ue-config+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mcvideo-user-profile+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.mid-call+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.ngap': {
        source: 'iana',
      },
      'application/vnd.3gpp.pfcp': {
        source: 'iana',
      },
      'application/vnd.3gpp.pic-bw-large': {
        source: 'iana',
        extensions: ['plb'],
      },
      'application/vnd.3gpp.pic-bw-small': {
        source: 'iana',
        extensions: ['psb'],
      },
      'application/vnd.3gpp.pic-bw-var': {
        source: 'iana',
        extensions: ['pvb'],
      },
      'application/vnd.3gpp.s1ap': {
        source: 'iana',
      },
      'application/vnd.3gpp.sms': {
        source: 'iana',
      },
      'application/vnd.3gpp.sms+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.srvcc-ext+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.srvcc-info+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.state-and-event-info+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp.ussd+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp2.bcmcsinfo+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.3gpp2.sms': {
        source: 'iana',
      },
      'application/vnd.3gpp2.tcap': {
        source: 'iana',
        extensions: ['tcap'],
      },
      'application/vnd.3lightssoftware.imagescal': {
        source: 'iana',
      },
      'application/vnd.3m.post-it-notes': {
        source: 'iana',
        extensions: ['pwn'],
      },
      'application/vnd.accpac.simply.aso': {
        source: 'iana',
        extensions: ['aso'],
      },
      'application/vnd.accpac.simply.imp': {
        source: 'iana',
        extensions: ['imp'],
      },
      'application/vnd.acucobol': {
        source: 'iana',
        extensions: ['acu'],
      },
      'application/vnd.acucorp': {
        source: 'iana',
        extensions: ['atc', 'acutc'],
      },
      'application/vnd.adobe.air-application-installer-package+zip': {
        source: 'apache',
        compressible: false,
        extensions: ['air'],
      },
      'application/vnd.adobe.flash.movie': {
        source: 'iana',
      },
      'application/vnd.adobe.formscentral.fcdt': {
        source: 'iana',
        extensions: ['fcdt'],
      },
      'application/vnd.adobe.fxp': {
        source: 'iana',
        extensions: ['fxp', 'fxpl'],
      },
      'application/vnd.adobe.partial-upload': {
        source: 'iana',
      },
      'application/vnd.adobe.xdp+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xdp'],
      },
      'application/vnd.adobe.xfdf': {
        source: 'iana',
        extensions: ['xfdf'],
      },
      'application/vnd.aether.imp': {
        source: 'iana',
      },
      'application/vnd.afpc.afplinedata': {
        source: 'iana',
      },
      'application/vnd.afpc.afplinedata-pagedef': {
        source: 'iana',
      },
      'application/vnd.afpc.cmoca-cmresource': {
        source: 'iana',
      },
      'application/vnd.afpc.foca-charset': {
        source: 'iana',
      },
      'application/vnd.afpc.foca-codedfont': {
        source: 'iana',
      },
      'application/vnd.afpc.foca-codepage': {
        source: 'iana',
      },
      'application/vnd.afpc.modca': {
        source: 'iana',
      },
      'application/vnd.afpc.modca-cmtable': {
        source: 'iana',
      },
      'application/vnd.afpc.modca-formdef': {
        source: 'iana',
      },
      'application/vnd.afpc.modca-mediummap': {
        source: 'iana',
      },
      'application/vnd.afpc.modca-objectcontainer': {
        source: 'iana',
      },
      'application/vnd.afpc.modca-overlay': {
        source: 'iana',
      },
      'application/vnd.afpc.modca-pagesegment': {
        source: 'iana',
      },
      'application/vnd.age': {
        source: 'iana',
        extensions: ['age'],
      },
      'application/vnd.ah-barcode': {
        source: 'iana',
      },
      'application/vnd.ahead.space': {
        source: 'iana',
        extensions: ['ahead'],
      },
      'application/vnd.airzip.filesecure.azf': {
        source: 'iana',
        extensions: ['azf'],
      },
      'application/vnd.airzip.filesecure.azs': {
        source: 'iana',
        extensions: ['azs'],
      },
      'application/vnd.amadeus+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.amazon.ebook': {
        source: 'apache',
        extensions: ['azw'],
      },
      'application/vnd.amazon.mobi8-ebook': {
        source: 'iana',
      },
      'application/vnd.americandynamics.acc': {
        source: 'iana',
        extensions: ['acc'],
      },
      'application/vnd.amiga.ami': {
        source: 'iana',
        extensions: ['ami'],
      },
      'application/vnd.amundsen.maze+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.android.ota': {
        source: 'iana',
      },
      'application/vnd.android.package-archive': {
        source: 'apache',
        compressible: false,
        extensions: ['apk'],
      },
      'application/vnd.anki': {
        source: 'iana',
      },
      'application/vnd.anser-web-certificate-issue-initiation': {
        source: 'iana',
        extensions: ['cii'],
      },
      'application/vnd.anser-web-funds-transfer-initiation': {
        source: 'apache',
        extensions: ['fti'],
      },
      'application/vnd.antix.game-component': {
        source: 'iana',
        extensions: ['atx'],
      },
      'application/vnd.apache.arrow.file': {
        source: 'iana',
      },
      'application/vnd.apache.arrow.stream': {
        source: 'iana',
      },
      'application/vnd.apache.thrift.binary': {
        source: 'iana',
      },
      'application/vnd.apache.thrift.compact': {
        source: 'iana',
      },
      'application/vnd.apache.thrift.json': {
        source: 'iana',
      },
      'application/vnd.api+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.aplextor.warrp+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.apothekende.reservation+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.apple.installer+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['mpkg'],
      },
      'application/vnd.apple.keynote': {
        source: 'iana',
        extensions: ['key'],
      },
      'application/vnd.apple.mpegurl': {
        source: 'iana',
        extensions: ['m3u8'],
      },
      'application/vnd.apple.numbers': {
        source: 'iana',
        extensions: ['numbers'],
      },
      'application/vnd.apple.pages': {
        source: 'iana',
        extensions: ['pages'],
      },
      'application/vnd.apple.pkpass': {
        compressible: false,
        extensions: ['pkpass'],
      },
      'application/vnd.arastra.swi': {
        source: 'iana',
      },
      'application/vnd.aristanetworks.swi': {
        source: 'iana',
        extensions: ['swi'],
      },
      'application/vnd.artisan+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.artsquare': {
        source: 'iana',
      },
      'application/vnd.astraea-software.iota': {
        source: 'iana',
        extensions: ['iota'],
      },
      'application/vnd.audiograph': {
        source: 'iana',
        extensions: ['aep'],
      },
      'application/vnd.autopackage': {
        source: 'iana',
      },
      'application/vnd.avalon+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.avistar+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.balsamiq.bmml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['bmml'],
      },
      'application/vnd.balsamiq.bmpr': {
        source: 'iana',
      },
      'application/vnd.banana-accounting': {
        source: 'iana',
      },
      'application/vnd.bbf.usp.error': {
        source: 'iana',
      },
      'application/vnd.bbf.usp.msg': {
        source: 'iana',
      },
      'application/vnd.bbf.usp.msg+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.bekitzur-stech+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.bint.med-content': {
        source: 'iana',
      },
      'application/vnd.biopax.rdf+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.blink-idb-value-wrapper': {
        source: 'iana',
      },
      'application/vnd.blueice.multipass': {
        source: 'iana',
        extensions: ['mpm'],
      },
      'application/vnd.bluetooth.ep.oob': {
        source: 'iana',
      },
      'application/vnd.bluetooth.le.oob': {
        source: 'iana',
      },
      'application/vnd.bmi': {
        source: 'iana',
        extensions: ['bmi'],
      },
      'application/vnd.bpf': {
        source: 'iana',
      },
      'application/vnd.bpf3': {
        source: 'iana',
      },
      'application/vnd.businessobjects': {
        source: 'iana',
        extensions: ['rep'],
      },
      'application/vnd.byu.uapi+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.cab-jscript': {
        source: 'iana',
      },
      'application/vnd.canon-cpdl': {
        source: 'iana',
      },
      'application/vnd.canon-lips': {
        source: 'iana',
      },
      'application/vnd.capasystems-pg+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.cendio.thinlinc.clientconf': {
        source: 'iana',
      },
      'application/vnd.century-systems.tcp_stream': {
        source: 'iana',
      },
      'application/vnd.chemdraw+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['cdxml'],
      },
      'application/vnd.chess-pgn': {
        source: 'iana',
      },
      'application/vnd.chipnuts.karaoke-mmd': {
        source: 'iana',
        extensions: ['mmd'],
      },
      'application/vnd.ciedi': {
        source: 'iana',
      },
      'application/vnd.cinderella': {
        source: 'iana',
        extensions: ['cdy'],
      },
      'application/vnd.cirpack.isdn-ext': {
        source: 'iana',
      },
      'application/vnd.citationstyles.style+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['csl'],
      },
      'application/vnd.claymore': {
        source: 'iana',
        extensions: ['cla'],
      },
      'application/vnd.cloanto.rp9': {
        source: 'iana',
        extensions: ['rp9'],
      },
      'application/vnd.clonk.c4group': {
        source: 'iana',
        extensions: ['c4g', 'c4d', 'c4f', 'c4p', 'c4u'],
      },
      'application/vnd.cluetrust.cartomobile-config': {
        source: 'iana',
        extensions: ['c11amc'],
      },
      'application/vnd.cluetrust.cartomobile-config-pkg': {
        source: 'iana',
        extensions: ['c11amz'],
      },
      'application/vnd.coffeescript': {
        source: 'iana',
      },
      'application/vnd.collabio.xodocuments.document': {
        source: 'iana',
      },
      'application/vnd.collabio.xodocuments.document-template': {
        source: 'iana',
      },
      'application/vnd.collabio.xodocuments.presentation': {
        source: 'iana',
      },
      'application/vnd.collabio.xodocuments.presentation-template': {
        source: 'iana',
      },
      'application/vnd.collabio.xodocuments.spreadsheet': {
        source: 'iana',
      },
      'application/vnd.collabio.xodocuments.spreadsheet-template': {
        source: 'iana',
      },
      'application/vnd.collection+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.collection.doc+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.collection.next+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.comicbook+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/vnd.comicbook-rar': {
        source: 'iana',
      },
      'application/vnd.commerce-battelle': {
        source: 'iana',
      },
      'application/vnd.commonspace': {
        source: 'iana',
        extensions: ['csp'],
      },
      'application/vnd.contact.cmsg': {
        source: 'iana',
        extensions: ['cdbcmsg'],
      },
      'application/vnd.coreos.ignition+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.cosmocaller': {
        source: 'iana',
        extensions: ['cmc'],
      },
      'application/vnd.crick.clicker': {
        source: 'iana',
        extensions: ['clkx'],
      },
      'application/vnd.crick.clicker.keyboard': {
        source: 'iana',
        extensions: ['clkk'],
      },
      'application/vnd.crick.clicker.palette': {
        source: 'iana',
        extensions: ['clkp'],
      },
      'application/vnd.crick.clicker.template': {
        source: 'iana',
        extensions: ['clkt'],
      },
      'application/vnd.crick.clicker.wordbank': {
        source: 'iana',
        extensions: ['clkw'],
      },
      'application/vnd.criticaltools.wbs+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['wbs'],
      },
      'application/vnd.cryptii.pipe+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.crypto-shade-file': {
        source: 'iana',
      },
      'application/vnd.cryptomator.encrypted': {
        source: 'iana',
      },
      'application/vnd.cryptomator.vault': {
        source: 'iana',
      },
      'application/vnd.ctc-posml': {
        source: 'iana',
        extensions: ['pml'],
      },
      'application/vnd.ctct.ws+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.cups-pdf': {
        source: 'iana',
      },
      'application/vnd.cups-postscript': {
        source: 'iana',
      },
      'application/vnd.cups-ppd': {
        source: 'iana',
        extensions: ['ppd'],
      },
      'application/vnd.cups-raster': {
        source: 'iana',
      },
      'application/vnd.cups-raw': {
        source: 'iana',
      },
      'application/vnd.curl': {
        source: 'iana',
      },
      'application/vnd.curl.car': {
        source: 'apache',
        extensions: ['car'],
      },
      'application/vnd.curl.pcurl': {
        source: 'apache',
        extensions: ['pcurl'],
      },
      'application/vnd.cyan.dean.root+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.cybank': {
        source: 'iana',
      },
      'application/vnd.cyclonedx+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.cyclonedx+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.d2l.coursepackage1p0+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/vnd.d3m-dataset': {
        source: 'iana',
      },
      'application/vnd.d3m-problem': {
        source: 'iana',
      },
      'application/vnd.dart': {
        source: 'iana',
        compressible: true,
        extensions: ['dart'],
      },
      'application/vnd.data-vision.rdz': {
        source: 'iana',
        extensions: ['rdz'],
      },
      'application/vnd.datapackage+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.dataresource+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.dbf': {
        source: 'iana',
        extensions: ['dbf'],
      },
      'application/vnd.debian.binary-package': {
        source: 'iana',
      },
      'application/vnd.dece.data': {
        source: 'iana',
        extensions: ['uvf', 'uvvf', 'uvd', 'uvvd'],
      },
      'application/vnd.dece.ttml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['uvt', 'uvvt'],
      },
      'application/vnd.dece.unspecified': {
        source: 'iana',
        extensions: ['uvx', 'uvvx'],
      },
      'application/vnd.dece.zip': {
        source: 'iana',
        extensions: ['uvz', 'uvvz'],
      },
      'application/vnd.denovo.fcselayout-link': {
        source: 'iana',
        extensions: ['fe_launch'],
      },
      'application/vnd.desmume.movie': {
        source: 'iana',
      },
      'application/vnd.dir-bi.plate-dl-nosuffix': {
        source: 'iana',
      },
      'application/vnd.dm.delegation+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.dna': {
        source: 'iana',
        extensions: ['dna'],
      },
      'application/vnd.document+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.dolby.mlp': {
        source: 'apache',
        extensions: ['mlp'],
      },
      'application/vnd.dolby.mobile.1': {
        source: 'iana',
      },
      'application/vnd.dolby.mobile.2': {
        source: 'iana',
      },
      'application/vnd.doremir.scorecloud-binary-document': {
        source: 'iana',
      },
      'application/vnd.dpgraph': {
        source: 'iana',
        extensions: ['dpg'],
      },
      'application/vnd.dreamfactory': {
        source: 'iana',
        extensions: ['dfac'],
      },
      'application/vnd.drive+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.ds-keypoint': {
        source: 'apache',
        extensions: ['kpxx'],
      },
      'application/vnd.dtg.local': {
        source: 'iana',
      },
      'application/vnd.dtg.local.flash': {
        source: 'iana',
      },
      'application/vnd.dtg.local.html': {
        source: 'iana',
      },
      'application/vnd.dvb.ait': {
        source: 'iana',
        extensions: ['ait'],
      },
      'application/vnd.dvb.dvbisl+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.dvb.dvbj': {
        source: 'iana',
      },
      'application/vnd.dvb.esgcontainer': {
        source: 'iana',
      },
      'application/vnd.dvb.ipdcdftnotifaccess': {
        source: 'iana',
      },
      'application/vnd.dvb.ipdcesgaccess': {
        source: 'iana',
      },
      'application/vnd.dvb.ipdcesgaccess2': {
        source: 'iana',
      },
      'application/vnd.dvb.ipdcesgpdd': {
        source: 'iana',
      },
      'application/vnd.dvb.ipdcroaming': {
        source: 'iana',
      },
      'application/vnd.dvb.iptv.alfec-base': {
        source: 'iana',
      },
      'application/vnd.dvb.iptv.alfec-enhancement': {
        source: 'iana',
      },
      'application/vnd.dvb.notif-aggregate-root+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.dvb.notif-container+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.dvb.notif-generic+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.dvb.notif-ia-msglist+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.dvb.notif-ia-registration-request+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.dvb.notif-ia-registration-response+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.dvb.notif-init+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.dvb.pfr': {
        source: 'iana',
      },
      'application/vnd.dvb.service': {
        source: 'iana',
        extensions: ['svc'],
      },
      'application/vnd.dxr': {
        source: 'iana',
      },
      'application/vnd.dynageo': {
        source: 'iana',
        extensions: ['geo'],
      },
      'application/vnd.dzr': {
        source: 'iana',
      },
      'application/vnd.easykaraoke.cdgdownload': {
        source: 'iana',
      },
      'application/vnd.ecdis-update': {
        source: 'iana',
      },
      'application/vnd.ecip.rlp': {
        source: 'iana',
      },
      'application/vnd.eclipse.ditto+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.ecowin.chart': {
        source: 'iana',
        extensions: ['mag'],
      },
      'application/vnd.ecowin.filerequest': {
        source: 'iana',
      },
      'application/vnd.ecowin.fileupdate': {
        source: 'iana',
      },
      'application/vnd.ecowin.series': {
        source: 'iana',
      },
      'application/vnd.ecowin.seriesrequest': {
        source: 'iana',
      },
      'application/vnd.ecowin.seriesupdate': {
        source: 'iana',
      },
      'application/vnd.efi.img': {
        source: 'iana',
      },
      'application/vnd.efi.iso': {
        source: 'iana',
      },
      'application/vnd.emclient.accessrequest+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.enliven': {
        source: 'iana',
        extensions: ['nml'],
      },
      'application/vnd.enphase.envoy': {
        source: 'iana',
      },
      'application/vnd.eprints.data+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.epson.esf': {
        source: 'iana',
        extensions: ['esf'],
      },
      'application/vnd.epson.msf': {
        source: 'iana',
        extensions: ['msf'],
      },
      'application/vnd.epson.quickanime': {
        source: 'iana',
        extensions: ['qam'],
      },
      'application/vnd.epson.salt': {
        source: 'iana',
        extensions: ['slt'],
      },
      'application/vnd.epson.ssf': {
        source: 'iana',
        extensions: ['ssf'],
      },
      'application/vnd.ericsson.quickcall': {
        source: 'iana',
      },
      'application/vnd.espass-espass+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/vnd.eszigno3+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['es3', 'et3'],
      },
      'application/vnd.etsi.aoc+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.asic-e+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/vnd.etsi.asic-s+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/vnd.etsi.cug+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.iptvcommand+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.iptvdiscovery+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.iptvprofile+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.iptvsad-bc+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.iptvsad-cod+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.iptvsad-npvr+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.iptvservice+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.iptvsync+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.iptvueprofile+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.mcid+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.mheg5': {
        source: 'iana',
      },
      'application/vnd.etsi.overload-control-policy-dataset+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.pstn+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.sci+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.simservs+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.timestamp-token': {
        source: 'iana',
      },
      'application/vnd.etsi.tsl+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.etsi.tsl.der': {
        source: 'iana',
      },
      'application/vnd.eu.kasparian.car+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.eudora.data': {
        source: 'iana',
      },
      'application/vnd.evolv.ecig.profile': {
        source: 'iana',
      },
      'application/vnd.evolv.ecig.settings': {
        source: 'iana',
      },
      'application/vnd.evolv.ecig.theme': {
        source: 'iana',
      },
      'application/vnd.exstream-empower+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/vnd.exstream-package': {
        source: 'iana',
      },
      'application/vnd.ezpix-album': {
        source: 'iana',
        extensions: ['ez2'],
      },
      'application/vnd.ezpix-package': {
        source: 'iana',
        extensions: ['ez3'],
      },
      'application/vnd.f-secure.mobile': {
        source: 'iana',
      },
      'application/vnd.familysearch.gedcom+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/vnd.fastcopy-disk-image': {
        source: 'iana',
      },
      'application/vnd.fdf': {
        source: 'iana',
        extensions: ['fdf'],
      },
      'application/vnd.fdsn.mseed': {
        source: 'iana',
        extensions: ['mseed'],
      },
      'application/vnd.fdsn.seed': {
        source: 'iana',
        extensions: ['seed', 'dataless'],
      },
      'application/vnd.ffsns': {
        source: 'iana',
      },
      'application/vnd.ficlab.flb+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/vnd.filmit.zfc': {
        source: 'iana',
      },
      'application/vnd.fints': {
        source: 'iana',
      },
      'application/vnd.firemonkeys.cloudcell': {
        source: 'iana',
      },
      'application/vnd.flographit': {
        source: 'iana',
        extensions: ['gph'],
      },
      'application/vnd.fluxtime.clip': {
        source: 'iana',
        extensions: ['ftc'],
      },
      'application/vnd.font-fontforge-sfd': {
        source: 'iana',
      },
      'application/vnd.framemaker': {
        source: 'iana',
        extensions: ['fm', 'frame', 'maker', 'book'],
      },
      'application/vnd.frogans.fnc': {
        source: 'iana',
        extensions: ['fnc'],
      },
      'application/vnd.frogans.ltf': {
        source: 'iana',
        extensions: ['ltf'],
      },
      'application/vnd.fsc.weblaunch': {
        source: 'iana',
        extensions: ['fsc'],
      },
      'application/vnd.fujifilm.fb.docuworks': {
        source: 'iana',
      },
      'application/vnd.fujifilm.fb.docuworks.binder': {
        source: 'iana',
      },
      'application/vnd.fujifilm.fb.docuworks.container': {
        source: 'iana',
      },
      'application/vnd.fujifilm.fb.jfi+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.fujitsu.oasys': {
        source: 'iana',
        extensions: ['oas'],
      },
      'application/vnd.fujitsu.oasys2': {
        source: 'iana',
        extensions: ['oa2'],
      },
      'application/vnd.fujitsu.oasys3': {
        source: 'iana',
        extensions: ['oa3'],
      },
      'application/vnd.fujitsu.oasysgp': {
        source: 'iana',
        extensions: ['fg5'],
      },
      'application/vnd.fujitsu.oasysprs': {
        source: 'iana',
        extensions: ['bh2'],
      },
      'application/vnd.fujixerox.art-ex': {
        source: 'iana',
      },
      'application/vnd.fujixerox.art4': {
        source: 'iana',
      },
      'application/vnd.fujixerox.ddd': {
        source: 'iana',
        extensions: ['ddd'],
      },
      'application/vnd.fujixerox.docuworks': {
        source: 'iana',
        extensions: ['xdw'],
      },
      'application/vnd.fujixerox.docuworks.binder': {
        source: 'iana',
        extensions: ['xbd'],
      },
      'application/vnd.fujixerox.docuworks.container': {
        source: 'iana',
      },
      'application/vnd.fujixerox.hbpl': {
        source: 'iana',
      },
      'application/vnd.fut-misnet': {
        source: 'iana',
      },
      'application/vnd.futoin+cbor': {
        source: 'iana',
      },
      'application/vnd.futoin+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.fuzzysheet': {
        source: 'iana',
        extensions: ['fzs'],
      },
      'application/vnd.genomatix.tuxedo': {
        source: 'iana',
        extensions: ['txd'],
      },
      'application/vnd.gentics.grd+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.geo+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.geocube+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.geogebra.file': {
        source: 'iana',
        extensions: ['ggb'],
      },
      'application/vnd.geogebra.slides': {
        source: 'iana',
      },
      'application/vnd.geogebra.tool': {
        source: 'iana',
        extensions: ['ggt'],
      },
      'application/vnd.geometry-explorer': {
        source: 'iana',
        extensions: ['gex', 'gre'],
      },
      'application/vnd.geonext': {
        source: 'iana',
        extensions: ['gxt'],
      },
      'application/vnd.geoplan': {
        source: 'iana',
        extensions: ['g2w'],
      },
      'application/vnd.geospace': {
        source: 'iana',
        extensions: ['g3w'],
      },
      'application/vnd.gerber': {
        source: 'iana',
      },
      'application/vnd.globalplatform.card-content-mgt': {
        source: 'iana',
      },
      'application/vnd.globalplatform.card-content-mgt-response': {
        source: 'iana',
      },
      'application/vnd.gmx': {
        source: 'iana',
        extensions: ['gmx'],
      },
      'application/vnd.google-apps.document': {
        compressible: false,
        extensions: ['gdoc'],
      },
      'application/vnd.google-apps.presentation': {
        compressible: false,
        extensions: ['gslides'],
      },
      'application/vnd.google-apps.spreadsheet': {
        compressible: false,
        extensions: ['gsheet'],
      },
      'application/vnd.google-earth.kml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['kml'],
      },
      'application/vnd.google-earth.kmz': {
        source: 'iana',
        compressible: false,
        extensions: ['kmz'],
      },
      'application/vnd.gov.sk.e-form+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.gov.sk.e-form+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/vnd.gov.sk.xmldatacontainer+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.grafeq': {
        source: 'iana',
        extensions: ['gqf', 'gqs'],
      },
      'application/vnd.gridmp': {
        source: 'iana',
      },
      'application/vnd.groove-account': {
        source: 'iana',
        extensions: ['gac'],
      },
      'application/vnd.groove-help': {
        source: 'iana',
        extensions: ['ghf'],
      },
      'application/vnd.groove-identity-message': {
        source: 'iana',
        extensions: ['gim'],
      },
      'application/vnd.groove-injector': {
        source: 'iana',
        extensions: ['grv'],
      },
      'application/vnd.groove-tool-message': {
        source: 'iana',
        extensions: ['gtm'],
      },
      'application/vnd.groove-tool-template': {
        source: 'iana',
        extensions: ['tpl'],
      },
      'application/vnd.groove-vcard': {
        source: 'iana',
        extensions: ['vcg'],
      },
      'application/vnd.hal+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.hal+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['hal'],
      },
      'application/vnd.handheld-entertainment+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['zmm'],
      },
      'application/vnd.hbci': {
        source: 'iana',
        extensions: ['hbci'],
      },
      'application/vnd.hc+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.hcl-bireports': {
        source: 'iana',
      },
      'application/vnd.hdt': {
        source: 'iana',
      },
      'application/vnd.heroku+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.hhe.lesson-player': {
        source: 'iana',
        extensions: ['les'],
      },
      'application/vnd.hl7cda+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/vnd.hl7v2+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/vnd.hp-hpgl': {
        source: 'iana',
        extensions: ['hpgl'],
      },
      'application/vnd.hp-hpid': {
        source: 'iana',
        extensions: ['hpid'],
      },
      'application/vnd.hp-hps': {
        source: 'iana',
        extensions: ['hps'],
      },
      'application/vnd.hp-jlyt': {
        source: 'iana',
        extensions: ['jlt'],
      },
      'application/vnd.hp-pcl': {
        source: 'iana',
        extensions: ['pcl'],
      },
      'application/vnd.hp-pclxl': {
        source: 'iana',
        extensions: ['pclxl'],
      },
      'application/vnd.httphone': {
        source: 'iana',
      },
      'application/vnd.hydrostatix.sof-data': {
        source: 'iana',
        extensions: ['sfd-hdstx'],
      },
      'application/vnd.hyper+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.hyper-item+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.hyperdrive+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.hzn-3d-crossword': {
        source: 'iana',
      },
      'application/vnd.ibm.afplinedata': {
        source: 'iana',
      },
      'application/vnd.ibm.electronic-media': {
        source: 'iana',
      },
      'application/vnd.ibm.minipay': {
        source: 'iana',
        extensions: ['mpy'],
      },
      'application/vnd.ibm.modcap': {
        source: 'iana',
        extensions: ['afp', 'listafp', 'list3820'],
      },
      'application/vnd.ibm.rights-management': {
        source: 'iana',
        extensions: ['irm'],
      },
      'application/vnd.ibm.secure-container': {
        source: 'iana',
        extensions: ['sc'],
      },
      'application/vnd.iccprofile': {
        source: 'iana',
        extensions: ['icc', 'icm'],
      },
      'application/vnd.ieee.1905': {
        source: 'iana',
      },
      'application/vnd.igloader': {
        source: 'iana',
        extensions: ['igl'],
      },
      'application/vnd.imagemeter.folder+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/vnd.imagemeter.image+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/vnd.immervision-ivp': {
        source: 'iana',
        extensions: ['ivp'],
      },
      'application/vnd.immervision-ivu': {
        source: 'iana',
        extensions: ['ivu'],
      },
      'application/vnd.ims.imsccv1p1': {
        source: 'iana',
      },
      'application/vnd.ims.imsccv1p2': {
        source: 'iana',
      },
      'application/vnd.ims.imsccv1p3': {
        source: 'iana',
      },
      'application/vnd.ims.lis.v2.result+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.ims.lti.v2.toolconsumerprofile+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.ims.lti.v2.toolproxy+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.ims.lti.v2.toolproxy.id+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.ims.lti.v2.toolsettings+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.ims.lti.v2.toolsettings.simple+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.informedcontrol.rms+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.informix-visionary': {
        source: 'iana',
      },
      'application/vnd.infotech.project': {
        source: 'iana',
      },
      'application/vnd.infotech.project+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.innopath.wamp.notification': {
        source: 'iana',
      },
      'application/vnd.insors.igm': {
        source: 'iana',
        extensions: ['igm'],
      },
      'application/vnd.intercon.formnet': {
        source: 'iana',
        extensions: ['xpw', 'xpx'],
      },
      'application/vnd.intergeo': {
        source: 'iana',
        extensions: ['i2g'],
      },
      'application/vnd.intertrust.digibox': {
        source: 'iana',
      },
      'application/vnd.intertrust.nncp': {
        source: 'iana',
      },
      'application/vnd.intu.qbo': {
        source: 'iana',
        extensions: ['qbo'],
      },
      'application/vnd.intu.qfx': {
        source: 'iana',
        extensions: ['qfx'],
      },
      'application/vnd.iptc.g2.catalogitem+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.iptc.g2.conceptitem+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.iptc.g2.knowledgeitem+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.iptc.g2.newsitem+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.iptc.g2.newsmessage+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.iptc.g2.packageitem+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.iptc.g2.planningitem+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.ipunplugged.rcprofile': {
        source: 'iana',
        extensions: ['rcprofile'],
      },
      'application/vnd.irepository.package+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['irp'],
      },
      'application/vnd.is-xpr': {
        source: 'iana',
        extensions: ['xpr'],
      },
      'application/vnd.isac.fcs': {
        source: 'iana',
        extensions: ['fcs'],
      },
      'application/vnd.iso11783-10+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/vnd.jam': {
        source: 'iana',
        extensions: ['jam'],
      },
      'application/vnd.japannet-directory-service': {
        source: 'iana',
      },
      'application/vnd.japannet-jpnstore-wakeup': {
        source: 'iana',
      },
      'application/vnd.japannet-payment-wakeup': {
        source: 'iana',
      },
      'application/vnd.japannet-registration': {
        source: 'iana',
      },
      'application/vnd.japannet-registration-wakeup': {
        source: 'iana',
      },
      'application/vnd.japannet-setstore-wakeup': {
        source: 'iana',
      },
      'application/vnd.japannet-verification': {
        source: 'iana',
      },
      'application/vnd.japannet-verification-wakeup': {
        source: 'iana',
      },
      'application/vnd.jcp.javame.midlet-rms': {
        source: 'iana',
        extensions: ['rms'],
      },
      'application/vnd.jisp': {
        source: 'iana',
        extensions: ['jisp'],
      },
      'application/vnd.joost.joda-archive': {
        source: 'iana',
        extensions: ['joda'],
      },
      'application/vnd.jsk.isdn-ngn': {
        source: 'iana',
      },
      'application/vnd.kahootz': {
        source: 'iana',
        extensions: ['ktz', 'ktr'],
      },
      'application/vnd.kde.karbon': {
        source: 'iana',
        extensions: ['karbon'],
      },
      'application/vnd.kde.kchart': {
        source: 'iana',
        extensions: ['chrt'],
      },
      'application/vnd.kde.kformula': {
        source: 'iana',
        extensions: ['kfo'],
      },
      'application/vnd.kde.kivio': {
        source: 'iana',
        extensions: ['flw'],
      },
      'application/vnd.kde.kontour': {
        source: 'iana',
        extensions: ['kon'],
      },
      'application/vnd.kde.kpresenter': {
        source: 'iana',
        extensions: ['kpr', 'kpt'],
      },
      'application/vnd.kde.kspread': {
        source: 'iana',
        extensions: ['ksp'],
      },
      'application/vnd.kde.kword': {
        source: 'iana',
        extensions: ['kwd', 'kwt'],
      },
      'application/vnd.kenameaapp': {
        source: 'iana',
        extensions: ['htke'],
      },
      'application/vnd.kidspiration': {
        source: 'iana',
        extensions: ['kia'],
      },
      'application/vnd.kinar': {
        source: 'iana',
        extensions: ['kne', 'knp'],
      },
      'application/vnd.koan': {
        source: 'iana',
        extensions: ['skp', 'skd', 'skt', 'skm'],
      },
      'application/vnd.kodak-descriptor': {
        source: 'iana',
        extensions: ['sse'],
      },
      'application/vnd.las': {
        source: 'iana',
      },
      'application/vnd.las.las+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.las.las+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['lasxml'],
      },
      'application/vnd.laszip': {
        source: 'iana',
      },
      'application/vnd.leap+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.liberty-request+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.llamagraphics.life-balance.desktop': {
        source: 'iana',
        extensions: ['lbd'],
      },
      'application/vnd.llamagraphics.life-balance.exchange+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['lbe'],
      },
      'application/vnd.logipipe.circuit+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/vnd.loom': {
        source: 'iana',
      },
      'application/vnd.lotus-1-2-3': {
        source: 'iana',
        extensions: ['123'],
      },
      'application/vnd.lotus-approach': {
        source: 'iana',
        extensions: ['apr'],
      },
      'application/vnd.lotus-freelance': {
        source: 'iana',
        extensions: ['pre'],
      },
      'application/vnd.lotus-notes': {
        source: 'iana',
        extensions: ['nsf'],
      },
      'application/vnd.lotus-organizer': {
        source: 'iana',
        extensions: ['org'],
      },
      'application/vnd.lotus-screencam': {
        source: 'iana',
        extensions: ['scm'],
      },
      'application/vnd.lotus-wordpro': {
        source: 'iana',
        extensions: ['lwp'],
      },
      'application/vnd.macports.portpkg': {
        source: 'iana',
        extensions: ['portpkg'],
      },
      'application/vnd.mapbox-vector-tile': {
        source: 'iana',
        extensions: ['mvt'],
      },
      'application/vnd.marlin.drm.actiontoken+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.marlin.drm.conftoken+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.marlin.drm.license+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.marlin.drm.mdcf': {
        source: 'iana',
      },
      'application/vnd.mason+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.maxar.archive.3tz+zip': {
        source: 'iana',
        compressible: false,
      },
      'application/vnd.maxmind.maxmind-db': {
        source: 'iana',
      },
      'application/vnd.mcd': {
        source: 'iana',
        extensions: ['mcd'],
      },
      'application/vnd.medcalcdata': {
        source: 'iana',
        extensions: ['mc1'],
      },
      'application/vnd.mediastation.cdkey': {
        source: 'iana',
        extensions: ['cdkey'],
      },
      'application/vnd.meridian-slingshot': {
        source: 'iana',
      },
      'application/vnd.mfer': {
        source: 'iana',
        extensions: ['mwf'],
      },
      'application/vnd.mfmp': {
        source: 'iana',
        extensions: ['mfm'],
      },
      'application/vnd.micro+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.micrografx.flo': {
        source: 'iana',
        extensions: ['flo'],
      },
      'application/vnd.micrografx.igx': {
        source: 'iana',
        extensions: ['igx'],
      },
      'application/vnd.microsoft.portable-executable': {
        source: 'iana',
      },
      'application/vnd.microsoft.windows.thumbnail-cache': {
        source: 'iana',
      },
      'application/vnd.miele+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.mif': {
        source: 'iana',
        extensions: ['mif'],
      },
      'application/vnd.minisoft-hp3000-save': {
        source: 'iana',
      },
      'application/vnd.mitsubishi.misty-guard.trustweb': {
        source: 'iana',
      },
      'application/vnd.mobius.daf': {
        source: 'iana',
        extensions: ['daf'],
      },
      'application/vnd.mobius.dis': {
        source: 'iana',
        extensions: ['dis'],
      },
      'application/vnd.mobius.mbk': {
        source: 'iana',
        extensions: ['mbk'],
      },
      'application/vnd.mobius.mqy': {
        source: 'iana',
        extensions: ['mqy'],
      },
      'application/vnd.mobius.msl': {
        source: 'iana',
        extensions: ['msl'],
      },
      'application/vnd.mobius.plc': {
        source: 'iana',
        extensions: ['plc'],
      },
      'application/vnd.mobius.txf': {
        source: 'iana',
        extensions: ['txf'],
      },
      'application/vnd.mophun.application': {
        source: 'iana',
        extensions: ['mpn'],
      },
      'application/vnd.mophun.certificate': {
        source: 'iana',
        extensions: ['mpc'],
      },
      'application/vnd.motorola.flexsuite': {
        source: 'iana',
      },
      'application/vnd.motorola.flexsuite.adsi': {
        source: 'iana',
      },
      'application/vnd.motorola.flexsuite.fis': {
        source: 'iana',
      },
      'application/vnd.motorola.flexsuite.gotap': {
        source: 'iana',
      },
      'application/vnd.motorola.flexsuite.kmr': {
        source: 'iana',
      },
      'application/vnd.motorola.flexsuite.ttc': {
        source: 'iana',
      },
      'application/vnd.motorola.flexsuite.wem': {
        source: 'iana',
      },
      'application/vnd.motorola.iprm': {
        source: 'iana',
      },
      'application/vnd.mozilla.xul+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xul'],
      },
      'application/vnd.ms-3mfdocument': {
        source: 'iana',
      },
      'application/vnd.ms-artgalry': {
        source: 'iana',
        extensions: ['cil'],
      },
      'application/vnd.ms-asf': {
        source: 'iana',
      },
      'application/vnd.ms-cab-compressed': {
        source: 'iana',
        extensions: ['cab'],
      },
      'application/vnd.ms-color.iccprofile': {
        source: 'apache',
      },
      'application/vnd.ms-excel': {
        source: 'iana',
        compressible: false,
        extensions: ['xls', 'xlm', 'xla', 'xlc', 'xlt', 'xlw'],
      },
      'application/vnd.ms-excel.addin.macroenabled.12': {
        source: 'iana',
        extensions: ['xlam'],
      },
      'application/vnd.ms-excel.sheet.binary.macroenabled.12': {
        source: 'iana',
        extensions: ['xlsb'],
      },
      'application/vnd.ms-excel.sheet.macroenabled.12': {
        source: 'iana',
        extensions: ['xlsm'],
      },
      'application/vnd.ms-excel.template.macroenabled.12': {
        source: 'iana',
        extensions: ['xltm'],
      },
      'application/vnd.ms-fontobject': {
        source: 'iana',
        compressible: true,
        extensions: ['eot'],
      },
      'application/vnd.ms-htmlhelp': {
        source: 'iana',
        extensions: ['chm'],
      },
      'application/vnd.ms-ims': {
        source: 'iana',
        extensions: ['ims'],
      },
      'application/vnd.ms-lrm': {
        source: 'iana',
        extensions: ['lrm'],
      },
      'application/vnd.ms-office.activex+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.ms-officetheme': {
        source: 'iana',
        extensions: ['thmx'],
      },
      'application/vnd.ms-opentype': {
        source: 'apache',
        compressible: true,
      },
      'application/vnd.ms-outlook': {
        compressible: false,
        extensions: ['msg'],
      },
      'application/vnd.ms-package.obfuscated-opentype': {
        source: 'apache',
      },
      'application/vnd.ms-pki.seccat': {
        source: 'apache',
        extensions: ['cat'],
      },
      'application/vnd.ms-pki.stl': {
        source: 'apache',
        extensions: ['stl'],
      },
      'application/vnd.ms-playready.initiator+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.ms-powerpoint': {
        source: 'iana',
        compressible: false,
        extensions: ['ppt', 'pps', 'pot'],
      },
      'application/vnd.ms-powerpoint.addin.macroenabled.12': {
        source: 'iana',
        extensions: ['ppam'],
      },
      'application/vnd.ms-powerpoint.presentation.macroenabled.12': {
        source: 'iana',
        extensions: ['pptm'],
      },
      'application/vnd.ms-powerpoint.slide.macroenabled.12': {
        source: 'iana',
        extensions: ['sldm'],
      },
      'application/vnd.ms-powerpoint.slideshow.macroenabled.12': {
        source: 'iana',
        extensions: ['ppsm'],
      },
      'application/vnd.ms-powerpoint.template.macroenabled.12': {
        source: 'iana',
        extensions: ['potm'],
      },
      'application/vnd.ms-printdevicecapabilities+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.ms-printing.printticket+xml': {
        source: 'apache',
        compressible: true,
      },
      'application/vnd.ms-printschematicket+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.ms-project': {
        source: 'iana',
        extensions: ['mpp', 'mpt'],
      },
      'application/vnd.ms-tnef': {
        source: 'iana',
      },
      'application/vnd.ms-windows.devicepairing': {
        source: 'iana',
      },
      'application/vnd.ms-windows.nwprinting.oob': {
        source: 'iana',
      },
      'application/vnd.ms-windows.printerpairing': {
        source: 'iana',
      },
      'application/vnd.ms-windows.wsd.oob': {
        source: 'iana',
      },
      'application/vnd.ms-wmdrm.lic-chlg-req': {
        source: 'iana',
      },
      'application/vnd.ms-wmdrm.lic-resp': {
        source: 'iana',
      },
      'application/vnd.ms-wmdrm.meter-chlg-req': {
        source: 'iana',
      },
      'application/vnd.ms-wmdrm.meter-resp': {
        source: 'iana',
      },
      'application/vnd.ms-word.document.macroenabled.12': {
        source: 'iana',
        extensions: ['docm'],
      },
      'application/vnd.ms-word.template.macroenabled.12': {
        source: 'iana',
        extensions: ['dotm'],
      },
      'application/vnd.ms-works': {
        source: 'iana',
        extensions: ['wps', 'wks', 'wcm', 'wdb'],
      },
      'application/vnd.ms-wpl': {
        source: 'iana',
        extensions: ['wpl'],
      },
      'application/vnd.ms-xpsdocument': {
        source: 'iana',
        compressible: false,
        extensions: ['xps'],
      },
      'application/vnd.msa-disk-image': {
        source: 'iana',
      },
      'application/vnd.mseq': {
        source: 'iana',
        extensions: ['mseq'],
      },
      'application/vnd.msign': {
        source: 'iana',
      },
      'application/vnd.multiad.creator': {
        source: 'iana',
      },
      'application/vnd.multiad.creator.cif': {
        source: 'iana',
      },
      'application/vnd.music-niff': {
        source: 'iana',
      },
      'application/vnd.musician': {
        source: 'iana',
        extensions: ['mus'],
      },
      'application/vnd.muvee.style': {
        source: 'iana',
        extensions: ['msty'],
      },
      'application/vnd.mynfc': {
        source: 'iana',
        extensions: ['taglet'],
      },
      'application/vnd.nacamar.ybrid+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.ncd.control': {
        source: 'iana',
      },
      'application/vnd.ncd.reference': {
        source: 'iana',
      },
      'application/vnd.nearst.inv+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.nebumind.line': {
        source: 'iana',
      },
      'application/vnd.nervana': {
        source: 'iana',
      },
      'application/vnd.netfpx': {
        source: 'iana',
      },
      'application/vnd.neurolanguage.nlu': {
        source: 'iana',
        extensions: ['nlu'],
      },
      'application/vnd.nimn': {
        source: 'iana',
      },
      'application/vnd.nintendo.nitro.rom': {
        source: 'iana',
      },
      'application/vnd.nintendo.snes.rom': {
        source: 'iana',
      },
      'application/vnd.nitf': {
        source: 'iana',
        extensions: ['ntf', 'nitf'],
      },
      'application/vnd.noblenet-directory': {
        source: 'iana',
        extensions: ['nnd'],
      },
      'application/vnd.noblenet-sealer': {
        source: 'iana',
        extensions: ['nns'],
      },
      'application/vnd.noblenet-web': {
        source: 'iana',
        extensions: ['nnw'],
      },
      'application/vnd.nokia.catalogs': {
        source: 'iana',
      },
      'application/vnd.nokia.conml+wbxml': {
        source: 'iana',
      },
      'application/vnd.nokia.conml+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.nokia.iptv.config+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.nokia.isds-radio-presets': {
        source: 'iana',
      },
      'application/vnd.nokia.landmark+wbxml': {
        source: 'iana',
      },
      'application/vnd.nokia.landmark+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.nokia.landmarkcollection+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.nokia.n-gage.ac+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['ac'],
      },
      'application/vnd.nokia.n-gage.data': {
        source: 'iana',
        extensions: ['ngdat'],
      },
      'application/vnd.nokia.n-gage.symbian.install': {
        source: 'iana',
        extensions: ['n-gage'],
      },
      'application/vnd.nokia.ncd': {
        source: 'iana',
      },
      'application/vnd.nokia.pcd+wbxml': {
        source: 'iana',
      },
      'application/vnd.nokia.pcd+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.nokia.radio-preset': {
        source: 'iana',
        extensions: ['rpst'],
      },
      'application/vnd.nokia.radio-presets': {
        source: 'iana',
        extensions: ['rpss'],
      },
      'application/vnd.novadigm.edm': {
        source: 'iana',
        extensions: ['edm'],
      },
      'application/vnd.novadigm.edx': {
        source: 'iana',
        extensions: ['edx'],
      },
      'application/vnd.novadigm.ext': {
        source: 'iana',
        extensions: ['ext'],
      },
      'application/vnd.ntt-local.content-share': {
        source: 'iana',
      },
      'application/vnd.ntt-local.file-transfer': {
        source: 'iana',
      },
      'application/vnd.ntt-local.ogw_remote-access': {
        source: 'iana',
      },
      'application/vnd.ntt-local.sip-ta_remote': {
        source: 'iana',
      },
      'application/vnd.ntt-local.sip-ta_tcp_stream': {
        source: 'iana',
      },
      'application/vnd.oasis.opendocument.chart': {
        source: 'iana',
        extensions: ['odc'],
      },
      'application/vnd.oasis.opendocument.chart-template': {
        source: 'iana',
        extensions: ['otc'],
      },
      'application/vnd.oasis.opendocument.database': {
        source: 'iana',
        extensions: ['odb'],
      },
      'application/vnd.oasis.opendocument.formula': {
        source: 'iana',
        extensions: ['odf'],
      },
      'application/vnd.oasis.opendocument.formula-template': {
        source: 'iana',
        extensions: ['odft'],
      },
      'application/vnd.oasis.opendocument.graphics': {
        source: 'iana',
        compressible: false,
        extensions: ['odg'],
      },
      'application/vnd.oasis.opendocument.graphics-template': {
        source: 'iana',
        extensions: ['otg'],
      },
      'application/vnd.oasis.opendocument.image': {
        source: 'iana',
        extensions: ['odi'],
      },
      'application/vnd.oasis.opendocument.image-template': {
        source: 'iana',
        extensions: ['oti'],
      },
      'application/vnd.oasis.opendocument.presentation': {
        source: 'iana',
        compressible: false,
        extensions: ['odp'],
      },
      'application/vnd.oasis.opendocument.presentation-template': {
        source: 'iana',
        extensions: ['otp'],
      },
      'application/vnd.oasis.opendocument.spreadsheet': {
        source: 'iana',
        compressible: false,
        extensions: ['ods'],
      },
      'application/vnd.oasis.opendocument.spreadsheet-template': {
        source: 'iana',
        extensions: ['ots'],
      },
      'application/vnd.oasis.opendocument.text': {
        source: 'iana',
        compressible: false,
        extensions: ['odt'],
      },
      'application/vnd.oasis.opendocument.text-master': {
        source: 'iana',
        extensions: ['odm'],
      },
      'application/vnd.oasis.opendocument.text-template': {
        source: 'iana',
        extensions: ['ott'],
      },
      'application/vnd.oasis.opendocument.text-web': {
        source: 'iana',
        extensions: ['oth'],
      },
      'application/vnd.obn': {
        source: 'iana',
      },
      'application/vnd.ocf+cbor': {
        source: 'iana',
      },
      'application/vnd.oci.image.manifest.v1+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oftn.l10n+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oipf.contentaccessdownload+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oipf.contentaccessstreaming+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oipf.cspg-hexbinary': {
        source: 'iana',
      },
      'application/vnd.oipf.dae.svg+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oipf.dae.xhtml+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oipf.mippvcontrolmessage+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oipf.pae.gem': {
        source: 'iana',
      },
      'application/vnd.oipf.spdiscovery+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oipf.spdlist+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oipf.ueprofile+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oipf.userprofile+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.olpc-sugar': {
        source: 'iana',
        extensions: ['xo'],
      },
      'application/vnd.oma-scws-config': {
        source: 'iana',
      },
      'application/vnd.oma-scws-http-request': {
        source: 'iana',
      },
      'application/vnd.oma-scws-http-response': {
        source: 'iana',
      },
      'application/vnd.oma.bcast.associated-procedure-parameter+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.bcast.drm-trigger+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.bcast.imd+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.bcast.ltkm': {
        source: 'iana',
      },
      'application/vnd.oma.bcast.notification+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.bcast.provisioningtrigger': {
        source: 'iana',
      },
      'application/vnd.oma.bcast.sgboot': {
        source: 'iana',
      },
      'application/vnd.oma.bcast.sgdd+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.bcast.sgdu': {
        source: 'iana',
      },
      'application/vnd.oma.bcast.simple-symbol-container': {
        source: 'iana',
      },
      'application/vnd.oma.bcast.smartcard-trigger+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.bcast.sprov+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.bcast.stkm': {
        source: 'iana',
      },
      'application/vnd.oma.cab-address-book+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.cab-feature-handler+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.cab-pcc+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.cab-subs-invite+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.cab-user-prefs+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.dcd': {
        source: 'iana',
      },
      'application/vnd.oma.dcdc': {
        source: 'iana',
      },
      'application/vnd.oma.dd2+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['dd2'],
      },
      'application/vnd.oma.drm.risd+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.group-usage-list+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.lwm2m+cbor': {
        source: 'iana',
      },
      'application/vnd.oma.lwm2m+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.lwm2m+tlv': {
        source: 'iana',
      },
      'application/vnd.oma.pal+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.poc.detailed-progress-report+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.poc.final-report+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.poc.groups+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.poc.invocation-descriptor+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.poc.optimized-progress-report+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.push': {
        source: 'iana',
      },
      'application/vnd.oma.scidm.messages+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oma.xcap-directory+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.omads-email+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/vnd.omads-file+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/vnd.omads-folder+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/vnd.omaloc-supl-init': {
        source: 'iana',
      },
      'application/vnd.onepager': {
        source: 'iana',
      },
      'application/vnd.onepagertamp': {
        source: 'iana',
      },
      'application/vnd.onepagertamx': {
        source: 'iana',
      },
      'application/vnd.onepagertat': {
        source: 'iana',
      },
      'application/vnd.onepagertatp': {
        source: 'iana',
      },
      'application/vnd.onepagertatx': {
        source: 'iana',
      },
      'application/vnd.openblox.game+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['obgx'],
      },
      'application/vnd.openblox.game-binary': {
        source: 'iana',
      },
      'application/vnd.openeye.oeb': {
        source: 'iana',
      },
      'application/vnd.openofficeorg.extension': {
        source: 'apache',
        extensions: ['oxt'],
      },
      'application/vnd.openstreetmap.data+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['osm'],
      },
      'application/vnd.opentimestamps.ots': {
        source: 'iana',
      },
      'application/vnd.openxmlformats-officedocument.custom-properties+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.customxmlproperties+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.drawing+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.drawingml.chart+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.extended-properties+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.presentationml.comments+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.presentationml.presentation': {
        source: 'iana',
        compressible: false,
        extensions: ['pptx'],
      },
      'application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.presentationml.presprops+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.presentationml.slide': {
        source: 'iana',
        extensions: ['sldx'],
      },
      'application/vnd.openxmlformats-officedocument.presentationml.slide+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.presentationml.slideshow': {
        source: 'iana',
        extensions: ['ppsx'],
      },
      'application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.presentationml.tags+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.presentationml.template': {
        source: 'iana',
        extensions: ['potx'],
      },
      'application/vnd.openxmlformats-officedocument.presentationml.template.main+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': {
        source: 'iana',
        compressible: false,
        extensions: ['xlsx'],
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.template': {
        source: 'iana',
        extensions: ['xltx'],
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.theme+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.themeoverride+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.vmldrawing': {
        source: 'iana',
      },
      'application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': {
        source: 'iana',
        compressible: false,
        extensions: ['docx'],
      },
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.wordprocessingml.template': {
        source: 'iana',
        extensions: ['dotx'],
      },
      'application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-package.core-properties+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.openxmlformats-package.relationships+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oracle.resource+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.orange.indata': {
        source: 'iana',
      },
      'application/vnd.osa.netdeploy': {
        source: 'iana',
      },
      'application/vnd.osgeo.mapguide.package': {
        source: 'iana',
        extensions: ['mgp'],
      },
      'application/vnd.osgi.bundle': {
        source: 'iana',
      },
      'application/vnd.osgi.dp': {
        source: 'iana',
        extensions: ['dp'],
      },
      'application/vnd.osgi.subsystem': {
        source: 'iana',
        extensions: ['esa'],
      },
      'application/vnd.otps.ct-kip+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.oxli.countgraph': {
        source: 'iana',
      },
      'application/vnd.pagerduty+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.palm': {
        source: 'iana',
        extensions: ['pdb', 'pqa', 'oprc'],
      },
      'application/vnd.panoply': {
        source: 'iana',
      },
      'application/vnd.paos.xml': {
        source: 'iana',
      },
      'application/vnd.patentdive': {
        source: 'iana',
      },
      'application/vnd.patientecommsdoc': {
        source: 'iana',
      },
      'application/vnd.pawaafile': {
        source: 'iana',
        extensions: ['paw'],
      },
      'application/vnd.pcos': {
        source: 'iana',
      },
      'application/vnd.pg.format': {
        source: 'iana',
        extensions: ['str'],
      },
      'application/vnd.pg.osasli': {
        source: 'iana',
        extensions: ['ei6'],
      },
      'application/vnd.piaccess.application-licence': {
        source: 'iana',
      },
      'application/vnd.picsel': {
        source: 'iana',
        extensions: ['efif'],
      },
      'application/vnd.pmi.widget': {
        source: 'iana',
        extensions: ['wg'],
      },
      'application/vnd.poc.group-advertisement+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.pocketlearn': {
        source: 'iana',
        extensions: ['plf'],
      },
      'application/vnd.powerbuilder6': {
        source: 'iana',
        extensions: ['pbd'],
      },
      'application/vnd.powerbuilder6-s': {
        source: 'iana',
      },
      'application/vnd.powerbuilder7': {
        source: 'iana',
      },
      'application/vnd.powerbuilder7-s': {
        source: 'iana',
      },
      'application/vnd.powerbuilder75': {
        source: 'iana',
      },
      'application/vnd.powerbuilder75-s': {
        source: 'iana',
      },
      'application/vnd.preminet': {
        source: 'iana',
      },
      'application/vnd.previewsystems.box': {
        source: 'iana',
        extensions: ['box'],
      },
      'application/vnd.proteus.magazine': {
        source: 'iana',
        extensions: ['mgz'],
      },
      'application/vnd.psfs': {
        source: 'iana',
      },
      'application/vnd.publishare-delta-tree': {
        source: 'iana',
        extensions: ['qps'],
      },
      'application/vnd.pvi.ptid1': {
        source: 'iana',
        extensions: ['ptid'],
      },
      'application/vnd.pwg-multiplexed': {
        source: 'iana',
      },
      'application/vnd.pwg-xhtml-print+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.qualcomm.brew-app-res': {
        source: 'iana',
      },
      'application/vnd.quarantainenet': {
        source: 'iana',
      },
      'application/vnd.quark.quarkxpress': {
        source: 'iana',
        extensions: ['qxd', 'qxt', 'qwd', 'qwt', 'qxl', 'qxb'],
      },
      'application/vnd.quobject-quoxdocument': {
        source: 'iana',
      },
      'application/vnd.radisys.moml+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.radisys.msml+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.radisys.msml-audit+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.radisys.msml-audit-conf+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.radisys.msml-audit-conn+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.radisys.msml-audit-dialog+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.radisys.msml-audit-stream+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.radisys.msml-conf+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.radisys.msml-dialog+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.radisys.msml-dialog-base+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.radisys.msml-dialog-fax-detect+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.radisys.msml-dialog-fax-sendrecv+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.radisys.msml-dialog-group+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.radisys.msml-dialog-speech+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.radisys.msml-dialog-transform+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.rainstor.data': {
        source: 'iana',
      },
      'application/vnd.rapid': {
        source: 'iana',
      },
      'application/vnd.rar': {
        source: 'iana',
        extensions: ['rar'],
      },
      'application/vnd.realvnc.bed': {
        source: 'iana',
        extensions: ['bed'],
      },
      'application/vnd.recordare.musicxml': {
        source: 'iana',
        extensions: ['mxl'],
      },
      'application/vnd.recordare.musicxml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['musicxml'],
      },
      'application/vnd.renlearn.rlprint': {
        source: 'iana',
      },
      'application/vnd.resilient.logic': {
        source: 'iana',
      },
      'application/vnd.restful+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.rig.cryptonote': {
        source: 'iana',
        extensions: ['cryptonote'],
      },
      'application/vnd.rim.cod': {
        source: 'apache',
        extensions: ['cod'],
      },
      'application/vnd.rn-realmedia': {
        source: 'apache',
        extensions: ['rm'],
      },
      'application/vnd.rn-realmedia-vbr': {
        source: 'apache',
        extensions: ['rmvb'],
      },
      'application/vnd.route66.link66+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['link66'],
      },
      'application/vnd.rs-274x': {
        source: 'iana',
      },
      'application/vnd.ruckus.download': {
        source: 'iana',
      },
      'application/vnd.s3sms': {
        source: 'iana',
      },
      'application/vnd.sailingtracker.track': {
        source: 'iana',
        extensions: ['st'],
      },
      'application/vnd.sar': {
        source: 'iana',
      },
      'application/vnd.sbm.cid': {
        source: 'iana',
      },
      'application/vnd.sbm.mid2': {
        source: 'iana',
      },
      'application/vnd.scribus': {
        source: 'iana',
      },
      'application/vnd.sealed.3df': {
        source: 'iana',
      },
      'application/vnd.sealed.csf': {
        source: 'iana',
      },
      'application/vnd.sealed.doc': {
        source: 'iana',
      },
      'application/vnd.sealed.eml': {
        source: 'iana',
      },
      'application/vnd.sealed.mht': {
        source: 'iana',
      },
      'application/vnd.sealed.net': {
        source: 'iana',
      },
      'application/vnd.sealed.ppt': {
        source: 'iana',
      },
      'application/vnd.sealed.tiff': {
        source: 'iana',
      },
      'application/vnd.sealed.xls': {
        source: 'iana',
      },
      'application/vnd.sealedmedia.softseal.html': {
        source: 'iana',
      },
      'application/vnd.sealedmedia.softseal.pdf': {
        source: 'iana',
      },
      'application/vnd.seemail': {
        source: 'iana',
        extensions: ['see'],
      },
      'application/vnd.seis+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.sema': {
        source: 'iana',
        extensions: ['sema'],
      },
      'application/vnd.semd': {
        source: 'iana',
        extensions: ['semd'],
      },
      'application/vnd.semf': {
        source: 'iana',
        extensions: ['semf'],
      },
      'application/vnd.shade-save-file': {
        source: 'iana',
      },
      'application/vnd.shana.informed.formdata': {
        source: 'iana',
        extensions: ['ifm'],
      },
      'application/vnd.shana.informed.formtemplate': {
        source: 'iana',
        extensions: ['itp'],
      },
      'application/vnd.shana.informed.interchange': {
        source: 'iana',
        extensions: ['iif'],
      },
      'application/vnd.shana.informed.package': {
        source: 'iana',
        extensions: ['ipk'],
      },
      'application/vnd.shootproof+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.shopkick+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.shp': {
        source: 'iana',
      },
      'application/vnd.shx': {
        source: 'iana',
      },
      'application/vnd.sigrok.session': {
        source: 'iana',
      },
      'application/vnd.simtech-mindmapper': {
        source: 'iana',
        extensions: ['twd', 'twds'],
      },
      'application/vnd.siren+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.smaf': {
        source: 'iana',
        extensions: ['mmf'],
      },
      'application/vnd.smart.notebook': {
        source: 'iana',
      },
      'application/vnd.smart.teacher': {
        source: 'iana',
        extensions: ['teacher'],
      },
      'application/vnd.snesdev-page-table': {
        source: 'iana',
      },
      'application/vnd.software602.filler.form+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['fo'],
      },
      'application/vnd.software602.filler.form-xml-zip': {
        source: 'iana',
      },
      'application/vnd.solent.sdkm+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['sdkm', 'sdkd'],
      },
      'application/vnd.spotfire.dxp': {
        source: 'iana',
        extensions: ['dxp'],
      },
      'application/vnd.spotfire.sfs': {
        source: 'iana',
        extensions: ['sfs'],
      },
      'application/vnd.sqlite3': {
        source: 'iana',
      },
      'application/vnd.sss-cod': {
        source: 'iana',
      },
      'application/vnd.sss-dtf': {
        source: 'iana',
      },
      'application/vnd.sss-ntf': {
        source: 'iana',
      },
      'application/vnd.stardivision.calc': {
        source: 'apache',
        extensions: ['sdc'],
      },
      'application/vnd.stardivision.draw': {
        source: 'apache',
        extensions: ['sda'],
      },
      'application/vnd.stardivision.impress': {
        source: 'apache',
        extensions: ['sdd'],
      },
      'application/vnd.stardivision.math': {
        source: 'apache',
        extensions: ['smf'],
      },
      'application/vnd.stardivision.writer': {
        source: 'apache',
        extensions: ['sdw', 'vor'],
      },
      'application/vnd.stardivision.writer-global': {
        source: 'apache',
        extensions: ['sgl'],
      },
      'application/vnd.stepmania.package': {
        source: 'iana',
        extensions: ['smzip'],
      },
      'application/vnd.stepmania.stepchart': {
        source: 'iana',
        extensions: ['sm'],
      },
      'application/vnd.street-stream': {
        source: 'iana',
      },
      'application/vnd.sun.wadl+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['wadl'],
      },
      'application/vnd.sun.xml.calc': {
        source: 'apache',
        extensions: ['sxc'],
      },
      'application/vnd.sun.xml.calc.template': {
        source: 'apache',
        extensions: ['stc'],
      },
      'application/vnd.sun.xml.draw': {
        source: 'apache',
        extensions: ['sxd'],
      },
      'application/vnd.sun.xml.draw.template': {
        source: 'apache',
        extensions: ['std'],
      },
      'application/vnd.sun.xml.impress': {
        source: 'apache',
        extensions: ['sxi'],
      },
      'application/vnd.sun.xml.impress.template': {
        source: 'apache',
        extensions: ['sti'],
      },
      'application/vnd.sun.xml.math': {
        source: 'apache',
        extensions: ['sxm'],
      },
      'application/vnd.sun.xml.writer': {
        source: 'apache',
        extensions: ['sxw'],
      },
      'application/vnd.sun.xml.writer.global': {
        source: 'apache',
        extensions: ['sxg'],
      },
      'application/vnd.sun.xml.writer.template': {
        source: 'apache',
        extensions: ['stw'],
      },
      'application/vnd.sus-calendar': {
        source: 'iana',
        extensions: ['sus', 'susp'],
      },
      'application/vnd.svd': {
        source: 'iana',
        extensions: ['svd'],
      },
      'application/vnd.swiftview-ics': {
        source: 'iana',
      },
      'application/vnd.sycle+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.syft+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.symbian.install': {
        source: 'apache',
        extensions: ['sis', 'sisx'],
      },
      'application/vnd.syncml+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
        extensions: ['xsm'],
      },
      'application/vnd.syncml.dm+wbxml': {
        source: 'iana',
        charset: 'UTF-8',
        extensions: ['bdm'],
      },
      'application/vnd.syncml.dm+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
        extensions: ['xdm'],
      },
      'application/vnd.syncml.dm.notification': {
        source: 'iana',
      },
      'application/vnd.syncml.dmddf+wbxml': {
        source: 'iana',
      },
      'application/vnd.syncml.dmddf+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
        extensions: ['ddf'],
      },
      'application/vnd.syncml.dmtnds+wbxml': {
        source: 'iana',
      },
      'application/vnd.syncml.dmtnds+xml': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
      },
      'application/vnd.syncml.ds.notification': {
        source: 'iana',
      },
      'application/vnd.tableschema+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.tao.intent-module-archive': {
        source: 'iana',
        extensions: ['tao'],
      },
      'application/vnd.tcpdump.pcap': {
        source: 'iana',
        extensions: ['pcap', 'cap', 'dmp'],
      },
      'application/vnd.think-cell.ppttc+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.tmd.mediaflex.api+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.tml': {
        source: 'iana',
      },
      'application/vnd.tmobile-livetv': {
        source: 'iana',
        extensions: ['tmo'],
      },
      'application/vnd.tri.onesource': {
        source: 'iana',
      },
      'application/vnd.trid.tpt': {
        source: 'iana',
        extensions: ['tpt'],
      },
      'application/vnd.triscape.mxs': {
        source: 'iana',
        extensions: ['mxs'],
      },
      'application/vnd.trueapp': {
        source: 'iana',
        extensions: ['tra'],
      },
      'application/vnd.truedoc': {
        source: 'iana',
      },
      'application/vnd.ubisoft.webplayer': {
        source: 'iana',
      },
      'application/vnd.ufdl': {
        source: 'iana',
        extensions: ['ufd', 'ufdl'],
      },
      'application/vnd.uiq.theme': {
        source: 'iana',
        extensions: ['utz'],
      },
      'application/vnd.umajin': {
        source: 'iana',
        extensions: ['umj'],
      },
      'application/vnd.unity': {
        source: 'iana',
        extensions: ['unityweb'],
      },
      'application/vnd.uoml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['uoml'],
      },
      'application/vnd.uplanet.alert': {
        source: 'iana',
      },
      'application/vnd.uplanet.alert-wbxml': {
        source: 'iana',
      },
      'application/vnd.uplanet.bearer-choice': {
        source: 'iana',
      },
      'application/vnd.uplanet.bearer-choice-wbxml': {
        source: 'iana',
      },
      'application/vnd.uplanet.cacheop': {
        source: 'iana',
      },
      'application/vnd.uplanet.cacheop-wbxml': {
        source: 'iana',
      },
      'application/vnd.uplanet.channel': {
        source: 'iana',
      },
      'application/vnd.uplanet.channel-wbxml': {
        source: 'iana',
      },
      'application/vnd.uplanet.list': {
        source: 'iana',
      },
      'application/vnd.uplanet.list-wbxml': {
        source: 'iana',
      },
      'application/vnd.uplanet.listcmd': {
        source: 'iana',
      },
      'application/vnd.uplanet.listcmd-wbxml': {
        source: 'iana',
      },
      'application/vnd.uplanet.signal': {
        source: 'iana',
      },
      'application/vnd.uri-map': {
        source: 'iana',
      },
      'application/vnd.valve.source.material': {
        source: 'iana',
      },
      'application/vnd.vcx': {
        source: 'iana',
        extensions: ['vcx'],
      },
      'application/vnd.vd-study': {
        source: 'iana',
      },
      'application/vnd.vectorworks': {
        source: 'iana',
      },
      'application/vnd.vel+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.verimatrix.vcas': {
        source: 'iana',
      },
      'application/vnd.veritone.aion+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.veryant.thin': {
        source: 'iana',
      },
      'application/vnd.ves.encrypted': {
        source: 'iana',
      },
      'application/vnd.vidsoft.vidconference': {
        source: 'iana',
      },
      'application/vnd.visio': {
        source: 'iana',
        extensions: ['vsd', 'vst', 'vss', 'vsw'],
      },
      'application/vnd.visionary': {
        source: 'iana',
        extensions: ['vis'],
      },
      'application/vnd.vividence.scriptfile': {
        source: 'iana',
      },
      'application/vnd.vsf': {
        source: 'iana',
        extensions: ['vsf'],
      },
      'application/vnd.wap.sic': {
        source: 'iana',
      },
      'application/vnd.wap.slc': {
        source: 'iana',
      },
      'application/vnd.wap.wbxml': {
        source: 'iana',
        charset: 'UTF-8',
        extensions: ['wbxml'],
      },
      'application/vnd.wap.wmlc': {
        source: 'iana',
        extensions: ['wmlc'],
      },
      'application/vnd.wap.wmlscriptc': {
        source: 'iana',
        extensions: ['wmlsc'],
      },
      'application/vnd.webturbo': {
        source: 'iana',
        extensions: ['wtb'],
      },
      'application/vnd.wfa.dpp': {
        source: 'iana',
      },
      'application/vnd.wfa.p2p': {
        source: 'iana',
      },
      'application/vnd.wfa.wsc': {
        source: 'iana',
      },
      'application/vnd.windows.devicepairing': {
        source: 'iana',
      },
      'application/vnd.wmc': {
        source: 'iana',
      },
      'application/vnd.wmf.bootstrap': {
        source: 'iana',
      },
      'application/vnd.wolfram.mathematica': {
        source: 'iana',
      },
      'application/vnd.wolfram.mathematica.package': {
        source: 'iana',
      },
      'application/vnd.wolfram.player': {
        source: 'iana',
        extensions: ['nbp'],
      },
      'application/vnd.wordperfect': {
        source: 'iana',
        extensions: ['wpd'],
      },
      'application/vnd.wqd': {
        source: 'iana',
        extensions: ['wqd'],
      },
      'application/vnd.wrq-hp3000-labelled': {
        source: 'iana',
      },
      'application/vnd.wt.stf': {
        source: 'iana',
        extensions: ['stf'],
      },
      'application/vnd.wv.csp+wbxml': {
        source: 'iana',
      },
      'application/vnd.wv.csp+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.wv.ssp+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.xacml+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.xara': {
        source: 'iana',
        extensions: ['xar'],
      },
      'application/vnd.xfdl': {
        source: 'iana',
        extensions: ['xfdl'],
      },
      'application/vnd.xfdl.webform': {
        source: 'iana',
      },
      'application/vnd.xmi+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/vnd.xmpie.cpkg': {
        source: 'iana',
      },
      'application/vnd.xmpie.dpkg': {
        source: 'iana',
      },
      'application/vnd.xmpie.plan': {
        source: 'iana',
      },
      'application/vnd.xmpie.ppkg': {
        source: 'iana',
      },
      'application/vnd.xmpie.xlim': {
        source: 'iana',
      },
      'application/vnd.yamaha.hv-dic': {
        source: 'iana',
        extensions: ['hvd'],
      },
      'application/vnd.yamaha.hv-script': {
        source: 'iana',
        extensions: ['hvs'],
      },
      'application/vnd.yamaha.hv-voice': {
        source: 'iana',
        extensions: ['hvp'],
      },
      'application/vnd.yamaha.openscoreformat': {
        source: 'iana',
        extensions: ['osf'],
      },
      'application/vnd.yamaha.openscoreformat.osfpvg+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['osfpvg'],
      },
      'application/vnd.yamaha.remote-setup': {
        source: 'iana',
      },
      'application/vnd.yamaha.smaf-audio': {
        source: 'iana',
        extensions: ['saf'],
      },
      'application/vnd.yamaha.smaf-phrase': {
        source: 'iana',
        extensions: ['spf'],
      },
      'application/vnd.yamaha.through-ngn': {
        source: 'iana',
      },
      'application/vnd.yamaha.tunnel-udpencap': {
        source: 'iana',
      },
      'application/vnd.yaoweme': {
        source: 'iana',
      },
      'application/vnd.yellowriver-custom-menu': {
        source: 'iana',
        extensions: ['cmp'],
      },
      'application/vnd.youtube.yt': {
        source: 'iana',
      },
      'application/vnd.zul': {
        source: 'iana',
        extensions: ['zir', 'zirz'],
      },
      'application/vnd.zzazz.deck+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['zaz'],
      },
      'application/voicexml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['vxml'],
      },
      'application/voucher-cms+json': {
        source: 'iana',
        compressible: true,
      },
      'application/vq-rtcpxr': {
        source: 'iana',
      },
      'application/wasm': {
        source: 'iana',
        compressible: true,
        extensions: ['wasm'],
      },
      'application/watcherinfo+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['wif'],
      },
      'application/webpush-options+json': {
        source: 'iana',
        compressible: true,
      },
      'application/whoispp-query': {
        source: 'iana',
      },
      'application/whoispp-response': {
        source: 'iana',
      },
      'application/widget': {
        source: 'iana',
        extensions: ['wgt'],
      },
      'application/winhlp': {
        source: 'apache',
        extensions: ['hlp'],
      },
      'application/wita': {
        source: 'iana',
      },
      'application/wordperfect5.1': {
        source: 'iana',
      },
      'application/wsdl+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['wsdl'],
      },
      'application/wspolicy+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['wspolicy'],
      },
      'application/x-7z-compressed': {
        source: 'apache',
        compressible: false,
        extensions: ['7z'],
      },
      'application/x-abiword': {
        source: 'apache',
        extensions: ['abw'],
      },
      'application/x-ace-compressed': {
        source: 'apache',
        extensions: ['ace'],
      },
      'application/x-amf': {
        source: 'apache',
      },
      'application/x-apple-diskimage': {
        source: 'apache',
        extensions: ['dmg'],
      },
      'application/x-arj': {
        compressible: false,
        extensions: ['arj'],
      },
      'application/x-authorware-bin': {
        source: 'apache',
        extensions: ['aab', 'x32', 'u32', 'vox'],
      },
      'application/x-authorware-map': {
        source: 'apache',
        extensions: ['aam'],
      },
      'application/x-authorware-seg': {
        source: 'apache',
        extensions: ['aas'],
      },
      'application/x-bcpio': {
        source: 'apache',
        extensions: ['bcpio'],
      },
      'application/x-bdoc': {
        compressible: false,
        extensions: ['bdoc'],
      },
      'application/x-bittorrent': {
        source: 'apache',
        extensions: ['torrent'],
      },
      'application/x-blorb': {
        source: 'apache',
        extensions: ['blb', 'blorb'],
      },
      'application/x-bzip': {
        source: 'apache',
        compressible: false,
        extensions: ['bz'],
      },
      'application/x-bzip2': {
        source: 'apache',
        compressible: false,
        extensions: ['bz2', 'boz'],
      },
      'application/x-cbr': {
        source: 'apache',
        extensions: ['cbr', 'cba', 'cbt', 'cbz', 'cb7'],
      },
      'application/x-cdlink': {
        source: 'apache',
        extensions: ['vcd'],
      },
      'application/x-cfs-compressed': {
        source: 'apache',
        extensions: ['cfs'],
      },
      'application/x-chat': {
        source: 'apache',
        extensions: ['chat'],
      },
      'application/x-chess-pgn': {
        source: 'apache',
        extensions: ['pgn'],
      },
      'application/x-chrome-extension': {
        extensions: ['crx'],
      },
      'application/x-cocoa': {
        source: 'nginx',
        extensions: ['cco'],
      },
      'application/x-compress': {
        source: 'apache',
      },
      'application/x-conference': {
        source: 'apache',
        extensions: ['nsc'],
      },
      'application/x-cpio': {
        source: 'apache',
        extensions: ['cpio'],
      },
      'application/x-csh': {
        source: 'apache',
        extensions: ['csh'],
      },
      'application/x-deb': {
        compressible: false,
      },
      'application/x-debian-package': {
        source: 'apache',
        extensions: ['deb', 'udeb'],
      },
      'application/x-dgc-compressed': {
        source: 'apache',
        extensions: ['dgc'],
      },
      'application/x-director': {
        source: 'apache',
        extensions: ['dir', 'dcr', 'dxr', 'cst', 'cct', 'cxt', 'w3d', 'fgd', 'swa'],
      },
      'application/x-doom': {
        source: 'apache',
        extensions: ['wad'],
      },
      'application/x-dtbncx+xml': {
        source: 'apache',
        compressible: true,
        extensions: ['ncx'],
      },
      'application/x-dtbook+xml': {
        source: 'apache',
        compressible: true,
        extensions: ['dtb'],
      },
      'application/x-dtbresource+xml': {
        source: 'apache',
        compressible: true,
        extensions: ['res'],
      },
      'application/x-dvi': {
        source: 'apache',
        compressible: false,
        extensions: ['dvi'],
      },
      'application/x-envoy': {
        source: 'apache',
        extensions: ['evy'],
      },
      'application/x-eva': {
        source: 'apache',
        extensions: ['eva'],
      },
      'application/x-font-bdf': {
        source: 'apache',
        extensions: ['bdf'],
      },
      'application/x-font-dos': {
        source: 'apache',
      },
      'application/x-font-framemaker': {
        source: 'apache',
      },
      'application/x-font-ghostscript': {
        source: 'apache',
        extensions: ['gsf'],
      },
      'application/x-font-libgrx': {
        source: 'apache',
      },
      'application/x-font-linux-psf': {
        source: 'apache',
        extensions: ['psf'],
      },
      'application/x-font-pcf': {
        source: 'apache',
        extensions: ['pcf'],
      },
      'application/x-font-snf': {
        source: 'apache',
        extensions: ['snf'],
      },
      'application/x-font-speedo': {
        source: 'apache',
      },
      'application/x-font-sunos-news': {
        source: 'apache',
      },
      'application/x-font-type1': {
        source: 'apache',
        extensions: ['pfa', 'pfb', 'pfm', 'afm'],
      },
      'application/x-font-vfont': {
        source: 'apache',
      },
      'application/x-freearc': {
        source: 'apache',
        extensions: ['arc'],
      },
      'application/x-futuresplash': {
        source: 'apache',
        extensions: ['spl'],
      },
      'application/x-gca-compressed': {
        source: 'apache',
        extensions: ['gca'],
      },
      'application/x-glulx': {
        source: 'apache',
        extensions: ['ulx'],
      },
      'application/x-gnumeric': {
        source: 'apache',
        extensions: ['gnumeric'],
      },
      'application/x-gramps-xml': {
        source: 'apache',
        extensions: ['gramps'],
      },
      'application/x-gtar': {
        source: 'apache',
        extensions: ['gtar'],
      },
      'application/x-gzip': {
        source: 'apache',
      },
      'application/x-hdf': {
        source: 'apache',
        extensions: ['hdf'],
      },
      'application/x-httpd-php': {
        compressible: true,
        extensions: ['php'],
      },
      'application/x-install-instructions': {
        source: 'apache',
        extensions: ['install'],
      },
      'application/x-iso9660-image': {
        source: 'apache',
        extensions: ['iso'],
      },
      'application/x-iwork-keynote-sffkey': {
        extensions: ['key'],
      },
      'application/x-iwork-numbers-sffnumbers': {
        extensions: ['numbers'],
      },
      'application/x-iwork-pages-sffpages': {
        extensions: ['pages'],
      },
      'application/x-java-archive-diff': {
        source: 'nginx',
        extensions: ['jardiff'],
      },
      'application/x-java-jnlp-file': {
        source: 'apache',
        compressible: false,
        extensions: ['jnlp'],
      },
      'application/x-javascript': {
        compressible: true,
      },
      'application/x-keepass2': {
        extensions: ['kdbx'],
      },
      'application/x-latex': {
        source: 'apache',
        compressible: false,
        extensions: ['latex'],
      },
      'application/x-lua-bytecode': {
        extensions: ['luac'],
      },
      'application/x-lzh-compressed': {
        source: 'apache',
        extensions: ['lzh', 'lha'],
      },
      'application/x-makeself': {
        source: 'nginx',
        extensions: ['run'],
      },
      'application/x-mie': {
        source: 'apache',
        extensions: ['mie'],
      },
      'application/x-mobipocket-ebook': {
        source: 'apache',
        extensions: ['prc', 'mobi'],
      },
      'application/x-mpegurl': {
        compressible: false,
      },
      'application/x-ms-application': {
        source: 'apache',
        extensions: ['application'],
      },
      'application/x-ms-shortcut': {
        source: 'apache',
        extensions: ['lnk'],
      },
      'application/x-ms-wmd': {
        source: 'apache',
        extensions: ['wmd'],
      },
      'application/x-ms-wmz': {
        source: 'apache',
        extensions: ['wmz'],
      },
      'application/x-ms-xbap': {
        source: 'apache',
        extensions: ['xbap'],
      },
      'application/x-msaccess': {
        source: 'apache',
        extensions: ['mdb'],
      },
      'application/x-msbinder': {
        source: 'apache',
        extensions: ['obd'],
      },
      'application/x-mscardfile': {
        source: 'apache',
        extensions: ['crd'],
      },
      'application/x-msclip': {
        source: 'apache',
        extensions: ['clp'],
      },
      'application/x-msdos-program': {
        extensions: ['exe'],
      },
      'application/x-msdownload': {
        source: 'apache',
        extensions: ['exe', 'dll', 'com', 'bat', 'msi'],
      },
      'application/x-msmediaview': {
        source: 'apache',
        extensions: ['mvb', 'm13', 'm14'],
      },
      'application/x-msmetafile': {
        source: 'apache',
        extensions: ['wmf', 'wmz', 'emf', 'emz'],
      },
      'application/x-msmoney': {
        source: 'apache',
        extensions: ['mny'],
      },
      'application/x-mspublisher': {
        source: 'apache',
        extensions: ['pub'],
      },
      'application/x-msschedule': {
        source: 'apache',
        extensions: ['scd'],
      },
      'application/x-msterminal': {
        source: 'apache',
        extensions: ['trm'],
      },
      'application/x-mswrite': {
        source: 'apache',
        extensions: ['wri'],
      },
      'application/x-netcdf': {
        source: 'apache',
        extensions: ['nc', 'cdf'],
      },
      'application/x-ns-proxy-autoconfig': {
        compressible: true,
        extensions: ['pac'],
      },
      'application/x-nzb': {
        source: 'apache',
        extensions: ['nzb'],
      },
      'application/x-perl': {
        source: 'nginx',
        extensions: ['pl', 'pm'],
      },
      'application/x-pilot': {
        source: 'nginx',
        extensions: ['prc', 'pdb'],
      },
      'application/x-pkcs12': {
        source: 'apache',
        compressible: false,
        extensions: ['p12', 'pfx'],
      },
      'application/x-pkcs7-certificates': {
        source: 'apache',
        extensions: ['p7b', 'spc'],
      },
      'application/x-pkcs7-certreqresp': {
        source: 'apache',
        extensions: ['p7r'],
      },
      'application/x-pki-message': {
        source: 'iana',
      },
      'application/x-rar-compressed': {
        source: 'apache',
        compressible: false,
        extensions: ['rar'],
      },
      'application/x-redhat-package-manager': {
        source: 'nginx',
        extensions: ['rpm'],
      },
      'application/x-research-info-systems': {
        source: 'apache',
        extensions: ['ris'],
      },
      'application/x-sea': {
        source: 'nginx',
        extensions: ['sea'],
      },
      'application/x-sh': {
        source: 'apache',
        compressible: true,
        extensions: ['sh'],
      },
      'application/x-shar': {
        source: 'apache',
        extensions: ['shar'],
      },
      'application/x-shockwave-flash': {
        source: 'apache',
        compressible: false,
        extensions: ['swf'],
      },
      'application/x-silverlight-app': {
        source: 'apache',
        extensions: ['xap'],
      },
      'application/x-sql': {
        source: 'apache',
        extensions: ['sql'],
      },
      'application/x-stuffit': {
        source: 'apache',
        compressible: false,
        extensions: ['sit'],
      },
      'application/x-stuffitx': {
        source: 'apache',
        extensions: ['sitx'],
      },
      'application/x-subrip': {
        source: 'apache',
        extensions: ['srt'],
      },
      'application/x-sv4cpio': {
        source: 'apache',
        extensions: ['sv4cpio'],
      },
      'application/x-sv4crc': {
        source: 'apache',
        extensions: ['sv4crc'],
      },
      'application/x-t3vm-image': {
        source: 'apache',
        extensions: ['t3'],
      },
      'application/x-tads': {
        source: 'apache',
        extensions: ['gam'],
      },
      'application/x-tar': {
        source: 'apache',
        compressible: true,
        extensions: ['tar'],
      },
      'application/x-tcl': {
        source: 'apache',
        extensions: ['tcl', 'tk'],
      },
      'application/x-tex': {
        source: 'apache',
        extensions: ['tex'],
      },
      'application/x-tex-tfm': {
        source: 'apache',
        extensions: ['tfm'],
      },
      'application/x-texinfo': {
        source: 'apache',
        extensions: ['texinfo', 'texi'],
      },
      'application/x-tgif': {
        source: 'apache',
        extensions: ['obj'],
      },
      'application/x-ustar': {
        source: 'apache',
        extensions: ['ustar'],
      },
      'application/x-virtualbox-hdd': {
        compressible: true,
        extensions: ['hdd'],
      },
      'application/x-virtualbox-ova': {
        compressible: true,
        extensions: ['ova'],
      },
      'application/x-virtualbox-ovf': {
        compressible: true,
        extensions: ['ovf'],
      },
      'application/x-virtualbox-vbox': {
        compressible: true,
        extensions: ['vbox'],
      },
      'application/x-virtualbox-vbox-extpack': {
        compressible: false,
        extensions: ['vbox-extpack'],
      },
      'application/x-virtualbox-vdi': {
        compressible: true,
        extensions: ['vdi'],
      },
      'application/x-virtualbox-vhd': {
        compressible: true,
        extensions: ['vhd'],
      },
      'application/x-virtualbox-vmdk': {
        compressible: true,
        extensions: ['vmdk'],
      },
      'application/x-wais-source': {
        source: 'apache',
        extensions: ['src'],
      },
      'application/x-web-app-manifest+json': {
        compressible: true,
        extensions: ['webapp'],
      },
      'application/x-www-form-urlencoded': {
        source: 'iana',
        compressible: true,
      },
      'application/x-x509-ca-cert': {
        source: 'iana',
        extensions: ['der', 'crt', 'pem'],
      },
      'application/x-x509-ca-ra-cert': {
        source: 'iana',
      },
      'application/x-x509-next-ca-cert': {
        source: 'iana',
      },
      'application/x-xfig': {
        source: 'apache',
        extensions: ['fig'],
      },
      'application/x-xliff+xml': {
        source: 'apache',
        compressible: true,
        extensions: ['xlf'],
      },
      'application/x-xpinstall': {
        source: 'apache',
        compressible: false,
        extensions: ['xpi'],
      },
      'application/x-xz': {
        source: 'apache',
        extensions: ['xz'],
      },
      'application/x-zmachine': {
        source: 'apache',
        extensions: ['z1', 'z2', 'z3', 'z4', 'z5', 'z6', 'z7', 'z8'],
      },
      'application/x400-bp': {
        source: 'iana',
      },
      'application/xacml+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/xaml+xml': {
        source: 'apache',
        compressible: true,
        extensions: ['xaml'],
      },
      'application/xcap-att+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xav'],
      },
      'application/xcap-caps+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xca'],
      },
      'application/xcap-diff+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xdf'],
      },
      'application/xcap-el+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xel'],
      },
      'application/xcap-error+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/xcap-ns+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xns'],
      },
      'application/xcon-conference-info+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/xcon-conference-info-diff+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/xenc+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xenc'],
      },
      'application/xhtml+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xhtml', 'xht'],
      },
      'application/xhtml-voice+xml': {
        source: 'apache',
        compressible: true,
      },
      'application/xliff+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xlf'],
      },
      'application/xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xml', 'xsl', 'xsd', 'rng'],
      },
      'application/xml-dtd': {
        source: 'iana',
        compressible: true,
        extensions: ['dtd'],
      },
      'application/xml-external-parsed-entity': {
        source: 'iana',
      },
      'application/xml-patch+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/xmpp+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/xop+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xop'],
      },
      'application/xproc+xml': {
        source: 'apache',
        compressible: true,
        extensions: ['xpl'],
      },
      'application/xslt+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xsl', 'xslt'],
      },
      'application/xspf+xml': {
        source: 'apache',
        compressible: true,
        extensions: ['xspf'],
      },
      'application/xv+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['mxml', 'xhvml', 'xvml', 'xvm'],
      },
      'application/yang': {
        source: 'iana',
        extensions: ['yang'],
      },
      'application/yang-data+json': {
        source: 'iana',
        compressible: true,
      },
      'application/yang-data+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/yang-patch+json': {
        source: 'iana',
        compressible: true,
      },
      'application/yang-patch+xml': {
        source: 'iana',
        compressible: true,
      },
      'application/yin+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['yin'],
      },
      'application/zip': {
        source: 'iana',
        compressible: false,
        extensions: ['zip'],
      },
      'application/zlib': {
        source: 'iana',
      },
      'application/zstd': {
        source: 'iana',
      },
      'audio/1d-interleaved-parityfec': {
        source: 'iana',
      },
      'audio/32kadpcm': {
        source: 'iana',
      },
      'audio/3gpp': {
        source: 'iana',
        compressible: false,
        extensions: ['3gpp'],
      },
      'audio/3gpp2': {
        source: 'iana',
      },
      'audio/aac': {
        source: 'iana',
      },
      'audio/ac3': {
        source: 'iana',
      },
      'audio/adpcm': {
        source: 'apache',
        extensions: ['adp'],
      },
      'audio/amr': {
        source: 'iana',
        extensions: ['amr'],
      },
      'audio/amr-wb': {
        source: 'iana',
      },
      'audio/amr-wb+': {
        source: 'iana',
      },
      'audio/aptx': {
        source: 'iana',
      },
      'audio/asc': {
        source: 'iana',
      },
      'audio/atrac-advanced-lossless': {
        source: 'iana',
      },
      'audio/atrac-x': {
        source: 'iana',
      },
      'audio/atrac3': {
        source: 'iana',
      },
      'audio/basic': {
        source: 'iana',
        compressible: false,
        extensions: ['au', 'snd'],
      },
      'audio/bv16': {
        source: 'iana',
      },
      'audio/bv32': {
        source: 'iana',
      },
      'audio/clearmode': {
        source: 'iana',
      },
      'audio/cn': {
        source: 'iana',
      },
      'audio/dat12': {
        source: 'iana',
      },
      'audio/dls': {
        source: 'iana',
      },
      'audio/dsr-es201108': {
        source: 'iana',
      },
      'audio/dsr-es202050': {
        source: 'iana',
      },
      'audio/dsr-es202211': {
        source: 'iana',
      },
      'audio/dsr-es202212': {
        source: 'iana',
      },
      'audio/dv': {
        source: 'iana',
      },
      'audio/dvi4': {
        source: 'iana',
      },
      'audio/eac3': {
        source: 'iana',
      },
      'audio/encaprtp': {
        source: 'iana',
      },
      'audio/evrc': {
        source: 'iana',
      },
      'audio/evrc-qcp': {
        source: 'iana',
      },
      'audio/evrc0': {
        source: 'iana',
      },
      'audio/evrc1': {
        source: 'iana',
      },
      'audio/evrcb': {
        source: 'iana',
      },
      'audio/evrcb0': {
        source: 'iana',
      },
      'audio/evrcb1': {
        source: 'iana',
      },
      'audio/evrcnw': {
        source: 'iana',
      },
      'audio/evrcnw0': {
        source: 'iana',
      },
      'audio/evrcnw1': {
        source: 'iana',
      },
      'audio/evrcwb': {
        source: 'iana',
      },
      'audio/evrcwb0': {
        source: 'iana',
      },
      'audio/evrcwb1': {
        source: 'iana',
      },
      'audio/evs': {
        source: 'iana',
      },
      'audio/flexfec': {
        source: 'iana',
      },
      'audio/fwdred': {
        source: 'iana',
      },
      'audio/g711-0': {
        source: 'iana',
      },
      'audio/g719': {
        source: 'iana',
      },
      'audio/g722': {
        source: 'iana',
      },
      'audio/g7221': {
        source: 'iana',
      },
      'audio/g723': {
        source: 'iana',
      },
      'audio/g726-16': {
        source: 'iana',
      },
      'audio/g726-24': {
        source: 'iana',
      },
      'audio/g726-32': {
        source: 'iana',
      },
      'audio/g726-40': {
        source: 'iana',
      },
      'audio/g728': {
        source: 'iana',
      },
      'audio/g729': {
        source: 'iana',
      },
      'audio/g7291': {
        source: 'iana',
      },
      'audio/g729d': {
        source: 'iana',
      },
      'audio/g729e': {
        source: 'iana',
      },
      'audio/gsm': {
        source: 'iana',
      },
      'audio/gsm-efr': {
        source: 'iana',
      },
      'audio/gsm-hr-08': {
        source: 'iana',
      },
      'audio/ilbc': {
        source: 'iana',
      },
      'audio/ip-mr_v2.5': {
        source: 'iana',
      },
      'audio/isac': {
        source: 'apache',
      },
      'audio/l16': {
        source: 'iana',
      },
      'audio/l20': {
        source: 'iana',
      },
      'audio/l24': {
        source: 'iana',
        compressible: false,
      },
      'audio/l8': {
        source: 'iana',
      },
      'audio/lpc': {
        source: 'iana',
      },
      'audio/melp': {
        source: 'iana',
      },
      'audio/melp1200': {
        source: 'iana',
      },
      'audio/melp2400': {
        source: 'iana',
      },
      'audio/melp600': {
        source: 'iana',
      },
      'audio/mhas': {
        source: 'iana',
      },
      'audio/midi': {
        source: 'apache',
        extensions: ['mid', 'midi', 'kar', 'rmi'],
      },
      'audio/mobile-xmf': {
        source: 'iana',
        extensions: ['mxmf'],
      },
      'audio/mp3': {
        compressible: false,
        extensions: ['mp3'],
      },
      'audio/mp4': {
        source: 'iana',
        compressible: false,
        extensions: ['m4a', 'mp4a'],
      },
      'audio/mp4a-latm': {
        source: 'iana',
      },
      'audio/mpa': {
        source: 'iana',
      },
      'audio/mpa-robust': {
        source: 'iana',
      },
      'audio/mpeg': {
        source: 'iana',
        compressible: false,
        extensions: ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a'],
      },
      'audio/mpeg4-generic': {
        source: 'iana',
      },
      'audio/musepack': {
        source: 'apache',
      },
      'audio/ogg': {
        source: 'iana',
        compressible: false,
        extensions: ['oga', 'ogg', 'spx', 'opus'],
      },
      'audio/opus': {
        source: 'iana',
      },
      'audio/parityfec': {
        source: 'iana',
      },
      'audio/pcma': {
        source: 'iana',
      },
      'audio/pcma-wb': {
        source: 'iana',
      },
      'audio/pcmu': {
        source: 'iana',
      },
      'audio/pcmu-wb': {
        source: 'iana',
      },
      'audio/prs.sid': {
        source: 'iana',
      },
      'audio/qcelp': {
        source: 'iana',
      },
      'audio/raptorfec': {
        source: 'iana',
      },
      'audio/red': {
        source: 'iana',
      },
      'audio/rtp-enc-aescm128': {
        source: 'iana',
      },
      'audio/rtp-midi': {
        source: 'iana',
      },
      'audio/rtploopback': {
        source: 'iana',
      },
      'audio/rtx': {
        source: 'iana',
      },
      'audio/s3m': {
        source: 'apache',
        extensions: ['s3m'],
      },
      'audio/scip': {
        source: 'iana',
      },
      'audio/silk': {
        source: 'apache',
        extensions: ['sil'],
      },
      'audio/smv': {
        source: 'iana',
      },
      'audio/smv-qcp': {
        source: 'iana',
      },
      'audio/smv0': {
        source: 'iana',
      },
      'audio/sofa': {
        source: 'iana',
      },
      'audio/sp-midi': {
        source: 'iana',
      },
      'audio/speex': {
        source: 'iana',
      },
      'audio/t140c': {
        source: 'iana',
      },
      'audio/t38': {
        source: 'iana',
      },
      'audio/telephone-event': {
        source: 'iana',
      },
      'audio/tetra_acelp': {
        source: 'iana',
      },
      'audio/tetra_acelp_bb': {
        source: 'iana',
      },
      'audio/tone': {
        source: 'iana',
      },
      'audio/tsvcis': {
        source: 'iana',
      },
      'audio/uemclip': {
        source: 'iana',
      },
      'audio/ulpfec': {
        source: 'iana',
      },
      'audio/usac': {
        source: 'iana',
      },
      'audio/vdvi': {
        source: 'iana',
      },
      'audio/vmr-wb': {
        source: 'iana',
      },
      'audio/vnd.3gpp.iufp': {
        source: 'iana',
      },
      'audio/vnd.4sb': {
        source: 'iana',
      },
      'audio/vnd.audiokoz': {
        source: 'iana',
      },
      'audio/vnd.celp': {
        source: 'iana',
      },
      'audio/vnd.cisco.nse': {
        source: 'iana',
      },
      'audio/vnd.cmles.radio-events': {
        source: 'iana',
      },
      'audio/vnd.cns.anp1': {
        source: 'iana',
      },
      'audio/vnd.cns.inf1': {
        source: 'iana',
      },
      'audio/vnd.dece.audio': {
        source: 'iana',
        extensions: ['uva', 'uvva'],
      },
      'audio/vnd.digital-winds': {
        source: 'iana',
        extensions: ['eol'],
      },
      'audio/vnd.dlna.adts': {
        source: 'iana',
      },
      'audio/vnd.dolby.heaac.1': {
        source: 'iana',
      },
      'audio/vnd.dolby.heaac.2': {
        source: 'iana',
      },
      'audio/vnd.dolby.mlp': {
        source: 'iana',
      },
      'audio/vnd.dolby.mps': {
        source: 'iana',
      },
      'audio/vnd.dolby.pl2': {
        source: 'iana',
      },
      'audio/vnd.dolby.pl2x': {
        source: 'iana',
      },
      'audio/vnd.dolby.pl2z': {
        source: 'iana',
      },
      'audio/vnd.dolby.pulse.1': {
        source: 'iana',
      },
      'audio/vnd.dra': {
        source: 'iana',
        extensions: ['dra'],
      },
      'audio/vnd.dts': {
        source: 'iana',
        extensions: ['dts'],
      },
      'audio/vnd.dts.hd': {
        source: 'iana',
        extensions: ['dtshd'],
      },
      'audio/vnd.dts.uhd': {
        source: 'iana',
      },
      'audio/vnd.dvb.file': {
        source: 'iana',
      },
      'audio/vnd.everad.plj': {
        source: 'iana',
      },
      'audio/vnd.hns.audio': {
        source: 'iana',
      },
      'audio/vnd.lucent.voice': {
        source: 'iana',
        extensions: ['lvp'],
      },
      'audio/vnd.ms-playready.media.pya': {
        source: 'iana',
        extensions: ['pya'],
      },
      'audio/vnd.nokia.mobile-xmf': {
        source: 'iana',
      },
      'audio/vnd.nortel.vbk': {
        source: 'iana',
      },
      'audio/vnd.nuera.ecelp4800': {
        source: 'iana',
        extensions: ['ecelp4800'],
      },
      'audio/vnd.nuera.ecelp7470': {
        source: 'iana',
        extensions: ['ecelp7470'],
      },
      'audio/vnd.nuera.ecelp9600': {
        source: 'iana',
        extensions: ['ecelp9600'],
      },
      'audio/vnd.octel.sbc': {
        source: 'iana',
      },
      'audio/vnd.presonus.multitrack': {
        source: 'iana',
      },
      'audio/vnd.qcelp': {
        source: 'iana',
      },
      'audio/vnd.rhetorex.32kadpcm': {
        source: 'iana',
      },
      'audio/vnd.rip': {
        source: 'iana',
        extensions: ['rip'],
      },
      'audio/vnd.rn-realaudio': {
        compressible: false,
      },
      'audio/vnd.sealedmedia.softseal.mpeg': {
        source: 'iana',
      },
      'audio/vnd.vmx.cvsd': {
        source: 'iana',
      },
      'audio/vnd.wave': {
        compressible: false,
      },
      'audio/vorbis': {
        source: 'iana',
        compressible: false,
      },
      'audio/vorbis-config': {
        source: 'iana',
      },
      'audio/wav': {
        compressible: false,
        extensions: ['wav'],
      },
      'audio/wave': {
        compressible: false,
        extensions: ['wav'],
      },
      'audio/webm': {
        source: 'apache',
        compressible: false,
        extensions: ['weba'],
      },
      'audio/x-aac': {
        source: 'apache',
        compressible: false,
        extensions: ['aac'],
      },
      'audio/x-aiff': {
        source: 'apache',
        extensions: ['aif', 'aiff', 'aifc'],
      },
      'audio/x-caf': {
        source: 'apache',
        compressible: false,
        extensions: ['caf'],
      },
      'audio/x-flac': {
        source: 'apache',
        extensions: ['flac'],
      },
      'audio/x-m4a': {
        source: 'nginx',
        extensions: ['m4a'],
      },
      'audio/x-matroska': {
        source: 'apache',
        extensions: ['mka'],
      },
      'audio/x-mpegurl': {
        source: 'apache',
        extensions: ['m3u'],
      },
      'audio/x-ms-wax': {
        source: 'apache',
        extensions: ['wax'],
      },
      'audio/x-ms-wma': {
        source: 'apache',
        extensions: ['wma'],
      },
      'audio/x-pn-realaudio': {
        source: 'apache',
        extensions: ['ram', 'ra'],
      },
      'audio/x-pn-realaudio-plugin': {
        source: 'apache',
        extensions: ['rmp'],
      },
      'audio/x-realaudio': {
        source: 'nginx',
        extensions: ['ra'],
      },
      'audio/x-tta': {
        source: 'apache',
      },
      'audio/x-wav': {
        source: 'apache',
        extensions: ['wav'],
      },
      'audio/xm': {
        source: 'apache',
        extensions: ['xm'],
      },
      'chemical/x-cdx': {
        source: 'apache',
        extensions: ['cdx'],
      },
      'chemical/x-cif': {
        source: 'apache',
        extensions: ['cif'],
      },
      'chemical/x-cmdf': {
        source: 'apache',
        extensions: ['cmdf'],
      },
      'chemical/x-cml': {
        source: 'apache',
        extensions: ['cml'],
      },
      'chemical/x-csml': {
        source: 'apache',
        extensions: ['csml'],
      },
      'chemical/x-pdb': {
        source: 'apache',
      },
      'chemical/x-xyz': {
        source: 'apache',
        extensions: ['xyz'],
      },
      'font/collection': {
        source: 'iana',
        extensions: ['ttc'],
      },
      'font/otf': {
        source: 'iana',
        compressible: true,
        extensions: ['otf'],
      },
      'font/sfnt': {
        source: 'iana',
      },
      'font/ttf': {
        source: 'iana',
        compressible: true,
        extensions: ['ttf'],
      },
      'font/woff': {
        source: 'iana',
        extensions: ['woff'],
      },
      'font/woff2': {
        source: 'iana',
        extensions: ['woff2'],
      },
      'image/aces': {
        source: 'iana',
        extensions: ['exr'],
      },
      'image/apng': {
        compressible: false,
        extensions: ['apng'],
      },
      'image/avci': {
        source: 'iana',
        extensions: ['avci'],
      },
      'image/avcs': {
        source: 'iana',
        extensions: ['avcs'],
      },
      'image/avif': {
        source: 'iana',
        compressible: false,
        extensions: ['avif'],
      },
      'image/bmp': {
        source: 'iana',
        compressible: true,
        extensions: ['bmp'],
      },
      'image/cgm': {
        source: 'iana',
        extensions: ['cgm'],
      },
      'image/dicom-rle': {
        source: 'iana',
        extensions: ['drle'],
      },
      'image/emf': {
        source: 'iana',
        extensions: ['emf'],
      },
      'image/fits': {
        source: 'iana',
        extensions: ['fits'],
      },
      'image/g3fax': {
        source: 'iana',
        extensions: ['g3'],
      },
      'image/gif': {
        source: 'iana',
        compressible: false,
        extensions: ['gif'],
      },
      'image/heic': {
        source: 'iana',
        extensions: ['heic'],
      },
      'image/heic-sequence': {
        source: 'iana',
        extensions: ['heics'],
      },
      'image/heif': {
        source: 'iana',
        extensions: ['heif'],
      },
      'image/heif-sequence': {
        source: 'iana',
        extensions: ['heifs'],
      },
      'image/hej2k': {
        source: 'iana',
        extensions: ['hej2'],
      },
      'image/hsj2': {
        source: 'iana',
        extensions: ['hsj2'],
      },
      'image/ief': {
        source: 'iana',
        extensions: ['ief'],
      },
      'image/jls': {
        source: 'iana',
        extensions: ['jls'],
      },
      'image/jp2': {
        source: 'iana',
        compressible: false,
        extensions: ['jp2', 'jpg2'],
      },
      'image/jpeg': {
        source: 'iana',
        compressible: false,
        extensions: ['jpeg', 'jpg', 'jpe'],
      },
      'image/jph': {
        source: 'iana',
        extensions: ['jph'],
      },
      'image/jphc': {
        source: 'iana',
        extensions: ['jhc'],
      },
      'image/jpm': {
        source: 'iana',
        compressible: false,
        extensions: ['jpm'],
      },
      'image/jpx': {
        source: 'iana',
        compressible: false,
        extensions: ['jpx', 'jpf'],
      },
      'image/jxr': {
        source: 'iana',
        extensions: ['jxr'],
      },
      'image/jxra': {
        source: 'iana',
        extensions: ['jxra'],
      },
      'image/jxrs': {
        source: 'iana',
        extensions: ['jxrs'],
      },
      'image/jxs': {
        source: 'iana',
        extensions: ['jxs'],
      },
      'image/jxsc': {
        source: 'iana',
        extensions: ['jxsc'],
      },
      'image/jxsi': {
        source: 'iana',
        extensions: ['jxsi'],
      },
      'image/jxss': {
        source: 'iana',
        extensions: ['jxss'],
      },
      'image/ktx': {
        source: 'iana',
        extensions: ['ktx'],
      },
      'image/ktx2': {
        source: 'iana',
        extensions: ['ktx2'],
      },
      'image/naplps': {
        source: 'iana',
      },
      'image/pjpeg': {
        compressible: false,
      },
      'image/png': {
        source: 'iana',
        compressible: false,
        extensions: ['png'],
      },
      'image/prs.btif': {
        source: 'iana',
        extensions: ['btif'],
      },
      'image/prs.pti': {
        source: 'iana',
        extensions: ['pti'],
      },
      'image/pwg-raster': {
        source: 'iana',
      },
      'image/sgi': {
        source: 'apache',
        extensions: ['sgi'],
      },
      'image/svg+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['svg', 'svgz'],
      },
      'image/t38': {
        source: 'iana',
        extensions: ['t38'],
      },
      'image/tiff': {
        source: 'iana',
        compressible: false,
        extensions: ['tif', 'tiff'],
      },
      'image/tiff-fx': {
        source: 'iana',
        extensions: ['tfx'],
      },
      'image/vnd.adobe.photoshop': {
        source: 'iana',
        compressible: true,
        extensions: ['psd'],
      },
      'image/vnd.airzip.accelerator.azv': {
        source: 'iana',
        extensions: ['azv'],
      },
      'image/vnd.cns.inf2': {
        source: 'iana',
      },
      'image/vnd.dece.graphic': {
        source: 'iana',
        extensions: ['uvi', 'uvvi', 'uvg', 'uvvg'],
      },
      'image/vnd.djvu': {
        source: 'iana',
        extensions: ['djvu', 'djv'],
      },
      'image/vnd.dvb.subtitle': {
        source: 'iana',
        extensions: ['sub'],
      },
      'image/vnd.dwg': {
        source: 'iana',
        extensions: ['dwg'],
      },
      'image/vnd.dxf': {
        source: 'iana',
        extensions: ['dxf'],
      },
      'image/vnd.fastbidsheet': {
        source: 'iana',
        extensions: ['fbs'],
      },
      'image/vnd.fpx': {
        source: 'iana',
        extensions: ['fpx'],
      },
      'image/vnd.fst': {
        source: 'iana',
        extensions: ['fst'],
      },
      'image/vnd.fujixerox.edmics-mmr': {
        source: 'iana',
        extensions: ['mmr'],
      },
      'image/vnd.fujixerox.edmics-rlc': {
        source: 'iana',
        extensions: ['rlc'],
      },
      'image/vnd.globalgraphics.pgb': {
        source: 'iana',
      },
      'image/vnd.microsoft.icon': {
        source: 'iana',
        compressible: true,
        extensions: ['ico'],
      },
      'image/vnd.mix': {
        source: 'iana',
      },
      'image/vnd.mozilla.apng': {
        source: 'iana',
      },
      'image/vnd.ms-dds': {
        compressible: true,
        extensions: ['dds'],
      },
      'image/vnd.ms-modi': {
        source: 'iana',
        extensions: ['mdi'],
      },
      'image/vnd.ms-photo': {
        source: 'apache',
        extensions: ['wdp'],
      },
      'image/vnd.net-fpx': {
        source: 'iana',
        extensions: ['npx'],
      },
      'image/vnd.pco.b16': {
        source: 'iana',
        extensions: ['b16'],
      },
      'image/vnd.radiance': {
        source: 'iana',
      },
      'image/vnd.sealed.png': {
        source: 'iana',
      },
      'image/vnd.sealedmedia.softseal.gif': {
        source: 'iana',
      },
      'image/vnd.sealedmedia.softseal.jpg': {
        source: 'iana',
      },
      'image/vnd.svf': {
        source: 'iana',
      },
      'image/vnd.tencent.tap': {
        source: 'iana',
        extensions: ['tap'],
      },
      'image/vnd.valve.source.texture': {
        source: 'iana',
        extensions: ['vtf'],
      },
      'image/vnd.wap.wbmp': {
        source: 'iana',
        extensions: ['wbmp'],
      },
      'image/vnd.xiff': {
        source: 'iana',
        extensions: ['xif'],
      },
      'image/vnd.zbrush.pcx': {
        source: 'iana',
        extensions: ['pcx'],
      },
      'image/webp': {
        source: 'apache',
        extensions: ['webp'],
      },
      'image/wmf': {
        source: 'iana',
        extensions: ['wmf'],
      },
      'image/x-3ds': {
        source: 'apache',
        extensions: ['3ds'],
      },
      'image/x-cmu-raster': {
        source: 'apache',
        extensions: ['ras'],
      },
      'image/x-cmx': {
        source: 'apache',
        extensions: ['cmx'],
      },
      'image/x-freehand': {
        source: 'apache',
        extensions: ['fh', 'fhc', 'fh4', 'fh5', 'fh7'],
      },
      'image/x-icon': {
        source: 'apache',
        compressible: true,
        extensions: ['ico'],
      },
      'image/x-jng': {
        source: 'nginx',
        extensions: ['jng'],
      },
      'image/x-mrsid-image': {
        source: 'apache',
        extensions: ['sid'],
      },
      'image/x-ms-bmp': {
        source: 'nginx',
        compressible: true,
        extensions: ['bmp'],
      },
      'image/x-pcx': {
        source: 'apache',
        extensions: ['pcx'],
      },
      'image/x-pict': {
        source: 'apache',
        extensions: ['pic', 'pct'],
      },
      'image/x-portable-anymap': {
        source: 'apache',
        extensions: ['pnm'],
      },
      'image/x-portable-bitmap': {
        source: 'apache',
        extensions: ['pbm'],
      },
      'image/x-portable-graymap': {
        source: 'apache',
        extensions: ['pgm'],
      },
      'image/x-portable-pixmap': {
        source: 'apache',
        extensions: ['ppm'],
      },
      'image/x-rgb': {
        source: 'apache',
        extensions: ['rgb'],
      },
      'image/x-tga': {
        source: 'apache',
        extensions: ['tga'],
      },
      'image/x-xbitmap': {
        source: 'apache',
        extensions: ['xbm'],
      },
      'image/x-xcf': {
        compressible: false,
      },
      'image/x-xpixmap': {
        source: 'apache',
        extensions: ['xpm'],
      },
      'image/x-xwindowdump': {
        source: 'apache',
        extensions: ['xwd'],
      },
      'message/cpim': {
        source: 'iana',
      },
      'message/delivery-status': {
        source: 'iana',
      },
      'message/disposition-notification': {
        source: 'iana',
        extensions: ['disposition-notification'],
      },
      'message/external-body': {
        source: 'iana',
      },
      'message/feedback-report': {
        source: 'iana',
      },
      'message/global': {
        source: 'iana',
        extensions: ['u8msg'],
      },
      'message/global-delivery-status': {
        source: 'iana',
        extensions: ['u8dsn'],
      },
      'message/global-disposition-notification': {
        source: 'iana',
        extensions: ['u8mdn'],
      },
      'message/global-headers': {
        source: 'iana',
        extensions: ['u8hdr'],
      },
      'message/http': {
        source: 'iana',
        compressible: false,
      },
      'message/imdn+xml': {
        source: 'iana',
        compressible: true,
      },
      'message/news': {
        source: 'iana',
      },
      'message/partial': {
        source: 'iana',
        compressible: false,
      },
      'message/rfc822': {
        source: 'iana',
        compressible: true,
        extensions: ['eml', 'mime'],
      },
      'message/s-http': {
        source: 'iana',
      },
      'message/sip': {
        source: 'iana',
      },
      'message/sipfrag': {
        source: 'iana',
      },
      'message/tracking-status': {
        source: 'iana',
      },
      'message/vnd.si.simp': {
        source: 'iana',
      },
      'message/vnd.wfa.wsc': {
        source: 'iana',
        extensions: ['wsc'],
      },
      'model/3mf': {
        source: 'iana',
        extensions: ['3mf'],
      },
      'model/e57': {
        source: 'iana',
      },
      'model/gltf+json': {
        source: 'iana',
        compressible: true,
        extensions: ['gltf'],
      },
      'model/gltf-binary': {
        source: 'iana',
        compressible: true,
        extensions: ['glb'],
      },
      'model/iges': {
        source: 'iana',
        compressible: false,
        extensions: ['igs', 'iges'],
      },
      'model/mesh': {
        source: 'iana',
        compressible: false,
        extensions: ['msh', 'mesh', 'silo'],
      },
      'model/mtl': {
        source: 'iana',
        extensions: ['mtl'],
      },
      'model/obj': {
        source: 'iana',
        extensions: ['obj'],
      },
      'model/step': {
        source: 'iana',
      },
      'model/step+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['stpx'],
      },
      'model/step+zip': {
        source: 'iana',
        compressible: false,
        extensions: ['stpz'],
      },
      'model/step-xml+zip': {
        source: 'iana',
        compressible: false,
        extensions: ['stpxz'],
      },
      'model/stl': {
        source: 'iana',
        extensions: ['stl'],
      },
      'model/vnd.collada+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['dae'],
      },
      'model/vnd.dwf': {
        source: 'iana',
        extensions: ['dwf'],
      },
      'model/vnd.flatland.3dml': {
        source: 'iana',
      },
      'model/vnd.gdl': {
        source: 'iana',
        extensions: ['gdl'],
      },
      'model/vnd.gs-gdl': {
        source: 'apache',
      },
      'model/vnd.gs.gdl': {
        source: 'iana',
      },
      'model/vnd.gtw': {
        source: 'iana',
        extensions: ['gtw'],
      },
      'model/vnd.moml+xml': {
        source: 'iana',
        compressible: true,
      },
      'model/vnd.mts': {
        source: 'iana',
        extensions: ['mts'],
      },
      'model/vnd.opengex': {
        source: 'iana',
        extensions: ['ogex'],
      },
      'model/vnd.parasolid.transmit.binary': {
        source: 'iana',
        extensions: ['x_b'],
      },
      'model/vnd.parasolid.transmit.text': {
        source: 'iana',
        extensions: ['x_t'],
      },
      'model/vnd.pytha.pyox': {
        source: 'iana',
      },
      'model/vnd.rosette.annotated-data-model': {
        source: 'iana',
      },
      'model/vnd.sap.vds': {
        source: 'iana',
        extensions: ['vds'],
      },
      'model/vnd.usdz+zip': {
        source: 'iana',
        compressible: false,
        extensions: ['usdz'],
      },
      'model/vnd.valve.source.compiled-map': {
        source: 'iana',
        extensions: ['bsp'],
      },
      'model/vnd.vtu': {
        source: 'iana',
        extensions: ['vtu'],
      },
      'model/vrml': {
        source: 'iana',
        compressible: false,
        extensions: ['wrl', 'vrml'],
      },
      'model/x3d+binary': {
        source: 'apache',
        compressible: false,
        extensions: ['x3db', 'x3dbz'],
      },
      'model/x3d+fastinfoset': {
        source: 'iana',
        extensions: ['x3db'],
      },
      'model/x3d+vrml': {
        source: 'apache',
        compressible: false,
        extensions: ['x3dv', 'x3dvz'],
      },
      'model/x3d+xml': {
        source: 'iana',
        compressible: true,
        extensions: ['x3d', 'x3dz'],
      },
      'model/x3d-vrml': {
        source: 'iana',
        extensions: ['x3dv'],
      },
      'multipart/alternative': {
        source: 'iana',
        compressible: false,
      },
      'multipart/appledouble': {
        source: 'iana',
      },
      'multipart/byteranges': {
        source: 'iana',
      },
      'multipart/digest': {
        source: 'iana',
      },
      'multipart/encrypted': {
        source: 'iana',
        compressible: false,
      },
      'multipart/form-data': {
        source: 'iana',
        compressible: false,
      },
      'multipart/header-set': {
        source: 'iana',
      },
      'multipart/mixed': {
        source: 'iana',
      },
      'multipart/multilingual': {
        source: 'iana',
      },
      'multipart/parallel': {
        source: 'iana',
      },
      'multipart/related': {
        source: 'iana',
        compressible: false,
      },
      'multipart/report': {
        source: 'iana',
      },
      'multipart/signed': {
        source: 'iana',
        compressible: false,
      },
      'multipart/vnd.bint.med-plus': {
        source: 'iana',
      },
      'multipart/voice-message': {
        source: 'iana',
      },
      'multipart/x-mixed-replace': {
        source: 'iana',
      },
      'text/1d-interleaved-parityfec': {
        source: 'iana',
      },
      'text/cache-manifest': {
        source: 'iana',
        compressible: true,
        extensions: ['appcache', 'manifest'],
      },
      'text/calendar': {
        source: 'iana',
        extensions: ['ics', 'ifb'],
      },
      'text/calender': {
        compressible: true,
      },
      'text/cmd': {
        compressible: true,
      },
      'text/coffeescript': {
        extensions: ['coffee', 'litcoffee'],
      },
      'text/cql': {
        source: 'iana',
      },
      'text/cql-expression': {
        source: 'iana',
      },
      'text/cql-identifier': {
        source: 'iana',
      },
      'text/css': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
        extensions: ['css'],
      },
      'text/csv': {
        source: 'iana',
        compressible: true,
        extensions: ['csv'],
      },
      'text/csv-schema': {
        source: 'iana',
      },
      'text/directory': {
        source: 'iana',
      },
      'text/dns': {
        source: 'iana',
      },
      'text/ecmascript': {
        source: 'iana',
      },
      'text/encaprtp': {
        source: 'iana',
      },
      'text/enriched': {
        source: 'iana',
      },
      'text/fhirpath': {
        source: 'iana',
      },
      'text/flexfec': {
        source: 'iana',
      },
      'text/fwdred': {
        source: 'iana',
      },
      'text/gff3': {
        source: 'iana',
      },
      'text/grammar-ref-list': {
        source: 'iana',
      },
      'text/html': {
        source: 'iana',
        compressible: true,
        extensions: ['html', 'htm', 'shtml'],
      },
      'text/jade': {
        extensions: ['jade'],
      },
      'text/javascript': {
        source: 'iana',
        compressible: true,
      },
      'text/jcr-cnd': {
        source: 'iana',
      },
      'text/jsx': {
        compressible: true,
        extensions: ['jsx'],
      },
      'text/less': {
        compressible: true,
        extensions: ['less'],
      },
      'text/markdown': {
        source: 'iana',
        compressible: true,
        extensions: ['markdown', 'md'],
      },
      'text/mathml': {
        source: 'nginx',
        extensions: ['mml'],
      },
      'text/mdx': {
        compressible: true,
        extensions: ['mdx'],
      },
      'text/mizar': {
        source: 'iana',
      },
      'text/n3': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
        extensions: ['n3'],
      },
      'text/parameters': {
        source: 'iana',
        charset: 'UTF-8',
      },
      'text/parityfec': {
        source: 'iana',
      },
      'text/plain': {
        source: 'iana',
        compressible: true,
        extensions: ['txt', 'text', 'conf', 'def', 'list', 'log', 'in', 'ini'],
      },
      'text/provenance-notation': {
        source: 'iana',
        charset: 'UTF-8',
      },
      'text/prs.fallenstein.rst': {
        source: 'iana',
      },
      'text/prs.lines.tag': {
        source: 'iana',
        extensions: ['dsc'],
      },
      'text/prs.prop.logic': {
        source: 'iana',
      },
      'text/raptorfec': {
        source: 'iana',
      },
      'text/red': {
        source: 'iana',
      },
      'text/rfc822-headers': {
        source: 'iana',
      },
      'text/richtext': {
        source: 'iana',
        compressible: true,
        extensions: ['rtx'],
      },
      'text/rtf': {
        source: 'iana',
        compressible: true,
        extensions: ['rtf'],
      },
      'text/rtp-enc-aescm128': {
        source: 'iana',
      },
      'text/rtploopback': {
        source: 'iana',
      },
      'text/rtx': {
        source: 'iana',
      },
      'text/sgml': {
        source: 'iana',
        extensions: ['sgml', 'sgm'],
      },
      'text/shaclc': {
        source: 'iana',
      },
      'text/shex': {
        source: 'iana',
        extensions: ['shex'],
      },
      'text/slim': {
        extensions: ['slim', 'slm'],
      },
      'text/spdx': {
        source: 'iana',
        extensions: ['spdx'],
      },
      'text/strings': {
        source: 'iana',
      },
      'text/stylus': {
        extensions: ['stylus', 'styl'],
      },
      'text/t140': {
        source: 'iana',
      },
      'text/tab-separated-values': {
        source: 'iana',
        compressible: true,
        extensions: ['tsv'],
      },
      'text/troff': {
        source: 'iana',
        extensions: ['t', 'tr', 'roff', 'man', 'me', 'ms'],
      },
      'text/turtle': {
        source: 'iana',
        charset: 'UTF-8',
        extensions: ['ttl'],
      },
      'text/ulpfec': {
        source: 'iana',
      },
      'text/uri-list': {
        source: 'iana',
        compressible: true,
        extensions: ['uri', 'uris', 'urls'],
      },
      'text/vcard': {
        source: 'iana',
        compressible: true,
        extensions: ['vcard'],
      },
      'text/vnd.a': {
        source: 'iana',
      },
      'text/vnd.abc': {
        source: 'iana',
      },
      'text/vnd.ascii-art': {
        source: 'iana',
      },
      'text/vnd.curl': {
        source: 'iana',
        extensions: ['curl'],
      },
      'text/vnd.curl.dcurl': {
        source: 'apache',
        extensions: ['dcurl'],
      },
      'text/vnd.curl.mcurl': {
        source: 'apache',
        extensions: ['mcurl'],
      },
      'text/vnd.curl.scurl': {
        source: 'apache',
        extensions: ['scurl'],
      },
      'text/vnd.debian.copyright': {
        source: 'iana',
        charset: 'UTF-8',
      },
      'text/vnd.dmclientscript': {
        source: 'iana',
      },
      'text/vnd.dvb.subtitle': {
        source: 'iana',
        extensions: ['sub'],
      },
      'text/vnd.esmertec.theme-descriptor': {
        source: 'iana',
        charset: 'UTF-8',
      },
      'text/vnd.familysearch.gedcom': {
        source: 'iana',
        extensions: ['ged'],
      },
      'text/vnd.ficlab.flt': {
        source: 'iana',
      },
      'text/vnd.fly': {
        source: 'iana',
        extensions: ['fly'],
      },
      'text/vnd.fmi.flexstor': {
        source: 'iana',
        extensions: ['flx'],
      },
      'text/vnd.gml': {
        source: 'iana',
      },
      'text/vnd.graphviz': {
        source: 'iana',
        extensions: ['gv'],
      },
      'text/vnd.hans': {
        source: 'iana',
      },
      'text/vnd.hgl': {
        source: 'iana',
      },
      'text/vnd.in3d.3dml': {
        source: 'iana',
        extensions: ['3dml'],
      },
      'text/vnd.in3d.spot': {
        source: 'iana',
        extensions: ['spot'],
      },
      'text/vnd.iptc.newsml': {
        source: 'iana',
      },
      'text/vnd.iptc.nitf': {
        source: 'iana',
      },
      'text/vnd.latex-z': {
        source: 'iana',
      },
      'text/vnd.motorola.reflex': {
        source: 'iana',
      },
      'text/vnd.ms-mediapackage': {
        source: 'iana',
      },
      'text/vnd.net2phone.commcenter.command': {
        source: 'iana',
      },
      'text/vnd.radisys.msml-basic-layout': {
        source: 'iana',
      },
      'text/vnd.senx.warpscript': {
        source: 'iana',
      },
      'text/vnd.si.uricatalogue': {
        source: 'iana',
      },
      'text/vnd.sosi': {
        source: 'iana',
      },
      'text/vnd.sun.j2me.app-descriptor': {
        source: 'iana',
        charset: 'UTF-8',
        extensions: ['jad'],
      },
      'text/vnd.trolltech.linguist': {
        source: 'iana',
        charset: 'UTF-8',
      },
      'text/vnd.wap.si': {
        source: 'iana',
      },
      'text/vnd.wap.sl': {
        source: 'iana',
      },
      'text/vnd.wap.wml': {
        source: 'iana',
        extensions: ['wml'],
      },
      'text/vnd.wap.wmlscript': {
        source: 'iana',
        extensions: ['wmls'],
      },
      'text/vtt': {
        source: 'iana',
        charset: 'UTF-8',
        compressible: true,
        extensions: ['vtt'],
      },
      'text/x-asm': {
        source: 'apache',
        extensions: ['s', 'asm'],
      },
      'text/x-c': {
        source: 'apache',
        extensions: ['c', 'cc', 'cxx', 'cpp', 'h', 'hh', 'dic'],
      },
      'text/x-component': {
        source: 'nginx',
        extensions: ['htc'],
      },
      'text/x-fortran': {
        source: 'apache',
        extensions: ['f', 'for', 'f77', 'f90'],
      },
      'text/x-gwt-rpc': {
        compressible: true,
      },
      'text/x-handlebars-template': {
        extensions: ['hbs'],
      },
      'text/x-java-source': {
        source: 'apache',
        extensions: ['java'],
      },
      'text/x-jquery-tmpl': {
        compressible: true,
      },
      'text/x-lua': {
        extensions: ['lua'],
      },
      'text/x-markdown': {
        compressible: true,
        extensions: ['mkd'],
      },
      'text/x-nfo': {
        source: 'apache',
        extensions: ['nfo'],
      },
      'text/x-opml': {
        source: 'apache',
        extensions: ['opml'],
      },
      'text/x-org': {
        compressible: true,
        extensions: ['org'],
      },
      'text/x-pascal': {
        source: 'apache',
        extensions: ['p', 'pas'],
      },
      'text/x-processing': {
        compressible: true,
        extensions: ['pde'],
      },
      'text/x-sass': {
        extensions: ['sass'],
      },
      'text/x-scss': {
        extensions: ['scss'],
      },
      'text/x-setext': {
        source: 'apache',
        extensions: ['etx'],
      },
      'text/x-sfv': {
        source: 'apache',
        extensions: ['sfv'],
      },
      'text/x-suse-ymp': {
        compressible: true,
        extensions: ['ymp'],
      },
      'text/x-uuencode': {
        source: 'apache',
        extensions: ['uu'],
      },
      'text/x-vcalendar': {
        source: 'apache',
        extensions: ['vcs'],
      },
      'text/x-vcard': {
        source: 'apache',
        extensions: ['vcf'],
      },
      'text/xml': {
        source: 'iana',
        compressible: true,
        extensions: ['xml'],
      },
      'text/xml-external-parsed-entity': {
        source: 'iana',
      },
      'text/yaml': {
        compressible: true,
        extensions: ['yaml', 'yml'],
      },
      'video/1d-interleaved-parityfec': {
        source: 'iana',
      },
      'video/3gpp': {
        source: 'iana',
        extensions: ['3gp', '3gpp'],
      },
      'video/3gpp-tt': {
        source: 'iana',
      },
      'video/3gpp2': {
        source: 'iana',
        extensions: ['3g2'],
      },
      'video/av1': {
        source: 'iana',
      },
      'video/bmpeg': {
        source: 'iana',
      },
      'video/bt656': {
        source: 'iana',
      },
      'video/celb': {
        source: 'iana',
      },
      'video/dv': {
        source: 'iana',
      },
      'video/encaprtp': {
        source: 'iana',
      },
      'video/ffv1': {
        source: 'iana',
      },
      'video/flexfec': {
        source: 'iana',
      },
      'video/h261': {
        source: 'iana',
        extensions: ['h261'],
      },
      'video/h263': {
        source: 'iana',
        extensions: ['h263'],
      },
      'video/h263-1998': {
        source: 'iana',
      },
      'video/h263-2000': {
        source: 'iana',
      },
      'video/h264': {
        source: 'iana',
        extensions: ['h264'],
      },
      'video/h264-rcdo': {
        source: 'iana',
      },
      'video/h264-svc': {
        source: 'iana',
      },
      'video/h265': {
        source: 'iana',
      },
      'video/iso.segment': {
        source: 'iana',
        extensions: ['m4s'],
      },
      'video/jpeg': {
        source: 'iana',
        extensions: ['jpgv'],
      },
      'video/jpeg2000': {
        source: 'iana',
      },
      'video/jpm': {
        source: 'apache',
        extensions: ['jpm', 'jpgm'],
      },
      'video/jxsv': {
        source: 'iana',
      },
      'video/mj2': {
        source: 'iana',
        extensions: ['mj2', 'mjp2'],
      },
      'video/mp1s': {
        source: 'iana',
      },
      'video/mp2p': {
        source: 'iana',
      },
      'video/mp2t': {
        source: 'iana',
        extensions: ['ts'],
      },
      'video/mp4': {
        source: 'iana',
        compressible: false,
        extensions: ['mp4', 'mp4v', 'mpg4'],
      },
      'video/mp4v-es': {
        source: 'iana',
      },
      'video/mpeg': {
        source: 'iana',
        compressible: false,
        extensions: ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'],
      },
      'video/mpeg4-generic': {
        source: 'iana',
      },
      'video/mpv': {
        source: 'iana',
      },
      'video/nv': {
        source: 'iana',
      },
      'video/ogg': {
        source: 'iana',
        compressible: false,
        extensions: ['ogv'],
      },
      'video/parityfec': {
        source: 'iana',
      },
      'video/pointer': {
        source: 'iana',
      },
      'video/quicktime': {
        source: 'iana',
        compressible: false,
        extensions: ['qt', 'mov'],
      },
      'video/raptorfec': {
        source: 'iana',
      },
      'video/raw': {
        source: 'iana',
      },
      'video/rtp-enc-aescm128': {
        source: 'iana',
      },
      'video/rtploopback': {
        source: 'iana',
      },
      'video/rtx': {
        source: 'iana',
      },
      'video/scip': {
        source: 'iana',
      },
      'video/smpte291': {
        source: 'iana',
      },
      'video/smpte292m': {
        source: 'iana',
      },
      'video/ulpfec': {
        source: 'iana',
      },
      'video/vc1': {
        source: 'iana',
      },
      'video/vc2': {
        source: 'iana',
      },
      'video/vnd.cctv': {
        source: 'iana',
      },
      'video/vnd.dece.hd': {
        source: 'iana',
        extensions: ['uvh', 'uvvh'],
      },
      'video/vnd.dece.mobile': {
        source: 'iana',
        extensions: ['uvm', 'uvvm'],
      },
      'video/vnd.dece.mp4': {
        source: 'iana',
      },
      'video/vnd.dece.pd': {
        source: 'iana',
        extensions: ['uvp', 'uvvp'],
      },
      'video/vnd.dece.sd': {
        source: 'iana',
        extensions: ['uvs', 'uvvs'],
      },
      'video/vnd.dece.video': {
        source: 'iana',
        extensions: ['uvv', 'uvvv'],
      },
      'video/vnd.directv.mpeg': {
        source: 'iana',
      },
      'video/vnd.directv.mpeg-tts': {
        source: 'iana',
      },
      'video/vnd.dlna.mpeg-tts': {
        source: 'iana',
      },
      'video/vnd.dvb.file': {
        source: 'iana',
        extensions: ['dvb'],
      },
      'video/vnd.fvt': {
        source: 'iana',
        extensions: ['fvt'],
      },
      'video/vnd.hns.video': {
        source: 'iana',
      },
      'video/vnd.iptvforum.1dparityfec-1010': {
        source: 'iana',
      },
      'video/vnd.iptvforum.1dparityfec-2005': {
        source: 'iana',
      },
      'video/vnd.iptvforum.2dparityfec-1010': {
        source: 'iana',
      },
      'video/vnd.iptvforum.2dparityfec-2005': {
        source: 'iana',
      },
      'video/vnd.iptvforum.ttsavc': {
        source: 'iana',
      },
      'video/vnd.iptvforum.ttsmpeg2': {
        source: 'iana',
      },
      'video/vnd.motorola.video': {
        source: 'iana',
      },
      'video/vnd.motorola.videop': {
        source: 'iana',
      },
      'video/vnd.mpegurl': {
        source: 'iana',
        extensions: ['mxu', 'm4u'],
      },
      'video/vnd.ms-playready.media.pyv': {
        source: 'iana',
        extensions: ['pyv'],
      },
      'video/vnd.nokia.interleaved-multimedia': {
        source: 'iana',
      },
      'video/vnd.nokia.mp4vr': {
        source: 'iana',
      },
      'video/vnd.nokia.videovoip': {
        source: 'iana',
      },
      'video/vnd.objectvideo': {
        source: 'iana',
      },
      'video/vnd.radgamettools.bink': {
        source: 'iana',
      },
      'video/vnd.radgamettools.smacker': {
        source: 'iana',
      },
      'video/vnd.sealed.mpeg1': {
        source: 'iana',
      },
      'video/vnd.sealed.mpeg4': {
        source: 'iana',
      },
      'video/vnd.sealed.swf': {
        source: 'iana',
      },
      'video/vnd.sealedmedia.softseal.mov': {
        source: 'iana',
      },
      'video/vnd.uvvu.mp4': {
        source: 'iana',
        extensions: ['uvu', 'uvvu'],
      },
      'video/vnd.vivo': {
        source: 'iana',
        extensions: ['viv'],
      },
      'video/vnd.youtube.yt': {
        source: 'iana',
      },
      'video/vp8': {
        source: 'iana',
      },
      'video/vp9': {
        source: 'iana',
      },
      'video/webm': {
        source: 'apache',
        compressible: false,
        extensions: ['webm'],
      },
      'video/x-f4v': {
        source: 'apache',
        extensions: ['f4v'],
      },
      'video/x-fli': {
        source: 'apache',
        extensions: ['fli'],
      },
      'video/x-flv': {
        source: 'apache',
        compressible: false,
        extensions: ['flv'],
      },
      'video/x-m4v': {
        source: 'apache',
        extensions: ['m4v'],
      },
      'video/x-matroska': {
        source: 'apache',
        compressible: false,
        extensions: ['mkv', 'mk3d', 'mks'],
      },
      'video/x-mng': {
        source: 'apache',
        extensions: ['mng'],
      },
      'video/x-ms-asf': {
        source: 'apache',
        extensions: ['asf', 'asx'],
      },
      'video/x-ms-vob': {
        source: 'apache',
        extensions: ['vob'],
      },
      'video/x-ms-wm': {
        source: 'apache',
        extensions: ['wm'],
      },
      'video/x-ms-wmv': {
        source: 'apache',
        compressible: false,
        extensions: ['wmv'],
      },
      'video/x-ms-wmx': {
        source: 'apache',
        extensions: ['wmx'],
      },
      'video/x-ms-wvx': {
        source: 'apache',
        extensions: ['wvx'],
      },
      'video/x-msvideo': {
        source: 'apache',
        extensions: ['avi'],
      },
      'video/x-sgi-movie': {
        source: 'apache',
        extensions: ['movie'],
      },
      'video/x-smv': {
        source: 'apache',
        extensions: ['smv'],
      },
      'x-conference/x-cooltalk': {
        source: 'apache',
        extensions: ['ice'],
      },
      'x-shader/x-fragment': {
        compressible: true,
      },
      'x-shader/x-vertex': {
        compressible: true,
      },
    };
  },
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  'node_modules/mime-db/index.js'(exports, module) {
    module.exports = require_db();
  },
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  'node_modules/mime-types/index.js'(exports) {
    'use strict';
    var db = require_mime_db();
    var extname = __require('path').extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type !== 'string') {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return 'UTF-8';
      }
      return false;
    }
    function contentType(str2) {
      if (!str2 || typeof str2 !== 'string') {
        return false;
      }
      var mime = str2.indexOf('/') === -1 ? exports.lookup(str2) : str2;
      if (!mime) {
        return false;
      }
      if (mime.indexOf('charset') === -1) {
        var charset2 = exports.charset(mime);
        if (charset2) mime += '; charset=' + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== 'string') {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path5) {
      if (!path5 || typeof path5 !== 'string') {
        return false;
      }
      var extension2 = extname('x.' + path5)
        .toLowerCase()
        .substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions3, types) {
      var preference = ['nginx', 'apache', void 0, 'iana'];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions3[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (
              types[extension2] !== 'application/octet-stream' &&
              (from > to || (from === to && types[extension2].substr(0, 12) === 'application/'))
            ) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  },
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  'node_modules/asynckit/lib/defer.js'(exports, module) {
    module.exports = defer;
    function defer(fn) {
      var nextTick =
        typeof setImmediate == 'function'
          ? setImmediate
          : typeof process == 'object' && typeof process.nextTick == 'function'
            ? process.nextTick
            : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  },
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  'node_modules/asynckit/lib/async.js'(exports, module) {
    var defer = require_defer();
    module.exports = async2;
    function async2(callback) {
      var isAsync = false;
      defer(function () {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  },
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  'node_modules/asynckit/lib/abort.js'(exports, module) {
    module.exports = abort;
    function abort(state2) {
      Object.keys(state2.jobs).forEach(clean.bind(state2));
      state2.jobs = {};
    }
    function clean(key2) {
      if (typeof this.jobs[key2] == 'function') {
        this.jobs[key2]();
      }
    }
  },
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  'node_modules/asynckit/lib/iterate.js'(exports, module) {
    var async2 = require_async();
    var abort = require_abort();
    module.exports = iterate;
    function iterate(list, iterator2, state2, callback) {
      var key2 = state2['keyedList'] ? state2['keyedList'][state2.index] : state2.index;
      state2.jobs[key2] = runJob(iterator2, key2, list[key2], function (error, output) {
        if (!(key2 in state2.jobs)) {
          return;
        }
        delete state2.jobs[key2];
        if (error) {
          abort(state2);
        } else {
          state2.results[key2] = output;
        }
        callback(error, state2.results);
      });
    }
    function runJob(iterator2, key2, item, callback) {
      var aborter;
      if (iterator2.length == 2) {
        aborter = iterator2(item, async2(callback));
      } else {
        aborter = iterator2(item, key2, async2(callback));
      }
      return aborter;
    }
  },
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  'node_modules/asynckit/lib/state.js'(exports, module) {
    module.exports = state2;
    function state2(list, sortMethod) {
      var isNamedList = !Array.isArray(list),
        initState = {
          index: 0,
          keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
          jobs: {},
          results: isNamedList ? {} : [],
          size: isNamedList ? Object.keys(list).length : list.length,
        };
      if (sortMethod) {
        initState.keyedList.sort(
          isNamedList
            ? sortMethod
            : function (a, b) {
                return sortMethod(list[a], list[b]);
              }
        );
      }
      return initState;
    }
  },
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  'node_modules/asynckit/lib/terminator.js'(exports, module) {
    var abort = require_abort();
    var async2 = require_async();
    module.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async2(callback)(null, this.results);
    }
  },
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  'node_modules/asynckit/parallel.js'(exports, module) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module.exports = parallel;
    function parallel(list, iterator2, callback) {
      var state2 = initState(list);
      while (state2.index < (state2['keyedList'] || list).length) {
        iterate(list, iterator2, state2, function (error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state2.jobs).length === 0) {
            callback(null, state2.results);
            return;
          }
        });
        state2.index++;
      }
      return terminator.bind(state2, callback);
    }
  },
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  'node_modules/asynckit/serialOrdered.js'(exports, module) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module.exports = serialOrdered;
    module.exports.ascending = ascending;
    module.exports.descending = descending;
    function serialOrdered(list, iterator2, sortMethod, callback) {
      var state2 = initState(list, sortMethod);
      iterate(list, iterator2, state2, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state2.index++;
        if (state2.index < (state2['keyedList'] || list).length) {
          iterate(list, iterator2, state2, iteratorHandler);
          return;
        }
        callback(null, state2.results);
      });
      return terminator.bind(state2, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  },
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  'node_modules/asynckit/serial.js'(exports, module) {
    var serialOrdered = require_serialOrdered();
    module.exports = serial;
    function serial(list, iterator2, callback) {
      return serialOrdered(list, iterator2, null, callback);
    }
  },
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  'node_modules/asynckit/index.js'(exports, module) {
    module.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered(),
    };
  },
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  'node_modules/es-object-atoms/index.js'(exports, module) {
    'use strict';
    module.exports = Object;
  },
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  'node_modules/es-errors/index.js'(exports, module) {
    'use strict';
    module.exports = Error;
  },
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  'node_modules/es-errors/eval.js'(exports, module) {
    'use strict';
    module.exports = EvalError;
  },
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  'node_modules/es-errors/range.js'(exports, module) {
    'use strict';
    module.exports = RangeError;
  },
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  'node_modules/es-errors/ref.js'(exports, module) {
    'use strict';
    module.exports = ReferenceError;
  },
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  'node_modules/es-errors/syntax.js'(exports, module) {
    'use strict';
    module.exports = SyntaxError;
  },
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  'node_modules/es-errors/type.js'(exports, module) {
    'use strict';
    module.exports = TypeError;
  },
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  'node_modules/es-errors/uri.js'(exports, module) {
    'use strict';
    module.exports = URIError;
  },
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  'node_modules/math-intrinsics/abs.js'(exports, module) {
    'use strict';
    module.exports = Math.abs;
  },
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  'node_modules/math-intrinsics/floor.js'(exports, module) {
    'use strict';
    module.exports = Math.floor;
  },
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  'node_modules/math-intrinsics/max.js'(exports, module) {
    'use strict';
    module.exports = Math.max;
  },
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  'node_modules/math-intrinsics/min.js'(exports, module) {
    'use strict';
    module.exports = Math.min;
  },
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  'node_modules/math-intrinsics/pow.js'(exports, module) {
    'use strict';
    module.exports = Math.pow;
  },
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  'node_modules/math-intrinsics/round.js'(exports, module) {
    'use strict';
    module.exports = Math.round;
  },
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  'node_modules/math-intrinsics/isNaN.js'(exports, module) {
    'use strict';
    module.exports =
      Number.isNaN ||
      function isNaN2(a) {
        return a !== a;
      };
  },
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  'node_modules/math-intrinsics/sign.js'(exports, module) {
    'use strict';
    var $isNaN = require_isNaN();
    module.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  },
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  'node_modules/gopd/gOPD.js'(exports, module) {
    'use strict';
    module.exports = Object.getOwnPropertyDescriptor;
  },
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  'node_modules/gopd/index.js'(exports, module) {
    'use strict';
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], 'length');
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  },
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  'node_modules/es-define-property/index.js'(exports, module) {
    'use strict';
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, 'a', { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  },
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  'node_modules/has-symbols/shams.js'(exports, module) {
    'use strict';
    module.exports = function hasSymbols() {
      if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
        return false;
      }
      if (typeof Symbol.iterator === 'symbol') {
        return true;
      }
      var obj = {};
      var sym = Symbol('test');
      var symObj = Object(sym);
      if (typeof sym === 'string') {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
        return false;
      }
      if (
        typeof Object.getOwnPropertyNames === 'function' &&
        Object.getOwnPropertyNames(obj).length !== 0
      ) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === 'function') {
        var descriptor =
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  },
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  'node_modules/has-symbols/index.js'(exports, module) {
    'use strict';
    var origSymbol = typeof Symbol !== 'undefined' && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== 'function') {
        return false;
      }
      if (typeof Symbol !== 'function') {
        return false;
      }
      if (typeof origSymbol('foo') !== 'symbol') {
        return false;
      }
      if (typeof Symbol('bar') !== 'symbol') {
        return false;
      }
      return hasSymbolSham();
    };
  },
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  'node_modules/get-proto/Reflect.getPrototypeOf.js'(exports, module) {
    'use strict';
    module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;
  },
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  'node_modules/get-proto/Object.getPrototypeOf.js'(exports, module) {
    'use strict';
    var $Object = require_es_object_atoms();
    module.exports = $Object.getPrototypeOf || null;
  },
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  'node_modules/function-bind/implementation.js'(exports, module) {
    'use strict';
    var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = '[object Function]';
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function (arr, joiner) {
      var str2 = '';
      for (var i = 0; i < arr.length; i += 1) {
        str2 += arr[i];
        if (i + 1 < arr.length) {
          str2 += joiner;
        }
      }
      return str2;
    };
    module.exports = function bind2(that) {
      var target = this;
      if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function () {
        if (this instanceof bound) {
          var result = target.apply(this, concatty(args, arguments));
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(that, concatty(args, arguments));
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
      }
      bound = Function(
        'binder',
        'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }'
      )(binder);
      if (target.prototype) {
        var Empty = function Empty2() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  },
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  'node_modules/function-bind/index.js'(exports, module) {
    'use strict';
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  },
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  'node_modules/call-bind-apply-helpers/functionCall.js'(exports, module) {
    'use strict';
    module.exports = Function.prototype.call;
  },
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  'node_modules/call-bind-apply-helpers/functionApply.js'(exports, module) {
    'use strict';
    module.exports = Function.prototype.apply;
  },
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  'node_modules/call-bind-apply-helpers/reflectApply.js'(exports, module) {
    'use strict';
    module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;
  },
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  'node_modules/call-bind-apply-helpers/actualApply.js'(exports, module) {
    'use strict';
    var bind2 = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind2.call($call, $apply);
  },
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  'node_modules/call-bind-apply-helpers/index.js'(exports, module) {
    'use strict';
    var bind2 = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== 'function') {
        throw new $TypeError('a function is required');
      }
      return $actualApply(bind2, $call, args);
    };
  },
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  'node_modules/dunder-proto/get.js'(exports, module) {
    'use strict';
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor =
        /** @type {{ __proto__?: typeof Array.prototype }} */
        [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
        throw e;
      }
    }
    var desc =
      !!hasProtoAccessor &&
      gOPD &&
      gOPD(
        Object.prototype,
        /** @type {keyof typeof Object.prototype} */
        '__proto__'
      );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports =
      desc && typeof desc.get === 'function'
        ? callBind([desc.get])
        : typeof $getPrototypeOf === 'function'
          ? /** @type {import('./get')} */
            function getDunder(value) {
              return $getPrototypeOf(value == null ? value : $Object(value));
            }
          : false;
  },
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  'node_modules/get-proto/index.js'(exports, module) {
    'use strict';
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module.exports = reflectGetProto
      ? function getProto(O) {
          return reflectGetProto(O);
        }
      : originalGetProto
        ? function getProto(O) {
            if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
              throw new TypeError('getProto: not an object');
            }
            return originalGetProto(O);
          }
        : getDunderProto
          ? function getProto(O) {
              return getDunderProto(O);
            }
          : null;
  },
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  'node_modules/hasown/index.js'(exports, module) {
    'use strict';
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind2 = require_function_bind();
    module.exports = bind2.call(call, $hasOwn);
  },
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  'node_modules/get-intrinsic/index.js'(exports, module) {
    'use strict';
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function (expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
      } catch (e) {}
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function () {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD
      ? (function () {
          try {
            arguments.callee;
            return throwTypeError;
          } catch (calleeThrows) {
            try {
              return $gOPD(arguments, 'callee').get;
            } catch (gOPDthrows) {
              return throwTypeError;
            }
          }
        })()
      : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray =
      typeof Uint8Array === 'undefined' || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      '%AggregateError%': typeof AggregateError === 'undefined' ? undefined2 : AggregateError,
      '%Array%': Array,
      '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined2 : ArrayBuffer,
      '%ArrayIteratorPrototype%':
        hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      '%AsyncFromSyncIteratorPrototype%': undefined2,
      '%AsyncFunction%': needsEval,
      '%AsyncGenerator%': needsEval,
      '%AsyncGeneratorFunction%': needsEval,
      '%AsyncIteratorPrototype%': needsEval,
      '%Atomics%': typeof Atomics === 'undefined' ? undefined2 : Atomics,
      '%BigInt%': typeof BigInt === 'undefined' ? undefined2 : BigInt,
      '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined2 : BigInt64Array,
      '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined2 : BigUint64Array,
      '%Boolean%': Boolean,
      '%DataView%': typeof DataView === 'undefined' ? undefined2 : DataView,
      '%Date%': Date,
      '%decodeURI%': decodeURI,
      '%decodeURIComponent%': decodeURIComponent,
      '%encodeURI%': encodeURI,
      '%encodeURIComponent%': encodeURIComponent,
      '%Error%': $Error,
      '%eval%': eval,
      // eslint-disable-line no-eval
      '%EvalError%': $EvalError,
      '%Float16Array%': typeof Float16Array === 'undefined' ? undefined2 : Float16Array,
      '%Float32Array%': typeof Float32Array === 'undefined' ? undefined2 : Float32Array,
      '%Float64Array%': typeof Float64Array === 'undefined' ? undefined2 : Float64Array,
      '%FinalizationRegistry%':
        typeof FinalizationRegistry === 'undefined' ? undefined2 : FinalizationRegistry,
      '%Function%': $Function,
      '%GeneratorFunction%': needsEval,
      '%Int8Array%': typeof Int8Array === 'undefined' ? undefined2 : Int8Array,
      '%Int16Array%': typeof Int16Array === 'undefined' ? undefined2 : Int16Array,
      '%Int32Array%': typeof Int32Array === 'undefined' ? undefined2 : Int32Array,
      '%isFinite%': isFinite,
      '%isNaN%': isNaN,
      '%IteratorPrototype%':
        hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      '%JSON%': typeof JSON === 'object' ? JSON : undefined2,
      '%Map%': typeof Map === 'undefined' ? undefined2 : Map,
      '%MapIteratorPrototype%':
        typeof Map === 'undefined' || !hasSymbols || !getProto
          ? undefined2
          : getProto(/* @__PURE__ */ new Map()[Symbol.iterator]()),
      '%Math%': Math,
      '%Number%': Number,
      '%Object%': $Object,
      '%Object.getOwnPropertyDescriptor%': $gOPD,
      '%parseFloat%': parseFloat,
      '%parseInt%': parseInt,
      '%Promise%': typeof Promise === 'undefined' ? undefined2 : Promise,
      '%Proxy%': typeof Proxy === 'undefined' ? undefined2 : Proxy,
      '%RangeError%': $RangeError,
      '%ReferenceError%': $ReferenceError,
      '%Reflect%': typeof Reflect === 'undefined' ? undefined2 : Reflect,
      '%RegExp%': RegExp,
      '%Set%': typeof Set === 'undefined' ? undefined2 : Set,
      '%SetIteratorPrototype%':
        typeof Set === 'undefined' || !hasSymbols || !getProto
          ? undefined2
          : getProto(/* @__PURE__ */ new Set()[Symbol.iterator]()),
      '%SharedArrayBuffer%':
        typeof SharedArrayBuffer === 'undefined' ? undefined2 : SharedArrayBuffer,
      '%String%': String,
      '%StringIteratorPrototype%':
        hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined2,
      '%Symbol%': hasSymbols ? Symbol : undefined2,
      '%SyntaxError%': $SyntaxError,
      '%ThrowTypeError%': ThrowTypeError,
      '%TypedArray%': TypedArray,
      '%TypeError%': $TypeError,
      '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined2 : Uint8Array,
      '%Uint8ClampedArray%':
        typeof Uint8ClampedArray === 'undefined' ? undefined2 : Uint8ClampedArray,
      '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined2 : Uint16Array,
      '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined2 : Uint32Array,
      '%URIError%': $URIError,
      '%WeakMap%': typeof WeakMap === 'undefined' ? undefined2 : WeakMap,
      '%WeakRef%': typeof WeakRef === 'undefined' ? undefined2 : WeakRef,
      '%WeakSet%': typeof WeakSet === 'undefined' ? undefined2 : WeakSet,
      '%Function.prototype.call%': $call,
      '%Function.prototype.apply%': $apply,
      '%Object.defineProperty%': $defineProperty,
      '%Object.getPrototypeOf%': $ObjectGPO,
      '%Math.abs%': abs,
      '%Math.floor%': floor,
      '%Math.max%': max,
      '%Math.min%': min,
      '%Math.pow%': pow,
      '%Math.round%': round,
      '%Math.sign%': sign,
      '%Reflect.getPrototypeOf%': $ReflectGPO,
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS['%Error.prototype%'] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name3) {
      var value;
      if (name3 === '%AsyncFunction%') {
        value = getEvalledConstructor('async function () {}');
      } else if (name3 === '%GeneratorFunction%') {
        value = getEvalledConstructor('function* () {}');
      } else if (name3 === '%AsyncGeneratorFunction%') {
        value = getEvalledConstructor('async function* () {}');
      } else if (name3 === '%AsyncGenerator%') {
        var fn = doEval2('%AsyncGeneratorFunction%');
        if (fn) {
          value = fn.prototype;
        }
      } else if (name3 === '%AsyncIteratorPrototype%') {
        var gen = doEval2('%AsyncGenerator%');
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name3] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
      '%ArrayPrototype%': ['Array', 'prototype'],
      '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
      '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
      '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
      '%ArrayProto_values%': ['Array', 'prototype', 'values'],
      '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
      '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
      '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
      '%BooleanPrototype%': ['Boolean', 'prototype'],
      '%DataViewPrototype%': ['DataView', 'prototype'],
      '%DatePrototype%': ['Date', 'prototype'],
      '%ErrorPrototype%': ['Error', 'prototype'],
      '%EvalErrorPrototype%': ['EvalError', 'prototype'],
      '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
      '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
      '%FunctionPrototype%': ['Function', 'prototype'],
      '%Generator%': ['GeneratorFunction', 'prototype'],
      '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
      '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
      '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
      '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
      '%JSONParse%': ['JSON', 'parse'],
      '%JSONStringify%': ['JSON', 'stringify'],
      '%MapPrototype%': ['Map', 'prototype'],
      '%NumberPrototype%': ['Number', 'prototype'],
      '%ObjectPrototype%': ['Object', 'prototype'],
      '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
      '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
      '%PromisePrototype%': ['Promise', 'prototype'],
      '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
      '%Promise_all%': ['Promise', 'all'],
      '%Promise_reject%': ['Promise', 'reject'],
      '%Promise_resolve%': ['Promise', 'resolve'],
      '%RangeErrorPrototype%': ['RangeError', 'prototype'],
      '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
      '%RegExpPrototype%': ['RegExp', 'prototype'],
      '%SetPrototype%': ['Set', 'prototype'],
      '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
      '%StringPrototype%': ['String', 'prototype'],
      '%SymbolPrototype%': ['Symbol', 'prototype'],
      '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
      '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
      '%TypeErrorPrototype%': ['TypeError', 'prototype'],
      '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
      '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
      '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
      '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
      '%URIErrorPrototype%': ['URIError', 'prototype'],
      '%WeakMapPrototype%': ['WeakMap', 'prototype'],
      '%WeakSetPrototype%': ['WeakSet', 'prototype'],
    };
    var bind2 = require_function_bind();
    var hasOwn2 = require_hasown();
    var $concat = bind2.call($call, Array.prototype.concat);
    var $spliceApply = bind2.call($apply, Array.prototype.splice);
    var $replace = bind2.call($call, String.prototype.replace);
    var $strSlice = bind2.call($call, String.prototype.slice);
    var $exec = bind2.call($call, RegExp.prototype.exec);
    var rePropName =
      /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === '%' && last !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
      } else if (last === '%' && first !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
      }
      var result = [];
      $replace(string, rePropName, function (match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name3, allowMissing) {
      var intrinsicName = name3;
      var alias;
      if (hasOwn2(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = '%' + alias[0] + '%';
      }
      if (hasOwn2(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === 'undefined' && !allowMissing) {
          throw new $TypeError(
            'intrinsic ' + name3 + ' exists, but is not available. Please file an issue!'
          );
        }
        return {
          alias,
          name: intrinsicName,
          value,
        };
      }
      throw new $SyntaxError('intrinsic ' + name3 + ' does not exist!');
    };
    module.exports = function GetIntrinsic(name3, allowMissing) {
      if (typeof name3 !== 'string' || name3.length === 0) {
        throw new $TypeError('intrinsic name must be a non-empty string');
      }
      if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name3) === null) {
        throw new $SyntaxError(
          '`%` may not be present anywhere but at the beginning and end of the intrinsic name'
        );
      }
      var parts = stringToPath(name3);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
      var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if (
          (first === '"' ||
            first === "'" ||
            first === '`' ||
            last === '"' ||
            last === "'" ||
            last === '`') &&
          first !== last
        ) {
          throw new $SyntaxError('property names with quotes must have matching quotes');
        }
        if (part === 'constructor' || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += '.' + part;
        intrinsicRealName = '%' + intrinsicBaseName + '%';
        if (hasOwn2(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError(
                'base intrinsic for ' + name3 + ' exists, but the property is not available.'
              );
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn2(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  },
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  'node_modules/has-tostringtag/shams.js'(exports, module) {
    'use strict';
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  },
});

// node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({
  'node_modules/es-set-tostringtag/index.js'(exports, module) {
    'use strict';
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
    var hasToStringTag = require_shams2()();
    var hasOwn2 = require_hasown();
    var $TypeError = require_type();
    var toStringTag2 = hasToStringTag ? Symbol.toStringTag : null;
    module.exports = function setToStringTag(object, value) {
      var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
      var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
      if (
        (typeof overrideIfSet !== 'undefined' && typeof overrideIfSet !== 'boolean') ||
        (typeof nonConfigurable !== 'undefined' && typeof nonConfigurable !== 'boolean')
      ) {
        throw new $TypeError(
          'if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans'
        );
      }
      if (toStringTag2 && (overrideIfSet || !hasOwn2(object, toStringTag2))) {
        if ($defineProperty) {
          $defineProperty(object, toStringTag2, {
            configurable: !nonConfigurable,
            enumerable: false,
            value,
            writable: false,
          });
        } else {
          object[toStringTag2] = value;
        }
      }
    };
  },
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  'node_modules/form-data/lib/populate.js'(exports, module) {
    'use strict';
    module.exports = function (dst, src) {
      Object.keys(src).forEach(function (prop2) {
        dst[prop2] = dst[prop2] || src[prop2];
      });
      return dst;
    };
  },
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  'node_modules/form-data/lib/form_data.js'(exports, module) {
    'use strict';
    var CombinedStream = require_combined_stream();
    var util3 = __require('util');
    var path5 = __require('path');
    var http4 = __require('http');
    var https3 = __require('https');
    var parseUrl = __require('url').parse;
    var fs2 = __require('fs');
    var Stream2 = __require('stream').Stream;
    var crypto10 = __require('crypto');
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var setToStringTag = require_es_set_tostringtag();
    var hasOwn2 = require_hasown();
    var populate = require_populate();
    function FormData3(options) {
      if (!(this instanceof FormData3)) {
        return new FormData3(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    util3.inherits(FormData3, CombinedStream);
    FormData3.LINE_BREAK = '\r\n';
    FormData3.DEFAULT_CONTENT_TYPE = 'application/octet-stream';
    FormData3.prototype.append = function (field, value, options) {
      options = options || {};
      if (typeof options === 'string') {
        options = { filename: options };
      }
      var append3 = CombinedStream.prototype.append.bind(this);
      if (typeof value === 'number' || value == null) {
        value = String(value);
      }
      if (Array.isArray(value)) {
        this._error(new Error('Arrays are not supported.'));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append3(header);
      append3(value);
      append3(footer);
      this._trackLength(header, value, options);
    };
    FormData3.prototype._trackLength = function (header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += Number(options.knownLength);
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === 'string') {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData3.LINE_BREAK.length;
      if (
        !value ||
        (!value.path &&
          !(value.readable && hasOwn2(value, 'httpVersion')) &&
          !(value instanceof Stream2))
      ) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData3.prototype._lengthRetriever = function (value, callback) {
      if (hasOwn2(value, 'fd')) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs2.stat(value.path, function (err, stat) {
            if (err) {
              callback(err);
              return;
            }
            var fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (hasOwn2(value, 'httpVersion')) {
        callback(null, Number(value.headers['content-length']));
      } else if (hasOwn2(value, 'httpModule')) {
        value.on('response', function (response) {
          value.pause();
          callback(null, Number(response.headers['content-length']));
        });
        value.resume();
      } else {
        callback('Unknown stream');
      }
    };
    FormData3.prototype._multiPartHeader = function (field, value, options) {
      if (typeof options.header === 'string') {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = '';
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(
          contentDisposition || []
        ),
        // if no content type. allow it to be empty array
        'Content-Type': [].concat(contentType || []),
      };
      if (typeof options.header === 'object') {
        populate(headers, options.header);
      }
      var header;
      for (var prop2 in headers) {
        if (hasOwn2(headers, prop2)) {
          header = headers[prop2];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop2 + ': ' + header.join('; ') + FormData3.LINE_BREAK;
          }
        }
      }
      return '--' + this.getBoundary() + FormData3.LINE_BREAK + contents + FormData3.LINE_BREAK;
    };
    FormData3.prototype._getContentDisposition = function (value, options) {
      var filename;
      if (typeof options.filepath === 'string') {
        filename = path5.normalize(options.filepath).replace(/\\/g, '/');
      } else if (options.filename || (value && (value.name || value.path))) {
        filename = path5.basename(options.filename || (value && (value.name || value.path)));
      } else if (value && value.readable && hasOwn2(value, 'httpVersion')) {
        filename = path5.basename(value.client._httpMessage.path || '');
      }
      if (filename) {
        return 'filename="' + filename + '"';
      }
    };
    FormData3.prototype._getContentType = function (value, options) {
      var contentType = options.contentType;
      if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value && value.readable && hasOwn2(value, 'httpVersion')) {
        contentType = value.headers['content-type'];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && value && typeof value === 'object') {
        contentType = FormData3.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData3.prototype._multiPartFooter = function () {
      return function (next2) {
        var footer = FormData3.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next2(footer);
      }.bind(this);
    };
    FormData3.prototype._lastBoundary = function () {
      return '--' + this.getBoundary() + '--' + FormData3.LINE_BREAK;
    };
    FormData3.prototype.getHeaders = function (userHeaders) {
      var header;
      var formHeaders = {
        'content-type': 'multipart/form-data; boundary=' + this.getBoundary(),
      };
      for (header in userHeaders) {
        if (hasOwn2(userHeaders, header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData3.prototype.setBoundary = function (boundary2) {
      if (typeof boundary2 !== 'string') {
        throw new TypeError('FormData boundary must be a string');
      }
      this._boundary = boundary2;
    };
    FormData3.prototype.getBoundary = function () {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData3.prototype.getBuffer = function () {
      var dataBuffer = new Buffer.alloc(0);
      var boundary2 = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== 'function') {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (
            typeof this._streams[i] !== 'string' ||
            this._streams[i].substring(2, boundary2.length + 2) !== boundary2
          ) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData3.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData3.prototype._generateBoundary = function () {
      this._boundary = '--------------------------' + crypto10.randomBytes(12).toString('hex');
    };
    FormData3.prototype.getLengthSync = function () {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error('Cannot calculate proper length in synchronous way.'));
      }
      return knownLength;
    };
    FormData3.prototype.hasKnownLength = function () {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData3.prototype.getLength = function (cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function (err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function (length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData3.prototype.submit = function (params, cb) {
      var request;
      var options;
      var defaults3 = { method: 'post' };
      if (typeof params === 'string') {
        params = parseUrl(params);
        options = populate(
          {
            port: params.port,
            path: params.pathname,
            host: params.hostname,
            protocol: params.protocol,
          },
          defaults3
        );
      } else {
        options = populate(params, defaults3);
        if (!options.port) {
          options.port = options.protocol === 'https:' ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol === 'https:') {
        request = https3.request(options);
      } else {
        request = http4.request(options);
      }
      this.getLength(
        function (err, length) {
          if (err && err !== 'Unknown stream') {
            this._error(err);
            return;
          }
          if (length) {
            request.setHeader('Content-Length', length);
          }
          this.pipe(request);
          if (cb) {
            var onResponse;
            var callback = function (error, responce) {
              request.removeListener('error', callback);
              request.removeListener('response', onResponse);
              return cb.call(this, error, responce);
            };
            onResponse = callback.bind(this, null);
            request.on('error', callback);
            request.on('response', onResponse);
          }
        }.bind(this)
      );
      return request;
    };
    FormData3.prototype._error = function (err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit('error', err);
      }
    };
    FormData3.prototype.toString = function () {
      return '[object FormData]';
    };
    setToStringTag(FormData3, 'FormData');
    module.exports = FormData3;
  },
});

// node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data, FormData_default;
var init_FormData = __esm({
  'node_modules/axios/lib/platform/node/classes/FormData.js'() {
    import_form_data = __toESM(require_form_data(), 1);
    FormData_default = import_form_data.default;
  },
});

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key2) {
  return utils_default.endsWith(key2, '[]') ? key2.slice(0, -2) : key2;
}
function renderKey(path5, key2, dots) {
  if (!path5) return key2;
  return path5
    .concat(key2)
    .map(function each2(token, i) {
      token = removeBrackets(token);
      return !dots && i ? '[' + token + ']' : token;
    })
    .join(dots ? '.' : '');
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError('target must be an object');
  }
  formData = formData || new (FormData_default || FormData)();
  options = utils_default.toFlatObject(
    options,
    {
      metaTokens: true,
      dots: false,
      indexes: false,
    },
    false,
    function defined(option, source2) {
      return !utils_default.isUndefined(source2[option]);
    }
  );
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || (typeof Blob !== 'undefined' && Blob);
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }
  function convertValue(value) {
    if (value === null) return '';
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (utils_default.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default('Blob is not supported. Use a Buffer instead.');
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key2, path5) {
    let arr = value;
    if (value && !path5 && typeof value === 'object') {
      if (utils_default.endsWith(key2, '{}')) {
        key2 = metaTokens ? key2 : key2.slice(0, -2);
        value = JSON.stringify(value);
      } else if (
        (utils_default.isArray(value) && isFlatArray(value)) ||
        ((utils_default.isFileList(value) || utils_default.endsWith(key2, '[]')) &&
          (arr = utils_default.toArray(value)))
      ) {
        key2 = removeBrackets(key2);
        arr.forEach(function each2(el, index2) {
          !(utils_default.isUndefined(el) || el === null) &&
            formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true
                ? renderKey([key2], index2, dots)
                : indexes === null
                  ? key2
                  : key2 + '[]',
              convertValue(el)
            );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path5, key2, dots), convertValue(value));
    return false;
  }
  const stack2 = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable,
  });
  function build(value, path5) {
    if (utils_default.isUndefined(value)) return;
    if (stack2.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path5.join('.'));
    }
    stack2.push(value);
    utils_default.forEach(value, function each2(el, key2) {
      const result =
        !(utils_default.isUndefined(el) || el === null) &&
        visitor.call(
          formData,
          el,
          utils_default.isString(key2) ? key2.trim() : key2,
          path5,
          exposedHelpers
        );
      if (result === true) {
        build(el, path5 ? path5.concat(key2) : [key2]);
      }
    });
    stack2.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError('data must be an object');
  }
  build(obj);
  return formData;
}
var predicates, toFormData_default;
var init_toFormData = __esm({
  'node_modules/axios/lib/helpers/toFormData.js'() {
    'use strict';
    init_utils();
    init_AxiosError();
    init_FormData();
    predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop2) {
      return /^is[A-Z]/.test(prop2);
    });
    toFormData_default = toFormData;
  },
});

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str2) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\0',
  };
  return encodeURIComponent(str2).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2, AxiosURLSearchParams_default;
var init_AxiosURLSearchParams = __esm({
  'node_modules/axios/lib/helpers/AxiosURLSearchParams.js'() {
    'use strict';
    init_toFormData();
    prototype2 = AxiosURLSearchParams.prototype;
    prototype2.append = function append(name3, value) {
      this._pairs.push([name3, value]);
    };
    prototype2.toString = function toString2(encoder) {
      const _encode = encoder
        ? function (value) {
            return encoder.call(this, value, encode);
          }
        : encode;
      return this._pairs
        .map(function each2(pair) {
          return _encode(pair[0]) + '=' + _encode(pair[1]);
        }, '')
        .join('&');
    };
    AxiosURLSearchParams_default = AxiosURLSearchParams;
  },
});

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val)
    .replace(/%3A/gi, ':')
    .replace(/%24/g, '$')
    .replace(/%2C/gi, ',')
    .replace(/%20/g, '+');
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = (options && options.encode) || encode2;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options,
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params)
      ? params.toString()
      : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf('#');
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }
  return url2;
}
var init_buildURL = __esm({
  'node_modules/axios/lib/helpers/buildURL.js'() {
    'use strict';
    init_utils();
    init_AxiosURLSearchParams();
  },
});

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager, InterceptorManager_default;
var init_InterceptorManager = __esm({
  'node_modules/axios/lib/core/InterceptorManager.js'() {
    'use strict';
    init_utils();
    InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null,
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils_default.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    InterceptorManager_default = InterceptorManager;
  },
});

// node_modules/axios/lib/defaults/transitional.js
var transitional_default;
var init_transitional = __esm({
  'node_modules/axios/lib/defaults/transitional.js'() {
    'use strict';
    transitional_default = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false,
    };
  },
});

// node_modules/axios/lib/platform/node/classes/URLSearchParams.js
import url from 'url';
var URLSearchParams_default;
var init_URLSearchParams = __esm({
  'node_modules/axios/lib/platform/node/classes/URLSearchParams.js'() {
    'use strict';
    URLSearchParams_default = url.URLSearchParams;
  },
});

// node_modules/axios/lib/platform/node/index.js
import crypto2 from 'crypto';
var ALPHA, DIGIT, ALPHABET, generateString, node_default;
var init_node = __esm({
  'node_modules/axios/lib/platform/node/index.js'() {
    init_URLSearchParams();
    init_FormData();
    ALPHA = 'abcdefghijklmnopqrstuvwxyz';
    DIGIT = '0123456789';
    ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT,
    };
    generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str2 = '';
      const { length } = alphabet;
      const randomValues = new Uint32Array(size);
      crypto2.randomFillSync(randomValues);
      for (let i = 0; i < size; i++) {
        str2 += alphabet[randomValues[i] % length];
      }
      return str2;
    };
    node_default = {
      isNode: true,
      classes: {
        URLSearchParams: URLSearchParams_default,
        FormData: FormData_default,
        Blob: (typeof Blob !== 'undefined' && Blob) || null,
      },
      ALPHABET,
      generateString,
      protocols: ['http', 'https', 'file', 'data'],
    };
  },
});

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin,
});
var hasBrowserEnv, _navigator, hasStandardBrowserEnv, hasStandardBrowserWebWorkerEnv, origin;
var init_utils2 = __esm({
  'node_modules/axios/lib/platform/common/utils.js'() {
    hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';
    _navigator = (typeof navigator === 'object' && navigator) || void 0;
    hasStandardBrowserEnv =
      hasBrowserEnv &&
      (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);
    hasStandardBrowserWebWorkerEnv = (() => {
      return (
        typeof WorkerGlobalScope !== 'undefined' && // eslint-disable-next-line no-undef
        self instanceof WorkerGlobalScope &&
        typeof self.importScripts === 'function'
      );
    })();
    origin = (hasBrowserEnv && window.location.href) || 'http://localhost';
  },
});

// node_modules/axios/lib/platform/index.js
var platform_default;
var init_platform = __esm({
  'node_modules/axios/lib/platform/index.js'() {
    init_node();
    init_utils2();
    platform_default = {
      ...utils_exports,
      ...node_default,
    };
  },
});

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), {
    visitor: function (value, key2, path5, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key2, value.toString('base64'));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options,
  });
}
var init_toURLEncodedForm = __esm({
  'node_modules/axios/lib/helpers/toURLEncodedForm.js'() {
    'use strict';
    init_utils();
    init_toFormData();
    init_platform();
  },
});

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name3) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name3).map((match) => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key2;
  for (i = 0; i < len; i++) {
    key2 = keys[i];
    obj[key2] = arr[key2];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path5, value, target, index2) {
    let name3 = path5[index2++];
    if (name3 === '__proto__') return true;
    const isNumericKey = Number.isFinite(+name3);
    const isLast = index2 >= path5.length;
    name3 = !name3 && utils_default.isArray(target) ? target.length : name3;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name3)) {
        target[name3] = [target[name3], value];
      } else {
        target[name3] = value;
      }
      return !isNumericKey;
    }
    if (!target[name3] || !utils_default.isObject(target[name3])) {
      target[name3] = [];
    }
    const result = buildPath(path5, value, target[name3], index2);
    if (result && utils_default.isArray(target[name3])) {
      target[name3] = arrayToObject(target[name3]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name3, value) => {
      buildPath(parsePropPath(name3), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default;
var init_formDataToJSON = __esm({
  'node_modules/axios/lib/helpers/formDataToJSON.js'() {
    'use strict';
    init_utils();
    formDataToJSON_default = formDataToJSON;
  },
});

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults, defaults_default;
var init_defaults = __esm({
  'node_modules/axios/lib/defaults/index.js'() {
    'use strict';
    init_utils();
    init_AxiosError();
    init_transitional();
    init_toFormData();
    init_toURLEncodedForm();
    init_platform();
    init_formDataToJSON();
    defaults = {
      transitional: transitional_default,
      adapter: ['xhr', 'http', 'fetch'],
      transformRequest: [
        function transformRequest(data, headers) {
          const contentType = headers.getContentType() || '';
          const hasJSONContentType = contentType.indexOf('application/json') > -1;
          const isObjectPayload = utils_default.isObject(data);
          if (isObjectPayload && utils_default.isHTMLForm(data)) {
            data = new FormData(data);
          }
          const isFormData2 = utils_default.isFormData(data);
          if (isFormData2) {
            return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
          }
          if (
            utils_default.isArrayBuffer(data) ||
            utils_default.isBuffer(data) ||
            utils_default.isStream(data) ||
            utils_default.isFile(data) ||
            utils_default.isBlob(data) ||
            utils_default.isReadableStream(data)
          ) {
            return data;
          }
          if (utils_default.isArrayBufferView(data)) {
            return data.buffer;
          }
          if (utils_default.isURLSearchParams(data)) {
            headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
            return data.toString();
          }
          let isFileList2;
          if (isObjectPayload) {
            if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
              return toURLEncodedForm(data, this.formSerializer).toString();
            }
            if (
              (isFileList2 = utils_default.isFileList(data)) ||
              contentType.indexOf('multipart/form-data') > -1
            ) {
              const _FormData = this.env && this.env.FormData;
              return toFormData_default(
                isFileList2 ? { 'files[]': data } : data,
                _FormData && new _FormData(),
                this.formSerializer
              );
            }
          }
          if (isObjectPayload || hasJSONContentType) {
            headers.setContentType('application/json', false);
            return stringifySafely(data);
          }
          return data;
        },
      ],
      transformResponse: [
        function transformResponse(data) {
          const transitional2 = this.transitional || defaults.transitional;
          const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
          const JSONRequested = this.responseType === 'json';
          if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
            return data;
          }
          if (
            data &&
            utils_default.isString(data) &&
            ((forcedJSONParsing && !this.responseType) || JSONRequested)
          ) {
            const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
            const strictJSONParsing = !silentJSONParsing && JSONRequested;
            try {
              return JSON.parse(data, this.parseReviver);
            } catch (e) {
              if (strictJSONParsing) {
                if (e.name === 'SyntaxError') {
                  throw AxiosError_default.from(
                    e,
                    AxiosError_default.ERR_BAD_RESPONSE,
                    this,
                    null,
                    this.response
                  );
                }
                throw e;
              }
            }
          }
          return data;
        },
      ],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform_default.classes.FormData,
        Blob: platform_default.classes.Blob,
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          Accept: 'application/json, text/plain, */*',
          'Content-Type': void 0,
        },
      },
    };
    utils_default.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
      defaults.headers[method] = {};
    });
    defaults_default = defaults;
  },
});

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf, parseHeaders_default;
var init_parseHeaders = __esm({
  'node_modules/axios/lib/helpers/parseHeaders.js'() {
    'use strict';
    init_utils();
    ignoreDuplicateOf = utils_default.toObjectSet([
      'age',
      'authorization',
      'content-length',
      'content-type',
      'etag',
      'expires',
      'from',
      'host',
      'if-modified-since',
      'if-unmodified-since',
      'last-modified',
      'location',
      'max-forwards',
      'proxy-authorization',
      'referer',
      'retry-after',
      'user-agent',
    ]);
    parseHeaders_default = (rawHeaders) => {
      const parsed = {};
      let key2;
      let val;
      let i;
      rawHeaders &&
        rawHeaders.split('\n').forEach(function parser(line) {
          i = line.indexOf(':');
          key2 = line.substring(0, i).trim().toLowerCase();
          val = line.substring(i + 1).trim();
          if (!key2 || (parsed[key2] && ignoreDuplicateOf[key2])) {
            return;
          }
          if (key2 === 'set-cookie') {
            if (parsed[key2]) {
              parsed[key2].push(val);
            } else {
              parsed[key2] = [val];
            }
          } else {
            parsed[key2] = parsed[key2] ? parsed[key2] + ', ' + val : val;
          }
        });
      return parsed;
    };
  },
});

// node_modules/axios/lib/core/AxiosHeaders.js
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str2) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while ((match = tokensRE.exec(str2))) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header
    .trim()
    .toLowerCase()
    .replace(/([a-z\d])(\w*)/g, (w, char, str2) => {
      return char.toUpperCase() + str2;
    });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(' ' + header);
  ['get', 'set', 'has'].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function (arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true,
    });
  });
}
var $internals, isValidHeaderName, AxiosHeaders, AxiosHeaders_default;
var init_AxiosHeaders = __esm({
  'node_modules/axios/lib/core/AxiosHeaders.js'() {
    'use strict';
    init_utils();
    init_parseHeaders();
    $internals = Symbol('internals');
    isValidHeaderName = (str2) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str2.trim());
    AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self3 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error('header name must be a non-empty string');
          }
          const key2 = utils_default.findKey(self3, lHeader);
          if (
            !key2 ||
            self3[key2] === void 0 ||
            _rewrite === true ||
            (_rewrite === void 0 && self3[key2] !== false)
          ) {
            self3[key2 || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) =>
          utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (
          utils_default.isString(header) &&
          (header = header.trim()) &&
          !isValidHeaderName(header)
        ) {
          setHeaders(parseHeaders_default(header), valueOrRewrite);
        } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
          let obj = {},
            dest,
            key2;
          for (const entry of header) {
            if (!utils_default.isArray(entry)) {
              throw TypeError('Object iterator must return a key-value pair');
            }
            obj[(key2 = entry[0])] = (dest = obj[key2])
              ? utils_default.isArray(dest)
                ? [...dest, entry[1]]
                : [dest, entry[1]]
              : entry[1];
          }
          setHeaders(obj, valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key2 = utils_default.findKey(this, header);
          if (key2) {
            const value = this[key2];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils_default.isFunction(parser)) {
              return parser.call(this, value, key2);
            }
            if (utils_default.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError('parser must be boolean|regexp|function');
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key2 = utils_default.findKey(this, header);
          return !!(
            key2 &&
            this[key2] !== void 0 &&
            (!matcher || matchHeaderValue(this, this[key2], key2, matcher))
          );
        }
        return false;
      }
      delete(header, matcher) {
        const self3 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key2 = utils_default.findKey(self3, _header);
            if (key2 && (!matcher || matchHeaderValue(self3, self3[key2], key2, matcher))) {
              delete self3[key2];
              deleted = true;
            }
          }
        }
        if (utils_default.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key2 = keys[i];
          if (!matcher || matchHeaderValue(this, this[key2], key2, matcher, true)) {
            delete this[key2];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self3 = this;
        const headers = {};
        utils_default.forEach(this, (value, header) => {
          const key2 = utils_default.findKey(headers, header);
          if (key2) {
            self3[key2] = normalizeValue(value);
            delete self3[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self3[header];
          }
          self3[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils_default.forEach(this, (value, header) => {
          value != null &&
            value !== false &&
            (obj[header] = asStrings && utils_default.isArray(value) ? value.join(', ') : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON())
          .map(([header, value]) => header + ': ' + value)
          .join('\n');
      }
      getSetCookie() {
        return this.get('set-cookie') || [];
      }
      get [Symbol.toStringTag]() {
        return 'AxiosHeaders';
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals =
          (this[$internals] =
          this[$internals] =
            {
              accessors: {},
            });
        const accessors = internals.accessors;
        const prototype3 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype3, _header);
            accessors[lHeader] = true;
          }
        }
        utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor([
      'Content-Type',
      'Content-Length',
      'Accept',
      'Accept-Encoding',
      'User-Agent',
      'Authorization',
    ]);
    utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key2) => {
      let mapped = key2[0].toUpperCase() + key2.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        },
      };
    });
    utils_default.freezeMethods(AxiosHeaders);
    AxiosHeaders_default = AxiosHeaders;
  },
});

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
var init_transformData = __esm({
  'node_modules/axios/lib/core/transformData.js'() {
    'use strict';
    init_utils();
    init_defaults();
    init_AxiosHeaders();
  },
});

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
var init_isCancel = __esm({
  'node_modules/axios/lib/cancel/isCancel.js'() {
    'use strict';
  },
});

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(
    this,
    message == null ? 'canceled' : message,
    AxiosError_default.ERR_CANCELED,
    config,
    request
  );
  this.name = 'CanceledError';
}
var CanceledError_default;
var init_CanceledError = __esm({
  'node_modules/axios/lib/cancel/CanceledError.js'() {
    'use strict';
    init_AxiosError();
    init_utils();
    utils_default.inherits(CanceledError, AxiosError_default, {
      __CANCEL__: true,
    });
    CanceledError_default = CanceledError;
  },
});

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(
      new AxiosError_default(
        'Request failed with status code ' + response.status,
        [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][
          Math.floor(response.status / 100) - 4
        ],
        response.config,
        response.request,
        response
      )
    );
  }
}
var init_settle = __esm({
  'node_modules/axios/lib/core/settle.js'() {
    'use strict';
    init_AxiosError();
  },
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
var init_isAbsoluteURL = __esm({
  'node_modules/axios/lib/helpers/isAbsoluteURL.js'() {
    'use strict';
  },
});

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}
var init_combineURLs = __esm({
  'node_modules/axios/lib/helpers/combineURLs.js'() {
    'use strict';
  },
});

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
var init_buildFullPath = __esm({
  'node_modules/axios/lib/core/buildFullPath.js'() {
    'use strict';
    init_isAbsoluteURL();
    init_combineURLs();
  },
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  'node_modules/proxy-from-env/index.js'(exports) {
    'use strict';
    var parseUrl = __require('url').parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443,
    };
    var stringEndsWith =
      String.prototype.endsWith ||
      function (s) {
        return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
      };
    function getProxyForUrl(url2) {
      var parsedUrl = typeof url2 === 'string' ? parseUrl(url2) : url2 || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
        return '';
      }
      proto = proto.split(':', 1)[0];
      hostname = hostname.replace(/:\d*$/, '');
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return '';
      }
      var proxy2 =
        getEnv('npm_config_' + proto + '_proxy') ||
        getEnv(proto + '_proxy') ||
        getEnv('npm_config_proxy') ||
        getEnv('all_proxy');
      if (proxy2 && proxy2.indexOf('://') === -1) {
        proxy2 = proto + '://' + proxy2;
      }
      return proxy2;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === '*') {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function (proxy2) {
        if (!proxy2) {
          return true;
        }
        var parsedProxy = proxy2.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy2;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === '*') {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key2) {
      return process.env[key2.toLowerCase()] || process.env[key2.toUpperCase()] || '';
    }
    exports.getProxyForUrl = getProxyForUrl;
  },
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  'node_modules/ms/index.js'(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function (val, options) {
      options = options || {};
      var type = typeof val;
      if (type === 'string' && val.length > 0) {
        return parse2(val);
      } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        'val is not a non-empty string or a valid number. val=' + JSON.stringify(val)
      );
    };
    function parse2(str2) {
      str2 = String(str2);
      if (str2.length > 100) {
        return;
      }
      var match =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str2
        );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'weeks':
        case 'week':
        case 'w':
          return n * w;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + 's';
      }
      return ms + 'ms';
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
      }
      return ms + ' ms';
    }
    function plural(ms, msAbs, n, name3) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + ' ' + name3 + (isPlural ? 's' : '');
    }
  },
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  'node_modules/debug/src/common.js'(exports, module) {
    function setup2(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key2) => {
        createDebug[key2] = env2[key2];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self3 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self3.diff = ms;
          self3.prev = prevTime;
          self3.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== 'string') {
            args.unshift('%O');
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === '%%') {
              return '%';
            }
            index2++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === 'function') {
              const val = args[index2];
              match = formatter.call(self3, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug.formatArgs.call(self3, args);
          const logFn = self3.log || createDebug.log;
          logFn.apply(self3, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend2;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, 'enabled', {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          },
        });
        if (typeof createDebug.init === 'function') {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(
          this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace
        );
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === 'string' ? namespaces : '')
          .trim()
          .replace(/\s+/g, ',')
          .split(',')
          .filter(Boolean);
        for (const ns of split) {
          if (ns[0] === '-') {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (
            templateIndex < template.length &&
            (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')
          ) {
            if (template[templateIndex] === '*') {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === '*') {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => '-' + namespace),
        ].join(',');
        createDebug.enable('');
        return namespaces;
      }
      function enabled(name3) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name3, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name3, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn(
          'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
        );
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup2;
  },
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  'node_modules/debug/src/browser.js'(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save2;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn(
            'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
          );
        }
      };
    })();
    exports.colors = [
      '#0000CC',
      '#0000FF',
      '#0033CC',
      '#0033FF',
      '#0066CC',
      '#0066FF',
      '#0099CC',
      '#0099FF',
      '#00CC00',
      '#00CC33',
      '#00CC66',
      '#00CC99',
      '#00CCCC',
      '#00CCFF',
      '#3300CC',
      '#3300FF',
      '#3333CC',
      '#3333FF',
      '#3366CC',
      '#3366FF',
      '#3399CC',
      '#3399FF',
      '#33CC00',
      '#33CC33',
      '#33CC66',
      '#33CC99',
      '#33CCCC',
      '#33CCFF',
      '#6600CC',
      '#6600FF',
      '#6633CC',
      '#6633FF',
      '#66CC00',
      '#66CC33',
      '#9900CC',
      '#9900FF',
      '#9933CC',
      '#9933FF',
      '#99CC00',
      '#99CC33',
      '#CC0000',
      '#CC0033',
      '#CC0066',
      '#CC0099',
      '#CC00CC',
      '#CC00FF',
      '#CC3300',
      '#CC3333',
      '#CC3366',
      '#CC3399',
      '#CC33CC',
      '#CC33FF',
      '#CC6600',
      '#CC6633',
      '#CC9900',
      '#CC9933',
      '#CCCC00',
      '#CCCC33',
      '#FF0000',
      '#FF0033',
      '#FF0066',
      '#FF0099',
      '#FF00CC',
      '#FF00FF',
      '#FF3300',
      '#FF3333',
      '#FF3366',
      '#FF3399',
      '#FF33CC',
      '#FF33FF',
      '#FF6600',
      '#FF6633',
      '#FF9900',
      '#FF9933',
      '#FFCC00',
      '#FFCC33',
    ];
    function useColors() {
      if (
        typeof window !== 'undefined' &&
        window.process &&
        (window.process.type === 'renderer' || window.process.__nwjs)
      ) {
        return true;
      }
      if (
        typeof navigator !== 'undefined' &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
      ) {
        return false;
      }
      let m;
      return (
        (typeof document !== 'undefined' &&
          document.documentElement &&
          document.documentElement.style &&
          document.documentElement.style.WebkitAppearance) || // Is firebug? http://stackoverflow.com/a/398120/376773
        (typeof window !== 'undefined' &&
          window.console &&
          (window.console.firebug || (window.console.exception && window.console.table))) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        (typeof navigator !== 'undefined' &&
          navigator.userAgent &&
          (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
          parseInt(m[1], 10) >= 31) || // Double check webkit in userAgent just in case we are in a worker
        (typeof navigator !== 'undefined' &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
      );
    }
    function formatArgs(args) {
      args[0] =
        (this.useColors ? '%c' : '') +
        this.namespace +
        (this.useColors ? ' %c' : ' ') +
        args[0] +
        (this.useColors ? '%c ' : ' ') +
        '+' +
        module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === '%%') {
          return;
        }
        index2++;
        if (match === '%c') {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {});
    function save2(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem('debug', namespaces);
        } else {
          exports.storage.removeItem('debug');
        }
      } catch (error) {}
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG');
      } catch (error) {}
      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {}
    }
    module.exports = require_common()(exports);
    var { formatters: formatters2 } = module.exports;
    formatters2.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
      }
    };
  },
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  'node_modules/has-flag/index.js'(exports, module) {
    'use strict';
    module.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf('--');
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  },
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  'node_modules/supports-color/index.js'(exports, module) {
    'use strict';
    var os2 = __require('os');
    var tty = __require('tty');
    var hasFlag = require_has_flag();
    var { env: env2 } = process;
    var forceColor;
    if (
      hasFlag('no-color') ||
      hasFlag('no-colors') ||
      hasFlag('color=false') ||
      hasFlag('color=never')
    ) {
      forceColor = 0;
    } else if (
      hasFlag('color') ||
      hasFlag('colors') ||
      hasFlag('color=true') ||
      hasFlag('color=always')
    ) {
      forceColor = 1;
    }
    if ('FORCE_COLOR' in env2) {
      if (env2.FORCE_COLOR === 'true') {
        forceColor = 1;
      } else if (env2.FORCE_COLOR === 'false') {
        forceColor = 0;
      } else {
        forceColor =
          env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3,
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
        return 3;
      }
      if (hasFlag('color=256')) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env2.TERM === 'dumb') {
        return min;
      }
      if (process.platform === 'win32') {
        const osRelease = os2.release().split('.');
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ('CI' in env2) {
        if (
          ['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(
            (sign) => sign in env2
          ) ||
          env2.CI_NAME === 'codeship'
        ) {
          return 1;
        }
        return min;
      }
      if ('TEAMCITY_VERSION' in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === 'truecolor') {
        return 3;
      }
      if ('TERM_PROGRAM' in env2) {
        const version4 = parseInt((env2.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
        switch (env2.TERM_PROGRAM) {
          case 'iTerm.app':
            return version4 >= 3 ? 3 : 2;
          case 'Apple_Terminal':
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ('COLORTERM' in env2) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream4) {
      const level = supportsColor(stream4, stream4 && stream4.isTTY);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2))),
    };
  },
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  'node_modules/debug/src/node.js'(exports, module) {
    var tty = __require('tty');
    var util3 = __require('util');
    exports.init = init2;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save2;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util3.deprecate(
      () => {},
      'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75,
          76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161,
          162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197,
          198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221,
        ];
      }
    } catch (error) {}
    exports.inspectOpts = Object.keys(process.env)
      .filter((key2) => {
        return /^debug_/i.test(key2);
      })
      .reduce((obj, key2) => {
        const prop2 = key2
          .substring(6)
          .toLowerCase()
          .replace(/_([a-z])/g, (_, k) => {
            return k.toUpperCase();
          });
        let val = process.env[key2];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
          val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
          val = false;
        } else if (val === 'null') {
          val = null;
        } else {
          val = Number(val);
        }
        obj[prop2] = val;
        return obj;
      }, {});
    function useColors() {
      return 'colors' in exports.inspectOpts
        ? Boolean(exports.inspectOpts.colors)
        : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name3, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = '\x1B[3' + (c < 8 ? c : '8;5;' + c);
        const prefix = `  ${colorCode};1m${name3} \x1B[0m`;
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\x1B[0m');
      } else {
        args[0] = getDate() + name3 + ' ' + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return '';
      }
      return /* @__PURE__ */ new Date().toISOString() + ' ';
    }
    function log2(...args) {
      return process.stderr.write(util3.formatWithOptions(exports.inspectOpts, ...args) + '\n');
    }
    function save2(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = require_common()(exports);
    var { formatters: formatters2 } = module.exports;
    formatters2.o = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util3
        .inspect(v, this.inspectOpts)
        .split('\n')
        .map((str2) => str2.trim())
        .join(' ');
    };
    formatters2.O = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts);
    };
  },
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  'node_modules/debug/src/index.js'(exports, module) {
    if (
      typeof process === 'undefined' ||
      process.type === 'renderer' ||
      process.browser === true ||
      process.__nwjs
    ) {
      module.exports = require_browser();
    } else {
      module.exports = require_node();
    }
  },
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  'node_modules/follow-redirects/debug.js'(exports, module) {
    var debug;
    module.exports = function () {
      if (!debug) {
        try {
          debug = require_src()('follow-redirects');
        } catch (error) {}
        if (typeof debug !== 'function') {
          debug = function () {};
        }
      }
      debug.apply(null, arguments);
    };
  },
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  'node_modules/follow-redirects/index.js'(exports, module) {
    var url2 = __require('url');
    var URL3 = url2.URL;
    var http4 = __require('http');
    var https3 = __require('https');
    var Writable = __require('stream').Writable;
    var assert = __require('assert');
    var debug = require_debug();
    (function detectUnsupportedEnvironment() {
      var looksLikeNode = typeof process !== 'undefined';
      var looksLikeBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
      var looksLikeV8 = isFunction3(Error.captureStackTrace);
      if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn('The follow-redirects package should be excluded from browser builds.');
      }
    })();
    var useNativeURL = false;
    try {
      assert(new URL3(''));
    } catch (error) {
      useNativeURL = error.code === 'ERR_INVALID_URL';
    }
    var preservedUrlFields = [
      'auth',
      'host',
      'hostname',
      'href',
      'path',
      'pathname',
      'port',
      'protocol',
      'query',
      'search',
      'hash',
    ];
    var events = ['abort', 'aborted', 'connect', 'error', 'socket', 'timeout'];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function (event2) {
      eventHandlers[event2] = function (arg1, arg2, arg3) {
        this._redirectable.emit(event2, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType('ERR_INVALID_URL', 'Invalid URL', TypeError);
    var RedirectionError = createErrorType(
      'ERR_FR_REDIRECTION_FAILURE',
      'Redirected request failed'
    );
    var TooManyRedirectsError = createErrorType(
      'ERR_FR_TOO_MANY_REDIRECTS',
      'Maximum number of redirects exceeded',
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      'ERR_FR_MAX_BODY_LENGTH_EXCEEDED',
      'Request body larger than maxBodyLength limit'
    );
    var WriteAfterEndError = createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
    var destroy = Writable.prototype.destroy || noop4;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on('response', responseCallback);
      }
      var self3 = this;
      this._onNativeResponse = function (response) {
        try {
          self3._processResponse(response);
        } catch (cause) {
          self3.emit(
            'error',
            cause instanceof RedirectionError ? cause : new RedirectionError({ cause })
          );
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function () {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit('abort');
    };
    RedirectableRequest.prototype.destroy = function (error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function (data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString2(data) && !isBuffer2(data)) {
        throw new TypeError('data should be a string, Buffer or Uint8Array');
      }
      if (isFunction3(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit('error', new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function (data, encoding, callback) {
      if (isFunction3(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction3(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self3 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function () {
          self3._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function (name3, value) {
      this._options.headers[name3] = value;
      this._currentRequest.setHeader(name3, value);
    };
    RedirectableRequest.prototype.removeHeader = function (name3) {
      delete this._options.headers[name3];
      this._currentRequest.removeHeader(name3);
    };
    RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
      var self3 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener('timeout', socket.destroy);
        socket.addListener('timeout', socket.destroy);
      }
      function startTimer(socket) {
        if (self3._timeout) {
          clearTimeout(self3._timeout);
        }
        self3._timeout = setTimeout(function () {
          self3.emit('timeout');
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self3._timeout) {
          clearTimeout(self3._timeout);
          self3._timeout = null;
        }
        self3.removeListener('abort', clearTimer);
        self3.removeListener('error', clearTimer);
        self3.removeListener('response', clearTimer);
        self3.removeListener('close', clearTimer);
        if (callback) {
          self3.removeListener('timeout', callback);
        }
        if (!self3.socket) {
          self3._currentRequest.removeListener('socket', startTimer);
        }
      }
      if (callback) {
        this.on('timeout', callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once('socket', startTimer);
      }
      this.on('socket', destroyOnTimeout);
      this.on('abort', clearTimer);
      this.on('error', clearTimer);
      this.on('response', clearTimer);
      this.on('close', clearTimer);
      return this;
    };
    ['flushHeaders', 'getHeader', 'setNoDelay', 'setSocketKeepAlive'].forEach(function (method) {
      RedirectableRequest.prototype[method] = function (a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ['aborted', 'connection', 'socket'].forEach(function (property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function () {
          return this._currentRequest[property];
        },
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function (options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf('?');
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function () {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError('Unsupported protocol ' + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = (this._currentRequest = nativeProtocol.request(
        this._options,
        this._onNativeResponse
      ));
      request._redirectable = this;
      for (var event2 of events) {
        request.on(event2, eventHandlers[event2]);
      }
      this._currentUrl = /^\//.test(this._options.path)
        ? url2.format(this._options)
        : // When making a request to a proxy, []
          // a client MUST send the target URI in absolute-form [].
          this._options.path;
      if (this._isRedirect) {
        var i = 0;
        var self3 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self3._currentRequest) {
            if (error) {
              self3.emit('error', error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self3._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function (response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode,
        });
      }
      var location = response.headers.location;
      if (
        !location ||
        this._options.followRedirects === false ||
        statusCode < 300 ||
        statusCode >= 400
      ) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit('response', response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign(
          {
            // The Host header was set by nativeProtocol.request
            Host: response.req.getHeader('host'),
          },
          this._options.headers
        );
      }
      var method = this._options.method;
      if (
        ((statusCode === 301 || statusCode === 302) && this._options.method === 'POST') || // RFC72316.4.4: The 303 (See Other) status code indicates that
        // the server is redirecting the user agent to a different resource []
        // A user agent can perform a retrieval request targeting that URI
        // (a GET or HEAD request if using HTTP) []
        (statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method))
      ) {
        this._options.method = 'GET';
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location)
        ? this._currentUrl
        : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug('redirecting to', redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (
        (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== 'https:') ||
        (redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost))
      ) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction3(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode,
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders,
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap(protocols) {
      var exports2 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024,
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function (scheme) {
        var protocol = scheme + ':';
        var nativeProtocol = (nativeProtocols[protocol] = protocols[scheme]);
        var wrappedProtocol = (exports2[scheme] = Object.create(nativeProtocol));
        function request(input, options, callback) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString2(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback = options;
            options = validateUrl(input);
            input = { protocol };
          }
          if (isFunction3(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign(
            {
              maxRedirects: exports2.maxRedirects,
              maxBodyLength: exports2.maxBodyLength,
            },
            input,
            options
          );
          options.nativeProtocols = nativeProtocols;
          if (!isString2(options.host) && !isString2(options.hostname)) {
            options.hostname = '::1';
          }
          assert.equal(options.protocol, protocol, 'protocol mismatch');
          debug('options', options);
          return new RedirectableRequest(options, callback);
        }
        function get4(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get4, configurable: true, enumerable: true, writable: true },
        });
      });
      return exports2;
    }
    function noop4() {}
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL3(input);
      } else {
        parsed = validateUrl(url2.parse(input));
        if (!isString2(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative, base) {
      return useNativeURL ? new URL3(relative, base) : parseUrl(url2.resolve(base, relative));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread3 = target || {};
      for (var key2 of preservedUrlFields) {
        spread3[key2] = urlObject[key2];
      }
      if (spread3.hostname.startsWith('[')) {
        spread3.hostname = spread3.hostname.slice(1, -1);
      }
      if (spread3.port !== '') {
        spread3.port = Number(spread3.port);
      }
      spread3.path = spread3.search ? spread3.pathname + spread3.search : spread3.pathname;
      return spread3;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === 'undefined'
        ? void 0
        : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        if (isFunction3(Error.captureStackTrace)) {
          Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ': ' + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false,
        },
        name: {
          value: 'Error [' + code + ']',
          enumerable: false,
        },
      });
      return CustomError;
    }
    function destroyRequest(request, error) {
      for (var event2 of events) {
        request.removeListener(event2, eventHandlers[event2]);
      }
      request.on('error', noop4);
      request.destroy(error);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString2(subdomain) && isString2(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === '.' && subdomain.endsWith(domain);
    }
    function isString2(value) {
      return typeof value === 'string' || value instanceof String;
    }
    function isFunction3(value) {
      return typeof value === 'function';
    }
    function isBuffer2(value) {
      return typeof value === 'object' && 'length' in value;
    }
    function isURL(value) {
      return URL3 && value instanceof URL3;
    }
    module.exports = wrap({ http: http4, https: https3 });
    module.exports.wrap = wrap;
  },
});

// node_modules/axios/lib/env/data.js
var VERSION;
var init_data = __esm({
  'node_modules/axios/lib/env/data.js'() {
    VERSION = '1.12.2';
  },
});

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return (match && match[1]) || '';
}
var init_parseProtocol = __esm({
  'node_modules/axios/lib/helpers/parseProtocol.js'() {
    'use strict';
  },
});

// node_modules/axios/lib/helpers/fromDataURI.js
function fromDataURI(uri, asBlob, options) {
  const _Blob = (options && options.Blob) || platform_default.classes.Blob;
  const protocol = parseProtocol(uri);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol === 'data') {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
    const match = DATA_URL_PATTERN.exec(uri);
    if (!match) {
      throw new AxiosError_default('Invalid URL', AxiosError_default.ERR_INVALID_URL);
    }
    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8');
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError_default('Blob is not supported', AxiosError_default.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime });
    }
    return buffer;
  }
  throw new AxiosError_default(
    'Unsupported protocol ' + protocol,
    AxiosError_default.ERR_NOT_SUPPORT
  );
}
var DATA_URL_PATTERN;
var init_fromDataURI = __esm({
  'node_modules/axios/lib/helpers/fromDataURI.js'() {
    'use strict';
    init_AxiosError();
    init_parseProtocol();
    init_platform();
    DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
  },
});

// node_modules/axios/lib/helpers/AxiosTransformStream.js
import stream from 'stream';
var kInternals, AxiosTransformStream, AxiosTransformStream_default;
var init_AxiosTransformStream = __esm({
  'node_modules/axios/lib/helpers/AxiosTransformStream.js'() {
    'use strict';
    init_utils();
    kInternals = Symbol('internals');
    AxiosTransformStream = class extends stream.Transform {
      constructor(options) {
        options = utils_default.toFlatObject(
          options,
          {
            maxRate: 0,
            chunkSize: 64 * 1024,
            minChunkSize: 100,
            timeWindow: 500,
            ticksRate: 2,
            samplesCount: 15,
          },
          null,
          (prop2, source2) => {
            return !utils_default.isUndefined(source2[prop2]);
          }
        );
        super({
          readableHighWaterMark: options.chunkSize,
        });
        const internals = (this[kInternals] = {
          timeWindow: options.timeWindow,
          chunkSize: options.chunkSize,
          maxRate: options.maxRate,
          minChunkSize: options.minChunkSize,
          bytesSeen: 0,
          isCaptured: false,
          notifiedBytesLoaded: 0,
          ts: Date.now(),
          bytes: 0,
          onReadCallback: null,
        });
        this.on('newListener', (event2) => {
          if (event2 === 'progress') {
            if (!internals.isCaptured) {
              internals.isCaptured = true;
            }
          }
        });
      }
      _read(size) {
        const internals = this[kInternals];
        if (internals.onReadCallback) {
          internals.onReadCallback();
        }
        return super._read(size);
      }
      _transform(chunk, encoding, callback) {
        const internals = this[kInternals];
        const maxRate = internals.maxRate;
        const readableHighWaterMark = this.readableHighWaterMark;
        const timeWindow = internals.timeWindow;
        const divider = 1e3 / timeWindow;
        const bytesThreshold = maxRate / divider;
        const minChunkSize =
          internals.minChunkSize !== false
            ? Math.max(internals.minChunkSize, bytesThreshold * 0.01)
            : 0;
        const pushChunk = (_chunk, _callback) => {
          const bytes = Buffer.byteLength(_chunk);
          internals.bytesSeen += bytes;
          internals.bytes += bytes;
          internals.isCaptured && this.emit('progress', internals.bytesSeen);
          if (this.push(_chunk)) {
            process.nextTick(_callback);
          } else {
            internals.onReadCallback = () => {
              internals.onReadCallback = null;
              process.nextTick(_callback);
            };
          }
        };
        const transformChunk = (_chunk, _callback) => {
          const chunkSize = Buffer.byteLength(_chunk);
          let chunkRemainder = null;
          let maxChunkSize = readableHighWaterMark;
          let bytesLeft;
          let passed = 0;
          if (maxRate) {
            const now = Date.now();
            if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
              internals.ts = now;
              bytesLeft = bytesThreshold - internals.bytes;
              internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
              passed = 0;
            }
            bytesLeft = bytesThreshold - internals.bytes;
          }
          if (maxRate) {
            if (bytesLeft <= 0) {
              return setTimeout(() => {
                _callback(null, _chunk);
              }, timeWindow - passed);
            }
            if (bytesLeft < maxChunkSize) {
              maxChunkSize = bytesLeft;
            }
          }
          if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
            chunkRemainder = _chunk.subarray(maxChunkSize);
            _chunk = _chunk.subarray(0, maxChunkSize);
          }
          pushChunk(
            _chunk,
            chunkRemainder
              ? () => {
                  process.nextTick(_callback, null, chunkRemainder);
                }
              : _callback
          );
        };
        transformChunk(chunk, function transformNextChunk(err, _chunk) {
          if (err) {
            return callback(err);
          }
          if (_chunk) {
            transformChunk(_chunk, transformNextChunk);
          } else {
            callback(null);
          }
        });
      }
    };
    AxiosTransformStream_default = AxiosTransformStream;
  },
});

// node_modules/axios/lib/helpers/readBlob.js
var asyncIterator, readBlob, readBlob_default;
var init_readBlob = __esm({
  'node_modules/axios/lib/helpers/readBlob.js'() {
    ({ asyncIterator } = Symbol);
    readBlob = async function* (blob) {
      if (blob.stream) {
        yield* blob.stream();
      } else if (blob.arrayBuffer) {
        yield await blob.arrayBuffer();
      } else if (blob[asyncIterator]) {
        yield* blob[asyncIterator]();
      } else {
        yield blob;
      }
    };
    readBlob_default = readBlob;
  },
});

// node_modules/axios/lib/helpers/formDataToStream.js
import util from 'util';
import { Readable } from 'stream';
var BOUNDARY_ALPHABET,
  textEncoder,
  CRLF,
  CRLF_BYTES,
  CRLF_BYTES_COUNT,
  FormDataPart,
  formDataToStream,
  formDataToStream_default;
var init_formDataToStream = __esm({
  'node_modules/axios/lib/helpers/formDataToStream.js'() {
    init_utils();
    init_readBlob();
    init_platform();
    BOUNDARY_ALPHABET = platform_default.ALPHABET.ALPHA_DIGIT + '-_';
    textEncoder = typeof TextEncoder === 'function' ? new TextEncoder() : new util.TextEncoder();
    CRLF = '\r\n';
    CRLF_BYTES = textEncoder.encode(CRLF);
    CRLF_BYTES_COUNT = 2;
    FormDataPart = class {
      constructor(name3, value) {
        const { escapeName } = this.constructor;
        const isStringValue = utils_default.isString(value);
        let headers = `Content-Disposition: form-data; name="${escapeName(name3)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ''}${CRLF}`;
        if (isStringValue) {
          value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
        } else {
          headers += `Content-Type: ${value.type || 'application/octet-stream'}${CRLF}`;
        }
        this.headers = textEncoder.encode(headers + CRLF);
        this.contentLength = isStringValue ? value.byteLength : value.size;
        this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
        this.name = name3;
        this.value = value;
      }
      async *encode() {
        yield this.headers;
        const { value } = this;
        if (utils_default.isTypedArray(value)) {
          yield value;
        } else {
          yield* readBlob_default(value);
        }
        yield CRLF_BYTES;
      }
      static escapeName(name3) {
        return String(name3).replace(
          /[\r\n"]/g,
          (match) =>
            ({
              '\r': '%0D',
              '\n': '%0A',
              '"': '%22',
            })[match]
        );
      }
    };
    formDataToStream = (form, headersHandler, options) => {
      const {
        tag: tag2 = 'form-data-boundary',
        size = 25,
        boundary: boundary2 = tag2 + '-' + platform_default.generateString(size, BOUNDARY_ALPHABET),
      } = options || {};
      if (!utils_default.isFormData(form)) {
        throw TypeError('FormData instance required');
      }
      if (boundary2.length < 1 || boundary2.length > 70) {
        throw Error('boundary must be 10-70 characters long');
      }
      const boundaryBytes = textEncoder.encode('--' + boundary2 + CRLF);
      const footerBytes = textEncoder.encode('--' + boundary2 + '--' + CRLF);
      let contentLength = footerBytes.byteLength;
      const parts = Array.from(form.entries()).map(([name3, value]) => {
        const part = new FormDataPart(name3, value);
        contentLength += part.size;
        return part;
      });
      contentLength += boundaryBytes.byteLength * parts.length;
      contentLength = utils_default.toFiniteNumber(contentLength);
      const computedHeaders = {
        'Content-Type': `multipart/form-data; boundary=${boundary2}`,
      };
      if (Number.isFinite(contentLength)) {
        computedHeaders['Content-Length'] = contentLength;
      }
      headersHandler && headersHandler(computedHeaders);
      return Readable.from(
        (async function* () {
          for (const part of parts) {
            yield boundaryBytes;
            yield* part.encode();
          }
          yield footerBytes;
        })()
      );
    };
    formDataToStream_default = formDataToStream;
  },
});

// node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
import stream2 from 'stream';
var ZlibHeaderTransformStream, ZlibHeaderTransformStream_default;
var init_ZlibHeaderTransformStream = __esm({
  'node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js'() {
    'use strict';
    ZlibHeaderTransformStream = class extends stream2.Transform {
      __transform(chunk, encoding, callback) {
        this.push(chunk);
        callback();
      }
      _transform(chunk, encoding, callback) {
        if (chunk.length !== 0) {
          this._transform = this.__transform;
          if (chunk[0] !== 120) {
            const header = Buffer.alloc(2);
            header[0] = 120;
            header[1] = 156;
            this.push(header, encoding);
          }
        }
        this.__transform(chunk, encoding, callback);
      }
    };
    ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;
  },
});

// node_modules/axios/lib/helpers/callbackify.js
var callbackify, callbackify_default;
var init_callbackify = __esm({
  'node_modules/axios/lib/helpers/callbackify.js'() {
    init_utils();
    callbackify = (fn, reducer) => {
      return utils_default.isAsyncFn(fn)
        ? function (...args) {
            const cb = args.pop();
            fn.apply(this, args).then((value) => {
              try {
                reducer ? cb(null, ...reducer(value)) : cb(null, value);
              } catch (err) {
                cb(err);
              }
            }, cb);
          }
        : fn;
    };
    callbackify_default = callbackify;
  },
});

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head2 = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push2(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head2] = chunkLength;
    timestamps[head2] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head2) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head2 = (head2 + 1) % samplesCount;
    if (head2 === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round((bytesCount * 1e3) / passed) : void 0;
  };
}
var speedometer_default;
var init_speedometer = __esm({
  'node_modules/axios/lib/helpers/speedometer.js'() {
    'use strict';
    speedometer_default = speedometer;
  },
});

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer2;
  const invoke2 = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
    fn(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke2(args, now);
    } else {
      lastArgs = args;
      if (!timer2) {
        timer2 = setTimeout(() => {
          timer2 = null;
          invoke2(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke2(lastArgs);
  return [throttled, flush];
}
var throttle_default;
var init_throttle = __esm({
  'node_modules/axios/lib/helpers/throttle.js'() {
    throttle_default = throttle;
  },
});

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer, progressEventDecorator, asyncDecorator;
var init_progressEventReducer = __esm({
  'node_modules/axios/lib/helpers/progressEventReducer.js'() {
    init_speedometer();
    init_throttle();
    init_utils();
    progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer_default(50, 250);
      return throttle_default((e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? 'download' : 'upload']: true,
        };
        listener(data);
      }, freq);
    };
    progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;
      return [
        (loaded) =>
          throttled[0]({
            lengthComputable,
            total,
            loaded,
          }),
        throttled[1],
      ];
    };
    asyncDecorator =
      (fn) =>
      (...args) =>
        utils_default.asap(() => fn(...args));
  },
});

// node_modules/axios/lib/helpers/estimateDataURLDecodedBytes.js
function estimateDataURLDecodedBytes(url2) {
  if (!url2 || typeof url2 !== 'string') return 0;
  if (!url2.startsWith('data:')) return 0;
  const comma = url2.indexOf(',');
  if (comma < 0) return 0;
  const meta = url2.slice(5, comma);
  const body = url2.slice(comma + 1);
  const isBase64 = /;base64/i.test(meta);
  if (isBase64) {
    let effectiveLen = body.length;
    const len = body.length;
    for (let i = 0; i < len; i++) {
      if (body.charCodeAt(i) === 37 && i + 2 < len) {
        const a = body.charCodeAt(i + 1);
        const b = body.charCodeAt(i + 2);
        const isHex =
          ((a >= 48 && a <= 57) || (a >= 65 && a <= 70) || (a >= 97 && a <= 102)) &&
          ((b >= 48 && b <= 57) || (b >= 65 && b <= 70) || (b >= 97 && b <= 102));
        if (isHex) {
          effectiveLen -= 2;
          i += 2;
        }
      }
    }
    let pad = 0;
    let idx = len - 1;
    const tailIsPct3D = (j) =>
      j >= 2 &&
      body.charCodeAt(j - 2) === 37 && // '%'
      body.charCodeAt(j - 1) === 51 && // '3'
      (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100);
    if (idx >= 0) {
      if (body.charCodeAt(idx) === 61) {
        pad++;
        idx--;
      } else if (tailIsPct3D(idx)) {
        pad++;
        idx -= 3;
      }
    }
    if (pad === 1 && idx >= 0) {
      if (body.charCodeAt(idx) === 61) {
        pad++;
      } else if (tailIsPct3D(idx)) {
        pad++;
      }
    }
    const groups = Math.floor(effectiveLen / 4);
    const bytes = groups * 3 - (pad || 0);
    return bytes > 0 ? bytes : 0;
  }
  return Buffer.byteLength(body, 'utf8');
}
var init_estimateDataURLDecodedBytes = __esm({
  'node_modules/axios/lib/helpers/estimateDataURLDecodedBytes.js'() {},
});

// node_modules/axios/lib/adapters/http.js
import http from 'http';
import https from 'https';
import util2 from 'util';
import zlib from 'zlib';
import stream3 from 'stream';
import { EventEmitter } from 'events';
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location) {
  let proxy2 = configProxy;
  if (!proxy2 && proxy2 !== false) {
    const proxyUrl = import_proxy_from_env.default.getProxyForUrl(location);
    if (proxyUrl) {
      proxy2 = new URL(proxyUrl);
    }
  }
  if (proxy2) {
    if (proxy2.username) {
      proxy2.auth = (proxy2.username || '') + ':' + (proxy2.password || '');
    }
    if (proxy2.auth) {
      if (proxy2.auth.username || proxy2.auth.password) {
        proxy2.auth = (proxy2.auth.username || '') + ':' + (proxy2.auth.password || '');
      }
      const base64 = Buffer.from(proxy2.auth, 'utf8').toString('base64');
      options.headers['Proxy-Authorization'] = 'Basic ' + base64;
    }
    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');
    const proxyHost = proxy2.hostname || proxy2.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy2.port;
    options.path = location;
    if (proxy2.protocol) {
      options.protocol = proxy2.protocol.includes(':') ? proxy2.protocol : `${proxy2.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
var import_proxy_from_env,
  import_follow_redirects,
  zlibOptions,
  brotliOptions,
  isBrotliSupported,
  httpFollow,
  httpsFollow,
  isHttps,
  supportedProtocols,
  flushOnFinish,
  isHttpAdapterSupported,
  wrapAsync,
  resolveFamily,
  buildAddressEntry,
  http_default;
var init_http = __esm({
  'node_modules/axios/lib/adapters/http.js'() {
    'use strict';
    init_utils();
    init_settle();
    init_buildFullPath();
    init_buildURL();
    import_proxy_from_env = __toESM(require_proxy_from_env(), 1);
    import_follow_redirects = __toESM(require_follow_redirects(), 1);
    init_data();
    init_transitional();
    init_AxiosError();
    init_CanceledError();
    init_platform();
    init_fromDataURI();
    init_AxiosHeaders();
    init_AxiosTransformStream();
    init_formDataToStream();
    init_readBlob();
    init_ZlibHeaderTransformStream();
    init_callbackify();
    init_progressEventReducer();
    init_estimateDataURLDecodedBytes();
    zlibOptions = {
      flush: zlib.constants.Z_SYNC_FLUSH,
      finishFlush: zlib.constants.Z_SYNC_FLUSH,
    };
    brotliOptions = {
      flush: zlib.constants.BROTLI_OPERATION_FLUSH,
      finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH,
    };
    isBrotliSupported = utils_default.isFunction(zlib.createBrotliDecompress);
    ({ http: httpFollow, https: httpsFollow } = import_follow_redirects.default);
    isHttps = /https:?/;
    supportedProtocols = platform_default.protocols.map((protocol) => {
      return protocol + ':';
    });
    flushOnFinish = (stream4, [throttled, flush]) => {
      stream4.on('end', flush).on('error', flush);
      return throttled;
    };
    isHttpAdapterSupported =
      typeof process !== 'undefined' && utils_default.kindOf(process) === 'process';
    wrapAsync = (asyncExecutor) => {
      return new Promise((resolve, reject) => {
        let onDone;
        let isDone;
        const done = (value, isRejected) => {
          if (isDone) return;
          isDone = true;
          onDone && onDone(value, isRejected);
        };
        const _resolve = (value) => {
          done(value);
          resolve(value);
        };
        const _reject = (reason) => {
          done(reason, true);
          reject(reason);
        };
        asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(
          _reject
        );
      });
    };
    resolveFamily = ({ address, family }) => {
      if (!utils_default.isString(address)) {
        throw TypeError('address must be a string');
      }
      return {
        address,
        family: family || (address.indexOf('.') < 0 ? 6 : 4),
      };
    };
    buildAddressEntry = (address, family) =>
      resolveFamily(utils_default.isObject(address) ? address : { address, family });
    http_default =
      isHttpAdapterSupported &&
      function httpAdapter(config) {
        return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
          let { data, lookup, family } = config;
          const { responseType, responseEncoding } = config;
          const method = config.method.toUpperCase();
          let isDone;
          let rejected = false;
          let req;
          if (lookup) {
            const _lookup = callbackify_default(lookup, (value) =>
              utils_default.isArray(value) ? value : [value]
            );
            lookup = (hostname, opt, cb) => {
              _lookup(hostname, opt, (err, arg0, arg1) => {
                if (err) {
                  return cb(err);
                }
                const addresses = utils_default.isArray(arg0)
                  ? arg0.map((addr) => buildAddressEntry(addr))
                  : [buildAddressEntry(arg0, arg1)];
                opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
              });
            };
          }
          const emitter = new EventEmitter();
          const onFinished = () => {
            if (config.cancelToken) {
              config.cancelToken.unsubscribe(abort);
            }
            if (config.signal) {
              config.signal.removeEventListener('abort', abort);
            }
            emitter.removeAllListeners();
          };
          onDone((value, isRejected) => {
            isDone = true;
            if (isRejected) {
              rejected = true;
              onFinished();
            }
          });
          function abort(reason) {
            emitter.emit(
              'abort',
              !reason || reason.type ? new CanceledError_default(null, config, req) : reason
            );
          }
          emitter.once('abort', reject);
          if (config.cancelToken || config.signal) {
            config.cancelToken && config.cancelToken.subscribe(abort);
            if (config.signal) {
              config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);
            }
          }
          const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
          const parsed = new URL(
            fullPath,
            platform_default.hasBrowserEnv ? platform_default.origin : void 0
          );
          const protocol = parsed.protocol || supportedProtocols[0];
          if (protocol === 'data:') {
            if (config.maxContentLength > -1) {
              const dataUrl = String(config.url || fullPath || '');
              const estimated = estimateDataURLDecodedBytes(dataUrl);
              if (estimated > config.maxContentLength) {
                return reject(
                  new AxiosError_default(
                    'maxContentLength size of ' + config.maxContentLength + ' exceeded',
                    AxiosError_default.ERR_BAD_RESPONSE,
                    config
                  )
                );
              }
            }
            let convertedData;
            if (method !== 'GET') {
              return settle(resolve, reject, {
                status: 405,
                statusText: 'method not allowed',
                headers: {},
                config,
              });
            }
            try {
              convertedData = fromDataURI(config.url, responseType === 'blob', {
                Blob: config.env && config.env.Blob,
              });
            } catch (err) {
              throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config);
            }
            if (responseType === 'text') {
              convertedData = convertedData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === 'utf8') {
                convertedData = utils_default.stripBOM(convertedData);
              }
            } else if (responseType === 'stream') {
              convertedData = stream3.Readable.from(convertedData);
            }
            return settle(resolve, reject, {
              data: convertedData,
              status: 200,
              statusText: 'OK',
              headers: new AxiosHeaders_default(),
              config,
            });
          }
          if (supportedProtocols.indexOf(protocol) === -1) {
            return reject(
              new AxiosError_default(
                'Unsupported protocol ' + protocol,
                AxiosError_default.ERR_BAD_REQUEST,
                config
              )
            );
          }
          const headers = AxiosHeaders_default.from(config.headers).normalize();
          headers.set('User-Agent', 'axios/' + VERSION, false);
          const { onUploadProgress, onDownloadProgress } = config;
          const maxRate = config.maxRate;
          let maxUploadRate = void 0;
          let maxDownloadRate = void 0;
          if (utils_default.isSpecCompliantForm(data)) {
            const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
            data = formDataToStream_default(
              data,
              (formHeaders) => {
                headers.set(formHeaders);
              },
              {
                tag: `axios-${VERSION}-boundary`,
                boundary: (userBoundary && userBoundary[1]) || void 0,
              }
            );
          } else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
            headers.set(data.getHeaders());
            if (!headers.hasContentLength()) {
              try {
                const knownLength = await util2.promisify(data.getLength).call(data);
                Number.isFinite(knownLength) &&
                  knownLength >= 0 &&
                  headers.setContentLength(knownLength);
              } catch (e) {}
            }
          } else if (utils_default.isBlob(data) || utils_default.isFile(data)) {
            data.size && headers.setContentType(data.type || 'application/octet-stream');
            headers.setContentLength(data.size || 0);
            data = stream3.Readable.from(readBlob_default(data));
          } else if (data && !utils_default.isStream(data)) {
            if (Buffer.isBuffer(data)) {
            } else if (utils_default.isArrayBuffer(data)) {
              data = Buffer.from(new Uint8Array(data));
            } else if (utils_default.isString(data)) {
              data = Buffer.from(data, 'utf-8');
            } else {
              return reject(
                new AxiosError_default(
                  'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
                  AxiosError_default.ERR_BAD_REQUEST,
                  config
                )
              );
            }
            headers.setContentLength(data.length, false);
            if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
              return reject(
                new AxiosError_default(
                  'Request body larger than maxBodyLength limit',
                  AxiosError_default.ERR_BAD_REQUEST,
                  config
                )
              );
            }
          }
          const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
          if (utils_default.isArray(maxRate)) {
            maxUploadRate = maxRate[0];
            maxDownloadRate = maxRate[1];
          } else {
            maxUploadRate = maxDownloadRate = maxRate;
          }
          if (data && (onUploadProgress || maxUploadRate)) {
            if (!utils_default.isStream(data)) {
              data = stream3.Readable.from(data, { objectMode: false });
            }
            data = stream3.pipeline(
              [
                data,
                new AxiosTransformStream_default({
                  maxRate: utils_default.toFiniteNumber(maxUploadRate),
                }),
              ],
              utils_default.noop
            );
            onUploadProgress &&
              data.on(
                'progress',
                flushOnFinish(
                  data,
                  progressEventDecorator(
                    contentLength,
                    progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
                  )
                )
              );
          }
          let auth = void 0;
          if (config.auth) {
            const username = config.auth.username || '';
            const password = config.auth.password || '';
            auth = username + ':' + password;
          }
          if (!auth && parsed.username) {
            const urlUsername = parsed.username;
            const urlPassword = parsed.password;
            auth = urlUsername + ':' + urlPassword;
          }
          auth && headers.delete('authorization');
          let path5;
          try {
            path5 = buildURL(
              parsed.pathname + parsed.search,
              config.params,
              config.paramsSerializer
            ).replace(/^\?/, '');
          } catch (err) {
            const customErr = new Error(err.message);
            customErr.config = config;
            customErr.url = config.url;
            customErr.exists = true;
            return reject(customErr);
          }
          headers.set(
            'Accept-Encoding',
            'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''),
            false
          );
          const options = {
            path: path5,
            method,
            headers: headers.toJSON(),
            agents: { http: config.httpAgent, https: config.httpsAgent },
            auth,
            protocol,
            family,
            beforeRedirect: dispatchBeforeRedirect,
            beforeRedirects: {},
          };
          !utils_default.isUndefined(lookup) && (options.lookup = lookup);
          if (config.socketPath) {
            options.socketPath = config.socketPath;
          } else {
            options.hostname = parsed.hostname.startsWith('[')
              ? parsed.hostname.slice(1, -1)
              : parsed.hostname;
            options.port = parsed.port;
            setProxy(
              options,
              config.proxy,
              protocol +
                '//' +
                parsed.hostname +
                (parsed.port ? ':' + parsed.port : '') +
                options.path
            );
          }
          let transport;
          const isHttpsRequest = isHttps.test(options.protocol);
          options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
          if (config.transport) {
            transport = config.transport;
          } else if (config.maxRedirects === 0) {
            transport = isHttpsRequest ? https : http;
          } else {
            if (config.maxRedirects) {
              options.maxRedirects = config.maxRedirects;
            }
            if (config.beforeRedirect) {
              options.beforeRedirects.config = config.beforeRedirect;
            }
            transport = isHttpsRequest ? httpsFollow : httpFollow;
          }
          if (config.maxBodyLength > -1) {
            options.maxBodyLength = config.maxBodyLength;
          } else {
            options.maxBodyLength = Infinity;
          }
          if (config.insecureHTTPParser) {
            options.insecureHTTPParser = config.insecureHTTPParser;
          }
          req = transport.request(options, function handleResponse(res) {
            if (req.destroyed) return;
            const streams = [res];
            const responseLength = +res.headers['content-length'];
            if (onDownloadProgress || maxDownloadRate) {
              const transformStream = new AxiosTransformStream_default({
                maxRate: utils_default.toFiniteNumber(maxDownloadRate),
              });
              onDownloadProgress &&
                transformStream.on(
                  'progress',
                  flushOnFinish(
                    transformStream,
                    progressEventDecorator(
                      responseLength,
                      progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
                    )
                  )
                );
              streams.push(transformStream);
            }
            let responseStream = res;
            const lastRequest = res.req || req;
            if (config.decompress !== false && res.headers['content-encoding']) {
              if (method === 'HEAD' || res.statusCode === 204) {
                delete res.headers['content-encoding'];
              }
              switch ((res.headers['content-encoding'] || '').toLowerCase()) {
                /*eslint default-case:0*/
                case 'gzip':
                case 'x-gzip':
                case 'compress':
                case 'x-compress':
                  streams.push(zlib.createUnzip(zlibOptions));
                  delete res.headers['content-encoding'];
                  break;
                case 'deflate':
                  streams.push(new ZlibHeaderTransformStream_default());
                  streams.push(zlib.createUnzip(zlibOptions));
                  delete res.headers['content-encoding'];
                  break;
                case 'br':
                  if (isBrotliSupported) {
                    streams.push(zlib.createBrotliDecompress(brotliOptions));
                    delete res.headers['content-encoding'];
                  }
              }
            }
            responseStream =
              streams.length > 1 ? stream3.pipeline(streams, utils_default.noop) : streams[0];
            const offListeners = stream3.finished(responseStream, () => {
              offListeners();
              onFinished();
            });
            const response = {
              status: res.statusCode,
              statusText: res.statusMessage,
              headers: new AxiosHeaders_default(res.headers),
              config,
              request: lastRequest,
            };
            if (responseType === 'stream') {
              response.data = responseStream;
              settle(resolve, reject, response);
            } else {
              const responseBuffer = [];
              let totalResponseBytes = 0;
              responseStream.on('data', function handleStreamData(chunk) {
                responseBuffer.push(chunk);
                totalResponseBytes += chunk.length;
                if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                  rejected = true;
                  responseStream.destroy();
                  reject(
                    new AxiosError_default(
                      'maxContentLength size of ' + config.maxContentLength + ' exceeded',
                      AxiosError_default.ERR_BAD_RESPONSE,
                      config,
                      lastRequest
                    )
                  );
                }
              });
              responseStream.on('aborted', function handlerStreamAborted() {
                if (rejected) {
                  return;
                }
                const err = new AxiosError_default(
                  'stream has been aborted',
                  AxiosError_default.ERR_BAD_RESPONSE,
                  config,
                  lastRequest
                );
                responseStream.destroy(err);
                reject(err);
              });
              responseStream.on('error', function handleStreamError(err) {
                if (req.destroyed) return;
                reject(AxiosError_default.from(err, null, config, lastRequest));
              });
              responseStream.on('end', function handleStreamEnd() {
                try {
                  let responseData =
                    responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                  if (responseType !== 'arraybuffer') {
                    responseData = responseData.toString(responseEncoding);
                    if (!responseEncoding || responseEncoding === 'utf8') {
                      responseData = utils_default.stripBOM(responseData);
                    }
                  }
                  response.data = responseData;
                } catch (err) {
                  return reject(
                    AxiosError_default.from(err, null, config, response.request, response)
                  );
                }
                settle(resolve, reject, response);
              });
            }
            emitter.once('abort', (err) => {
              if (!responseStream.destroyed) {
                responseStream.emit('error', err);
                responseStream.destroy();
              }
            });
          });
          emitter.once('abort', (err) => {
            reject(err);
            req.destroy(err);
          });
          req.on('error', function handleRequestError(err) {
            reject(AxiosError_default.from(err, null, config, req));
          });
          req.on('socket', function handleRequestSocket(socket) {
            socket.setKeepAlive(true, 1e3 * 60);
          });
          if (config.timeout) {
            const timeout = parseInt(config.timeout, 10);
            if (Number.isNaN(timeout)) {
              reject(
                new AxiosError_default(
                  'error trying to parse `config.timeout` to int',
                  AxiosError_default.ERR_BAD_OPTION_VALUE,
                  config,
                  req
                )
              );
              return;
            }
            req.setTimeout(timeout, function handleRequestTimeout() {
              if (isDone) return;
              let timeoutErrorMessage = config.timeout
                ? 'timeout of ' + config.timeout + 'ms exceeded'
                : 'timeout exceeded';
              const transitional2 = config.transitional || transitional_default;
              if (config.timeoutErrorMessage) {
                timeoutErrorMessage = config.timeoutErrorMessage;
              }
              reject(
                new AxiosError_default(
                  timeoutErrorMessage,
                  transitional2.clarifyTimeoutError
                    ? AxiosError_default.ETIMEDOUT
                    : AxiosError_default.ECONNABORTED,
                  config,
                  req
                )
              );
              abort();
            });
          }
          if (utils_default.isStream(data)) {
            let ended = false;
            let errored = false;
            data.on('end', () => {
              ended = true;
            });
            data.once('error', (err) => {
              errored = true;
              req.destroy(err);
            });
            data.on('close', () => {
              if (!ended && !errored) {
                abort(new CanceledError_default('Request stream has been aborted', config, req));
              }
            });
            data.pipe(req);
          } else {
            req.end(data);
          }
        });
      };
  },
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default;
var init_isURLSameOrigin = __esm({
  'node_modules/axios/lib/helpers/isURLSameOrigin.js'() {
    init_platform();
    isURLSameOrigin_default = platform_default.hasStandardBrowserEnv
      ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
          url2 = new URL(url2, platform_default.origin);
          return (
            origin2.protocol === url2.protocol &&
            origin2.host === url2.host &&
            (isMSIE || origin2.port === url2.port)
          );
        })(
          new URL(platform_default.origin),
          platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
        )
      : () => true;
  },
});

// node_modules/axios/lib/helpers/cookies.js
var cookies_default;
var init_cookies = __esm({
  'node_modules/axios/lib/helpers/cookies.js'() {
    init_utils();
    init_platform();
    cookies_default = platform_default.hasStandardBrowserEnv
      ? // Standard browser envs support document.cookie
        {
          write(name3, value, expires, path5, domain, secure) {
            const cookie = [name3 + '=' + encodeURIComponent(value)];
            utils_default.isNumber(expires) &&
              cookie.push('expires=' + new Date(expires).toGMTString());
            utils_default.isString(path5) && cookie.push('path=' + path5);
            utils_default.isString(domain) && cookie.push('domain=' + domain);
            secure === true && cookie.push('secure');
            document.cookie = cookie.join('; ');
          },
          read(name3) {
            const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name3 + ')=([^;]*)'));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove(name3) {
            this.write(name3, '', Date.now() - 864e5);
          },
        }
      : // Non-standard browser env (web workers, react-native) lack needed support.
        {
          write() {},
          read() {
            return null;
          },
          remove() {},
        };
  },
});

// node_modules/axios/lib/core/mergeConfig.js
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source2, prop2, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source2)) {
      return utils_default.merge.call({ caseless }, target, source2);
    } else if (utils_default.isPlainObject(source2)) {
      return utils_default.merge({}, source2);
    } else if (utils_default.isArray(source2)) {
      return source2.slice();
    }
    return source2;
  }
  function mergeDeepProperties(a, b, prop2, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, prop2, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, prop2, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop2) {
    if (prop2 in config2) {
      return getMergedValue(a, b);
    } else if (prop2 in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop2) =>
      mergeDeepProperties(headersToObject(a), headersToObject(b), prop2, true),
  };
  utils_default.forEach(
    Object.keys({ ...config1, ...config2 }),
    function computeConfigValue(prop2) {
      const merge2 = mergeMap[prop2] || mergeDeepProperties;
      const configValue = merge2(config1[prop2], config2[prop2], prop2);
      (utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys) ||
        (config[prop2] = configValue);
    }
  );
  return config;
}
var headersToObject;
var init_mergeConfig = __esm({
  'node_modules/axios/lib/core/mergeConfig.js'() {
    'use strict';
    init_utils();
    init_AxiosHeaders();
    headersToObject = (thing) => (thing instanceof AxiosHeaders_default ? { ...thing } : thing);
  },
});

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default;
var init_resolveConfig = __esm({
  'node_modules/axios/lib/helpers/resolveConfig.js'() {
    init_platform();
    init_utils();
    init_isURLSameOrigin();
    init_cookies();
    init_buildFullPath();
    init_mergeConfig();
    init_AxiosHeaders();
    init_buildURL();
    resolveConfig_default = (config) => {
      const newConfig = mergeConfig({}, config);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders_default.from(headers);
      newConfig.url = buildURL(
        buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls),
        config.params,
        config.paramsSerializer
      );
      if (auth) {
        headers.set(
          'Authorization',
          'Basic ' +
            btoa(
              (auth.username || '') +
                ':' +
                (auth.password ? unescape(encodeURIComponent(auth.password)) : '')
            )
        );
      }
      if (utils_default.isFormData(data)) {
        if (
          platform_default.hasStandardBrowserEnv ||
          platform_default.hasStandardBrowserWebWorkerEnv
        ) {
          headers.setContentType(void 0);
        } else if (utils_default.isFunction(data.getHeaders)) {
          const formHeaders = data.getHeaders();
          const allowedHeaders = ['content-type', 'content-length'];
          Object.entries(formHeaders).forEach(([key2, val]) => {
            if (allowedHeaders.includes(key2.toLowerCase())) {
              headers.set(key2, val);
            }
          });
        }
      }
      if (platform_default.hasStandardBrowserEnv) {
        withXSRFToken &&
          utils_default.isFunction(withXSRFToken) &&
          (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin_default(newConfig.url))) {
          const xsrfValue =
            xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
  },
});

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported, xhr_default;
var init_xhr = __esm({
  'node_modules/axios/lib/adapters/xhr.js'() {
    init_utils();
    init_settle();
    init_transitional();
    init_AxiosError();
    init_CanceledError();
    init_parseProtocol();
    init_platform();
    init_AxiosHeaders();
    init_progressEventReducer();
    init_resolveConfig();
    isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';
    xhr_default =
      isXHRAdapterSupported &&
      function (config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          const _config = resolveConfig_default(config);
          let requestData = _config.data;
          const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
          let { responseType, onUploadProgress, onDownloadProgress } = _config;
          let onCanceled;
          let uploadThrottled, downloadThrottled;
          let flushUpload, flushDownload;
          function done() {
            flushUpload && flushUpload();
            flushDownload && flushDownload();
            _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
            _config.signal && _config.signal.removeEventListener('abort', onCanceled);
          }
          let request = new XMLHttpRequest();
          request.open(_config.method.toUpperCase(), _config.url, true);
          request.timeout = _config.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            const responseHeaders = AxiosHeaders_default.from(
              'getAllResponseHeaders' in request && request.getAllResponseHeaders()
            );
            const responseData =
              !responseType || responseType === 'text' || responseType === 'json'
                ? request.responseText
                : request.response;
            const response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config,
              request,
            };
            settle(
              function _resolve(value) {
                resolve(value);
                done();
              },
              function _reject(err) {
                reject(err);
                done();
              },
              response
            );
            request = null;
          }
          if ('onloadend' in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (
                request.status === 0 &&
                !(request.responseURL && request.responseURL.indexOf('file:') === 0)
              ) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(
              new AxiosError_default(
                'Request aborted',
                AxiosError_default.ECONNABORTED,
                config,
                request
              )
            );
            request = null;
          };
          request.onerror = function handleError(event2) {
            const msg = event2 && event2.message ? event2.message : 'Network Error';
            const err = new AxiosError_default(
              msg,
              AxiosError_default.ERR_NETWORK,
              config,
              request
            );
            err.event = event2 || null;
            reject(err);
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            let timeoutErrorMessage = _config.timeout
              ? 'timeout of ' + _config.timeout + 'ms exceeded'
              : 'timeout exceeded';
            const transitional2 = _config.transitional || transitional_default;
            if (_config.timeoutErrorMessage) {
              timeoutErrorMessage = _config.timeoutErrorMessage;
            }
            reject(
              new AxiosError_default(
                timeoutErrorMessage,
                transitional2.clarifyTimeoutError
                  ? AxiosError_default.ETIMEDOUT
                  : AxiosError_default.ECONNABORTED,
                config,
                request
              )
            );
            request = null;
          };
          requestData === void 0 && requestHeaders.setContentType(null);
          if ('setRequestHeader' in request) {
            utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key2) {
              request.setRequestHeader(key2, val);
            });
          }
          if (!utils_default.isUndefined(_config.withCredentials)) {
            request.withCredentials = !!_config.withCredentials;
          }
          if (responseType && responseType !== 'json') {
            request.responseType = _config.responseType;
          }
          if (onDownloadProgress) {
            [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
            request.addEventListener('progress', downloadThrottled);
          }
          if (onUploadProgress && request.upload) {
            [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
            request.upload.addEventListener('progress', uploadThrottled);
            request.upload.addEventListener('loadend', flushUpload);
          }
          if (_config.cancelToken || _config.signal) {
            onCanceled = (cancel2) => {
              if (!request) {
                return;
              }
              reject(
                !cancel2 || cancel2.type
                  ? new CanceledError_default(null, config, request)
                  : cancel2
              );
              request.abort();
              request = null;
            };
            _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
            if (_config.signal) {
              _config.signal.aborted
                ? onCanceled()
                : _config.signal.addEventListener('abort', onCanceled);
            }
          }
          const protocol = parseProtocol(_config.url);
          if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
            reject(
              new AxiosError_default(
                'Unsupported protocol ' + protocol + ':',
                AxiosError_default.ERR_BAD_REQUEST,
                config
              )
            );
            return;
          }
          request.send(requestData || null);
        });
      };
  },
});

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals, composeSignals_default;
var init_composeSignals = __esm({
  'node_modules/axios/lib/helpers/composeSignals.js'() {
    init_CanceledError();
    init_AxiosError();
    init_utils();
    composeSignals = (signals, timeout) => {
      const { length } = (signals = signals ? signals.filter(Boolean) : []);
      if (timeout || length) {
        let controller = new AbortController();
        let aborted2;
        const onabort = function (reason) {
          if (!aborted2) {
            aborted2 = true;
            unsubscribe();
            const err = reason instanceof Error ? reason : this.reason;
            controller.abort(
              err instanceof AxiosError_default
                ? err
                : new CanceledError_default(err instanceof Error ? err.message : err)
            );
          }
        };
        let timer2 =
          timeout &&
          setTimeout(() => {
            timer2 = null;
            onabort(
              new AxiosError_default(
                `timeout ${timeout} of ms exceeded`,
                AxiosError_default.ETIMEDOUT
              )
            );
          }, timeout);
        const unsubscribe = () => {
          if (signals) {
            timer2 && clearTimeout(timer2);
            timer2 = null;
            signals.forEach((signal2) => {
              signal2.unsubscribe
                ? signal2.unsubscribe(onabort)
                : signal2.removeEventListener('abort', onabort);
            });
            signals = null;
          }
        };
        signals.forEach((signal2) => signal2.addEventListener('abort', onabort));
        const { signal } = controller;
        signal.unsubscribe = () => utils_default.asap(unsubscribe);
        return signal;
      }
    };
    composeSignals_default = composeSignals;
  },
});

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk, readBytes, readStream, trackStream;
var init_trackStream = __esm({
  'node_modules/axios/lib/helpers/trackStream.js'() {
    streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;
      if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
      }
      let pos = 0;
      let end;
      while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
      }
    };
    readBytes = async function* (iterable, chunkSize) {
      for await (const chunk of readStream(iterable)) {
        yield* streamChunk(chunk, chunkSize);
      }
    };
    readStream = async function* (stream4) {
      if (stream4[Symbol.asyncIterator]) {
        yield* stream4;
        return;
      }
      const reader = stream4.getReader();
      try {
        for (;;) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          yield value;
        }
      } finally {
        await reader.cancel();
      }
    };
    trackStream = (stream4, chunkSize, onProgress, onFinish) => {
      const iterator2 = readBytes(stream4, chunkSize);
      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };
      return new ReadableStream(
        {
          async pull(controller) {
            try {
              const { done: done2, value } = await iterator2.next();
              if (done2) {
                _onFinish();
                controller.close();
                return;
              }
              let len = value.byteLength;
              if (onProgress) {
                let loadedBytes = (bytes += len);
                onProgress(loadedBytes);
              }
              controller.enqueue(new Uint8Array(value));
            } catch (err) {
              _onFinish(err);
              throw err;
            }
          },
          cancel(reason) {
            _onFinish(reason);
            return iterator2.return();
          },
        },
        {
          highWaterMark: 2,
        }
      );
    };
  },
});

// node_modules/axios/lib/adapters/fetch.js
var DEFAULT_CHUNK_SIZE,
  isFunction2,
  globalFetchAPI,
  ReadableStream2,
  TextEncoder2,
  test,
  factory,
  seedCache,
  getFetch,
  adapter;
var init_fetch = __esm({
  'node_modules/axios/lib/adapters/fetch.js'() {
    init_platform();
    init_utils();
    init_AxiosError();
    init_composeSignals();
    init_trackStream();
    init_AxiosHeaders();
    init_progressEventReducer();
    init_resolveConfig();
    init_settle();
    DEFAULT_CHUNK_SIZE = 64 * 1024;
    ({ isFunction: isFunction2 } = utils_default);
    globalFetchAPI = (({ Request, Response: Response2 }) => ({
      Request,
      Response: Response2,
    }))(utils_default.global);
    ({ ReadableStream: ReadableStream2, TextEncoder: TextEncoder2 } = utils_default.global);
    test = (fn, ...args) => {
      try {
        return !!fn(...args);
      } catch (e) {
        return false;
      }
    };
    factory = (env2) => {
      env2 = utils_default.merge.call(
        {
          skipUndefined: true,
        },
        globalFetchAPI,
        env2
      );
      const { fetch: envFetch, Request, Response: Response2 } = env2;
      const isFetchSupported = envFetch ? isFunction2(envFetch) : typeof fetch === 'function';
      const isRequestSupported = isFunction2(Request);
      const isResponseSupported = isFunction2(Response2);
      if (!isFetchSupported) {
        return false;
      }
      const isReadableStreamSupported = isFetchSupported && isFunction2(ReadableStream2);
      const encodeText =
        isFetchSupported &&
        (typeof TextEncoder2 === 'function'
          ? /* @__PURE__ */ (
              (encoder) => (str2) =>
                encoder.encode(str2)
            )(new TextEncoder2())
          : async (str2) => new Uint8Array(await new Request(str2).arrayBuffer()));
      const supportsRequestStream =
        isRequestSupported &&
        isReadableStreamSupported &&
        test(() => {
          let duplexAccessed = false;
          const hasContentType = new Request(platform_default.origin, {
            body: new ReadableStream2(),
            method: 'POST',
            get duplex() {
              duplexAccessed = true;
              return 'half';
            },
          }).headers.has('Content-Type');
          return duplexAccessed && !hasContentType;
        });
      const supportsResponseStream =
        isResponseSupported &&
        isReadableStreamSupported &&
        test(() => utils_default.isReadableStream(new Response2('').body));
      const resolvers = {
        stream: supportsResponseStream && ((res) => res.body),
      };
      isFetchSupported &&
        (() => {
          ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach((type) => {
            !resolvers[type] &&
              (resolvers[type] = (res, config) => {
                let method = res && res[type];
                if (method) {
                  return method.call(res);
                }
                throw new AxiosError_default(
                  `Response type '${type}' is not supported`,
                  AxiosError_default.ERR_NOT_SUPPORT,
                  config
                );
              });
          });
        })();
      const getBodyLength = async (body) => {
        if (body == null) {
          return 0;
        }
        if (utils_default.isBlob(body)) {
          return body.size;
        }
        if (utils_default.isSpecCompliantForm(body)) {
          const _request = new Request(platform_default.origin, {
            method: 'POST',
            body,
          });
          return (await _request.arrayBuffer()).byteLength;
        }
        if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
          return body.byteLength;
        }
        if (utils_default.isURLSearchParams(body)) {
          body = body + '';
        }
        if (utils_default.isString(body)) {
          return (await encodeText(body)).byteLength;
        }
      };
      const resolveBodyLength = async (headers, body) => {
        const length = utils_default.toFiniteNumber(headers.getContentLength());
        return length == null ? getBodyLength(body) : length;
      };
      return async (config) => {
        let {
          url: url2,
          method,
          data,
          signal,
          cancelToken,
          timeout,
          onDownloadProgress,
          onUploadProgress,
          responseType,
          headers,
          withCredentials = 'same-origin',
          fetchOptions,
        } = resolveConfig_default(config);
        let _fetch = envFetch || fetch;
        responseType = responseType ? (responseType + '').toLowerCase() : 'text';
        let composedSignal = composeSignals_default(
          [signal, cancelToken && cancelToken.toAbortSignal()],
          timeout
        );
        let request = null;
        const unsubscribe =
          composedSignal &&
          composedSignal.unsubscribe &&
          (() => {
            composedSignal.unsubscribe();
          });
        let requestContentLength;
        try {
          if (
            onUploadProgress &&
            supportsRequestStream &&
            method !== 'get' &&
            method !== 'head' &&
            (requestContentLength = await resolveBodyLength(headers, data)) !== 0
          ) {
            let _request = new Request(url2, {
              method: 'POST',
              body: data,
              duplex: 'half',
            });
            let contentTypeHeader;
            if (
              utils_default.isFormData(data) &&
              (contentTypeHeader = _request.headers.get('content-type'))
            ) {
              headers.setContentType(contentTypeHeader);
            }
            if (_request.body) {
              const [onProgress, flush] = progressEventDecorator(
                requestContentLength,
                progressEventReducer(asyncDecorator(onUploadProgress))
              );
              data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
            }
          }
          if (!utils_default.isString(withCredentials)) {
            withCredentials = withCredentials ? 'include' : 'omit';
          }
          const isCredentialsSupported = isRequestSupported && 'credentials' in Request.prototype;
          const resolvedOptions = {
            ...fetchOptions,
            signal: composedSignal,
            method: method.toUpperCase(),
            headers: headers.normalize().toJSON(),
            body: data,
            duplex: 'half',
            credentials: isCredentialsSupported ? withCredentials : void 0,
          };
          request = isRequestSupported && new Request(url2, resolvedOptions);
          let response = await (isRequestSupported
            ? _fetch(request, fetchOptions)
            : _fetch(url2, resolvedOptions));
          const isStreamResponse =
            supportsResponseStream && (responseType === 'stream' || responseType === 'response');
          if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
            const options = {};
            ['status', 'statusText', 'headers'].forEach((prop2) => {
              options[prop2] = response[prop2];
            });
            const responseContentLength = utils_default.toFiniteNumber(
              response.headers.get('content-length')
            );
            const [onProgress, flush] =
              (onDownloadProgress &&
                progressEventDecorator(
                  responseContentLength,
                  progressEventReducer(asyncDecorator(onDownloadProgress), true)
                )) ||
              [];
            response = new Response2(
              trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
                flush && flush();
                unsubscribe && unsubscribe();
              }),
              options
            );
          }
          responseType = responseType || 'text';
          let responseData = await resolvers[
            utils_default.findKey(resolvers, responseType) || 'text'
          ](response, config);
          !isStreamResponse && unsubscribe && unsubscribe();
          return await new Promise((resolve, reject) => {
            settle(resolve, reject, {
              data: responseData,
              headers: AxiosHeaders_default.from(response.headers),
              status: response.status,
              statusText: response.statusText,
              config,
              request,
            });
          });
        } catch (err) {
          unsubscribe && unsubscribe();
          if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {
            throw Object.assign(
              new AxiosError_default(
                'Network Error',
                AxiosError_default.ERR_NETWORK,
                config,
                request
              ),
              {
                cause: err.cause || err,
              }
            );
          }
          throw AxiosError_default.from(err, err && err.code, config, request);
        }
      };
    };
    seedCache = /* @__PURE__ */ new Map();
    getFetch = (config) => {
      let env2 = config ? config.env : {};
      const { fetch: fetch2, Request, Response: Response2 } = env2;
      const seeds = [Request, Response2, fetch2];
      let len = seeds.length,
        i = len,
        seed,
        target,
        map = seedCache;
      while (i--) {
        seed = seeds[i];
        target = map.get(seed);
        target === void 0 &&
          map.set(seed, (target = i ? /* @__PURE__ */ new Map() : factory(env2)));
        map = target;
      }
      return target;
    };
    adapter = getFetch();
  },
});

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters, renderReason, isResolvedHandle, adapters_default;
var init_adapters = __esm({
  'node_modules/axios/lib/adapters/adapters.js'() {
    init_utils();
    init_http();
    init_xhr();
    init_fetch();
    init_AxiosError();
    knownAdapters = {
      http: http_default,
      xhr: xhr_default,
      fetch: {
        get: getFetch,
      },
    };
    utils_default.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, 'name', { value });
        } catch (e) {}
        Object.defineProperty(fn, 'adapterName', { value });
      }
    });
    renderReason = (reason) => `- ${reason}`;
    isResolvedHandle = (adapter2) =>
      utils_default.isFunction(adapter2) || adapter2 === null || adapter2 === false;
    adapters_default = {
      getAdapter: (adapters, config) => {
        adapters = utils_default.isArray(adapters) ? adapters : [adapters];
        const { length } = adapters;
        let nameOrAdapter;
        let adapter2;
        const rejectedReasons = {};
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters[i];
          let id;
          adapter2 = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter2 = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter2 === void 0) {
              throw new AxiosError_default(`Unknown adapter '${id}'`);
            }
          }
          if (
            adapter2 &&
            (utils_default.isFunction(adapter2) || (adapter2 = adapter2.get(config)))
          ) {
            break;
          }
          rejectedReasons[id || '#' + i] = adapter2;
        }
        if (!adapter2) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state2]) =>
              `adapter ${id} ` +
              (state2 === false
                ? 'is not supported by the environment'
                : 'is not available in the build')
          );
          let s = length
            ? reasons.length > 1
              ? 'since :\n' + reasons.map(renderReason).join('\n')
              : ' ' + renderReason(reasons[0])
            : 'as no adapter specified';
          throw new AxiosError_default(
            `There is no suitable adapter to dispatch the request ` + s,
            'ERR_NOT_SUPPORT'
          );
        }
        return adapter2;
      },
      adapters: knownAdapters,
    };
  },
});

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(config, config.transformRequest);
  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }
  const adapter2 = adapters_default.getAdapter(config.adapter || defaults_default.adapter, config);
  return adapter2(config).then(
    function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(config, config.transformResponse, response);
      response.headers = AxiosHeaders_default.from(response.headers);
      return response;
    },
    function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            config.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    }
  );
}
var init_dispatchRequest = __esm({
  'node_modules/axios/lib/core/dispatchRequest.js'() {
    'use strict';
    init_transformData();
    init_isCancel();
    init_defaults();
    init_CanceledError();
    init_AxiosHeaders();
    init_adapters();
  },
});

// node_modules/axios/lib/helpers/validator.js
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError_default(
      'options must be an object',
      AxiosError_default.ERR_BAD_OPTION_VALUE
    );
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default(
          'option ' + opt + ' must be ' + result,
          AxiosError_default.ERR_BAD_OPTION_VALUE
        );
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default('Unknown option ' + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validators, deprecatedWarnings, validator_default;
var init_validator = __esm({
  'node_modules/axios/lib/helpers/validator.js'() {
    'use strict';
    init_data();
    init_AxiosError();
    validators = {};
    ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
      validators[type] = function validator(thing) {
        return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
      };
    });
    deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version4, message) {
      function formatMessage(opt, desc) {
        return (
          '[Axios v' +
          VERSION +
          "] Transitional option '" +
          opt +
          "'" +
          desc +
          (message ? '. ' + message : '')
        );
      }
      return (value, opt, opts) => {
        if (validator === false) {
          throw new AxiosError_default(
            formatMessage(opt, ' has been removed' + (version4 ? ' in ' + version4 : '')),
            AxiosError_default.ERR_DEPRECATED
          );
        }
        if (version4 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              ' has been deprecated since v' + version4 + ' and will be removed in the near future'
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    validators.spelling = function spelling(correctSpelling) {
      return (value, opt) => {
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
      };
    };
    validator_default = {
      assertOptions,
      validators,
    };
  },
});

// node_modules/axios/lib/core/Axios.js
var validators2, Axios, Axios_default;
var init_Axios = __esm({
  'node_modules/axios/lib/core/Axios.js'() {
    'use strict';
    init_utils();
    init_buildURL();
    init_InterceptorManager();
    init_dispatchRequest();
    init_mergeConfig();
    init_buildFullPath();
    init_validator();
    init_AxiosHeaders();
    validators2 = validator_default.validators;
    Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig || {};
        this.interceptors = {
          request: new InterceptorManager_default(),
          response: new InterceptorManager_default(),
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy = {};
            Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());
            const stack2 = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
            try {
              if (!err.stack) {
                err.stack = stack2;
              } else if (stack2 && !String(err.stack).endsWith(stack2.replace(/^.+\n.+\n/, ''))) {
                err.stack += '\n' + stack2;
              }
            } catch (e) {}
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === 'string') {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional: transitional2, paramsSerializer, headers } = config;
        if (transitional2 !== void 0) {
          validator_default.assertOptions(
            transitional2,
            {
              silentJSONParsing: validators2.transitional(validators2.boolean),
              forcedJSONParsing: validators2.transitional(validators2.boolean),
              clarifyTimeoutError: validators2.transitional(validators2.boolean),
            },
            false
          );
        }
        if (paramsSerializer != null) {
          if (utils_default.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer,
            };
          } else {
            validator_default.assertOptions(
              paramsSerializer,
              {
                encode: validators2.function,
                serialize: validators2.function,
              },
              true
            );
          }
        }
        if (config.allowAbsoluteUrls !== void 0) {
        } else if (this.defaults.allowAbsoluteUrls !== void 0) {
          config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
        } else {
          config.allowAbsoluteUrls = true;
        }
        validator_default.assertOptions(
          config,
          {
            baseUrl: validators2.spelling('baseURL'),
            withXsrfToken: validators2.spelling('withXSRFToken'),
          },
          true
        );
        config.method = (config.method || this.defaults.method || 'get').toLowerCase();
        let contextHeaders = headers && utils_default.merge(headers.common, headers[config.method]);
        headers &&
          utils_default.forEach(
            ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
            (method) => {
              delete headers[method];
            }
          );
        config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors =
            synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift(...requestInterceptorChain);
          chain.push(...responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils_default.forEach(
      ['delete', 'get', 'head', 'options'],
      function forEachMethodNoData(method) {
        Axios.prototype[method] = function (url2, config) {
          return this.request(
            mergeConfig(config || {}, {
              method,
              url: url2,
              data: (config || {}).data,
            })
          );
        };
      }
    );
    utils_default.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url2, data, config) {
          return this.request(
            mergeConfig(config || {}, {
              method,
              headers: isForm
                ? {
                    'Content-Type': 'multipart/form-data',
                  }
                : {},
              url: url2,
              data,
            })
          );
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
    });
    Axios_default = Axios;
  },
});

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken, CancelToken_default;
var init_CancelToken = __esm({
  'node_modules/axios/lib/cancel/CancelToken.js'() {
    'use strict';
    init_CanceledError();
    CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== 'function') {
          throw new TypeError('executor must be a function.');
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel2) => {
          if (!token._listeners) return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel2);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel2(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError_default(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index2 = this._listeners.indexOf(listener);
        if (index2 !== -1) {
          this._listeners.splice(index2, 1);
        }
      }
      toAbortSignal() {
        const controller = new AbortController();
        const abort = (err) => {
          controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = () => this.unsubscribe(abort);
        return controller.signal;
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel2;
        const token = new _CancelToken(function executor(c) {
          cancel2 = c;
        });
        return {
          token,
          cancel: cancel2,
        };
      }
    };
    CancelToken_default = CancelToken;
  },
});

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
var init_spread = __esm({
  'node_modules/axios/lib/helpers/spread.js'() {
    'use strict';
  },
});

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}
var init_isAxiosError = __esm({
  'node_modules/axios/lib/helpers/isAxiosError.js'() {
    'use strict';
    init_utils();
  },
});

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode, HttpStatusCode_default;
var init_HttpStatusCode = __esm({
  'node_modules/axios/lib/helpers/HttpStatusCode.js'() {
    HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511,
    };
    Object.entries(HttpStatusCode).forEach(([key2, value]) => {
      HttpStatusCode[value] = key2;
    });
    HttpStatusCode_default = HttpStatusCode;
  },
});

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios, axios_default;
var init_axios = __esm({
  'node_modules/axios/lib/axios.js'() {
    'use strict';
    init_utils();
    init_bind();
    init_Axios();
    init_mergeConfig();
    init_defaults();
    init_formDataToJSON();
    init_CanceledError();
    init_CancelToken();
    init_isCancel();
    init_data();
    init_toFormData();
    init_AxiosError();
    init_spread();
    init_isAxiosError();
    init_AxiosHeaders();
    init_adapters();
    init_HttpStatusCode();
    axios = createInstance(defaults_default);
    axios.Axios = Axios_default;
    axios.CanceledError = CanceledError_default;
    axios.CancelToken = CancelToken_default;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData_default;
    axios.AxiosError = AxiosError_default;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders_default;
    axios.formToJSON = (thing) =>
      formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters_default.getAdapter;
    axios.HttpStatusCode = HttpStatusCode_default;
    axios.default = axios;
    axios_default = axios;
  },
});

// node_modules/axios/index.js
var Axios2,
  AxiosError2,
  CanceledError2,
  isCancel2,
  CancelToken2,
  VERSION2,
  all2,
  Cancel,
  isAxiosError2,
  spread2,
  toFormData2,
  AxiosHeaders2,
  HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig2;
var init_axios2 = __esm({
  'node_modules/axios/index.js'() {
    init_axios();
    ({
      Axios: Axios2,
      AxiosError: AxiosError2,
      CanceledError: CanceledError2,
      isCancel: isCancel2,
      CancelToken: CancelToken2,
      VERSION: VERSION2,
      all: all2,
      Cancel,
      isAxiosError: isAxiosError2,
      spread: spread2,
      toFormData: toFormData2,
      AxiosHeaders: AxiosHeaders2,
      HttpStatusCode: HttpStatusCode2,
      formToJSON,
      getAdapter,
      mergeConfig: mergeConfig2,
    } = axios_default);
  },
});

// src/rateLimiter.ts
var RateLimiter;
var init_rateLimiter = __esm({
  'src/rateLimiter.ts'() {
    'use strict';
    RateLimiter = class {
      constructor(ratePerSecond, burst) {
        this.ratePerSecond = ratePerSecond;
        this.burst = burst;
        this.tokens = burst;
        this.lastRefill = Date.now();
      }
      tokens;
      queue = [];
      lastRefill;
      timer = null;
      refill() {
        const now = Date.now();
        const elapsed = (now - this.lastRefill) / 1e3;
        if (elapsed <= 0) return;
        this.lastRefill = now;
        this.tokens = Math.min(this.burst, this.tokens + elapsed * this.ratePerSecond);
      }
      scheduleDrain() {
        if (this.timer || this.queue.length === 0) return;
        const delay2 = 50;
        this.timer = setTimeout(() => {
          this.timer = null;
          this.refill();
          while (this.queue.length && this.tokens >= 1) {
            this.tokens -= 1;
            const resolve = this.queue.shift();
            resolve && resolve();
          }
          if (this.queue.length) this.scheduleDrain();
        }, delay2);
      }
      acquire() {
        this.refill();
        if (this.tokens >= 1 && this.queue.length === 0) {
          this.tokens -= 1;
          return Promise.resolve();
        }
        return new Promise((res) => {
          this.queue.push(res);
          this.scheduleDrain();
        });
      }
    };
  },
});

// src/cache.ts
function startCacheCleanup() {
  if (cleanupInterval) return;
  cleanupInterval = setInterval(() => {
    workItemCache.cleanup();
    apiCache.cleanup();
    metadataCache.cleanup();
  }, 3e5);
}
function stopCacheCleanup() {
  if (cleanupInterval) {
    clearInterval(cleanupInterval);
    cleanupInterval = null;
  }
}
function getCacheStats() {
  const workItemsStats = workItemCache.getStats();
  const apiStats = apiCache.getStats();
  const metadataStats = metadataCache.getStats();
  return {
    workItems: workItemsStats,
    api: apiStats,
    metadata: metadataStats,
    totalMemoryUsage: workItemsStats.memoryUsage + apiStats.memoryUsage + metadataStats.memoryUsage,
  };
}
var IntelligentCache, WorkItemCache, workItemCache, apiCache, metadataCache, cleanupInterval;
var init_cache = __esm({
  'src/cache.ts'() {
    'use strict';
    IntelligentCache = class {
      cache = /* @__PURE__ */ new Map();
      accessOrder = [];
      metrics;
      options;
      constructor(options = {}) {
        this.options = {
          maxSize: options.maxSize ?? 1e3,
          defaultTtl: options.defaultTtl ?? 3e5,
          // 5 minutes
          enableMetrics: options.enableMetrics ?? true,
          evictionPolicy: options.evictionPolicy ?? 'both',
        };
        this.metrics = {
          hits: 0,
          misses: 0,
          evictions: 0,
          size: 0,
          maxSize: this.options.maxSize,
          hitRate: 0,
        };
      }
      /**
       * Get a value from the cache
       */
      get(key2) {
        const entry = this.cache.get(key2);
        if (!entry) {
          this.metrics.misses++;
          this.updateHitRate();
          return null;
        }
        if (this.isExpired(entry)) {
          this.delete(key2);
          this.metrics.misses++;
          this.updateHitRate();
          return null;
        }
        entry.accessCount++;
        entry.lastAccessed = Date.now();
        this.updateAccessOrder(key2);
        this.metrics.hits++;
        this.updateHitRate();
        return entry.data;
      }
      /**
       * Set a value in the cache
       */
      set(key2, value, ttl) {
        const now = Date.now();
        const entry = {
          data: value,
          timestamp: now,
          ttl: ttl ?? this.options.defaultTtl,
          accessCount: 0,
          lastAccessed: now,
        };
        if (this.cache.size >= this.options.maxSize && !this.cache.has(key2)) {
          this.evict();
        }
        this.cache.set(key2, entry);
        this.updateAccessOrder(key2);
        this.metrics.size = this.cache.size;
      }
      /**
       * Check if a key exists and is not expired
       */
      has(key2) {
        const entry = this.cache.get(key2);
        if (!entry) return false;
        if (this.isExpired(entry)) {
          this.delete(key2);
          return false;
        }
        return true;
      }
      /**
       * Delete a key from the cache
       */
      delete(key2) {
        const deleted = this.cache.delete(key2);
        if (deleted) {
          const index2 = this.accessOrder.indexOf(key2);
          if (index2 > -1) {
            this.accessOrder.splice(index2, 1);
          }
          this.metrics.size = this.cache.size;
        }
        return deleted;
      }
      /**
       * Clear all entries from the cache
       */
      clear() {
        this.cache.clear();
        this.accessOrder = [];
        this.metrics.size = 0;
      }
      /**
       * Get cache metrics
       */
      getMetrics() {
        return { ...this.metrics };
      }
      /**
       * Get cache size
       */
      size() {
        return this.cache.size;
      }
      /**
       * Clean up expired entries
       */
      cleanup() {
        let cleaned = 0;
        for (const [key2, entry] of this.cache.entries()) {
          if (this.isExpired(entry)) {
            this.delete(key2);
            cleaned++;
          }
        }
        return cleaned;
      }
      /**
       * Get all keys in the cache
       */
      keys() {
        return Array.from(this.cache.keys());
      }
      /**
       * Get cache statistics for debugging
       */
      getStats() {
        const topKeys = Array.from(this.cache.entries())
          .map(([key2, entry]) => ({
            key: key2,
            accessCount: entry.accessCount,
            lastAccessed: entry.lastAccessed,
          }))
          .sort((a, b) => b.accessCount - a.accessCount)
          .slice(0, 10);
        const memoryUsage = this.cache.size * 100;
        return {
          metrics: this.getMetrics(),
          topKeys,
          memoryUsage,
        };
      }
      isExpired(entry) {
        return Date.now() - entry.timestamp > entry.ttl;
      }
      updateAccessOrder(key2) {
        const index2 = this.accessOrder.indexOf(key2);
        if (index2 > -1) {
          this.accessOrder.splice(index2, 1);
        }
        this.accessOrder.push(key2);
      }
      evict() {
        if (this.cache.size === 0) return;
        let keyToEvict = null;
        switch (this.options.evictionPolicy) {
          case 'lru':
            keyToEvict = this.accessOrder[0];
            break;
          case 'ttl': {
            let oldestTime = Date.now();
            for (const [key2, entry] of this.cache.entries()) {
              if (entry.timestamp < oldestTime) {
                oldestTime = entry.timestamp;
                keyToEvict = key2;
              }
            }
            break;
          }
          case 'both': {
            const now = Date.now();
            const oldThreshold = now - this.options.defaultTtl * 2;
            for (const [key2, entry] of this.cache.entries()) {
              if (entry.timestamp < oldThreshold) {
                keyToEvict = key2;
                break;
              }
            }
            if (!keyToEvict) {
              keyToEvict = this.accessOrder[0];
            }
            break;
          }
        }
        if (keyToEvict) {
          this.delete(keyToEvict);
          this.metrics.evictions++;
        }
      }
      updateHitRate() {
        const total = this.metrics.hits + this.metrics.misses;
        this.metrics.hitRate = total > 0 ? this.metrics.hits / total : 0;
      }
    };
    WorkItemCache = class _WorkItemCache extends IntelligentCache {
      static WORK_ITEM_TTL = 3e5;
      // 5 minutes
      static QUERY_TTL = 6e5;
      // 10 minutes
      static METADATA_TTL = 18e5;
      // 30 minutes
      constructor() {
        super({
          maxSize: 2e3,
          defaultTtl: _WorkItemCache.WORK_ITEM_TTL,
          enableMetrics: true,
          evictionPolicy: 'both',
        });
      }
      /**
       * Cache work items with appropriate TTL
       */
      setWorkItems(key2, workItems) {
        this.set(key2, workItems, _WorkItemCache.WORK_ITEM_TTL);
      }
      /**
       * Cache query results with longer TTL
       */
      setQueryResult(key2, result) {
        this.set(key2, result, _WorkItemCache.QUERY_TTL);
      }
      /**
       * Cache metadata with longest TTL
       */
      setMetadata(key2, metadata) {
        this.set(key2, metadata, _WorkItemCache.METADATA_TTL);
      }
      /**
       * Generate cache key for work items query
       */
      static generateWorkItemsKey(connectionId, query, filters) {
        const filterStr = JSON.stringify(filters);
        return `workitems:${connectionId}:${Buffer.from(query + filterStr).toString('base64')}`;
      }
      /**
       * Generate cache key for query
       */
      static generateQueryKey(connectionId, query) {
        return `query:${connectionId}:${Buffer.from(query).toString('base64')}`;
      }
      /**
       * Generate cache key for metadata
       */
      static generateMetadataKey(connectionId, type) {
        return `metadata:${connectionId}:${type}`;
      }
    };
    workItemCache = new WorkItemCache();
    apiCache = new IntelligentCache({ maxSize: 500, defaultTtl: 3e5 });
    metadataCache = new IntelligentCache({ maxSize: 100, defaultTtl: 18e5 });
    cleanupInterval = null;
  },
});

// src/performance.ts
import { performance as performance2 } from 'perf_hooks';
async function measureAsync(operation, fn, cacheHit) {
  const endTiming = performanceMonitor.startTiming(operation);
  try {
    const result = await fn();
    endTiming(void 0, cacheHit);
    return result;
  } catch (error) {
    endTiming(error instanceof Error ? error.message : 'Unknown error', cacheHit);
    throw error;
  }
}
var PerformanceMonitor, performanceMonitor, MemoryOptimizer;
var init_performance = __esm({
  'src/performance.ts'() {
    'use strict';
    init_cache();
    PerformanceMonitor = class {
      metrics = [];
      maxMetrics = 1e3;
      memoryPeak = 0;
      isEnabled = true;
      /**
       * Start timing an operation
       */
      startTiming(operation) {
        const startTime = performance2.now();
        const startMemory = this.getMemoryUsage();
        return (error, cacheHit) => {
          const endTime = performance2.now();
          const endMemory = this.getMemoryUsage();
          const metric = {
            operation,
            duration: endTime - startTime,
            timestamp: Date.now(),
            memoryUsage: endMemory.heapUsed - startMemory.heapUsed,
            cacheHit,
            error,
          };
          this.recordMetric(metric);
          return metric;
        };
      }
      /**
       * Record a performance metric
       */
      recordMetric(metric) {
        if (!this.isEnabled) return;
        this.metrics.push(metric);
        if (this.metrics.length > this.maxMetrics) {
          this.metrics = this.metrics.slice(-this.maxMetrics);
        }
        if (metric.memoryUsage && metric.memoryUsage > this.memoryPeak) {
          this.memoryPeak = metric.memoryUsage;
        }
      }
      /**
       * Get performance statistics
       */
      getStats() {
        if (this.metrics.length === 0) {
          return {
            totalOperations: 0,
            averageDuration: 0,
            minDuration: 0,
            maxDuration: 0,
            errorRate: 0,
            cacheHitRate: 0,
            memoryUsage: {
              current: this.getMemoryUsage().heapUsed,
              peak: this.memoryPeak,
              average: 0,
            },
          };
        }
        const durations = this.metrics.map((m) => m.duration);
        const errors = this.metrics.filter((m) => m.error).length;
        const cacheHits = this.metrics.filter((m) => m.cacheHit === true).length;
        const memoryUsages = this.metrics
          .filter((m) => m.memoryUsage !== void 0)
          .map((m) => m.memoryUsage);
        return {
          totalOperations: this.metrics.length,
          averageDuration: durations.reduce((a, b) => a + b, 0) / durations.length,
          minDuration: Math.min(...durations),
          maxDuration: Math.max(...durations),
          errorRate: errors / this.metrics.length,
          cacheHitRate: cacheHits / this.metrics.length,
          memoryUsage: {
            current: this.getMemoryUsage().heapUsed,
            peak: this.memoryPeak,
            average:
              memoryUsages.length > 0
                ? memoryUsages.reduce((a, b) => a + b, 0) / memoryUsages.length
                : 0,
          },
        };
      }
      /**
       * Get metrics for a specific operation
       */
      getOperationStats(operation) {
        const operationMetrics = this.metrics.filter((m) => m.operation === operation);
        if (operationMetrics.length === 0) {
          return this.getStats();
        }
        const durations = operationMetrics.map((m) => m.duration);
        const errors = operationMetrics.filter((m) => m.error).length;
        const cacheHits = operationMetrics.filter((m) => m.cacheHit === true).length;
        return {
          totalOperations: operationMetrics.length,
          averageDuration: durations.reduce((a, b) => a + b, 0) / durations.length,
          minDuration: Math.min(...durations),
          maxDuration: Math.max(...durations),
          errorRate: errors / operationMetrics.length,
          cacheHitRate: cacheHits / operationMetrics.length,
          memoryUsage: {
            current: this.getMemoryUsage().heapUsed,
            peak: this.memoryPeak,
            average: 0,
          },
        };
      }
      /**
       * Get recent metrics
       */
      getRecentMetrics(count = 50) {
        return this.metrics.slice(-count);
      }
      /**
       * Clear all metrics
       */
      clear() {
        this.metrics = [];
        this.memoryPeak = 0;
      }
      /**
       * Enable or disable monitoring
       */
      setEnabled(enabled) {
        this.isEnabled = enabled;
      }
      /**
       * Get current memory usage
       */
      getMemoryUsage() {
        return process.memoryUsage();
      }
      /**
       * Get comprehensive performance report
       */
      getPerformanceReport() {
        const stats = this.getStats();
        const cacheStats = getCacheStats();
        const memoryUsage = this.getMemoryUsage();
        const recommendations = [];
        if (stats.averageDuration > 1e3) {
          recommendations.push('Consider optimizing slow operations (>1s average)');
        }
        if (stats.errorRate > 0.1) {
          recommendations.push('High error rate detected - investigate error handling');
        }
        if (stats.cacheHitRate < 0.5) {
          recommendations.push('Low cache hit rate - consider improving caching strategy');
        }
        if (memoryUsage.heapUsed > 100 * 1024 * 1024) {
          recommendations.push('High memory usage - consider memory optimization');
        }
        if (cacheStats.totalMemoryUsage > 50 * 1024 * 1024) {
          recommendations.push('Cache memory usage is high - consider reducing cache size');
        }
        return {
          stats,
          cacheStats,
          memoryUsage,
          recommendations,
        };
      }
    };
    performanceMonitor = new PerformanceMonitor();
    MemoryOptimizer = class {
      static GC_THRESHOLD = 50 * 1024 * 1024;
      // 50MB
      static lastGC = 0;
      static GC_INTERVAL = 3e4;
      // 30 seconds
      /**
       * Force garbage collection if needed
       */
      static forceGCIfNeeded() {
        const memoryUsage = performanceMonitor.getMemoryUsage();
        const now = Date.now();
        if (memoryUsage.heapUsed > this.GC_THRESHOLD && now - this.lastGC > this.GC_INTERVAL) {
          if (global.gc) {
            global.gc();
            this.lastGC = now;
            return true;
          }
        }
        return false;
      }
      /**
       * Get memory usage summary
       */
      static getMemorySummary() {
        const current = performanceMonitor.getMemoryUsage();
        const peak = performanceMonitor.getStats().memoryUsage.peak;
        const recommendations = [];
        if (current.heapUsed > 100 * 1024 * 1024) {
          recommendations.push('Consider reducing memory usage');
        }
        if (current.external > 50 * 1024 * 1024) {
          recommendations.push('High external memory usage - check for memory leaks');
        }
        return {
          current,
          peak,
          recommendations,
        };
      }
    };
  },
});

// src/azureClient.ts
var escapeRegExp, stripProjectSegment, AzureDevOpsIntClient, AzureDevOpsClient;
var init_azureClient = __esm({
  'src/azureClient.ts'() {
    'use strict';
    init_axios2();
    init_rateLimiter();
    init_cache();
    init_performance();
    escapeRegExp = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    stripProjectSegment = (url2, encodedProject, rawProject) => {
      const candidates = /* @__PURE__ */ new Set();
      if (encodedProject) {
        candidates.add(encodedProject);
        const doubleEncoded = encodeURIComponent(encodedProject);
        if (doubleEncoded && doubleEncoded !== encodedProject) {
          candidates.add(doubleEncoded);
        }
      }
      if (rawProject?.trim()) {
        candidates.add(rawProject.trim());
      }
      try {
        const decoded = decodeURIComponent(encodedProject);
        if (decoded) {
          candidates.add(decoded);
          const fullyDecoded = decodeURIComponent(decoded);
          if (fullyDecoded) {
            candidates.add(fullyDecoded);
          }
        }
      } catch {}
      return Array.from(candidates).reduce((current, candidate) => {
        if (!candidate) {
          return current;
        }
        const pattern = new RegExp(`/${escapeRegExp(candidate)}$`);
        return current.replace(pattern, '');
      }, url2);
    };
    AzureDevOpsIntClient = class _AzureDevOpsIntClient {
      organization;
      project;
      encodedOrganization;
      encodedProject;
      axios;
      _repoCache;
      credential;
      // PAT or access token
      authType;
      limiter;
      onAuthFailure;
      team;
      encodedTeam;
      // Capability cache: prefer using [System.StateCategory] unless Azure DevOps rejects it for this org/project
      preferStateCategory;
      cachedIdentity;
      identityName;
      // Fallback identity name for on-prem servers
      baseUrl;
      // Store the base URL for browser URL generation
      apiBaseUrl;
      // Store the API base URL (for on-premises support)
      static connectionDataApiVersions = [
        '7.1-preview.1',
        '7.0-preview.1',
        '6.0-preview.1',
        '5.1-preview.2',
        '5.0-preview.3',
        '5.0-preview',
        '5.0',
      ];
      _authorizedGet(url2) {
        return this.axios.get(url2, { baseURL: void 0 });
      }
      constructor(organization, project, credential, options = {}) {
        this.organization = organization;
        this.project = project;
        this.credential = credential;
        this.authType = options.authType ?? 'pat';
        this.onAuthFailure = options.onAuthFailure;
        this.team = options.team?.trim() ? options.team.trim() : void 0;
        this.preferStateCategory = options.wiqlPreferStateCategory ?? true;
        this.identityName = options.identityName?.trim() ? options.identityName.trim() : void 0;
        if (this.identityName) {
          console.log(
            '[AzureClient] Configured with fallback identityName for on-prem:',
            this.identityName
          );
        }
        this.encodedOrganization = encodeURIComponent(organization);
        this.encodedProject = encodeURIComponent(project);
        this.encodedTeam = this.team ? encodeURIComponent(this.team) : void 0;
        const trimTrailingSlash = (value) => (value ? value.replace(/\/+$/, '') : void 0);
        const normalizeBaseUrl = (value) => {
          const fallback2 = `https://dev.azure.com/${this.encodedOrganization}`;
          if (!value) {
            return fallback2;
          }
          const trimmed = trimTrailingSlash(value) ?? fallback2;
          const withoutApis = trimmed.replace(/\/_apis$/i, '');
          if (/visualstudio\.com/i.test(withoutApis)) {
            return fallback2;
          }
          if (/dev\.azure\.com/i.test(withoutApis)) {
            return `https://dev.azure.com/${this.encodedOrganization}`;
          }
          const normalized = stripProjectSegment(withoutApis, this.encodedProject, this.project);
          return trimTrailingSlash(normalized) ?? fallback2;
        };
        const ensureApiSuffix = (value) => {
          const trimmed = trimTrailingSlash(value) ?? value;
          return /\/_apis$/i.test(trimmed) ? trimmed : `${trimmed}/_apis`;
        };
        if (options.apiBaseUrl) {
          const manualApi = ensureApiSuffix(options.apiBaseUrl);
          const derivedBase = stripProjectSegment(
            manualApi.replace(/\/_apis$/i, ''),
            this.encodedProject,
            this.project
          );
          const preferredBase = options.baseUrl
            ? normalizeBaseUrl(options.baseUrl)
            : normalizeBaseUrl(derivedBase);
          this.baseUrl = preferredBase;
          this.apiBaseUrl = manualApi.replace(/\/+$/, '');
          console.log('[AzureClient] Using manual API URL override:', {
            apiBaseUrl: this.apiBaseUrl,
            baseUrl: this.baseUrl,
          });
        } else if (options.baseUrl) {
          this.baseUrl = normalizeBaseUrl(options.baseUrl);
          this.apiBaseUrl = `${this.baseUrl}/${this.encodedProject}/_apis`;
        } else {
          this.baseUrl = `https://dev.azure.com/${this.encodedOrganization}`;
          this.apiBaseUrl = `${this.baseUrl}/${this.encodedProject}/_apis`;
        }
        this.baseUrl = this.baseUrl.replace(/\/+$/, '');
        this.apiBaseUrl = this.apiBaseUrl.replace(/\/+$/, '');
        this.axios = axios_default.create({
          baseURL: this.apiBaseUrl,
          timeout: 3e4,
          // 30s network timeout for slow Azure DevOps APIs
          headers: {
            'Content-Type': 'application/json',
          },
        });
        const rps = Math.max(1, Math.min(50, options.ratePerSecond ?? 5));
        const burst = Math.max(1, Math.min(100, options.burst ?? 10));
        this.limiter = new RateLimiter(rps, burst);
        this.axios.interceptors.request.use(async (cfg) => {
          await this.limiter.acquire();
          if (this.authType === 'pat') {
            (cfg.headers ||= {})['Authorization'] =
              `Basic ${Buffer.from(':' + this.credential).toString('base64')}`;
          } else {
            (cfg.headers ||= {})['Authorization'] = `Bearer ${this.credential}`;
          }
          cfg.__start = Date.now();
          cfg.__attempt = (cfg.__attempt || 0) + 1;
          const authHeader = cfg.headers?.['Authorization'];
          const tokenDebug = authHeader
            ? `${authHeader.substring(0, 20)}...${authHeader.substring(authHeader.length - 10)}`
            : 'NO_AUTH_HEADER';
          console.log(
            '[azureDevOpsInt][HTTP] \u2192',
            cfg.method?.toUpperCase(),
            cfg.url,
            'attempt',
            cfg.__attempt,
            'token:',
            tokenDebug
          );
          return cfg;
        });
        this.axios.interceptors.response.use(
          (resp) => {
            const ms = Date.now() - resp.config.__start;
            console.log(
              '[azureDevOpsInt][HTTP] \u2190',
              resp.config.method?.toUpperCase(),
              resp.config.url,
              resp.status,
              `${ms}ms`
            );
            return resp;
          },
          async (err) => {
            const cfg = err.config || {};
            const ms = cfg.__start ? Date.now() - cfg.__start : 'n/a';
            if (err.response) {
              const { status: status2, statusText, data } = err.response;
              if (status2 === 404) {
                console.error('[azureDevOpsInt][HTTP][404_DETAILS]', {
                  method: cfg.method?.toUpperCase(),
                  url: cfg.url,
                  fullUrl: cfg.baseURL + cfg.url,
                  status: status2,
                  statusText,
                  responseData: data,
                  authType: this.authType,
                  organization: this.organization,
                  project: this.project,
                });
              }
              console.error(
                '[azureDevOpsInt][HTTP][ERR]',
                cfg.method?.toUpperCase(),
                cfg.url,
                status2,
                statusText,
                `${ms}ms`
              );
              if (data) {
                let snippet2;
                try {
                  snippet2 =
                    typeof data === 'string'
                      ? data.slice(0, 500)
                      : JSON.stringify(data).slice(0, 500);
                } catch {
                  snippet2 = '[unserializable response data]';
                }
                console.error('[azureDevOpsInt][HTTP][ERR] body:', snippet2);
              }
              if (status2 === 401 && this.authType === 'bearer') {
                console.error(`[azureDevOpsInt][HTTP] 401 Unauthorized - authentication required`);
                const authError = new Error(
                  `Authentication failed: 401 Unauthorized. Please re-authenticate.`
                );
                authError.name = 'AuthenticationError';
                authError.status = status2;
                try {
                  this.onAuthFailure?.(authError);
                } catch (callbackError) {
                  console.error(
                    '[azureDevOpsInt][HTTP] onAuthFailure callback threw',
                    callbackError
                  );
                }
                throw authError;
              }
            } else if (err.code === 'ECONNABORTED') {
              console.error(
                '[azureDevOpsInt][HTTP][TIMEOUT]',
                cfg.method?.toUpperCase(),
                cfg.url,
                `${ms}ms`
              );
            } else {
              console.error('[azureDevOpsInt][HTTP][NETERR]', err.message);
            }
            const status = err.response?.status;
            const attempt = cfg.__attempt || 1;
            const maxAttempts = 4;
            if (
              status &&
              (status === 429 || (status >= 500 && status < 600)) &&
              attempt < maxAttempts
            ) {
              const backoffBase = 250 * Math.pow(2, attempt - 1);
              const jitter = Math.random() * backoffBase * 0.3;
              const delay2 = Math.min(4e3, backoffBase + jitter);
              console.warn(
                '[azureDevOpsInt][HTTP][RETRY]',
                cfg.url,
                'status',
                status,
                'retryInMs',
                Math.round(delay2),
                'attempt',
                attempt + 1
              );
              return new Promise((resolve) => setTimeout(resolve, delay2)).then(() =>
                this.axios(cfg)
              );
            }
            return Promise.reject(err);
          }
        );
      }
      /**
       * Update the credential (PAT or access token)
       * Useful for refreshing Entra ID tokens
       */
      updateCredential(newCredential) {
        this.credential = newCredential;
      }
      buildFullUrl(path5) {
        return `${this.apiBaseUrl}${path5}`;
      }
      getBrowserUrl(path5) {
        return `${this.baseUrl}/${this.encodedProject}${path5}`;
      }
      buildTeamApiUrl(path5) {
        if (!this.encodedTeam) return this.buildFullUrl(path5);
        const baseWithoutApis = this.apiBaseUrl.replace(/\/_apis$/, '');
        return `${baseWithoutApis}/${this.encodedTeam}/_apis${path5}`;
      }
      // ---------------- Identity Helpers ----------------
      /**
       * Fetches the authenticated Azure DevOps user identity GUID using connectionData.
       * Falls back to null on error.
       */
      async getAuthenticatedUserId() {
        console.log('[AzureClient] \u{1F50D} Testing authentication...');
        const identity = await this._getAuthenticatedIdentity();
        if (identity?.id) {
          console.log('[AzureClient] \u2705 Authentication successful!');
          console.log(
            `[AzureClient] \u{1F464} User: ${identity.displayName || 'Unknown'} (${identity.uniqueName || 'Unknown'})`
          );
          console.log(`[AzureClient] \u{1F511} Authentication method: Personal Access Token (PAT)`);
          console.log(`[AzureClient] \u{1F4CB} Your PAT has at least basic read permissions`);
          console.log(
            `[AzureClient] \u{1F4A1} If work item creation works, your PAT also has work item write permissions`
          );
        } else {
          console.log('[AzureClient] \u274C Authentication failed - no user identity returned');
        }
        try {
          console.log('[AzureClient][DEBUG] resolved identity object:', JSON.stringify(identity));
        } catch {}
        return identity?.id ?? null;
      }
      async _getAuthenticatedIdentity() {
        if (this.cachedIdentity) return this.cachedIdentity;
        try {
          let resp;
          const attempts = [];
          const attemptConnectionData = async (basePath, desc, useAxiosBase) => {
            let lastError2;
            const sanitized = basePath
              .replace(/([&?]+)api-version=[^&]+/i, '')
              .replace(/[&?]+$/, '');
            for (const version4 of _AzureDevOpsIntClient.connectionDataApiVersions) {
              const separator = sanitized.includes('?') ? '&' : '?';
              const fullUrl = `${sanitized}${separator}api-version=${version4}`;
              attempts.push({ desc: `${desc} (v=${version4})`, url: fullUrl });
              try {
                return useAxiosBase
                  ? await this.axios.get(fullUrl)
                  : await this._authorizedGet(fullUrl);
              } catch (error) {
                lastError2 = error;
                if (!this._shouldRetryConnectionDataVersion(error)) {
                  throw error;
                }
              }
            }
            throw lastError2 || new Error('connectionData api-version attempts exhausted');
          };
          try {
            const orgLevel = this.baseUrl.replace(/\/$/, '') + '/_apis/connectionData';
            resp = await attemptConnectionData(orgLevel, 'baseUrl org-level', false);
          } catch (err1) {
            try {
              const apiRoot = stripProjectSegment(
                this.apiBaseUrl.replace(/\/_apis\/?$/, ''),
                this.encodedProject,
                this.project
              );
              const apiConn = apiRoot.replace(/\/$/, '') + '/_apis/connectionData';
              resp = await attemptConnectionData(apiConn, 'apiBaseUrl without project', false);
            } catch (err2) {
              try {
                resp = await attemptConnectionData(
                  '/connectionData',
                  'relative to axios baseURL',
                  true
                );
              } catch (err3) {
                console.error('[azureDevOpsInt] connectionData attempts:', attempts);
                throw err1 || err2 || err3;
              }
            }
          }
          const user = resp.data?.authenticatedUser ?? {};
          const resolvedId =
            typeof user.id === 'string' || typeof user.id === 'number'
              ? String(user.id)
              : typeof user.descriptor === 'string'
                ? user.descriptor
                : typeof user.subjectDescriptor === 'string'
                  ? user.subjectDescriptor
                  : void 0;
          const displayName =
            typeof user.providerDisplayName === 'string'
              ? user.providerDisplayName
              : typeof user.displayName === 'string'
                ? user.displayName
                : void 0;
          const uniqueName =
            typeof user.uniqueName === 'string'
              ? user.uniqueName
              : typeof user.unique_name === 'string'
                ? user.unique_name
                : typeof user.mailAddress === 'string'
                  ? user.mailAddress
                  : typeof user.email === 'string'
                    ? user.email
                    : typeof user.principalName === 'string'
                      ? user.principalName
                      : typeof user.subjectDescriptor === 'string'
                        ? user.subjectDescriptor
                        : typeof user.descriptor === 'string'
                          ? user.descriptor
                          : void 0;
          const identity = {
            id: resolvedId,
            displayName,
            uniqueName,
          };
          this.cachedIdentity = identity;
          try {
            console.log('[AzureClient][DEBUG] resolved identity object:', JSON.stringify(identity));
          } catch {}
          if (!this.cachedIdentity.uniqueName && this.identityName) {
            console.log(
              '[AzureClient][DEBUG] using provided identityName as fallback:',
              this.identityName
            );
            this.cachedIdentity.uniqueName = this.identityName;
          }
          return this.cachedIdentity;
        } catch (e) {
          console.error('Error fetching authenticated user identity', e);
          if (this.identityName) {
            console.log(
              '[AzureClient][DEBUG] connectionData failed, using identityName fallback:',
              this.identityName
            );
            this.cachedIdentity = {
              uniqueName: this.identityName,
            };
            return this.cachedIdentity;
          }
          return null;
        }
      }
      _shouldRetryConnectionDataVersion(error) {
        const status = error?.response?.status;
        if (status !== 400) {
          return false;
        }
        const message = String(
          error?.response?.data?.message ||
            error?.response?.data?.error?.message ||
            error?.response?.data ||
            error?.message ||
            ''
        );
        return /preview/i.test(message) || /api[- ]?version/i.test(message);
      }
      buildWIQL(queryNameOrText) {
        return this._buildWIQL(queryNameOrText, this.preferStateCategory);
      }
      _selectFields() {
        return `[System.Id], [System.Title], [System.State], [System.WorkItemType], 
                           [System.AssignedTo], [System.CreatedDate], [System.ChangedDate],
                           [System.IterationPath], [System.Tags], [Microsoft.VSTS.Common.Priority]`;
      }
      _buildWIQL(queryNameOrText, useStateCategory) {
        const fields = this._selectFields();
        const selectedSprint = null;
        const sprintClause = selectedSprint
          ? `AND [System.IterationPath] = '${selectedSprint}'`
          : '';
        const activeFilter = this._activeStateFilter(useStateCategory);
        switch (queryNameOrText) {
          case 'My Activity':
            return `SELECT ${fields} FROM WorkItems 
                        WHERE [System.TeamProject] = @Project
                        AND ([System.AssignedTo] = @Me OR [System.CreatedBy] = @Me OR [System.ChangedBy] = @Me)
                        ${activeFilter}
                        ${sprintClause}
                        ORDER BY [System.ChangedDate] DESC`;
          case 'Assigned to me':
          case 'My Work Items':
            return `SELECT ${fields} FROM WorkItems 
                        WHERE [System.TeamProject] = @Project
                        AND [System.AssignedTo] = @Me 
                        ${activeFilter}
                        ${sprintClause}
                        ORDER BY [System.ChangedDate] DESC`;
          case 'Current Sprint':
            return selectedSprint
              ? `SELECT ${fields} FROM WorkItems 
                            WHERE [System.IterationPath] = '${selectedSprint}'
                            ${activeFilter}
                            ORDER BY [Microsoft.VSTS.Common.Priority] ASC, [System.Id] ASC`
              : `SELECT ${fields} FROM WorkItems 
                        WHERE [System.IterationPath] UNDER @CurrentIteration 
                        ${activeFilter}
                        ORDER BY [Microsoft.VSTS.Common.Priority] ASC, [System.Id] ASC`;
          case 'All Active':
            return `SELECT ${fields} FROM WorkItems 
                        WHERE [System.TeamProject] = @Project
                        ${activeFilter}
                        ${sprintClause}
                        ORDER BY [System.ChangedDate] DESC`;
          case 'Recently Updated':
            return `SELECT ${fields} FROM WorkItems 
                        WHERE [System.ChangedDate] >= @Today - 7
                        AND [System.State] <> 'Removed'
                        ${sprintClause}
                        ORDER BY [System.ChangedDate] DESC`;
          default:
            return queryNameOrText;
        }
      }
      _activeStateFilter(useStateCategory) {
        if (useStateCategory) {
          return `AND [System.StateCategory] <> 'Completed' AND [System.State] <> 'Removed'`;
        }
        return `AND [System.State] NOT IN ('Closed','Done','Resolved','Removed')`;
      }
      _mapRawWorkItems(rawItems) {
        if (!Array.isArray(rawItems)) return [];
        return rawItems
          .filter((item) => item && typeof item.id === 'number')
          .map((item) => {
            const mapped = {
              id: item.id,
              fields: item.fields || {},
            };
            if (Array.isArray(item.relations) && item.relations.length > 0) {
              const relations = item.relations
                .filter((rel) => rel && typeof rel === 'object')
                .map((rel) => {
                  const attributes =
                    rel.attributes && typeof rel.attributes === 'object'
                      ? { ...rel.attributes }
                      : void 0;
                  return {
                    url: typeof rel.url === 'string' ? rel.url : void 0,
                    rel: typeof rel.rel === 'string' ? rel.rel : void 0,
                    attributes,
                  };
                })
                .filter(Boolean);
              if (relations.length > 0) {
                mapped.relations = relations;
              }
            }
            return mapped;
          });
      }
      async _fetchWorkItemsByIds(ids) {
        if (!Array.isArray(ids) || ids.length === 0) return [];
        const uniqueIds = Array.from(new Set(ids.filter((id) => Number.isFinite(id))));
        if (uniqueIds.length === 0) return [];
        const results = [];
        const chunkSize = 200;
        for (let i = 0; i < uniqueIds.length; i += chunkSize) {
          const chunk = uniqueIds.slice(i, i + chunkSize);
          if (chunk.length === 0) continue;
          try {
            const resp = await this.axios.get(
              `/wit/workitems?ids=${chunk.join(',')}&$expand=all&api-version=7.0`
            );
            const rawItems = resp.data?.value || [];
            results.push(...this._mapRawWorkItems(rawItems));
          } catch (err) {
            console.warn(
              '[azureDevOpsInt][GETWI] Failed to expand work item chunk',
              err?.message || err
            );
          }
        }
        return results;
      }
      _filterItemsForProject(items) {
        if (!Array.isArray(items) || !this.project) return Array.isArray(items) ? [...items] : [];
        const target = this.project.trim().toLowerCase();
        return items.filter((item) => {
          const projectName = item?.fields?.['System.TeamProject'];
          if (!projectName || typeof projectName !== 'string') return true;
          return projectName.trim().toLowerCase() === target;
        });
      }
      _sortByChangedDateDesc(items) {
        return [...items].sort((a, b) => {
          const aDate = new Date(a?.fields?.['System.ChangedDate'] || 0).getTime();
          const bDate = new Date(b?.fields?.['System.ChangedDate'] || 0).getTime();
          return bDate - aDate;
        });
      }
      async _getFollowedWorkItems() {
        try {
          const resp = await this.axios.get('/work/workitems/favorites?api-version=7.0');
          const entries = Array.isArray(resp.data?.value) ? resp.data.value : [];
          const ids = entries
            .map((entry) => {
              if (typeof entry?.workItemId === 'number') return entry.workItemId;
              if (typeof entry?.id === 'number') return entry.id;
              const nested = entry?.workItem?.id;
              return typeof nested === 'number' ? nested : NaN;
            })
            .filter((id) => Number.isFinite(id));
          if (ids.length === 0) return [];
          const items = await this._fetchWorkItemsByIds(ids);
          const filtered = this._filterItemsForProject(items);
          return this._sortByChangedDateDesc(filtered);
        } catch (err) {
          console.warn(
            '[azureDevOpsInt][GETWI] Failed to fetch followed work items',
            err?.message || err
          );
          return [];
        }
      }
      async _getMentionedWorkItems() {
        const identity = await this._getAuthenticatedIdentity();
        if (!identity) return [];
        const terms = /* @__PURE__ */ new Set();
        if (typeof identity.displayName === 'string' && identity.displayName.trim()) {
          terms.add(identity.displayName.trim());
        }
        if (typeof identity.uniqueName === 'string' && identity.uniqueName.trim()) {
          terms.add(identity.uniqueName.trim());
        }
        if (terms.size === 0) return [];
        const clauses = Array.from(terms).map(
          (term) => `[System.History] CONTAINS '${this._escapeWIQL(term)}'`
        );
        const fields = this._selectFields();
        const stateFilter = this._activeStateFilter(this.preferStateCategory);
        const query = `SELECT ${fields} FROM WorkItems 
                        WHERE [System.TeamProject] = @Project
                        AND (${clauses.join(' OR ')})
                        ${stateFilter}
                        ORDER BY [System.ChangedDate] DESC`;
        try {
          return await this.runWIQL(query);
        } catch (err) {
          console.warn(
            '[azureDevOpsInt][GETWI] Failed to fetch mentioned work items',
            err?.message || err
          );
          return [];
        }
      }
      async getWorkItems(query) {
        return await measureAsync('getWorkItems', async () => {
          let wiql = '';
          let wiqlToSend = '';
          try {
            const cacheKey = WorkItemCache.generateWorkItemsKey(
              `${this.organization}-${this.project}`,
              query,
              { team: this.team }
            );
            const cached = workItemCache.get(cacheKey);
            if (cached) {
              console.log('[azureDevOpsInt][GETWI] Cache hit for query:', query);
              return cached;
            }
            if (query === 'Following') {
              const result = await this._getFollowedWorkItems();
              workItemCache.setWorkItems(cacheKey, result);
              return result;
            }
            if (query === 'Mentioned') {
              const result = await this._getMentionedWorkItems();
              workItemCache.setWorkItems(cacheKey, result);
              return result;
            }
            wiql = this.buildWIQL(query);
            if (query === 'Current Sprint') {
              try {
                const cur = await this.getCurrentIteration();
                const iterPath = cur?.path;
                if (iterPath && typeof iterPath === 'string') {
                  const safePath = this._escapeWIQL(iterPath);
                  wiql = `SELECT [System.Id], [System.Title], [System.State], [System.WorkItemType], [System.AssignedTo], [System.CreatedDate], [System.ChangedDate], [System.IterationPath], [System.Tags], [Microsoft.VSTS.Common.Priority] FROM WorkItems WHERE [System.IterationPath] UNDER '${safePath}' AND [System.State] <> 'Closed' AND [System.State] <> 'Removed' ORDER BY [Microsoft.VSTS.Common.Priority] ASC, [System.Id] ASC`;
                }
              } catch (e) {
                console.warn(
                  '[azureDevOpsInt][GETWI] getCurrentIteration failed, using @CurrentIteration',
                  e
                );
              }
            }
            console.log('[azureDevOpsInt][GETWI] Fetching work items with query:', wiql);
            console.log('[azureDevOpsInt][GETWI] API Base URL:', this.axios.defaults.baseURL);
            wiqlToSend = wiql;
            const knownUserScopedQueries = ['My Activity', 'Assigned to me', 'My Work Items'];
            const isKnownQuery = [
              'Recently Updated',
              'All Active',
              'Current Sprint',
              ...knownUserScopedQueries,
            ].includes(query);
            const needsLimit =
              !knownUserScopedQueries.includes(query) &&
              (['Recently Updated', 'All Active', 'Current Sprint'].includes(query) ||
                !isKnownQuery);
            if (needsLimit) {
              console.log(
                '[azureDevOpsInt][GETWI] Applying hard limit of 100 items for query:',
                query
              );
            }
            try {
              if (/@Me\b/i.test(wiql)) {
                const resolved = await this._getAuthenticatedIdentity();
                if (resolved) {
                  const idVal = resolved.uniqueName || resolved.displayName || resolved.id;
                  if (idVal) {
                    const escaped = this._escapeWIQL(String(idVal));
                    wiqlToSend = wiql.replace(/@Me\b/g, `'${escaped}'`);
                    console.log(
                      '[azureDevOpsInt][GETWI] Replacing @Me with explicit identity for compatibility: ',
                      idVal
                    );
                  } else {
                    console.log(
                      '[azureDevOpsInt][GETWI] _getAuthenticatedIdentity returned no usable identifier'
                    );
                  }
                } else {
                  console.log(
                    '[azureDevOpsInt][GETWI] Could not resolve authenticated identity to replace @Me'
                  );
                }
              }
            } catch (identErr) {
              console.warn(
                '[azureDevOpsInt][GETWI] Failed resolving identity for @Me replacement',
                identErr
              );
            }
            const wiqlEndpoint = '/wit/wiql?api-version=7.0';
            let wiqlResp;
            try {
              wiqlResp = await this.axios.post(wiqlEndpoint, { query: wiqlToSend });
            } catch (err) {
              if (this._isMissingStateCategoryError(err)) {
                console.warn(
                  '[azureDevOpsInt][GETWI] StateCategory unsupported in WIQL. Retrying with legacy state filters.'
                );
                this.preferStateCategory = false;
                const wiqlLegacy = this._buildWIQL(query, false);
                console.log('[azureDevOpsInt][GETWI] Fallback WIQL:', wiqlLegacy);
                let legacyToSend = wiqlLegacy;
                try {
                  if (/@Me\b/i.test(wiqlLegacy)) {
                    const resolved2 = await this._getAuthenticatedIdentity();
                    if (resolved2) {
                      const idVal2 = resolved2.uniqueName || resolved2.displayName || resolved2.id;
                      if (idVal2) {
                        legacyToSend = wiqlLegacy.replace(
                          /@Me\b/g,
                          `'${this._escapeWIQL(String(idVal2))}'`
                        );
                        console.log(
                          '[azureDevOpsInt][GETWI] Replacing @Me in fallback WIQL with explicit identity:',
                          idVal2
                        );
                      }
                    }
                  }
                } catch (e) {
                  console.warn(
                    '[azureDevOpsInt][GETWI] Identity resolution failed for fallback WIQL',
                    e
                  );
                }
                wiqlResp = await this.axios.post(wiqlEndpoint, { query: legacyToSend });
                wiql = wiqlLegacy;
              } else {
                throw err;
              }
            }
            console.log('[azureDevOpsInt][GETWI] WIQL response status:', wiqlResp.status);
            try {
              const bodySnippet = JSON.stringify(wiqlResp.data).slice(0, 2e3);
              console.log(
                '[azureDevOpsInt][GETWI][DEBUG] WIQL response body (truncated):',
                bodySnippet
              );
            } catch {}
            let refs = wiqlResp.data?.workItems || [];
            console.log(`[azureDevOpsInt][GETWI] WIQL reference count: ${refs.length}`);
            if (needsLimit && refs.length > 100) {
              refs = refs.slice(0, 100);
              console.log(
                `[azureDevOpsInt][GETWI] Applied client-side limit, reduced to ${refs.length} items`
              );
            }
            if (refs.length === 0) {
              console.log(
                '[azureDevOpsInt][GETWI] No work items matched query. Trying simpler query...'
              );
              const simpleWiql =
                'SELECT [System.Id], [System.Title] FROM WorkItems ORDER BY [System.Id] DESC';
              const simpleResp = await this.axios.post('/wit/wiql?api-version=7.0', {
                query: simpleWiql,
              });
              try {
                const simpleSnippet = JSON.stringify(simpleResp.data).slice(0, 1500);
                console.log(
                  '[azureDevOpsInt][GETWI][DEBUG] simpleWIQL response body (truncated):',
                  simpleSnippet
                );
              } catch {}
              const simpleRefs = simpleResp.data?.workItems || [];
              console.log(
                `[azureDevOpsInt][GETWI] Simple query returned ${simpleRefs.length} work items`
              );
              if (simpleRefs.length === 0) {
                console.log('[azureDevOpsInt][GETWI] No work items in project at all.');
              } else {
                console.log(
                  '[azureDevOpsInt][GETWI] Work items exist, but original query has no matches.'
                );
              }
              return [];
            }
            const ids = refs.map((w) => w.id).join(',');
            console.log('[azureDevOpsInt][GETWI] Expanding IDs:', ids);
            const itemsResp = await this.axios.get(
              `/wit/workitems?ids=${ids}&$expand=all&api-version=7.0`
            );
            const rawItems = itemsResp.data?.value || [];
            console.log('[azureDevOpsInt][GETWI] Raw expanded item count:', rawItems.length);
            const items = this._mapRawWorkItems(rawItems);
            console.log(`[azureDevOpsInt][GETWI] Returning ${items.length} mapped work items.`);
            workItemCache.setWorkItems(cacheKey, items);
            return items;
          } catch (err) {
            console.error('[azureDevOpsInt][GETWI][ERROR]', err?.message || err);
            let errorMessage = 'Failed to fetch work items';
            const status = err?.response?.status;
            if (status === 401 || status === 403) {
              errorMessage = `Authentication failed (${status}). Please check:
\u2022 Your Personal Access Token (PAT) is valid and not expired
\u2022 The PAT has "Work Items (Read)" permission
\u2022 You have access to this project`;
            } else if (status === 404) {
              console.log('[azureDevOpsInt][GETWI] 404 Not Found', {
                organization: this.organization,
                project: this.project,
                authType: this.authType,
                url: err?.request?.url || err?.config?.url,
              });
              errorMessage = `Project not found (404). Please verify:
\u2022 Organization: "${this.organization}"
\u2022 Project: "${this.project}"
\u2022 The project name matches exactly (case-sensitive)`;
            } else if (status === 400) {
              const apiError = err?.response?.data?.message || err?.response?.data?.value?.Message;
              if (apiError) {
                errorMessage = `Invalid query (400): ${apiError}`;
              } else {
                errorMessage = `Invalid query (400). The WIQL query may contain unsupported fields or syntax for this project.
Query name: "${query}"`;
              }
              console.error('[azureDevOpsInt][GETWI][ERROR] WIQL that failed:', wiqlToSend || wiql);
            } else if (status >= 500) {
              errorMessage = `Azure DevOps server error (${status}). The service may be temporarily unavailable.`;
            } else if (err?.code === 'ENOTFOUND' || err?.code === 'ECONNREFUSED') {
              errorMessage = `Network error: Cannot reach Azure DevOps.
\u2022 Check your internet connection
\u2022 Verify your base URL is correct
\u2022 Current URL: ${this.axios.defaults.baseURL}`;
            } else if (err?.message) {
              errorMessage = `${errorMessage}: ${err.message}`;
            }
            if (err?.response) {
              console.error('[azureDevOpsInt][GETWI][ERROR] HTTP status:', status);
              try {
                console.error(
                  '[azureDevOpsInt][GETWI][ERROR] Response data:',
                  JSON.stringify(err.response.data).slice(0, 600)
                );
              } catch {}
            }
            throw new Error(errorMessage);
          }
        });
      }
      _isMissingStateCategoryError(err) {
        const status = err?.response?.status;
        const bodyMessage = String(
          err?.response?.data?.message || err?.response?.data || err?.message || ''
        );
        if (status === 400 && /statecategory/i.test(bodyMessage)) return true;
        if (
          status === 400 &&
          /\bSystem\.State\b/i.test(bodyMessage) &&
          /not found|unknown|does not exist|is not valid/i.test(bodyMessage)
        )
          return true;
        return false;
      }
      async getWorkItemById(id) {
        try {
          const resp = await this.axios.get(`/wit/workitems/${id}?$expand=all&api-version=7.0`);
          return { id: resp.data.id, fields: resp.data.fields };
        } catch (err) {
          console.error('Error fetching work item by id:', err);
          return null;
        }
      }
      async runWIQL(wiql) {
        try {
          const wiqlResp = await this.axios.post('/wit/wiql?api-version=7.0', { query: wiql });
          if (!wiqlResp.data.workItems || wiqlResp.data.workItems.length === 0) return [];
          const ids = wiqlResp.data.workItems.map((w) => w.id).join(',');
          const itemsResp = await this.axios.get(
            `/wit/workitems?ids=${ids}&$expand=all&api-version=7.0`
          );
          const raw = itemsResp.data.value || [];
          return raw.map((r) => ({ id: r.id, fields: r.fields }));
        } catch (err) {
          console.error('runWIQL failed:', err);
          return [];
        }
      }
      async searchWorkItems(term) {
        if (!term?.trim()) return [];
        const safe = this._escapeWIQL(term.trim());
        const wiql = `SELECT [System.Id], [System.Title], [System.State] FROM WorkItems 
                 WHERE [System.Title] CONTAINS '${safe}' OR [System.Id] = '${safe}'
                 ORDER BY [System.ChangedDate] DESC`;
        return this.runWIQL(wiql);
      }
      async filterWorkItems(filter2) {
        const base =
          'SELECT [System.Id], [System.Title], [System.State], [System.WorkItemType], [System.AssignedTo], [System.IterationPath] FROM WorkItems WHERE ';
        const clauses = [];
        if (filter2?.sprint && filter2.sprint !== 'All') {
          if (filter2.sprint === '@CurrentIteration')
            clauses.push('[System.IterationPath] UNDER @CurrentIteration');
          else clauses.push(`[System.IterationPath] = '${this._escapeWIQL(filter2.sprint)}'`);
        }
        if (filter2?.includeState)
          clauses.push(`[System.State] = '${this._escapeWIQL(filter2.includeState)}'`);
        else if (Array.isArray(filter2?.excludeStates) && filter2.excludeStates.length) {
          filter2.excludeStates.forEach((st) =>
            clauses.push(`[System.State] <> '${this._escapeWIQL(st)}'`)
          );
        }
        if (filter2?.type && filter2.type !== 'All')
          clauses.push(`[System.WorkItemType] = '${this._escapeWIQL(filter2.type)}'`);
        if (filter2?.assignedTo === 'Me') clauses.push('[System.AssignedTo] = @Me');
        else if (filter2?.assignedTo === 'Unassigned') clauses.push('[System.AssignedTo] = ""');
        if (clauses.length === 0) clauses.push('[System.State] <> "Removed"');
        const wiql = base + clauses.join(' AND ') + ' ORDER BY [System.ChangedDate] DESC';
        return this.runWIQL(wiql);
      }
      async createWorkItem(type, title, description, assignedTo, extraFields) {
        console.log('[AzureClient] \u{1F50D} Creating work item:', {
          type,
          title: title.substring(0, 50) + '...',
        });
        const patch = [{ op: 'add', path: '/fields/System.Title', value: title }];
        if (description)
          patch.push({ op: 'add', path: '/fields/System.Description', value: description });
        if (assignedTo)
          patch.push({ op: 'add', path: '/fields/System.AssignedTo', value: assignedTo });
        if (extraFields && typeof extraFields === 'object') {
          for (const [field, value] of Object.entries(extraFields)) {
            if (value === void 0 || value === null || value === '') continue;
            patch.push({ op: 'add', path: `/fields/${field}`, value });
          }
        }
        try {
          const resp = await this.axios.post(`/wit/workitems/$${type}?api-version=7.0`, patch, {
            headers: { 'Content-Type': 'application/json-patch+json' },
          });
          console.log('[AzureClient] \u2705 Work item created successfully!');
          console.log(`[AzureClient] \u{1F4CB} Work Item ID: ${resp.data.id}`);
          console.log(
            `[AzureClient] \u{1F511} This confirms your authentication has work item WRITE permissions`
          );
          console.log(
            `[AzureClient] \u{1F3AF} Required permission: vso.work_write (for PAT) or equivalent scope (for OAuth)`
          );
          return { id: resp.data.id, fields: resp.data.fields };
        } catch (error) {
          console.error(
            '[AzureClient] \u274C Work item creation failed:',
            error.response?.status,
            error.response?.statusText
          );
          if (error.response?.status === 403) {
            console.error(
              '[AzureClient] \u{1F6AB} Permission denied - your authentication lacks work item write permissions'
            );
            console.error('[AzureClient] \u{1F4A1} Check your PAT scopes or Azure AD permissions');
          }
          throw error;
        }
      }
      async updateWorkItem(id, patchOps) {
        const resp = await this.axios.patch(`/wit/workitems/${id}?api-version=7.0`, patchOps, {
          headers: { 'Content-Type': 'application/json-patch+json' },
        });
        return { id: resp.data.id, fields: resp.data.fields };
      }
      async addWorkItemComment(id, text2) {
        const resp = await this.axios.post(
          `/wit/workitems/${id}/comments?api-version=7.0-preview.3`,
          {
            text: text2,
          }
        );
        return resp.data;
      }
      async addTimeEntry(id, hours, note) {
        if (typeof hours !== 'number' || hours <= 0)
          throw new Error('hours must be positive number');
        const patch = [
          { op: 'add', path: '/fields/Microsoft.VSTS.Scheduling.CompletedWork', value: hours },
        ];
        await this.updateWorkItem(id, patch);
        if (note) await this.addWorkItemComment(id, `Time tracked: ${hours} hours. ${note}`);
      }
      async getWorkItemTypes() {
        try {
          const resp = await this.axios.get(`/wit/workitemtypes?api-version=7.0`);
          return resp.data.value || [];
        } catch (e) {
          console.error('Error fetching work item types:', e);
          return [];
        }
      }
      async getWorkItemTypeStates(workItemType) {
        try {
          const resp = await this.axios.get(
            `/wit/workitemtypes/${encodeURIComponent(workItemType)}?api-version=7.0`
          );
          const states = resp.data.states || [];
          return states.map((state2) => state2.name || state2);
        } catch (e) {
          console.error(`Error fetching states for work item type ${workItemType}:`, e);
          return [];
        }
      }
      async getIterations() {
        try {
          const url2 = this.buildTeamApiUrl('/work/teamsettings/iterations?api-version=7.0');
          const resp = await this.axios.get(url2);
          return resp.data.value || [];
        } catch (err) {
          console.error('Error fetching iterations:', err);
          return [];
        }
      }
      async getCurrentIteration() {
        return await measureAsync('getCurrentIteration', async () => {
          try {
            const cacheKey = WorkItemCache.generateMetadataKey(
              `${this.organization}-${this.project}`,
              `currentIteration-${this.team || 'default'}`
            );
            const cached = workItemCache.get(cacheKey);
            if (cached) {
              return cached;
            }
            const url2 = this.buildTeamApiUrl(
              '/work/teamsettings/iterations?$timeframe=current&api-version=7.0'
            );
            const resp = await this.axios.get(url2);
            const result = resp.data.value?.[0] || null;
            workItemCache.setMetadata(cacheKey, result);
            return result;
          } catch (err) {
            console.error('Error fetching current iteration:', err);
            return null;
          }
        });
      }
      _escapeWIQL(value) {
        return String(value).replace(/'/g, "''");
      }
      // ---------------- Git & PR Helpers ----------------
      async getTeams() {
        return await measureAsync('getTeams', async () => {
          try {
            const cacheKey = WorkItemCache.generateMetadataKey(
              `${this.organization}-${this.project}`,
              'teams'
            );
            const cached = workItemCache.get(cacheKey);
            if (cached) {
              return cached;
            }
            const orgTeamsUrl =
              this.baseUrl.replace(/\/$/, '') +
              `/_apis/projects/${this.encodedProject}/teams?api-version=7.0`;
            const resp = await this.axios.get(orgTeamsUrl);
            const result = resp.data?.value || [];
            workItemCache.setMetadata(cacheKey, result);
            return result;
          } catch (e) {
            console.error('Error fetching teams', e);
            return [];
          }
        });
      }
      async getRepositories(force = false) {
        return await measureAsync('getRepositories', async () => {
          if (this._repoCache && !force) return this._repoCache;
          const cacheKey = WorkItemCache.generateMetadataKey(
            `${this.organization}-${this.project}`,
            'repositories'
          );
          if (!force) {
            const cached = workItemCache.get(cacheKey);
            if (cached) {
              this._repoCache = cached;
              return cached;
            }
          }
          try {
            const resp = await this.axios.get(`/git/repositories`);
            this._repoCache = resp.data.value || [];
            workItemCache.setMetadata(cacheKey, this._repoCache);
            return this._repoCache;
          } catch (e) {
            console.error('Error fetching repositories', e);
            return [];
          }
        });
      }
      async getDefaultRepository() {
        const repos = await this.getRepositories();
        return Array.isArray(repos) ? repos[0] : void 0;
      }
      async getPullRequests(repositoryId, status = 'active') {
        try {
          const resp = await this.axios.get(`/git/pullrequests`, {
            params: {
              'searchCriteria.repositoryId': repositoryId,
              'searchCriteria.status': status,
            },
          });
          const prs = resp.data.value || [];
          return prs.map((pr) => ({
            id: pr.pullRequestId,
            title: pr.title,
            status: pr.status,
            createdBy: pr.createdBy?.displayName,
            sourceRefName: pr.sourceRefName,
            targetRefName: pr.targetRefName,
            repository: pr.repository?.name,
            webUrl:
              pr._links?.web?.href ||
              this.getBrowserUrl(
                `/_git/${encodeURIComponent(pr.repository?.name)}/pullrequest/${pr.pullRequestId}`
              ),
          }));
        } catch (e) {
          console.error('Error fetching pull requests', e);
          return [];
        }
      }
      /**
       * Fetch pull requests across all repositories in the project, filtered by creator or reviewer = current user.
       * Merges results for authored and reviewing PRs to emulate an OR filter. Duplicates are de-duplicated by PR id.
       */
      async getMyPullRequestsAcrossRepos(status = 'active') {
        const me = await this.getAuthenticatedUserId();
        if (!me) {
          console.warn(
            '[azureDevOpsInt] Could not determine authenticated user id; returning empty PR list'
          );
          return [];
        }
        try {
          const [authoredResp, reviewingResp] = await Promise.all([
            this.axios.get(`/git/pullrequests`, {
              params: { 'searchCriteria.creatorId': me, 'searchCriteria.status': status },
            }),
            this.axios.get(`/git/pullrequests`, {
              params: { 'searchCriteria.reviewerId': me, 'searchCriteria.status': status },
            }),
          ]);
          const authored = authoredResp.data?.value || [];
          const reviewing = reviewingResp.data?.value || [];
          const combined = [...authored, ...reviewing];
          const seen = /* @__PURE__ */ new Set();
          const mapped = combined
            .filter((pr) => pr && typeof pr.pullRequestId === 'number')
            .filter((pr) => {
              if (seen.has(pr.pullRequestId)) return false;
              seen.add(pr.pullRequestId);
              return true;
            })
            .map((pr) => ({
              id: pr.pullRequestId,
              title: pr.title,
              status: pr.status,
              createdBy: pr.createdBy?.displayName,
              sourceRefName: pr.sourceRefName,
              targetRefName: pr.targetRefName,
              repository: pr.repository?.name,
              webUrl:
                pr._links?.web?.href ||
                this.getBrowserUrl(
                  `/_git/${encodeURIComponent(pr.repository?.name)}/pullrequest/${pr.pullRequestId}`
                ),
              createdDate: pr.creationDate,
            }));
          mapped.sort((a, b) => {
            const at = a.createdDate ? new Date(a.createdDate).getTime() : 0;
            const bt = b.createdDate ? new Date(b.createdDate).getTime() : 0;
            return bt - at;
          });
          return mapped;
        } catch (e) {
          console.error('Error fetching my pull requests across repos', e);
          return [];
        }
      }
      async createPullRequest(repositoryId, sourceRefName, targetRefName, title, description) {
        try {
          const payload = { sourceRefName, targetRefName, title };
          if (description) payload.description = description;
          const resp = await this.axios.post(
            `/git/repositories/${repositoryId}/pullrequests?api-version=7.0`,
            payload
          );
          return resp.data;
        } catch (e) {
          console.error('Error creating pull request', e);
          throw e;
        }
      }
      // ---------------- Build Helpers ----------------
      async getRecentBuilds(options = {}) {
        const {
          top = 10,
          branchName,
          repositoryId,
          definitions,
          resultFilter,
          statusFilter,
        } = options;
        try {
          const params = {
            $top: top,
            queryOrder: 'finishTimeDescending',
            'api-version': '7.0',
          };
          if (branchName) params.branchName = branchName;
          if (repositoryId) params.repositoryId = repositoryId;
          if (definitions !== void 0) {
            params.definitions = Array.isArray(definitions) ? definitions.join(',') : definitions;
          }
          if (resultFilter) params.resultFilter = resultFilter;
          if (statusFilter) params.statusFilter = statusFilter;
          const resp = await this.axios.get(`/build/builds`, { params });
          const values = Array.isArray(resp.data?.value) ? resp.data.value : [];
          return values.map((b) => ({
            id: b.id,
            buildNumber: b.buildNumber,
            status: b.status,
            result: b.result,
            definition: b.definition?.name,
            queueTime: b.queueTime,
            finishTime: b.finishTime,
            webUrl: b._links?.web?.href,
          }));
        } catch (e) {
          console.error('Error fetching builds', e);
          return [];
        }
      }
    };
    AzureDevOpsClient = AzureDevOpsIntClient;
  },
});

// src/azureClient.js
var azureClient_exports = {};
__export(azureClient_exports, {
  AzureDevOpsClient: () => AzureDevOpsClient,
  AzureDevOpsIntClient: () => AzureDevOpsIntClient,
});
var init_azureClient2 = __esm({
  'src/azureClient.js'() {
    'use strict';
    init_azureClient();
  },
});

// src/provider.ts
function isProviderOptions(value) {
  return value && typeof value === 'object' && !Array.isArray(value);
}
var DEFAULT_QUERY, WorkItemsProvider;
var init_provider = __esm({
  'src/provider.ts'() {
    'use strict';
    DEFAULT_QUERY = 'My Activity';
    WorkItemsProvider = class {
      connectionId;
      client;
      postMessage;
      logger;
      debounceMs = 2e3;
      _workItems = [];
      _selectedWorkItem;
      _kanbanView = false;
      _currentFilters = {};
      _refreshInFlight = false;
      _lastRefreshTs = 0;
      _workItemTypes = [];
      _currentQuery = DEFAULT_QUERY;
      transformWorkItemsFn;
      constructor(connectionOrClient, clientOrPostMessage, postMessageOrOptions, maybeOptions) {
        if (typeof connectionOrClient === 'string') {
          this.connectionId = connectionOrClient;
          this.client = clientOrPostMessage;
          this.postMessage =
            (typeof postMessageOrOptions === 'function' ? postMessageOrOptions : void 0) ||
            (() => {});
          this.applyOptions(maybeOptions ?? {});
        } else {
          this.connectionId = 'default';
          this.client = connectionOrClient;
          this.postMessage =
            (typeof clientOrPostMessage === 'function' ? clientOrPostMessage : void 0) ||
            (() => {});
          this.applyOptions(isProviderOptions(postMessageOrOptions) ? postMessageOrOptions : {});
        }
      }
      applyOptions(options) {
        this._kanbanView = options.kanbanView ?? this._kanbanView;
        this._currentFilters = options.currentFilters ?? this._currentFilters;
        this.logger = options.logger ?? this.logger;
        if (typeof options.debounceMs === 'number' && options.debounceMs >= 0) {
          this.debounceMs = options.debounceMs;
        }
        this.transformWorkItemsFn = options.transformWorkItems ?? this.transformWorkItemsFn;
      }
      updateClient(nextClient) {
        this.client = nextClient;
        this._workItemTypes = [];
      }
      setPostMessage(nextPostMessage) {
        this.postMessage = nextPostMessage || (() => {});
      }
      setLogger(nextLogger) {
        this.logger = nextLogger;
      }
      setTransformWorkItems(nextTransform) {
        this.transformWorkItemsFn = nextTransform;
      }
      getConnectionId() {
        return this.connectionId;
      }
      async refresh(query) {
        if (!this.client || typeof this.client.getWorkItems !== 'function') {
          this.log('warn', 'Cannot refresh work items; client missing getWorkItems');
          return;
        }
        const now = Date.now();
        if (now - this._lastRefreshTs < this.debounceMs) {
          return;
        }
        if (this._refreshInFlight) {
          return;
        }
        this._refreshInFlight = true;
        const normalizedQuery =
          typeof query === 'string' && query.trim().length > 0
            ? query.trim()
            : this._currentQuery || DEFAULT_QUERY;
        this._currentQuery = normalizedQuery;
        this._post({
          type: 'workItemsLoading',
          query: normalizedQuery,
        });
        try {
          const shouldFetchTypes =
            this._workItemTypes.length === 0 && typeof this.client.getWorkItemTypes === 'function';
          const typePromise = shouldFetchTypes
            ? Promise.resolve()
                .then(() => this.client.getWorkItemTypes())
                .catch((err) => {
                  this.log('warn', 'Failed to fetch work item types', {
                    connectionId: this.connectionId,
                    error: err?.message || String(err),
                  });
                  return null;
                })
            : null;
          this.log('debug', 'refresh(): starting fetch', {
            connectionId: this.connectionId,
            query: normalizedQuery,
          });
          const fetched = await this.client.getWorkItems(normalizedQuery);
          const processed = await this._applyTransform(fetched);
          this.log('info', 'refresh(): completed fetch', {
            connectionId: this.connectionId,
            count: Array.isArray(processed) ? processed.length : 'n/a',
          });
          if (typePromise) {
            try {
              const rawTypes = await typePromise;
              if (Array.isArray(rawTypes) && rawTypes.length > 0) {
                this._mergeWorkItemTypesFromNames(this._normalizeTypeNames(rawTypes));
              }
            } catch {}
          }
          this._workItems = processed;
          this._mergeWorkItemTypesFromItems(processed);
          this._notifyWorkItemsChanged();
          if (processed.length === 0) {
            this.log('debug', 'refresh(): no results for query', {
              connectionId: this.connectionId,
              query: normalizedQuery,
            });
          }
        } catch (err) {
          const errorMessage = err?.message || String(err);
          this.log('error', 'Failed to refresh work items', {
            connectionId: this.connectionId,
            query: normalizedQuery,
            error: errorMessage,
            stack: err?.stack,
          });
          this._error(errorMessage);
          console.error('[WorkItemsProvider] Refresh failed:', {
            connectionId: this.connectionId,
            query: normalizedQuery,
            error: errorMessage,
            fullError: err,
          });
        } finally {
          this._refreshInFlight = false;
          this._lastRefreshTs = Date.now();
        }
      }
      async getWorkItemById(id) {
        if (!this.client) return null;
        return this.client.getWorkItemById(id);
      }
      async createWorkItem(type, title, description, assignedTo, extraFields) {
        if (!this.client || typeof this.client.createWorkItem !== 'function') {
          throw new Error('No client');
        }
        const created = await this.client.createWorkItem(
          type,
          title,
          description,
          assignedTo,
          extraFields
        );
        await this.refresh();
        return created;
      }
      async updateWorkItem(id, patchOps) {
        if (!this.client || typeof this.client.updateWorkItem !== 'function') {
          throw new Error('No client');
        }
        const updated = await this.client.updateWorkItem(id, patchOps);
        await this.refresh();
        return updated;
      }
      async addWorkItemComment(id, text2) {
        if (!this.client || typeof this.client.addWorkItemComment !== 'function') {
          throw new Error('No client');
        }
        return this.client.addWorkItemComment(id, text2);
      }
      async addTimeEntry(id, hours, note) {
        if (!this.client || typeof this.client.addTimeEntry !== 'function') {
          throw new Error('No client');
        }
        await this.client.addTimeEntry(id, hours, note);
        await this.refresh();
      }
      async search(term) {
        if (!this.client || typeof this.client.searchWorkItems !== 'function') {
          this.log('warn', 'search() skipped; client missing searchWorkItems');
          return [];
        }
        const res = await this.client.searchWorkItems(term);
        await this.showWorkItems(res);
        return res;
      }
      async filter(filterObj) {
        if (!this.client || typeof this.client.filterWorkItems !== 'function') {
          this.log('warn', 'filter() skipped; client missing filterWorkItems');
          return [];
        }
        const res = await this.client.filterWorkItems(filterObj);
        await this.showWorkItems(res);
        return res;
      }
      async runWIQL(wiql) {
        if (!this.client || typeof this.client.runWIQL !== 'function') {
          this.log('warn', 'runWIQL() skipped; client missing runWIQL');
          return [];
        }
        return this.client.runWIQL(wiql);
      }
      async showWorkItems(items) {
        if (!Array.isArray(items)) return;
        const processed = await this._applyTransform(items);
        const shouldIgnoreEmpty = processed.length === 0 && this._workItems.length > 0;
        if (!shouldIgnoreEmpty) {
          this._workItems = processed;
        }
        this._mergeWorkItemTypesFromItems(shouldIgnoreEmpty ? this._workItems : processed);
        this._notifyWorkItemsChanged();
      }
      selectWorkItem(item) {
        this._selectedWorkItem = item;
        this._post({ type: 'workItemSelected', workItem: item });
      }
      getSelectedWorkItem() {
        return this._selectedWorkItem;
      }
      getWorkItems() {
        return [...this._workItems];
      }
      dispose() {
        this._workItems = [];
        this._selectedWorkItem = void 0;
        this._currentFilters = {};
        this._workItemTypes = [];
      }
      _notifyWorkItemsChanged() {
        this._post({
          type: 'workItemsLoaded',
          workItems: [...this._workItems],
          connectionId: this.connectionId,
          query: this._currentQuery,
          kanbanView: this._kanbanView,
          types: [...this._workItemTypes],
        });
        this._postWorkItemTypeOptions();
        if (Object.keys(this._currentFilters).length > 0)
          this._post({ type: 'restoreFilters', filters: this._currentFilters });
      }
      _post(msg) {
        if (!this.postMessage) return;
        if (msg && typeof msg === 'object' && !Array.isArray(msg)) {
          this.postMessage({ connectionId: this.connectionId, ...msg });
        } else {
          this.postMessage(msg);
        }
      }
      _error(message) {
        this._post({ type: 'workItemsError', error: message });
      }
      log(level, message, meta) {
        if (!this.logger) return;
        const fn = this.logger[level];
        if (typeof fn === 'function') {
          try {
            fn(message, meta);
          } catch {}
        }
      }
      getWorkItemTypeOptions() {
        return [...this._workItemTypes];
      }
      _normalizeTypeNames(rawTypes) {
        if (!Array.isArray(rawTypes)) return [];
        return rawTypes
          .map((entry) => {
            if (!entry) return '';
            if (typeof entry === 'string') return entry.trim();
            if (typeof entry.name === 'string') return entry.name.trim();
            if (typeof entry.text === 'string') return entry.text.trim();
            if (typeof entry.referenceName === 'string') return entry.referenceName.trim();
            return '';
          })
          .filter((name3) => name3.length > 0);
      }
      _mergeWorkItemTypesFromNames(names) {
        if (!Array.isArray(names) || names.length === 0) return;
        const current = new Set(this._workItemTypes);
        let changed = false;
        for (const raw of names) {
          const value = typeof raw === 'string' ? raw.trim() : '';
          if (!value) continue;
          if (!current.has(value)) {
            current.add(value);
            changed = true;
          }
        }
        if (changed) {
          this._workItemTypes = Array.from(current).sort((a, b) => a.localeCompare(b));
        }
      }
      _mergeWorkItemTypesFromItems(items) {
        if (!Array.isArray(items) || items.length === 0) return;
        const names = items
          .map((item) => {
            const fromFlattened = typeof item?.type === 'string' ? item.type : void 0;
            const fromFields =
              typeof item?.fields?.['System.WorkItemType'] === 'string'
                ? item.fields['System.WorkItemType']
                : void 0;
            const value = fromFlattened || fromFields;
            return typeof value === 'string' ? value.trim() : '';
          })
          .filter((name3) => name3.length > 0);
        this._mergeWorkItemTypesFromNames(names);
      }
      _postWorkItemTypeOptions() {
        this._post({ type: 'workItemTypeOptions', types: [...this._workItemTypes] });
      }
      async _applyTransform(items) {
        if (!Array.isArray(items)) return [];
        if (!this.transformWorkItemsFn) return [...items];
        try {
          const result = await this.transformWorkItemsFn({
            items: [...items],
            connectionId: this.connectionId,
          });
          if (Array.isArray(result)) {
            return result;
          }
        } catch (error) {
          this.log('warn', 'transformWorkItems failed', {
            connectionId: this.connectionId,
            error: error?.message || String(error),
          });
        }
        return [...items];
      }
    };
  },
});

// src/provider.js
var provider_exports = {};
__export(provider_exports, {
  WorkItemsProvider: () => WorkItemsProvider,
});
var init_provider2 = __esm({
  'src/provider.js'() {
    'use strict';
    init_provider();
  },
});

// node_modules/sql.js/dist/sql-wasm.js
var require_sql_wasm = __commonJS({
  'node_modules/sql.js/dist/sql-wasm.js'(exports, module) {
    var initSqlJsPromise = void 0;
    var initSqlJs = function (moduleConfig) {
      if (initSqlJsPromise) {
        return initSqlJsPromise;
      }
      initSqlJsPromise = new Promise(function (resolveModule, reject) {
        var Module = typeof moduleConfig !== 'undefined' ? moduleConfig : {};
        var originalOnAbortFunction = Module['onAbort'];
        Module['onAbort'] = function (errorThatCausedAbort) {
          reject(new Error(errorThatCausedAbort));
          if (originalOnAbortFunction) {
            originalOnAbortFunction(errorThatCausedAbort);
          }
        };
        Module['postRun'] = Module['postRun'] || [];
        Module['postRun'].push(function () {
          resolveModule(Module);
        });
        module = void 0;
        var f;
        f ||= typeof Module != 'undefined' ? Module : {};
        var aa = 'object' == typeof window,
          ba = 'undefined' != typeof WorkerGlobalScope,
          ca =
            'object' == typeof process &&
            'object' == typeof process.versions &&
            'string' == typeof process.versions.node &&
            'renderer' != process.type;
        ('use strict');
        f.onRuntimeInitialized = function () {
          function a(g, l) {
            switch (typeof l) {
              case 'boolean':
                dc(g, l ? 1 : 0);
                break;
              case 'number':
                ec(g, l);
                break;
              case 'string':
                fc(g, l, -1, -1);
                break;
              case 'object':
                if (null === l) lb(g);
                else if (null != l.length) {
                  var n = da(l, ea);
                  gc(g, n, l.length, -1);
                  fa(n);
                } else
                  va(
                    g,
                    'Wrong API use : tried to return a value of an unknown type (' + l + ').',
                    -1
                  );
                break;
              default:
                lb(g);
            }
          }
          function b(g, l) {
            for (var n = [], r = 0; r < g; r += 1) {
              var t = m(l + 4 * r, 'i32'),
                y = hc(t);
              if (1 === y || 2 === y) t = ic(t);
              else if (3 === y) t = jc(t);
              else if (4 === y) {
                y = t;
                t = kc(y);
                y = lc(y);
                for (var L = new Uint8Array(t), J = 0; J < t; J += 1) L[J] = p[y + J];
                t = L;
              } else t = null;
              n.push(t);
            }
            return n;
          }
          function c(g, l) {
            this.Qa = g;
            this.db = l;
            this.Oa = 1;
            this.lb = [];
          }
          function d(g, l) {
            this.db = l;
            l = ha(g) + 1;
            this.eb = ia(l);
            if (null === this.eb) throw Error('Unable to allocate memory for the SQL string');
            u(g, x, this.eb, l);
            this.kb = this.eb;
            this.Za = this.pb = null;
          }
          function e(g) {
            this.filename = 'dbfile_' + ((4294967295 * Math.random()) >>> 0);
            if (null != g) {
              var l = this.filename,
                n = '/',
                r = l;
              n && ((n = 'string' == typeof n ? n : ja(n)), (r = l ? ka(n + '/' + l) : n));
              l = la(true, true);
              r = ma(r, l);
              if (g) {
                if ('string' == typeof g) {
                  n = Array(g.length);
                  for (var t = 0, y = g.length; t < y; ++t) n[t] = g.charCodeAt(t);
                  g = n;
                }
                na(r, l | 146);
                n = oa(r, 577);
                pa(n, g, 0, g.length, 0);
                qa(n);
                na(r, l);
              }
            }
            this.handleError(q(this.filename, h));
            this.db = m(h, 'i32');
            ob(this.db);
            this.fb = {};
            this.Sa = {};
          }
          var h = z(4),
            k = f.cwrap,
            q = k('sqlite3_open', 'number', ['string', 'number']),
            w = k('sqlite3_close_v2', 'number', ['number']),
            v = k('sqlite3_exec', 'number', ['number', 'string', 'number', 'number', 'number']),
            C = k('sqlite3_changes', 'number', ['number']),
            G = k('sqlite3_prepare_v2', 'number', [
              'number',
              'string',
              'number',
              'number',
              'number',
            ]),
            pb = k('sqlite3_sql', 'string', ['number']),
            nc = k('sqlite3_normalized_sql', 'string', ['number']),
            qb = k('sqlite3_prepare_v2', 'number', [
              'number',
              'number',
              'number',
              'number',
              'number',
            ]),
            oc = k('sqlite3_bind_text', 'number', [
              'number',
              'number',
              'number',
              'number',
              'number',
            ]),
            rb = k('sqlite3_bind_blob', 'number', [
              'number',
              'number',
              'number',
              'number',
              'number',
            ]),
            pc = k('sqlite3_bind_double', 'number', ['number', 'number', 'number']),
            qc = k('sqlite3_bind_int', 'number', ['number', 'number', 'number']),
            rc = k('sqlite3_bind_parameter_index', 'number', ['number', 'string']),
            sc = k('sqlite3_step', 'number', ['number']),
            tc = k('sqlite3_errmsg', 'string', ['number']),
            uc = k('sqlite3_column_count', 'number', ['number']),
            vc = k('sqlite3_data_count', 'number', ['number']),
            wc = k('sqlite3_column_double', 'number', ['number', 'number']),
            sb = k('sqlite3_column_text', 'string', ['number', 'number']),
            xc = k('sqlite3_column_blob', 'number', ['number', 'number']),
            yc = k('sqlite3_column_bytes', 'number', ['number', 'number']),
            zc = k('sqlite3_column_type', 'number', ['number', 'number']),
            Ac = k('sqlite3_column_name', 'string', ['number', 'number']),
            Bc = k('sqlite3_reset', 'number', ['number']),
            Cc = k('sqlite3_clear_bindings', 'number', ['number']),
            Dc = k('sqlite3_finalize', 'number', ['number']),
            tb = k(
              'sqlite3_create_function_v2',
              'number',
              'number string number number number number number number number'.split(' ')
            ),
            hc = k('sqlite3_value_type', 'number', ['number']),
            kc = k('sqlite3_value_bytes', 'number', ['number']),
            jc = k('sqlite3_value_text', 'string', ['number']),
            lc = k('sqlite3_value_blob', 'number', ['number']),
            ic = k('sqlite3_value_double', 'number', ['number']),
            ec = k('sqlite3_result_double', '', ['number', 'number']),
            lb = k('sqlite3_result_null', '', ['number']),
            fc = k('sqlite3_result_text', '', ['number', 'string', 'number', 'number']),
            gc = k('sqlite3_result_blob', '', ['number', 'number', 'number', 'number']),
            dc = k('sqlite3_result_int', '', ['number', 'number']),
            va = k('sqlite3_result_error', '', ['number', 'string', 'number']),
            ub = k('sqlite3_aggregate_context', 'number', ['number', 'number']),
            ob = k('RegisterExtensionFunctions', 'number', ['number']),
            vb = k('sqlite3_update_hook', 'number', ['number', 'number', 'number']);
          c.prototype.bind = function (g) {
            if (!this.Qa) throw 'Statement closed';
            this.reset();
            return Array.isArray(g)
              ? this.Cb(g)
              : null != g && 'object' === typeof g
                ? this.Db(g)
                : true;
          };
          c.prototype.step = function () {
            if (!this.Qa) throw 'Statement closed';
            this.Oa = 1;
            var g = sc(this.Qa);
            switch (g) {
              case 100:
                return true;
              case 101:
                return false;
              default:
                throw this.db.handleError(g);
            }
          };
          c.prototype.wb = function (g) {
            null == g && ((g = this.Oa), (this.Oa += 1));
            return wc(this.Qa, g);
          };
          c.prototype.Gb = function (g) {
            null == g && ((g = this.Oa), (this.Oa += 1));
            g = sb(this.Qa, g);
            if ('function' !== typeof BigInt) throw Error('BigInt is not supported');
            return BigInt(g);
          };
          c.prototype.Hb = function (g) {
            null == g && ((g = this.Oa), (this.Oa += 1));
            return sb(this.Qa, g);
          };
          c.prototype.getBlob = function (g) {
            null == g && ((g = this.Oa), (this.Oa += 1));
            var l = yc(this.Qa, g);
            g = xc(this.Qa, g);
            for (var n = new Uint8Array(l), r = 0; r < l; r += 1) n[r] = p[g + r];
            return n;
          };
          c.prototype.get = function (g, l) {
            l = l || {};
            null != g && this.bind(g) && this.step();
            g = [];
            for (var n = vc(this.Qa), r = 0; r < n; r += 1)
              switch (zc(this.Qa, r)) {
                case 1:
                  var t = l.useBigInt ? this.Gb(r) : this.wb(r);
                  g.push(t);
                  break;
                case 2:
                  g.push(this.wb(r));
                  break;
                case 3:
                  g.push(this.Hb(r));
                  break;
                case 4:
                  g.push(this.getBlob(r));
                  break;
                default:
                  g.push(null);
              }
            return g;
          };
          c.prototype.getColumnNames = function () {
            for (var g = [], l = uc(this.Qa), n = 0; n < l; n += 1) g.push(Ac(this.Qa, n));
            return g;
          };
          c.prototype.getAsObject = function (g, l) {
            g = this.get(g, l);
            l = this.getColumnNames();
            for (var n = {}, r = 0; r < l.length; r += 1) n[l[r]] = g[r];
            return n;
          };
          c.prototype.getSQL = function () {
            return pb(this.Qa);
          };
          c.prototype.getNormalizedSQL = function () {
            return nc(this.Qa);
          };
          c.prototype.run = function (g) {
            null != g && this.bind(g);
            this.step();
            return this.reset();
          };
          c.prototype.sb = function (g, l) {
            null == l && ((l = this.Oa), (this.Oa += 1));
            g = ra(g);
            var n = da(g, ea);
            this.lb.push(n);
            this.db.handleError(oc(this.Qa, l, n, g.length - 1, 0));
          };
          c.prototype.Bb = function (g, l) {
            null == l && ((l = this.Oa), (this.Oa += 1));
            var n = da(g, ea);
            this.lb.push(n);
            this.db.handleError(rb(this.Qa, l, n, g.length, 0));
          };
          c.prototype.rb = function (g, l) {
            null == l && ((l = this.Oa), (this.Oa += 1));
            this.db.handleError((g === (g | 0) ? qc : pc)(this.Qa, l, g));
          };
          c.prototype.Eb = function (g) {
            null == g && ((g = this.Oa), (this.Oa += 1));
            rb(this.Qa, g, 0, 0, 0);
          };
          c.prototype.tb = function (g, l) {
            null == l && ((l = this.Oa), (this.Oa += 1));
            switch (typeof g) {
              case 'string':
                this.sb(g, l);
                return;
              case 'number':
                this.rb(g, l);
                return;
              case 'bigint':
                this.sb(g.toString(), l);
                return;
              case 'boolean':
                this.rb(g + 0, l);
                return;
              case 'object':
                if (null === g) {
                  this.Eb(l);
                  return;
                }
                if (null != g.length) {
                  this.Bb(g, l);
                  return;
                }
            }
            throw 'Wrong API use : tried to bind a value of an unknown type (' + g + ').';
          };
          c.prototype.Db = function (g) {
            var l = this;
            Object.keys(g).forEach(function (n) {
              var r = rc(l.Qa, n);
              0 !== r && l.tb(g[n], r);
            });
            return true;
          };
          c.prototype.Cb = function (g) {
            for (var l = 0; l < g.length; l += 1) this.tb(g[l], l + 1);
            return true;
          };
          c.prototype.reset = function () {
            this.freemem();
            return 0 === Cc(this.Qa) && 0 === Bc(this.Qa);
          };
          c.prototype.freemem = function () {
            for (var g; void 0 !== (g = this.lb.pop()); ) fa(g);
          };
          c.prototype.free = function () {
            this.freemem();
            var g = 0 === Dc(this.Qa);
            delete this.db.fb[this.Qa];
            this.Qa = 0;
            return g;
          };
          d.prototype.next = function () {
            if (null === this.eb) return { done: true };
            null !== this.Za && (this.Za.free(), (this.Za = null));
            if (!this.db.db) throw (this.mb(), Error('Database closed'));
            var g = sa(),
              l = z(4);
            ta(h);
            ta(l);
            try {
              this.db.handleError(qb(this.db.db, this.kb, -1, h, l));
              this.kb = m(l, 'i32');
              var n = m(h, 'i32');
              if (0 === n) return (this.mb(), { done: true });
              this.Za = new c(n, this.db);
              this.db.fb[n] = this.Za;
              return { value: this.Za, done: false };
            } catch (r) {
              throw ((this.pb = ua(this.kb)), this.mb(), r);
            } finally {
              wa(g);
            }
          };
          d.prototype.mb = function () {
            fa(this.eb);
            this.eb = null;
          };
          d.prototype.getRemainingSQL = function () {
            return null !== this.pb ? this.pb : ua(this.kb);
          };
          'function' === typeof Symbol &&
            'symbol' === typeof Symbol.iterator &&
            (d.prototype[Symbol.iterator] = function () {
              return this;
            });
          e.prototype.run = function (g, l) {
            if (!this.db) throw 'Database closed';
            if (l) {
              g = this.prepare(g, l);
              try {
                g.step();
              } finally {
                g.free();
              }
            } else this.handleError(v(this.db, g, 0, 0, h));
            return this;
          };
          e.prototype.exec = function (g, l, n) {
            if (!this.db) throw 'Database closed';
            var r = sa(),
              t = null;
            try {
              var y = xa(g),
                L = z(4);
              for (g = []; 0 !== m(y, 'i8'); ) {
                ta(h);
                ta(L);
                this.handleError(qb(this.db, y, -1, h, L));
                var J = m(h, 'i32');
                y = m(L, 'i32');
                if (0 !== J) {
                  var I = null;
                  t = new c(J, this);
                  for (null != l && t.bind(l); t.step(); )
                    (null === I && ((I = { columns: t.getColumnNames(), values: [] }), g.push(I)),
                      I.values.push(t.get(null, n)));
                  t.free();
                }
              }
              return g;
            } catch (M) {
              throw (t && t.free(), M);
            } finally {
              wa(r);
            }
          };
          e.prototype.each = function (g, l, n, r, t) {
            'function' === typeof l && ((r = n), (n = l), (l = void 0));
            g = this.prepare(g, l);
            try {
              for (; g.step(); ) n(g.getAsObject(null, t));
            } finally {
              g.free();
            }
            if ('function' === typeof r) return r();
          };
          e.prototype.prepare = function (g, l) {
            ta(h);
            this.handleError(G(this.db, g, -1, h, 0));
            g = m(h, 'i32');
            if (0 === g) throw 'Nothing to prepare';
            var n = new c(g, this);
            null != l && n.bind(l);
            return (this.fb[g] = n);
          };
          e.prototype.iterateStatements = function (g) {
            return new d(g, this);
          };
          e.prototype['export'] = function () {
            Object.values(this.fb).forEach(function (l) {
              l.free();
            });
            Object.values(this.Sa).forEach(A);
            this.Sa = {};
            this.handleError(w(this.db));
            var g = ya(this.filename);
            this.handleError(q(this.filename, h));
            this.db = m(h, 'i32');
            ob(this.db);
            return g;
          };
          e.prototype.close = function () {
            null !== this.db &&
              (Object.values(this.fb).forEach(function (g) {
                g.free();
              }),
              Object.values(this.Sa).forEach(A),
              (this.Sa = {}),
              this.Ya && (A(this.Ya), (this.Ya = void 0)),
              this.handleError(w(this.db)),
              za('/' + this.filename),
              (this.db = null));
          };
          e.prototype.handleError = function (g) {
            if (0 === g) return null;
            g = tc(this.db);
            throw Error(g);
          };
          e.prototype.getRowsModified = function () {
            return C(this.db);
          };
          e.prototype.create_function = function (g, l) {
            Object.prototype.hasOwnProperty.call(this.Sa, g) && (A(this.Sa[g]), delete this.Sa[g]);
            var n = Aa(function (r, t, y) {
              t = b(t, y);
              try {
                var L = l.apply(null, t);
              } catch (J) {
                va(r, J, -1);
                return;
              }
              a(r, L);
            }, 'viii');
            this.Sa[g] = n;
            this.handleError(tb(this.db, g, l.length, 1, 0, n, 0, 0, 0));
            return this;
          };
          e.prototype.create_aggregate = function (g, l) {
            var n =
                l.init ||
                function () {
                  return null;
                },
              r =
                l.finalize ||
                function (I) {
                  return I;
                },
              t = l.step;
            if (!t) throw 'An aggregate function must have a step function in ' + g;
            var y = {};
            Object.hasOwnProperty.call(this.Sa, g) && (A(this.Sa[g]), delete this.Sa[g]);
            l = g + '__finalize';
            Object.hasOwnProperty.call(this.Sa, l) && (A(this.Sa[l]), delete this.Sa[l]);
            var L = Aa(function (I, M, Ra) {
                var X = ub(I, 1);
                Object.hasOwnProperty.call(y, X) || (y[X] = n());
                M = b(M, Ra);
                M = [y[X]].concat(M);
                try {
                  y[X] = t.apply(null, M);
                } catch (Fc) {
                  (delete y[X], va(I, Fc, -1));
                }
              }, 'viii'),
              J = Aa(function (I) {
                var M = ub(I, 1);
                try {
                  var Ra = r(y[M]);
                } catch (X) {
                  delete y[M];
                  va(I, X, -1);
                  return;
                }
                a(I, Ra);
                delete y[M];
              }, 'vi');
            this.Sa[g] = L;
            this.Sa[l] = J;
            this.handleError(tb(this.db, g, t.length - 1, 1, 0, 0, L, J, 0));
            return this;
          };
          e.prototype.updateHook = function (g) {
            this.Ya && (vb(this.db, 0, 0), A(this.Ya), (this.Ya = void 0));
            g &&
              ((this.Ya = Aa(function (l, n, r, t, y) {
                switch (n) {
                  case 18:
                    l = 'insert';
                    break;
                  case 23:
                    l = 'update';
                    break;
                  case 9:
                    l = 'delete';
                    break;
                  default:
                    throw 'unknown operationCode in updateHook callback: ' + n;
                }
                r = r ? B(x, r) : '';
                t = t ? B(x, t) : '';
                if (y > Number.MAX_SAFE_INTEGER) throw 'rowId too big to fit inside a Number';
                g(l, r, t, Number(y));
              }, 'viiiij')),
              vb(this.db, this.Ya, 0));
          };
          f.Database = e;
        };
        var Ba = { ...f },
          Ca = './this.program',
          Da = (a, b) => {
            throw b;
          },
          D = '',
          Ea,
          Fa;
        if (ca) {
          var fs2 = __require('fs');
          __require('path');
          D = __dirname + '/';
          Fa = (a) => {
            a = Ga(a) ? new URL(a) : a;
            return fs2.readFileSync(a);
          };
          Ea = async (a) => {
            a = Ga(a) ? new URL(a) : a;
            return fs2.readFileSync(a, void 0);
          };
          !f.thisProgram && 1 < process.argv.length && (Ca = process.argv[1].replace(/\\/g, '/'));
          process.argv.slice(2);
          'undefined' != typeof module && (module.exports = f);
          Da = (a, b) => {
            process.exitCode = a;
            throw b;
          };
        } else if (aa || ba)
          (ba
            ? (D = self.location.href)
            : 'undefined' != typeof document &&
              document.currentScript &&
              (D = document.currentScript.src),
            (D = D.startsWith('blob:')
              ? ''
              : D.slice(0, D.replace(/[?#].*/, '').lastIndexOf('/') + 1)),
            ba &&
              (Fa = (a) => {
                var b = new XMLHttpRequest();
                b.open('GET', a, false);
                b.responseType = 'arraybuffer';
                b.send(null);
                return new Uint8Array(b.response);
              }),
            (Ea = async (a) => {
              if (Ga(a))
                return new Promise((c, d) => {
                  var e = new XMLHttpRequest();
                  e.open('GET', a, true);
                  e.responseType = 'arraybuffer';
                  e.onload = () => {
                    200 == e.status || (0 == e.status && e.response) ? c(e.response) : d(e.status);
                  };
                  e.onerror = d;
                  e.send(null);
                });
              var b = await fetch(a, { credentials: 'same-origin' });
              if (b.ok) return b.arrayBuffer();
              throw Error(b.status + ' : ' + b.url);
            }));
        var Ha = f.print || console.log.bind(console),
          Ia = f.printErr || console.error.bind(console);
        Object.assign(f, Ba);
        Ba = null;
        f.thisProgram && (Ca = f.thisProgram);
        var Ja = f.wasmBinary,
          Ka,
          La = false,
          Ma,
          p,
          x,
          Na,
          E,
          F,
          Oa,
          H,
          Pa,
          Ga = (a) => a.startsWith('file://');
        function Qa() {
          var a = Ka.buffer;
          f.HEAP8 = p = new Int8Array(a);
          f.HEAP16 = Na = new Int16Array(a);
          f.HEAPU8 = x = new Uint8Array(a);
          f.HEAPU16 = new Uint16Array(a);
          f.HEAP32 = E = new Int32Array(a);
          f.HEAPU32 = F = new Uint32Array(a);
          f.HEAPF32 = Oa = new Float32Array(a);
          f.HEAPF64 = Pa = new Float64Array(a);
          f.HEAP64 = H = new BigInt64Array(a);
          f.HEAPU64 = new BigUint64Array(a);
        }
        var K = 0,
          Sa = null;
        function Ta(a) {
          f.onAbort?.(a);
          a = 'Aborted(' + a + ')';
          Ia(a);
          La = true;
          throw new WebAssembly.RuntimeError(a + '. Build with -sASSERTIONS for more info.');
        }
        var Ua;
        async function Va(a) {
          if (!Ja)
            try {
              var b = await Ea(a);
              return new Uint8Array(b);
            } catch {}
          if (a == Ua && Ja) a = new Uint8Array(Ja);
          else if (Fa) a = Fa(a);
          else throw 'both async and sync fetching of the wasm failed';
          return a;
        }
        async function Wa(a, b) {
          try {
            var c = await Va(a);
            return await WebAssembly.instantiate(c, b);
          } catch (d) {
            (Ia(`failed to asynchronously prepare wasm: ${d}`), Ta(d));
          }
        }
        async function Xa(a) {
          var b = Ua;
          if (!Ja && 'function' == typeof WebAssembly.instantiateStreaming && !Ga(b) && !ca)
            try {
              var c = fetch(b, { credentials: 'same-origin' });
              return await WebAssembly.instantiateStreaming(c, a);
            } catch (d) {
              (Ia(`wasm streaming compile failed: ${d}`),
                Ia('falling back to ArrayBuffer instantiation'));
            }
          return Wa(b, a);
        }
        class Ya {
          name = 'ExitStatus';
          constructor(a) {
            this.message = `Program terminated with exit(${a})`;
            this.status = a;
          }
        }
        var Za = (a) => {
            for (; 0 < a.length; ) a.shift()(f);
          },
          $a = [],
          ab = [],
          bb = () => {
            var a = f.preRun.shift();
            ab.unshift(a);
          };
        function m(a, b = 'i8') {
          b.endsWith('*') && (b = '*');
          switch (b) {
            case 'i1':
              return p[a];
            case 'i8':
              return p[a];
            case 'i16':
              return Na[a >> 1];
            case 'i32':
              return E[a >> 2];
            case 'i64':
              return H[a >> 3];
            case 'float':
              return Oa[a >> 2];
            case 'double':
              return Pa[a >> 3];
            case '*':
              return F[a >> 2];
            default:
              Ta(`invalid type for getValue: ${b}`);
          }
        }
        var cb = f.noExitRuntime || true;
        function ta(a) {
          var b = 'i32';
          b.endsWith('*') && (b = '*');
          switch (b) {
            case 'i1':
              p[a] = 0;
              break;
            case 'i8':
              p[a] = 0;
              break;
            case 'i16':
              Na[a >> 1] = 0;
              break;
            case 'i32':
              E[a >> 2] = 0;
              break;
            case 'i64':
              H[a >> 3] = BigInt(0);
              break;
            case 'float':
              Oa[a >> 2] = 0;
              break;
            case 'double':
              Pa[a >> 3] = 0;
              break;
            case '*':
              F[a >> 2] = 0;
              break;
            default:
              Ta(`invalid type for setValue: ${b}`);
          }
        }
        var db = 'undefined' != typeof TextDecoder ? new TextDecoder() : void 0,
          B = (a, b = 0, c = NaN) => {
            var d = b + c;
            for (c = b; a[c] && !(c >= d); ) ++c;
            if (16 < c - b && a.buffer && db) return db.decode(a.subarray(b, c));
            for (d = ''; b < c; ) {
              var e = a[b++];
              if (e & 128) {
                var h = a[b++] & 63;
                if (192 == (e & 224)) d += String.fromCharCode(((e & 31) << 6) | h);
                else {
                  var k = a[b++] & 63;
                  e =
                    224 == (e & 240)
                      ? ((e & 15) << 12) | (h << 6) | k
                      : ((e & 7) << 18) | (h << 12) | (k << 6) | (a[b++] & 63);
                  65536 > e
                    ? (d += String.fromCharCode(e))
                    : ((e -= 65536),
                      (d += String.fromCharCode(55296 | (e >> 10), 56320 | (e & 1023))));
                }
              } else d += String.fromCharCode(e);
            }
            return d;
          },
          ua = (a, b) => (a ? B(x, a, b) : ''),
          eb = (a, b) => {
            for (var c = 0, d = a.length - 1; 0 <= d; d--) {
              var e = a[d];
              '.' === e
                ? a.splice(d, 1)
                : '..' === e
                  ? (a.splice(d, 1), c++)
                  : c && (a.splice(d, 1), c--);
            }
            if (b) for (; c; c--) a.unshift('..');
            return a;
          },
          ka = (a) => {
            var b = '/' === a.charAt(0),
              c = '/' === a.slice(-1);
            (a = eb(
              a.split('/').filter((d) => !!d),
              !b
            ).join('/')) ||
              b ||
              (a = '.');
            a && c && (a += '/');
            return (b ? '/' : '') + a;
          },
          fb = (a) => {
            var b = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/
              .exec(a)
              .slice(1);
            a = b[0];
            b = b[1];
            if (!a && !b) return '.';
            b &&= b.slice(0, -1);
            return a + b;
          },
          gb = (a) => a && a.match(/([^\/]+|\/)\/*$/)[1],
          hb = () => {
            if (ca) {
              var a = __require('crypto');
              return (b) => a.randomFillSync(b);
            }
            return (b) => crypto.getRandomValues(b);
          },
          ib = (a) => {
            (ib = hb())(a);
          },
          jb = (...a) => {
            for (var b = '', c = false, d = a.length - 1; -1 <= d && !c; d--) {
              c = 0 <= d ? a[d] : '/';
              if ('string' != typeof c)
                throw new TypeError('Arguments to path.resolve must be strings');
              if (!c) return '';
              b = c + '/' + b;
              c = '/' === c.charAt(0);
            }
            b = eb(
              b.split('/').filter((e) => !!e),
              !c
            ).join('/');
            return (c ? '/' : '') + b || '.';
          },
          kb = [],
          ha = (a) => {
            for (var b = 0, c = 0; c < a.length; ++c) {
              var d = a.charCodeAt(c);
              127 >= d
                ? b++
                : 2047 >= d
                  ? (b += 2)
                  : 55296 <= d && 57343 >= d
                    ? ((b += 4), ++c)
                    : (b += 3);
            }
            return b;
          },
          u = (a, b, c, d) => {
            if (!(0 < d)) return 0;
            var e = c;
            d = c + d - 1;
            for (var h = 0; h < a.length; ++h) {
              var k = a.charCodeAt(h);
              if (55296 <= k && 57343 >= k) {
                var q = a.charCodeAt(++h);
                k = (65536 + ((k & 1023) << 10)) | (q & 1023);
              }
              if (127 >= k) {
                if (c >= d) break;
                b[c++] = k;
              } else {
                if (2047 >= k) {
                  if (c + 1 >= d) break;
                  b[c++] = 192 | (k >> 6);
                } else {
                  if (65535 >= k) {
                    if (c + 2 >= d) break;
                    b[c++] = 224 | (k >> 12);
                  } else {
                    if (c + 3 >= d) break;
                    b[c++] = 240 | (k >> 18);
                    b[c++] = 128 | ((k >> 12) & 63);
                  }
                  b[c++] = 128 | ((k >> 6) & 63);
                }
                b[c++] = 128 | (k & 63);
              }
            }
            b[c] = 0;
            return c - e;
          },
          ra = (a, b) => {
            var c = Array(ha(a) + 1);
            a = u(a, c, 0, c.length);
            b && (c.length = a);
            return c;
          },
          mb = [];
        function nb(a, b) {
          mb[a] = { input: [], output: [], cb: b };
          wb(a, xb);
        }
        var xb = {
            open(a) {
              var b = mb[a.node.rdev];
              if (!b) throw new N(43);
              a.tty = b;
              a.seekable = false;
            },
            close(a) {
              a.tty.cb.fsync(a.tty);
            },
            fsync(a) {
              a.tty.cb.fsync(a.tty);
            },
            read(a, b, c, d) {
              if (!a.tty || !a.tty.cb.xb) throw new N(60);
              for (var e = 0, h = 0; h < d; h++) {
                try {
                  var k = a.tty.cb.xb(a.tty);
                } catch (q) {
                  throw new N(29);
                }
                if (void 0 === k && 0 === e) throw new N(6);
                if (null === k || void 0 === k) break;
                e++;
                b[c + h] = k;
              }
              e && (a.node.atime = Date.now());
              return e;
            },
            write(a, b, c, d) {
              if (!a.tty || !a.tty.cb.qb) throw new N(60);
              try {
                for (var e = 0; e < d; e++) a.tty.cb.qb(a.tty, b[c + e]);
              } catch (h) {
                throw new N(29);
              }
              d && (a.node.mtime = a.node.ctime = Date.now());
              return e;
            },
          },
          yb = {
            xb() {
              a: {
                if (!kb.length) {
                  var a = null;
                  if (ca) {
                    var b = Buffer.alloc(256),
                      c = 0,
                      d = process.stdin.fd;
                    try {
                      c = fs2.readSync(d, b, 0, 256);
                    } catch (e) {
                      if (e.toString().includes('EOF')) c = 0;
                      else throw e;
                    }
                    0 < c && (a = b.slice(0, c).toString('utf-8'));
                  } else
                    'undefined' != typeof window &&
                      'function' == typeof window.prompt &&
                      ((a = window.prompt('Input: ')), null !== a && (a += '\n'));
                  if (!a) {
                    a = null;
                    break a;
                  }
                  kb = ra(a, true);
                }
                a = kb.shift();
              }
              return a;
            },
            qb(a, b) {
              null === b || 10 === b
                ? (Ha(B(a.output)), (a.output = []))
                : 0 != b && a.output.push(b);
            },
            fsync(a) {
              0 < a.output?.length && (Ha(B(a.output)), (a.output = []));
            },
            Tb() {
              return {
                Ob: 25856,
                Qb: 5,
                Nb: 191,
                Pb: 35387,
                Mb: [
                  3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 0, 0,
                ],
              };
            },
            Ub() {
              return 0;
            },
            Vb() {
              return [24, 80];
            },
          },
          zb = {
            qb(a, b) {
              null === b || 10 === b
                ? (Ia(B(a.output)), (a.output = []))
                : 0 != b && a.output.push(b);
            },
            fsync(a) {
              0 < a.output?.length && (Ia(B(a.output)), (a.output = []));
            },
          },
          O = {
            Wa: null,
            Xa() {
              return O.createNode(null, '/', 16895, 0);
            },
            createNode(a, b, c, d) {
              if (24576 === (c & 61440) || 4096 === (c & 61440)) throw new N(63);
              O.Wa ||
                (O.Wa = {
                  dir: {
                    node: {
                      Ta: O.La.Ta,
                      Ua: O.La.Ua,
                      lookup: O.La.lookup,
                      hb: O.La.hb,
                      rename: O.La.rename,
                      unlink: O.La.unlink,
                      rmdir: O.La.rmdir,
                      readdir: O.La.readdir,
                      symlink: O.La.symlink,
                    },
                    stream: { Va: O.Ma.Va },
                  },
                  file: {
                    node: { Ta: O.La.Ta, Ua: O.La.Ua },
                    stream: {
                      Va: O.Ma.Va,
                      read: O.Ma.read,
                      write: O.Ma.write,
                      ib: O.Ma.ib,
                      jb: O.Ma.jb,
                    },
                  },
                  link: { node: { Ta: O.La.Ta, Ua: O.La.Ua, readlink: O.La.readlink }, stream: {} },
                  ub: { node: { Ta: O.La.Ta, Ua: O.La.Ua }, stream: Ab },
                });
              c = Bb(a, b, c, d);
              P(c.mode)
                ? ((c.La = O.Wa.dir.node), (c.Ma = O.Wa.dir.stream), (c.Na = {}))
                : 32768 === (c.mode & 61440)
                  ? ((c.La = O.Wa.file.node), (c.Ma = O.Wa.file.stream), (c.Ra = 0), (c.Na = null))
                  : 40960 === (c.mode & 61440)
                    ? ((c.La = O.Wa.link.node), (c.Ma = O.Wa.link.stream))
                    : 8192 === (c.mode & 61440) && ((c.La = O.Wa.ub.node), (c.Ma = O.Wa.ub.stream));
              c.atime = c.mtime = c.ctime = Date.now();
              a && ((a.Na[b] = c), (a.atime = a.mtime = a.ctime = c.atime));
              return c;
            },
            Sb(a) {
              return a.Na
                ? a.Na.subarray
                  ? a.Na.subarray(0, a.Ra)
                  : new Uint8Array(a.Na)
                : new Uint8Array(0);
            },
            La: {
              Ta(a) {
                var b = {};
                b.dev = 8192 === (a.mode & 61440) ? a.id : 1;
                b.ino = a.id;
                b.mode = a.mode;
                b.nlink = 1;
                b.uid = 0;
                b.gid = 0;
                b.rdev = a.rdev;
                P(a.mode)
                  ? (b.size = 4096)
                  : 32768 === (a.mode & 61440)
                    ? (b.size = a.Ra)
                    : 40960 === (a.mode & 61440)
                      ? (b.size = a.link.length)
                      : (b.size = 0);
                b.atime = new Date(a.atime);
                b.mtime = new Date(a.mtime);
                b.ctime = new Date(a.ctime);
                b.blksize = 4096;
                b.blocks = Math.ceil(b.size / b.blksize);
                return b;
              },
              Ua(a, b) {
                for (var c of ['mode', 'atime', 'mtime', 'ctime']) null != b[c] && (a[c] = b[c]);
                void 0 !== b.size &&
                  ((b = b.size),
                  a.Ra != b &&
                    (0 == b
                      ? ((a.Na = null), (a.Ra = 0))
                      : ((c = a.Na),
                        (a.Na = new Uint8Array(b)),
                        c && a.Na.set(c.subarray(0, Math.min(b, a.Ra))),
                        (a.Ra = b))));
              },
              lookup() {
                throw O.vb;
              },
              hb(a, b, c, d) {
                return O.createNode(a, b, c, d);
              },
              rename(a, b, c) {
                try {
                  var d = Q(b, c);
                } catch (h) {}
                if (d) {
                  if (P(a.mode)) for (var e in d.Na) throw new N(55);
                  Cb(d);
                }
                delete a.parent.Na[a.name];
                b.Na[c] = a;
                a.name = c;
                b.ctime = b.mtime = a.parent.ctime = a.parent.mtime = Date.now();
              },
              unlink(a, b) {
                delete a.Na[b];
                a.ctime = a.mtime = Date.now();
              },
              rmdir(a, b) {
                var c = Q(a, b),
                  d;
                for (d in c.Na) throw new N(55);
                delete a.Na[b];
                a.ctime = a.mtime = Date.now();
              },
              readdir(a) {
                return ['.', '..', ...Object.keys(a.Na)];
              },
              symlink(a, b, c) {
                a = O.createNode(a, b, 41471, 0);
                a.link = c;
                return a;
              },
              readlink(a) {
                if (40960 !== (a.mode & 61440)) throw new N(28);
                return a.link;
              },
            },
            Ma: {
              read(a, b, c, d, e) {
                var h = a.node.Na;
                if (e >= a.node.Ra) return 0;
                a = Math.min(a.node.Ra - e, d);
                if (8 < a && h.subarray) b.set(h.subarray(e, e + a), c);
                else for (d = 0; d < a; d++) b[c + d] = h[e + d];
                return a;
              },
              write(a, b, c, d, e, h) {
                b.buffer === p.buffer && (h = false);
                if (!d) return 0;
                a = a.node;
                a.mtime = a.ctime = Date.now();
                if (b.subarray && (!a.Na || a.Na.subarray)) {
                  if (h) return ((a.Na = b.subarray(c, c + d)), (a.Ra = d));
                  if (0 === a.Ra && 0 === e) return ((a.Na = b.slice(c, c + d)), (a.Ra = d));
                  if (e + d <= a.Ra) return (a.Na.set(b.subarray(c, c + d), e), d);
                }
                h = e + d;
                var k = a.Na ? a.Na.length : 0;
                k >= h ||
                  ((h = Math.max(h, (k * (1048576 > k ? 2 : 1.125)) >>> 0)),
                  0 != k && (h = Math.max(h, 256)),
                  (k = a.Na),
                  (a.Na = new Uint8Array(h)),
                  0 < a.Ra && a.Na.set(k.subarray(0, a.Ra), 0));
                if (a.Na.subarray && b.subarray) a.Na.set(b.subarray(c, c + d), e);
                else for (h = 0; h < d; h++) a.Na[e + h] = b[c + h];
                a.Ra = Math.max(a.Ra, e + d);
                return d;
              },
              Va(a, b, c) {
                1 === c
                  ? (b += a.position)
                  : 2 === c && 32768 === (a.node.mode & 61440) && (b += a.node.Ra);
                if (0 > b) throw new N(28);
                return b;
              },
              ib(a, b, c, d, e) {
                if (32768 !== (a.node.mode & 61440)) throw new N(43);
                a = a.node.Na;
                if (e & 2 || !a || a.buffer !== p.buffer) {
                  e = true;
                  d = 65536 * Math.ceil(b / 65536);
                  var h = Db(65536, d);
                  h && x.fill(0, h, h + d);
                  d = h;
                  if (!d) throw new N(48);
                  if (a) {
                    if (0 < c || c + b < a.length)
                      a.subarray
                        ? (a = a.subarray(c, c + b))
                        : (a = Array.prototype.slice.call(a, c, c + b));
                    p.set(a, d);
                  }
                } else ((e = false), (d = a.byteOffset));
                return { Kb: d, Ab: e };
              },
              jb(a, b, c, d) {
                O.Ma.write(a, b, 0, d, c, false);
                return 0;
              },
            },
          },
          la = (a, b) => {
            var c = 0;
            a && (c |= 365);
            b && (c |= 146);
            return c;
          },
          Eb = null,
          Fb = {},
          Gb = [],
          Hb = 1,
          R = null,
          Ib = false,
          Jb = true,
          Kb = {},
          N = class {
            name = 'ErrnoError';
            constructor(a) {
              this.Pa = a;
            }
          },
          Lb = class {
            gb = {};
            node = null;
            get flags() {
              return this.gb.flags;
            }
            set flags(a) {
              this.gb.flags = a;
            }
            get position() {
              return this.gb.position;
            }
            set position(a) {
              this.gb.position = a;
            }
          },
          Mb = class {
            La = {};
            Ma = {};
            ab = null;
            constructor(a, b, c, d) {
              a ||= this;
              this.parent = a;
              this.Xa = a.Xa;
              this.id = Hb++;
              this.name = b;
              this.mode = c;
              this.rdev = d;
              this.atime = this.mtime = this.ctime = Date.now();
            }
            get read() {
              return 365 === (this.mode & 365);
            }
            set read(a) {
              a ? (this.mode |= 365) : (this.mode &= -366);
            }
            get write() {
              return 146 === (this.mode & 146);
            }
            set write(a) {
              a ? (this.mode |= 146) : (this.mode &= -147);
            }
          };
        function S(a, b = {}) {
          if (!a) throw new N(44);
          b.nb ?? (b.nb = true);
          '/' === a.charAt(0) || (a = '//' + a);
          var c = 0;
          a: for (; 40 > c; c++) {
            a = a.split('/').filter((q) => !!q);
            for (var d = Eb, e = '/', h = 0; h < a.length; h++) {
              var k = h === a.length - 1;
              if (k && b.parent) break;
              if ('.' !== a[h])
                if ('..' === a[h]) ((e = fb(e)), (d = d.parent));
                else {
                  e = ka(e + '/' + a[h]);
                  try {
                    d = Q(d, a[h]);
                  } catch (q) {
                    if (44 === q?.Pa && k && b.Jb) return { path: e };
                    throw q;
                  }
                  !d.ab || (k && !b.nb) || (d = d.ab.root);
                  if (40960 === (d.mode & 61440) && (!k || b.$a)) {
                    if (!d.La.readlink) throw new N(52);
                    d = d.La.readlink(d);
                    '/' === d.charAt(0) || (d = fb(e) + '/' + d);
                    a = d + '/' + a.slice(h + 1).join('/');
                    continue a;
                  }
                }
            }
            return { path: e, node: d };
          }
          throw new N(32);
        }
        function ja(a) {
          for (var b; ; ) {
            if (a === a.parent)
              return ((a = a.Xa.zb), b ? ('/' !== a[a.length - 1] ? `${a}/${b}` : a + b) : a);
            b = b ? `${a.name}/${b}` : a.name;
            a = a.parent;
          }
        }
        function Nb(a, b) {
          for (var c = 0, d = 0; d < b.length; d++) c = ((c << 5) - c + b.charCodeAt(d)) | 0;
          return ((a + c) >>> 0) % R.length;
        }
        function Cb(a) {
          var b = Nb(a.parent.id, a.name);
          if (R[b] === a) R[b] = a.bb;
          else
            for (b = R[b]; b; ) {
              if (b.bb === a) {
                b.bb = a.bb;
                break;
              }
              b = b.bb;
            }
        }
        function Q(a, b) {
          var c = P(a.mode) ? ((c = Ob(a, 'x')) ? c : a.La.lookup ? 0 : 2) : 54;
          if (c) throw new N(c);
          for (c = R[Nb(a.id, b)]; c; c = c.bb) {
            var d = c.name;
            if (c.parent.id === a.id && d === b) return c;
          }
          return a.La.lookup(a, b);
        }
        function Bb(a, b, c, d) {
          a = new Mb(a, b, c, d);
          b = Nb(a.parent.id, a.name);
          a.bb = R[b];
          return (R[b] = a);
        }
        function P(a) {
          return 16384 === (a & 61440);
        }
        function Pb(a) {
          var b = ['r', 'w', 'rw'][a & 3];
          a & 512 && (b += 'w');
          return b;
        }
        function Ob(a, b) {
          if (Jb) return 0;
          if (!b.includes('r') || a.mode & 292) {
            if ((b.includes('w') && !(a.mode & 146)) || (b.includes('x') && !(a.mode & 73)))
              return 2;
          } else return 2;
          return 0;
        }
        function Qb(a, b) {
          if (!P(a.mode)) return 54;
          try {
            return (Q(a, b), 20);
          } catch (c) {}
          return Ob(a, 'wx');
        }
        function Rb(a, b, c) {
          try {
            var d = Q(a, b);
          } catch (e) {
            return e.Pa;
          }
          if ((a = Ob(a, 'wx'))) return a;
          if (c) {
            if (!P(d.mode)) return 54;
            if (d === d.parent || '/' === ja(d)) return 10;
          } else if (P(d.mode)) return 31;
          return 0;
        }
        function Sb(a) {
          if (!a) throw new N(63);
          return a;
        }
        function T(a) {
          a = Gb[a];
          if (!a) throw new N(8);
          return a;
        }
        function Tb(a, b = -1) {
          a = Object.assign(new Lb(), a);
          if (-1 == b)
            a: {
              for (b = 0; 4096 >= b; b++) if (!Gb[b]) break a;
              throw new N(33);
            }
          a.fd = b;
          return (Gb[b] = a);
        }
        function Ub(a, b = -1) {
          a = Tb(a, b);
          a.Ma?.Rb?.(a);
          return a;
        }
        function Vb(a, b, c) {
          var d = a?.Ma.Ua;
          a = d ? a : b;
          d ??= b.La.Ua;
          Sb(d);
          d(a, c);
        }
        var Ab = {
          open(a) {
            a.Ma = Fb[a.node.rdev].Ma;
            a.Ma.open?.(a);
          },
          Va() {
            throw new N(70);
          },
        };
        function wb(a, b) {
          Fb[a] = { Ma: b };
        }
        function Wb(a, b) {
          var c = '/' === b;
          if (c && Eb) throw new N(10);
          if (!c && b) {
            var d = S(b, { nb: false });
            b = d.path;
            d = d.node;
            if (d.ab) throw new N(10);
            if (!P(d.mode)) throw new N(54);
          }
          b = { type: a, Wb: {}, zb: b, Ib: [] };
          a = a.Xa(b);
          a.Xa = b;
          b.root = a;
          c ? (Eb = a) : d && ((d.ab = b), d.Xa && d.Xa.Ib.push(b));
        }
        function Xb(a, b, c) {
          var d = S(a, { parent: true }).node;
          a = gb(a);
          if (!a) throw new N(28);
          if ('.' === a || '..' === a) throw new N(20);
          var e = Qb(d, a);
          if (e) throw new N(e);
          if (!d.La.hb) throw new N(63);
          return d.La.hb(d, a, b, c);
        }
        function ma(a, b = 438) {
          return Xb(a, (b & 4095) | 32768, 0);
        }
        function U(a, b = 511) {
          return Xb(a, (b & 1023) | 16384, 0);
        }
        function Yb(a, b, c) {
          'undefined' == typeof c && ((c = b), (b = 438));
          Xb(a, b | 8192, c);
        }
        function Zb(a, b) {
          if (!jb(a)) throw new N(44);
          var c = S(b, { parent: true }).node;
          if (!c) throw new N(44);
          b = gb(b);
          var d = Qb(c, b);
          if (d) throw new N(d);
          if (!c.La.symlink) throw new N(63);
          c.La.symlink(c, b, a);
        }
        function $b(a) {
          var b = S(a, { parent: true }).node;
          a = gb(a);
          var c = Q(b, a),
            d = Rb(b, a, true);
          if (d) throw new N(d);
          if (!b.La.rmdir) throw new N(63);
          if (c.ab) throw new N(10);
          b.La.rmdir(b, a);
          Cb(c);
        }
        function za(a) {
          var b = S(a, { parent: true }).node;
          if (!b) throw new N(44);
          a = gb(a);
          var c = Q(b, a),
            d = Rb(b, a, false);
          if (d) throw new N(d);
          if (!b.La.unlink) throw new N(63);
          if (c.ab) throw new N(10);
          b.La.unlink(b, a);
          Cb(c);
        }
        function ac(a, b) {
          a = S(a, { $a: !b }).node;
          return Sb(a.La.Ta)(a);
        }
        function bc(a, b, c, d) {
          Vb(a, b, { mode: (c & 4095) | (b.mode & -4096), ctime: Date.now(), Fb: d });
        }
        function na(a, b) {
          a = 'string' == typeof a ? S(a, { $a: true }).node : a;
          bc(null, a, b);
        }
        function cc(a, b, c) {
          if (P(b.mode)) throw new N(31);
          if (32768 !== (b.mode & 61440)) throw new N(28);
          var d = Ob(b, 'w');
          if (d) throw new N(d);
          Vb(a, b, { size: c, timestamp: Date.now() });
        }
        function oa(a, b, c = 438) {
          if ('' === a) throw new N(44);
          if ('string' == typeof b) {
            var d = { r: 0, 'r+': 2, w: 577, 'w+': 578, a: 1089, 'a+': 1090 }[b];
            if ('undefined' == typeof d) throw Error(`Unknown file open mode: ${b}`);
            b = d;
          }
          c = b & 64 ? (c & 4095) | 32768 : 0;
          if ('object' == typeof a) d = a;
          else {
            var e = a.endsWith('/');
            a = S(a, { $a: !(b & 131072), Jb: true });
            d = a.node;
            a = a.path;
          }
          var h = false;
          if (b & 64)
            if (d) {
              if (b & 128) throw new N(20);
            } else {
              if (e) throw new N(31);
              d = Xb(a, c | 511, 0);
              h = true;
            }
          if (!d) throw new N(44);
          8192 === (d.mode & 61440) && (b &= -513);
          if (b & 65536 && !P(d.mode)) throw new N(54);
          if (
            !h &&
            (e = d
              ? 40960 === (d.mode & 61440)
                ? 32
                : P(d.mode) && ('r' !== Pb(b) || b & 576)
                  ? 31
                  : Ob(d, Pb(b))
              : 44)
          )
            throw new N(e);
          b & 512 &&
            !h &&
            ((e = d), (e = 'string' == typeof e ? S(e, { $a: true }).node : e), cc(null, e, 0));
          b &= -131713;
          e = Tb({
            node: d,
            path: ja(d),
            flags: b,
            seekable: true,
            position: 0,
            Ma: d.Ma,
            Lb: [],
            error: false,
          });
          e.Ma.open && e.Ma.open(e);
          h && na(d, c & 511);
          !f.logReadFiles || b & 1 || a in Kb || (Kb[a] = 1);
          return e;
        }
        function qa(a) {
          if (null === a.fd) throw new N(8);
          a.ob && (a.ob = null);
          try {
            a.Ma.close && a.Ma.close(a);
          } catch (b) {
            throw b;
          } finally {
            Gb[a.fd] = null;
          }
          a.fd = null;
        }
        function mc(a, b, c) {
          if (null === a.fd) throw new N(8);
          if (!a.seekable || !a.Ma.Va) throw new N(70);
          if (0 != c && 1 != c && 2 != c) throw new N(28);
          a.position = a.Ma.Va(a, b, c);
          a.Lb = [];
        }
        function Ec(a, b, c, d, e) {
          if (0 > d || 0 > e) throw new N(28);
          if (null === a.fd) throw new N(8);
          if (1 === (a.flags & 2097155)) throw new N(8);
          if (P(a.node.mode)) throw new N(31);
          if (!a.Ma.read) throw new N(28);
          var h = 'undefined' != typeof e;
          if (!h) e = a.position;
          else if (!a.seekable) throw new N(70);
          b = a.Ma.read(a, b, c, d, e);
          h || (a.position += b);
          return b;
        }
        function pa(a, b, c, d, e) {
          if (0 > d || 0 > e) throw new N(28);
          if (null === a.fd) throw new N(8);
          if (0 === (a.flags & 2097155)) throw new N(8);
          if (P(a.node.mode)) throw new N(31);
          if (!a.Ma.write) throw new N(28);
          a.seekable && a.flags & 1024 && mc(a, 0, 2);
          var h = 'undefined' != typeof e;
          if (!h) e = a.position;
          else if (!a.seekable) throw new N(70);
          b = a.Ma.write(a, b, c, d, e, void 0);
          h || (a.position += b);
          return b;
        }
        function ya(a) {
          var b = 'binary';
          if ('utf8' !== b && 'binary' !== b) throw Error(`Invalid encoding type "${b}"`);
          var c;
          var d = oa(a, d || 0);
          a = ac(a).size;
          var e = new Uint8Array(a);
          Ec(d, e, 0, a, 0);
          'utf8' === b ? (c = B(e)) : 'binary' === b && (c = e);
          qa(d);
          return c;
        }
        function V(a, b, c) {
          a = ka('/dev/' + a);
          var d = la(!!b, !!c);
          V.yb ?? (V.yb = 64);
          var e = (V.yb++ << 8) | 0;
          wb(e, {
            open(h) {
              h.seekable = false;
            },
            close() {
              c?.buffer?.length && c(10);
            },
            read(h, k, q, w) {
              for (var v = 0, C = 0; C < w; C++) {
                try {
                  var G = b();
                } catch (pb) {
                  throw new N(29);
                }
                if (void 0 === G && 0 === v) throw new N(6);
                if (null === G || void 0 === G) break;
                v++;
                k[q + C] = G;
              }
              v && (h.node.atime = Date.now());
              return v;
            },
            write(h, k, q, w) {
              for (var v = 0; v < w; v++)
                try {
                  c(k[q + v]);
                } catch (C) {
                  throw new N(29);
                }
              w && (h.node.mtime = h.node.ctime = Date.now());
              return v;
            },
          });
          Yb(a, d, e);
        }
        var W = {};
        function Gc(a, b, c) {
          if ('/' === b.charAt(0)) return b;
          a = -100 === a ? '/' : T(a).path;
          if (0 == b.length) {
            if (!c) throw new N(44);
            return a;
          }
          return a + '/' + b;
        }
        function Hc(a, b) {
          E[a >> 2] = b.dev;
          E[(a + 4) >> 2] = b.mode;
          F[(a + 8) >> 2] = b.nlink;
          E[(a + 12) >> 2] = b.uid;
          E[(a + 16) >> 2] = b.gid;
          E[(a + 20) >> 2] = b.rdev;
          H[(a + 24) >> 3] = BigInt(b.size);
          E[(a + 32) >> 2] = 4096;
          E[(a + 36) >> 2] = b.blocks;
          var c = b.atime.getTime(),
            d = b.mtime.getTime(),
            e = b.ctime.getTime();
          H[(a + 40) >> 3] = BigInt(Math.floor(c / 1e3));
          F[(a + 48) >> 2] = (c % 1e3) * 1e6;
          H[(a + 56) >> 3] = BigInt(Math.floor(d / 1e3));
          F[(a + 64) >> 2] = (d % 1e3) * 1e6;
          H[(a + 72) >> 3] = BigInt(Math.floor(e / 1e3));
          F[(a + 80) >> 2] = (e % 1e3) * 1e6;
          H[(a + 88) >> 3] = BigInt(b.ino);
          return 0;
        }
        var Ic = void 0,
          Jc = () => {
            var a = E[+Ic >> 2];
            Ic += 4;
            return a;
          },
          Kc = 0,
          Lc = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],
          Mc = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
          Nc = {},
          Oc = (a) => {
            Ma = a;
            cb || 0 < Kc || (f.onExit?.(a), (La = true));
            Da(a, new Ya(a));
          },
          Pc = (a) => {
            if (!La)
              try {
                if ((a(), !(cb || 0 < Kc)))
                  try {
                    ((Ma = a = Ma), Oc(a));
                  } catch (b) {
                    b instanceof Ya || 'unwind' == b || Da(1, b);
                  }
              } catch (b) {
                b instanceof Ya || 'unwind' == b || Da(1, b);
              }
          },
          Qc = {},
          Sc = () => {
            if (!Rc) {
              var a = {
                  USER: 'web_user',
                  LOGNAME: 'web_user',
                  PATH: '/',
                  PWD: '/',
                  HOME: '/home/web_user',
                  LANG:
                    (
                      ('object' == typeof navigator &&
                        navigator.languages &&
                        navigator.languages[0]) ||
                      'C'
                    ).replace('-', '_') + '.UTF-8',
                  _: Ca || './this.program',
                },
                b;
              for (b in Qc) void 0 === Qc[b] ? delete a[b] : (a[b] = Qc[b]);
              var c = [];
              for (b in a) c.push(`${b}=${a[b]}`);
              Rc = c;
            }
            return Rc;
          },
          Rc,
          xa = (a) => {
            var b = ha(a) + 1,
              c = z(b);
            u(a, x, c, b);
            return c;
          },
          Tc = (a, b, c, d) => {
            var e = {
              string: (v) => {
                var C = 0;
                null !== v && void 0 !== v && 0 !== v && (C = xa(v));
                return C;
              },
              array: (v) => {
                var C = z(v.length);
                p.set(v, C);
                return C;
              },
            };
            a = f['_' + a];
            var h = [],
              k = 0;
            if (d)
              for (var q = 0; q < d.length; q++) {
                var w = e[c[q]];
                w ? (0 === k && (k = sa()), (h[q] = w(d[q]))) : (h[q] = d[q]);
              }
            c = a(...h);
            return (c = (function (v) {
              0 !== k && wa(k);
              return 'string' === b ? (v ? B(x, v) : '') : 'boolean' === b ? !!v : v;
            })(c));
          },
          ea = 0,
          da = (a, b) => {
            b = 1 == b ? z(a.length) : ia(a.length);
            a.subarray || a.slice || (a = new Uint8Array(a));
            x.set(a, b);
            return b;
          },
          Uc,
          Vc = [],
          Y,
          A = (a) => {
            Uc.delete(Y.get(a));
            Y.set(a, null);
            Vc.push(a);
          },
          Aa = (a, b) => {
            if (!Uc) {
              Uc = /* @__PURE__ */ new WeakMap();
              var c = Y.length;
              if (Uc)
                for (var d = 0; d < 0 + c; d++) {
                  var e = Y.get(d);
                  e && Uc.set(e, d);
                }
            }
            if ((c = Uc.get(a) || 0)) return c;
            if (Vc.length) c = Vc.pop();
            else {
              try {
                Y.grow(1);
              } catch (w) {
                if (!(w instanceof RangeError)) throw w;
                throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
              }
              c = Y.length - 1;
            }
            try {
              Y.set(c, a);
            } catch (w) {
              if (!(w instanceof TypeError)) throw w;
              if ('function' == typeof WebAssembly.Function) {
                var h = WebAssembly.Function;
                d = { i: 'i32', j: 'i64', f: 'f32', d: 'f64', e: 'externref', p: 'i32' };
                e = { parameters: [], results: 'v' == b[0] ? [] : [d[b[0]]] };
                for (var k = 1; k < b.length; ++k) e.parameters.push(d[b[k]]);
                b = new h(e, a);
              } else {
                d = [1];
                e = b.slice(0, 1);
                b = b.slice(1);
                k = { i: 127, p: 127, j: 126, f: 125, d: 124, e: 111 };
                d.push(96);
                var q = b.length;
                128 > q ? d.push(q) : d.push(q % 128 | 128, q >> 7);
                for (h of b) d.push(k[h]);
                'v' == e ? d.push(0) : d.push(1, k[e]);
                b = [0, 97, 115, 109, 1, 0, 0, 0, 1];
                h = d.length;
                128 > h ? b.push(h) : b.push(h % 128 | 128, h >> 7);
                b.push(...d);
                b.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
                b = new WebAssembly.Module(new Uint8Array(b));
                b = new WebAssembly.Instance(b, { e: { f: a } }).exports.f;
              }
              Y.set(c, b);
            }
            Uc.set(a, c);
            return c;
          };
        R = Array(4096);
        Wb(O, '/');
        U('/tmp');
        U('/home');
        U('/home/web_user');
        (function () {
          U('/dev');
          wb(259, { read: () => 0, write: (d, e, h, k) => k, Va: () => 0 });
          Yb('/dev/null', 259);
          nb(1280, yb);
          nb(1536, zb);
          Yb('/dev/tty', 1280);
          Yb('/dev/tty1', 1536);
          var a = new Uint8Array(1024),
            b = 0,
            c = () => {
              0 === b && (ib(a), (b = a.byteLength));
              return a[--b];
            };
          V('random', c);
          V('urandom', c);
          U('/dev/shm');
          U('/dev/shm/tmp');
        })();
        (function () {
          U('/proc');
          var a = U('/proc/self');
          U('/proc/self/fd');
          Wb(
            {
              Xa() {
                var b = Bb(a, 'fd', 16895, 73);
                b.Ma = { Va: O.Ma.Va };
                b.La = {
                  lookup(c, d) {
                    c = +d;
                    var e = T(c);
                    c = {
                      parent: null,
                      Xa: { zb: 'fake' },
                      La: { readlink: () => e.path },
                      id: c + 1,
                    };
                    return (c.parent = c);
                  },
                  readdir() {
                    return Array.from(Gb.entries())
                      .filter(([, c]) => c)
                      .map(([c]) => c.toString());
                  },
                };
                return b;
              },
            },
            '/proc/self/fd'
          );
        })();
        O.vb = new N(44);
        O.vb.stack = '<generic error, no stack>';
        var Xc = {
            a: (a, b, c, d) =>
              Ta(
                `Assertion failed: ${a ? B(x, a) : ''}, at: ` +
                  [
                    b ? (b ? B(x, b) : '') : 'unknown filename',
                    c,
                    d ? (d ? B(x, d) : '') : 'unknown function',
                  ]
              ),
            i: function (a, b) {
              try {
                return ((a = a ? B(x, a) : ''), na(a, b), 0);
              } catch (c) {
                if ('undefined' == typeof W || 'ErrnoError' !== c.name) throw c;
                return -c.Pa;
              }
            },
            L: function (a, b, c) {
              try {
                b = b ? B(x, b) : '';
                b = Gc(a, b);
                if (c & -8) return -28;
                var d = S(b, { $a: true }).node;
                if (!d) return -44;
                a = '';
                c & 4 && (a += 'r');
                c & 2 && (a += 'w');
                c & 1 && (a += 'x');
                return a && Ob(d, a) ? -2 : 0;
              } catch (e) {
                if ('undefined' == typeof W || 'ErrnoError' !== e.name) throw e;
                return -e.Pa;
              }
            },
            j: function (a, b) {
              try {
                var c = T(a);
                bc(c, c.node, b, false);
                return 0;
              } catch (d) {
                if ('undefined' == typeof W || 'ErrnoError' !== d.name) throw d;
                return -d.Pa;
              }
            },
            h: function (a) {
              try {
                var b = T(a);
                Vb(b, b.node, { timestamp: Date.now(), Fb: false });
                return 0;
              } catch (c) {
                if ('undefined' == typeof W || 'ErrnoError' !== c.name) throw c;
                return -c.Pa;
              }
            },
            b: function (a, b, c) {
              Ic = c;
              try {
                var d = T(a);
                switch (b) {
                  case 0:
                    var e = Jc();
                    if (0 > e) break;
                    for (; Gb[e]; ) e++;
                    return Ub(d, e).fd;
                  case 1:
                  case 2:
                    return 0;
                  case 3:
                    return d.flags;
                  case 4:
                    return ((e = Jc()), (d.flags |= e), 0);
                  case 12:
                    return ((e = Jc()), (Na[(e + 0) >> 1] = 2), 0);
                  case 13:
                  case 14:
                    return 0;
                }
                return -28;
              } catch (h) {
                if ('undefined' == typeof W || 'ErrnoError' !== h.name) throw h;
                return -h.Pa;
              }
            },
            g: function (a, b) {
              try {
                var c = T(a),
                  d = c.node,
                  e = c.Ma.Ta;
                a = e ? c : d;
                e ??= d.La.Ta;
                Sb(e);
                var h = e(a);
                return Hc(b, h);
              } catch (k) {
                if ('undefined' == typeof W || 'ErrnoError' !== k.name) throw k;
                return -k.Pa;
              }
            },
            H: function (a, b) {
              b = -9007199254740992 > b || 9007199254740992 < b ? NaN : Number(b);
              try {
                if (isNaN(b)) return 61;
                var c = T(a);
                if (0 > b || 0 === (c.flags & 2097155)) throw new N(28);
                cc(c, c.node, b);
                return 0;
              } catch (d) {
                if ('undefined' == typeof W || 'ErrnoError' !== d.name) throw d;
                return -d.Pa;
              }
            },
            G: function (a, b) {
              try {
                if (0 === b) return -28;
                var c = ha('/') + 1;
                if (b < c) return -68;
                u('/', x, a, b);
                return c;
              } catch (d) {
                if ('undefined' == typeof W || 'ErrnoError' !== d.name) throw d;
                return -d.Pa;
              }
            },
            K: function (a, b) {
              try {
                return ((a = a ? B(x, a) : ''), Hc(b, ac(a, true)));
              } catch (c) {
                if ('undefined' == typeof W || 'ErrnoError' !== c.name) throw c;
                return -c.Pa;
              }
            },
            C: function (a, b, c) {
              try {
                return ((b = b ? B(x, b) : ''), (b = Gc(a, b)), U(b, c), 0);
              } catch (d) {
                if ('undefined' == typeof W || 'ErrnoError' !== d.name) throw d;
                return -d.Pa;
              }
            },
            J: function (a, b, c, d) {
              try {
                b = b ? B(x, b) : '';
                var e = d & 256;
                b = Gc(a, b, d & 4096);
                return Hc(c, e ? ac(b, true) : ac(b));
              } catch (h) {
                if ('undefined' == typeof W || 'ErrnoError' !== h.name) throw h;
                return -h.Pa;
              }
            },
            x: function (a, b, c, d) {
              Ic = d;
              try {
                b = b ? B(x, b) : '';
                b = Gc(a, b);
                var e = d ? Jc() : 0;
                return oa(b, c, e).fd;
              } catch (h) {
                if ('undefined' == typeof W || 'ErrnoError' !== h.name) throw h;
                return -h.Pa;
              }
            },
            v: function (a, b, c, d) {
              try {
                b = b ? B(x, b) : '';
                b = Gc(a, b);
                if (0 >= d) return -28;
                var e = S(b).node;
                if (!e) throw new N(44);
                if (!e.La.readlink) throw new N(28);
                var h = e.La.readlink(e);
                var k = Math.min(d, ha(h)),
                  q = p[c + k];
                u(h, x, c, d + 1);
                p[c + k] = q;
                return k;
              } catch (w) {
                if ('undefined' == typeof W || 'ErrnoError' !== w.name) throw w;
                return -w.Pa;
              }
            },
            u: function (a) {
              try {
                return ((a = a ? B(x, a) : ''), $b(a), 0);
              } catch (b) {
                if ('undefined' == typeof W || 'ErrnoError' !== b.name) throw b;
                return -b.Pa;
              }
            },
            f: function (a, b) {
              try {
                return ((a = a ? B(x, a) : ''), Hc(b, ac(a)));
              } catch (c) {
                if ('undefined' == typeof W || 'ErrnoError' !== c.name) throw c;
                return -c.Pa;
              }
            },
            r: function (a, b, c) {
              try {
                return (
                  (b = b ? B(x, b) : ''),
                  (b = Gc(a, b)),
                  0 === c ? za(b) : 512 === c ? $b(b) : Ta('Invalid flags passed to unlinkat'),
                  0
                );
              } catch (d) {
                if ('undefined' == typeof W || 'ErrnoError' !== d.name) throw d;
                return -d.Pa;
              }
            },
            q: function (a, b, c) {
              try {
                b = b ? B(x, b) : '';
                b = Gc(a, b, true);
                var d = Date.now(),
                  e,
                  h;
                if (c) {
                  var k = F[c >> 2] + 4294967296 * E[(c + 4) >> 2],
                    q = E[(c + 8) >> 2];
                  1073741823 == q
                    ? (e = d)
                    : 1073741822 == q
                      ? (e = null)
                      : (e = 1e3 * k + q / 1e6);
                  c += 16;
                  k = F[c >> 2] + 4294967296 * E[(c + 4) >> 2];
                  q = E[(c + 8) >> 2];
                  1073741823 == q
                    ? (h = d)
                    : 1073741822 == q
                      ? (h = null)
                      : (h = 1e3 * k + q / 1e6);
                } else h = e = d;
                if (null !== (h ?? e)) {
                  a = e;
                  var w = S(b, { $a: true }).node;
                  Sb(w.La.Ua)(w, { atime: a, mtime: h });
                }
                return 0;
              } catch (v) {
                if ('undefined' == typeof W || 'ErrnoError' !== v.name) throw v;
                return -v.Pa;
              }
            },
            m: () => Ta(''),
            l: () => {
              cb = false;
              Kc = 0;
            },
            A: function (a, b) {
              a = -9007199254740992 > a || 9007199254740992 < a ? NaN : Number(a);
              a = new Date(1e3 * a);
              E[b >> 2] = a.getSeconds();
              E[(b + 4) >> 2] = a.getMinutes();
              E[(b + 8) >> 2] = a.getHours();
              E[(b + 12) >> 2] = a.getDate();
              E[(b + 16) >> 2] = a.getMonth();
              E[(b + 20) >> 2] = a.getFullYear() - 1900;
              E[(b + 24) >> 2] = a.getDay();
              var c = a.getFullYear();
              E[(b + 28) >> 2] =
                ((0 !== c % 4 || (0 === c % 100 && 0 !== c % 400) ? Mc : Lc)[a.getMonth()] +
                  a.getDate() -
                  1) |
                0;
              E[(b + 36) >> 2] = -(60 * a.getTimezoneOffset());
              c = new Date(a.getFullYear(), 6, 1).getTimezoneOffset();
              var d = new Date(a.getFullYear(), 0, 1).getTimezoneOffset();
              E[(b + 32) >> 2] = (c != d && a.getTimezoneOffset() == Math.min(d, c)) | 0;
            },
            y: function (a, b, c, d, e, h, k) {
              e = -9007199254740992 > e || 9007199254740992 < e ? NaN : Number(e);
              try {
                if (isNaN(e)) return 61;
                var q = T(d);
                if (0 !== (b & 2) && 0 === (c & 2) && 2 !== (q.flags & 2097155)) throw new N(2);
                if (1 === (q.flags & 2097155)) throw new N(2);
                if (!q.Ma.ib) throw new N(43);
                if (!a) throw new N(28);
                var w = q.Ma.ib(q, a, e, b, c);
                var v = w.Kb;
                E[h >> 2] = w.Ab;
                F[k >> 2] = v;
                return 0;
              } catch (C) {
                if ('undefined' == typeof W || 'ErrnoError' !== C.name) throw C;
                return -C.Pa;
              }
            },
            z: function (a, b, c, d, e, h) {
              h = -9007199254740992 > h || 9007199254740992 < h ? NaN : Number(h);
              try {
                var k = T(e);
                if (c & 2) {
                  c = h;
                  if (32768 !== (k.node.mode & 61440)) throw new N(43);
                  if (!(d & 2)) {
                    var q = x.slice(a, a + b);
                    k.Ma.jb && k.Ma.jb(k, q, c, b, d);
                  }
                }
              } catch (w) {
                if ('undefined' == typeof W || 'ErrnoError' !== w.name) throw w;
                return -w.Pa;
              }
            },
            n: (a, b) => {
              Nc[a] && (clearTimeout(Nc[a].id), delete Nc[a]);
              if (!b) return 0;
              var c = setTimeout(() => {
                delete Nc[a];
                Pc(() => Wc(a, performance.now()));
              }, b);
              Nc[a] = {
                id: c,
                Xb: b,
              };
              return 0;
            },
            B: (a, b, c, d) => {
              var e = /* @__PURE__ */ new Date().getFullYear(),
                h = new Date(e, 0, 1).getTimezoneOffset();
              e = new Date(e, 6, 1).getTimezoneOffset();
              F[a >> 2] = 60 * Math.max(h, e);
              E[b >> 2] = Number(h != e);
              b = (k) => {
                var q = Math.abs(k);
                return `UTC${0 <= k ? '-' : '+'}${String(Math.floor(q / 60)).padStart(2, '0')}${String(q % 60).padStart(2, '0')}`;
              };
              a = b(h);
              b = b(e);
              e < h ? (u(a, x, c, 17), u(b, x, d, 17)) : (u(a, x, d, 17), u(b, x, c, 17));
            },
            d: () => Date.now(),
            s: () => 2147483648,
            c: () => performance.now(),
            o: (a) => {
              var b = x.length;
              a >>>= 0;
              if (2147483648 < a) return false;
              for (var c = 1; 4 >= c; c *= 2) {
                var d = b * (1 + 0.2 / c);
                d = Math.min(d, a + 100663296);
                a: {
                  d =
                    ((Math.min(2147483648, 65536 * Math.ceil(Math.max(a, d) / 65536)) -
                      Ka.buffer.byteLength +
                      65535) /
                      65536) |
                    0;
                  try {
                    Ka.grow(d);
                    Qa();
                    var e = 1;
                    break a;
                  } catch (h) {}
                  e = void 0;
                }
                if (e) return true;
              }
              return false;
            },
            E: (a, b) => {
              var c = 0;
              Sc().forEach((d, e) => {
                var h = b + c;
                e = F[(a + 4 * e) >> 2] = h;
                for (h = 0; h < d.length; ++h) p[e++] = d.charCodeAt(h);
                p[e] = 0;
                c += d.length + 1;
              });
              return 0;
            },
            F: (a, b) => {
              var c = Sc();
              F[a >> 2] = c.length;
              var d = 0;
              c.forEach((e) => (d += e.length + 1));
              F[b >> 2] = d;
              return 0;
            },
            e: function (a) {
              try {
                var b = T(a);
                qa(b);
                return 0;
              } catch (c) {
                if ('undefined' == typeof W || 'ErrnoError' !== c.name) throw c;
                return c.Pa;
              }
            },
            p: function (a, b) {
              try {
                var c = T(a);
                p[b] = c.tty ? 2 : P(c.mode) ? 3 : 40960 === (c.mode & 61440) ? 7 : 4;
                Na[(b + 2) >> 1] = 0;
                H[(b + 8) >> 3] = BigInt(0);
                H[(b + 16) >> 3] = BigInt(0);
                return 0;
              } catch (d) {
                if ('undefined' == typeof W || 'ErrnoError' !== d.name) throw d;
                return d.Pa;
              }
            },
            w: function (a, b, c, d) {
              try {
                a: {
                  var e = T(a);
                  a = b;
                  for (var h, k = (b = 0); k < c; k++) {
                    var q = F[a >> 2],
                      w = F[(a + 4) >> 2];
                    a += 8;
                    var v = Ec(e, p, q, w, h);
                    if (0 > v) {
                      var C = -1;
                      break a;
                    }
                    b += v;
                    if (v < w) break;
                    'undefined' != typeof h && (h += v);
                  }
                  C = b;
                }
                F[d >> 2] = C;
                return 0;
              } catch (G) {
                if ('undefined' == typeof W || 'ErrnoError' !== G.name) throw G;
                return G.Pa;
              }
            },
            D: function (a, b, c, d) {
              b = -9007199254740992 > b || 9007199254740992 < b ? NaN : Number(b);
              try {
                if (isNaN(b)) return 61;
                var e = T(a);
                mc(e, b, c);
                H[d >> 3] = BigInt(e.position);
                e.ob && 0 === b && 0 === c && (e.ob = null);
                return 0;
              } catch (h) {
                if ('undefined' == typeof W || 'ErrnoError' !== h.name) throw h;
                return h.Pa;
              }
            },
            I: function (a) {
              try {
                var b = T(a);
                return b.Ma?.fsync ? b.Ma.fsync(b) : 0;
              } catch (c) {
                if ('undefined' == typeof W || 'ErrnoError' !== c.name) throw c;
                return c.Pa;
              }
            },
            t: function (a, b, c, d) {
              try {
                a: {
                  var e = T(a);
                  a = b;
                  for (var h, k = (b = 0); k < c; k++) {
                    var q = F[a >> 2],
                      w = F[(a + 4) >> 2];
                    a += 8;
                    var v = pa(e, p, q, w, h);
                    if (0 > v) {
                      var C = -1;
                      break a;
                    }
                    b += v;
                    if (v < w) break;
                    'undefined' != typeof h && (h += v);
                  }
                  C = b;
                }
                F[d >> 2] = C;
                return 0;
              } catch (G) {
                if ('undefined' == typeof W || 'ErrnoError' !== G.name) throw G;
                return G.Pa;
              }
            },
            k: Oc,
          },
          Z;
        (async function () {
          function a(c) {
            Z = c.exports;
            Ka = Z.M;
            Qa();
            Y = Z.O;
            K--;
            f.monitorRunDependencies?.(K);
            0 == K && Sa && ((c = Sa), (Sa = null), c());
            return Z;
          }
          K++;
          f.monitorRunDependencies?.(K);
          var b = { a: Xc };
          if (f.instantiateWasm)
            return new Promise((c) => {
              f.instantiateWasm(b, (d, e) => {
                a(d, e);
                c(d.exports);
              });
            });
          Ua ??= f.locateFile ? f.locateFile('sql-wasm.wasm', D) : D + 'sql-wasm.wasm';
          return a((await Xa(b)).instance);
        })();
        f._sqlite3_free = (a) => (f._sqlite3_free = Z.P)(a);
        f._sqlite3_value_text = (a) => (f._sqlite3_value_text = Z.Q)(a);
        f._sqlite3_prepare_v2 = (a, b, c, d, e) => (f._sqlite3_prepare_v2 = Z.R)(a, b, c, d, e);
        f._sqlite3_step = (a) => (f._sqlite3_step = Z.S)(a);
        f._sqlite3_reset = (a) => (f._sqlite3_reset = Z.T)(a);
        f._sqlite3_exec = (a, b, c, d, e) => (f._sqlite3_exec = Z.U)(a, b, c, d, e);
        f._sqlite3_finalize = (a) => (f._sqlite3_finalize = Z.V)(a);
        f._sqlite3_column_name = (a, b) => (f._sqlite3_column_name = Z.W)(a, b);
        f._sqlite3_column_text = (a, b) => (f._sqlite3_column_text = Z.X)(a, b);
        f._sqlite3_column_type = (a, b) => (f._sqlite3_column_type = Z.Y)(a, b);
        f._sqlite3_errmsg = (a) => (f._sqlite3_errmsg = Z.Z)(a);
        f._sqlite3_clear_bindings = (a) => (f._sqlite3_clear_bindings = Z._)(a);
        f._sqlite3_value_blob = (a) => (f._sqlite3_value_blob = Z.$)(a);
        f._sqlite3_value_bytes = (a) => (f._sqlite3_value_bytes = Z.aa)(a);
        f._sqlite3_value_double = (a) => (f._sqlite3_value_double = Z.ba)(a);
        f._sqlite3_value_int = (a) => (f._sqlite3_value_int = Z.ca)(a);
        f._sqlite3_value_type = (a) => (f._sqlite3_value_type = Z.da)(a);
        f._sqlite3_result_blob = (a, b, c, d) => (f._sqlite3_result_blob = Z.ea)(a, b, c, d);
        f._sqlite3_result_double = (a, b) => (f._sqlite3_result_double = Z.fa)(a, b);
        f._sqlite3_result_error = (a, b, c) => (f._sqlite3_result_error = Z.ga)(a, b, c);
        f._sqlite3_result_int = (a, b) => (f._sqlite3_result_int = Z.ha)(a, b);
        f._sqlite3_result_int64 = (a, b) => (f._sqlite3_result_int64 = Z.ia)(a, b);
        f._sqlite3_result_null = (a) => (f._sqlite3_result_null = Z.ja)(a);
        f._sqlite3_result_text = (a, b, c, d) => (f._sqlite3_result_text = Z.ka)(a, b, c, d);
        f._sqlite3_aggregate_context = (a, b) => (f._sqlite3_aggregate_context = Z.la)(a, b);
        f._sqlite3_column_count = (a) => (f._sqlite3_column_count = Z.ma)(a);
        f._sqlite3_data_count = (a) => (f._sqlite3_data_count = Z.na)(a);
        f._sqlite3_column_blob = (a, b) => (f._sqlite3_column_blob = Z.oa)(a, b);
        f._sqlite3_column_bytes = (a, b) => (f._sqlite3_column_bytes = Z.pa)(a, b);
        f._sqlite3_column_double = (a, b) => (f._sqlite3_column_double = Z.qa)(a, b);
        f._sqlite3_bind_blob = (a, b, c, d, e) => (f._sqlite3_bind_blob = Z.ra)(a, b, c, d, e);
        f._sqlite3_bind_double = (a, b, c) => (f._sqlite3_bind_double = Z.sa)(a, b, c);
        f._sqlite3_bind_int = (a, b, c) => (f._sqlite3_bind_int = Z.ta)(a, b, c);
        f._sqlite3_bind_text = (a, b, c, d, e) => (f._sqlite3_bind_text = Z.ua)(a, b, c, d, e);
        f._sqlite3_bind_parameter_index = (a, b) => (f._sqlite3_bind_parameter_index = Z.va)(a, b);
        f._sqlite3_sql = (a) => (f._sqlite3_sql = Z.wa)(a);
        f._sqlite3_normalized_sql = (a) => (f._sqlite3_normalized_sql = Z.xa)(a);
        f._sqlite3_changes = (a) => (f._sqlite3_changes = Z.ya)(a);
        f._sqlite3_close_v2 = (a) => (f._sqlite3_close_v2 = Z.za)(a);
        f._sqlite3_create_function_v2 = (a, b, c, d, e, h, k, q, w) =>
          (f._sqlite3_create_function_v2 = Z.Aa)(a, b, c, d, e, h, k, q, w);
        f._sqlite3_update_hook = (a, b, c) => (f._sqlite3_update_hook = Z.Ba)(a, b, c);
        f._sqlite3_open = (a, b) => (f._sqlite3_open = Z.Ca)(a, b);
        var ia = (f._malloc = (a) => (ia = f._malloc = Z.Da)(a)),
          fa = (f._free = (a) => (fa = f._free = Z.Ea)(a));
        f._RegisterExtensionFunctions = (a) => (f._RegisterExtensionFunctions = Z.Fa)(a);
        var Db = (a, b) => (Db = Z.Ga)(a, b),
          Wc = (a, b) => (Wc = Z.Ha)(a, b),
          wa = (a) => (wa = Z.Ia)(a),
          z = (a) => (z = Z.Ja)(a),
          sa = () => (sa = Z.Ka)();
        f.stackSave = () => sa();
        f.stackRestore = (a) => wa(a);
        f.stackAlloc = (a) => z(a);
        f.cwrap = (a, b, c, d) => {
          var e = !c || c.every((h) => 'number' === h || 'boolean' === h);
          return 'string' !== b && e && !d ? f['_' + a] : (...h) => Tc(a, b, c, h);
        };
        f.addFunction = Aa;
        f.removeFunction = A;
        f.UTF8ToString = ua;
        f.ALLOC_NORMAL = ea;
        f.allocate = da;
        f.allocateUTF8OnStack = xa;
        function Yc() {
          function a() {
            f.calledRun = true;
            if (!La) {
              if (!f.noFSInit && !Ib) {
                var b, c;
                Ib = true;
                d ??= f.stdin;
                b ??= f.stdout;
                c ??= f.stderr;
                d ? V('stdin', d) : Zb('/dev/tty', '/dev/stdin');
                b ? V('stdout', null, b) : Zb('/dev/tty', '/dev/stdout');
                c ? V('stderr', null, c) : Zb('/dev/tty1', '/dev/stderr');
                oa('/dev/stdin', 0);
                oa('/dev/stdout', 1);
                oa('/dev/stderr', 1);
              }
              Z.N();
              Jb = false;
              f.onRuntimeInitialized?.();
              if (f.postRun)
                for (
                  'function' == typeof f.postRun && (f.postRun = [f.postRun]);
                  f.postRun.length;

                ) {
                  var d = f.postRun.shift();
                  $a.unshift(d);
                }
              Za($a);
            }
          }
          if (0 < K) Sa = Yc;
          else {
            if (f.preRun)
              for ('function' == typeof f.preRun && (f.preRun = [f.preRun]); f.preRun.length; )
                bb();
            Za(ab);
            0 < K
              ? (Sa = Yc)
              : f.setStatus
                ? (f.setStatus('Running...'),
                  setTimeout(() => {
                    setTimeout(() => f.setStatus(''), 1);
                    a();
                  }, 1))
                : a();
          }
        }
        if (f.preInit)
          for ('function' == typeof f.preInit && (f.preInit = [f.preInit]); 0 < f.preInit.length; )
            f.preInit.pop()();
        Yc();
        return Module;
      });
      return initSqlJsPromise;
    };
    if (typeof exports === 'object' && typeof module === 'object') {
      module.exports = initSqlJs;
      module.exports.default = initSqlJs;
    } else if (typeof define === 'function' && define['amd']) {
      define([], function () {
        return initSqlJs;
      });
    } else if (typeof exports === 'object') {
      exports['Module'] = initSqlJs;
    }
  },
});

// node_modules/xstate/dev/dist/xstate-dev.esm.js
function getGlobal() {
  if (typeof globalThis !== 'undefined') {
    return globalThis;
  }
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global !== 'undefined') {
    return global;
  }
}
function getDevTools() {
  const w = getGlobal();
  if (w.__xstate__) {
    return w.__xstate__;
  }
  return void 0;
}
var devToolsAdapter;
var init_xstate_dev_esm = __esm({
  'node_modules/xstate/dev/dist/xstate-dev.esm.js'() {
    devToolsAdapter = (service) => {
      if (typeof window === 'undefined') {
        return;
      }
      const devTools = getDevTools();
      if (devTools) {
        devTools.register(service);
      }
    };
  },
});

// node_modules/xstate/dist/raise-9ad1c5c6.esm.js
function createAfterEvent(delayRef, id) {
  return {
    type: `xstate.after.${delayRef}.${id}`,
  };
}
function createDoneStateEvent(id, output) {
  return {
    type: `xstate.done.state.${id}`,
    output,
  };
}
function createDoneActorEvent(invokeId, output) {
  return {
    type: `xstate.done.actor.${invokeId}`,
    output,
    actorId: invokeId,
  };
}
function createErrorActorEvent(id, error) {
  return {
    type: `xstate.error.actor.${id}`,
    error,
    actorId: id,
  };
}
function createInitEvent(input) {
  return {
    type: XSTATE_INIT,
    input,
  };
}
function reportUnhandledError(err) {
  setTimeout(() => {
    throw err;
  });
}
function matchesState(parentStateId, childStateId) {
  const parentStateValue = toStateValue(parentStateId);
  const childStateValue = toStateValue(childStateId);
  if (typeof childStateValue === 'string') {
    if (typeof parentStateValue === 'string') {
      return childStateValue === parentStateValue;
    }
    return false;
  }
  if (typeof parentStateValue === 'string') {
    return parentStateValue in childStateValue;
  }
  return Object.keys(parentStateValue).every((key2) => {
    if (!(key2 in childStateValue)) {
      return false;
    }
    return matchesState(parentStateValue[key2], childStateValue[key2]);
  });
}
function toStatePath(stateId) {
  if (isArray2(stateId)) {
    return stateId;
  }
  const result = [];
  let segment = '';
  for (let i = 0; i < stateId.length; i++) {
    const char = stateId.charCodeAt(i);
    switch (char) {
      // \
      case 92:
        segment += stateId[i + 1];
        i++;
        continue;
      // .
      case 46:
        result.push(segment);
        segment = '';
        continue;
    }
    segment += stateId[i];
  }
  result.push(segment);
  return result;
}
function toStateValue(stateValue) {
  if (isMachineSnapshot(stateValue)) {
    return stateValue.value;
  }
  if (typeof stateValue !== 'string') {
    return stateValue;
  }
  const statePath = toStatePath(stateValue);
  return pathToStateValue(statePath);
}
function pathToStateValue(statePath) {
  if (statePath.length === 1) {
    return statePath[0];
  }
  const value = {};
  let marker = value;
  for (let i = 0; i < statePath.length - 1; i++) {
    if (i === statePath.length - 2) {
      marker[statePath[i]] = statePath[i + 1];
    } else {
      const previous = marker;
      marker = {};
      previous[statePath[i]] = marker;
    }
  }
  return value;
}
function mapValues(collection, iteratee) {
  const result = {};
  const collectionKeys = Object.keys(collection);
  for (let i = 0; i < collectionKeys.length; i++) {
    const key2 = collectionKeys[i];
    result[key2] = iteratee(collection[key2], key2, collection, i);
  }
  return result;
}
function toArrayStrict(value) {
  if (isArray2(value)) {
    return value;
  }
  return [value];
}
function toArray2(value) {
  if (value === void 0) {
    return [];
  }
  return toArrayStrict(value);
}
function resolveOutput(mapper, context, event2, self3) {
  if (typeof mapper === 'function') {
    return mapper({
      context,
      event: event2,
      self: self3,
    });
  }
  return mapper;
}
function isArray2(value) {
  return Array.isArray(value);
}
function isErrorActorEvent(event2) {
  return event2.type.startsWith('xstate.error.actor');
}
function toTransitionConfigArray(configLike) {
  return toArrayStrict(configLike).map((transitionLike) => {
    if (typeof transitionLike === 'undefined' || typeof transitionLike === 'string') {
      return {
        target: transitionLike,
      };
    }
    return transitionLike;
  });
}
function normalizeTarget(target) {
  if (target === void 0 || target === TARGETLESS_KEY) {
    return void 0;
  }
  return toArray2(target);
}
function toObserver(nextHandler, errorHandler, completionHandler) {
  const isObserver = typeof nextHandler === 'object';
  const self3 = isObserver ? nextHandler : void 0;
  return {
    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self3),
    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self3),
    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(self3),
  };
}
function createInvokeId(stateNodeId, index2) {
  return `${index2}.${stateNodeId}`;
}
function resolveReferencedActor(machine, src) {
  const match = src.match(/^xstate\.invoke\.(\d+)\.(.*)/);
  if (!match) {
    return machine.implementations.actors[src];
  }
  const [, indexStr, nodeId] = match;
  const node = machine.getStateNodeById(nodeId);
  const invokeConfig = node.config.invoke;
  return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig).src;
}
function getAllOwnEventDescriptors(snapshot2) {
  return [.../* @__PURE__ */ new Set([...snapshot2._nodes.flatMap((sn) => sn.ownEvents)])];
}
function createScheduledEventId(actorRef, id) {
  return `${actorRef.sessionId}.${id}`;
}
function createSystem(rootActor, options) {
  const children = /* @__PURE__ */ new Map();
  const keyedActors = /* @__PURE__ */ new Map();
  const reverseKeyedActors = /* @__PURE__ */ new WeakMap();
  const inspectionObservers = /* @__PURE__ */ new Set();
  const timerMap = {};
  const { clock, logger: logger4 } = options;
  const scheduler = {
    schedule: (source2, target, event2, delay2, id = Math.random().toString(36).slice(2)) => {
      const scheduledEvent = {
        source: source2,
        target,
        event: event2,
        delay: delay2,
        id,
        startedAt: Date.now(),
      };
      const scheduledEventId = createScheduledEventId(source2, id);
      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;
      const timeout = clock.setTimeout(() => {
        delete timerMap[scheduledEventId];
        delete system._snapshot._scheduledEvents[scheduledEventId];
        system._relay(source2, target, event2);
      }, delay2);
      timerMap[scheduledEventId] = timeout;
    },
    cancel: (source2, id) => {
      const scheduledEventId = createScheduledEventId(source2, id);
      const timeout = timerMap[scheduledEventId];
      delete timerMap[scheduledEventId];
      delete system._snapshot._scheduledEvents[scheduledEventId];
      if (timeout !== void 0) {
        clock.clearTimeout(timeout);
      }
    },
    cancelAll: (actorRef) => {
      for (const scheduledEventId in system._snapshot._scheduledEvents) {
        const scheduledEvent = system._snapshot._scheduledEvents[scheduledEventId];
        if (scheduledEvent.source === actorRef) {
          scheduler.cancel(actorRef, scheduledEvent.id);
        }
      }
    },
  };
  const sendInspectionEvent = (event2) => {
    if (!inspectionObservers.size) {
      return;
    }
    const resolvedInspectionEvent = {
      ...event2,
      rootId: rootActor.sessionId,
    };
    inspectionObservers.forEach((observer) => observer.next?.(resolvedInspectionEvent));
  };
  const system = {
    _snapshot: {
      _scheduledEvents: (options?.snapshot && options.snapshot.scheduler) ?? {},
    },
    _bookId: () => `x:${idCounter++}`,
    _register: (sessionId, actorRef) => {
      children.set(sessionId, actorRef);
      return sessionId;
    },
    _unregister: (actorRef) => {
      children.delete(actorRef.sessionId);
      const systemId = reverseKeyedActors.get(actorRef);
      if (systemId !== void 0) {
        keyedActors.delete(systemId);
        reverseKeyedActors.delete(actorRef);
      }
    },
    get: (systemId) => {
      return keyedActors.get(systemId);
    },
    getAll: () => {
      return Object.fromEntries(keyedActors.entries());
    },
    _set: (systemId, actorRef) => {
      const existing = keyedActors.get(systemId);
      if (existing && existing !== actorRef) {
        throw new Error(`Actor with system ID '${systemId}' already exists.`);
      }
      keyedActors.set(systemId, actorRef);
      reverseKeyedActors.set(actorRef, systemId);
    },
    inspect: (observerOrFn) => {
      const observer = toObserver(observerOrFn);
      inspectionObservers.add(observer);
      return {
        unsubscribe() {
          inspectionObservers.delete(observer);
        },
      };
    },
    _sendInspectionEvent: sendInspectionEvent,
    _relay: (source2, target, event2) => {
      system._sendInspectionEvent({
        type: '@xstate.event',
        sourceRef: source2,
        actorRef: target,
        event: event2,
      });
      target._send(event2);
    },
    scheduler,
    getSnapshot: () => {
      return {
        _scheduledEvents: {
          ...system._snapshot._scheduledEvents,
        },
      };
    },
    start: () => {
      const scheduledEvents = system._snapshot._scheduledEvents;
      system._snapshot._scheduledEvents = {};
      for (const scheduledId in scheduledEvents) {
        const {
          source: source2,
          target,
          event: event2,
          delay: delay2,
          id,
        } = scheduledEvents[scheduledId];
        scheduler.schedule(source2, target, event2, delay2, id);
      }
    },
    _clock: clock,
    _logger: logger4,
  };
  return system;
}
function createActor(logic, ...[options]) {
  return new Actor(logic, options);
}
function resolveCancel(_, snapshot2, actionArgs, actionParams, { sendId }) {
  const resolvedSendId = typeof sendId === 'function' ? sendId(actionArgs, actionParams) : sendId;
  return [
    snapshot2,
    {
      sendId: resolvedSendId,
    },
    void 0,
  ];
}
function executeCancel(actorScope, params) {
  actorScope.defer(() => {
    actorScope.system.scheduler.cancel(actorScope.self, params.sendId);
  });
}
function cancel(sendId) {
  function cancel2(_args, _params) {}
  cancel2.type = 'xstate.cancel';
  cancel2.sendId = sendId;
  cancel2.resolve = resolveCancel;
  cancel2.execute = executeCancel;
  return cancel2;
}
function resolveSpawn(
  actorScope,
  snapshot2,
  actionArgs,
  _actionParams,
  { id, systemId, src, input, syncSnapshot }
) {
  const logic = typeof src === 'string' ? resolveReferencedActor(snapshot2.machine, src) : src;
  const resolvedId = typeof id === 'function' ? id(actionArgs) : id;
  let actorRef;
  let resolvedInput = void 0;
  if (logic) {
    resolvedInput =
      typeof input === 'function'
        ? input({
            context: snapshot2.context,
            event: actionArgs.event,
            self: actorScope.self,
          })
        : input;
    actorRef = createActor(logic, {
      id: resolvedId,
      src,
      parent: actorScope.self,
      syncSnapshot,
      systemId,
      input: resolvedInput,
    });
  }
  return [
    cloneMachineSnapshot(snapshot2, {
      children: {
        ...snapshot2.children,
        [resolvedId]: actorRef,
      },
    }),
    {
      id,
      systemId,
      actorRef,
      src,
      input: resolvedInput,
    },
    void 0,
  ];
}
function executeSpawn(actorScope, { actorRef }) {
  if (!actorRef) {
    return;
  }
  actorScope.defer(() => {
    if (actorRef._processingStatus === ProcessingStatus.Stopped) {
      return;
    }
    actorRef.start();
  });
}
function spawnChild(...[src, { id, systemId, input, syncSnapshot = false } = {}]) {
  function spawnChild2(_args, _params) {}
  spawnChild2.type = 'xstate.spawnChild';
  spawnChild2.id = id;
  spawnChild2.systemId = systemId;
  spawnChild2.src = src;
  spawnChild2.input = input;
  spawnChild2.syncSnapshot = syncSnapshot;
  spawnChild2.resolve = resolveSpawn;
  spawnChild2.execute = executeSpawn;
  return spawnChild2;
}
function resolveStop(_, snapshot2, args, actionParams, { actorRef }) {
  const actorRefOrString = typeof actorRef === 'function' ? actorRef(args, actionParams) : actorRef;
  const resolvedActorRef =
    typeof actorRefOrString === 'string' ? snapshot2.children[actorRefOrString] : actorRefOrString;
  let children = snapshot2.children;
  if (resolvedActorRef) {
    children = {
      ...children,
    };
    delete children[resolvedActorRef.id];
  }
  return [
    cloneMachineSnapshot(snapshot2, {
      children,
    }),
    resolvedActorRef,
    void 0,
  ];
}
function executeStop(actorScope, actorRef) {
  if (!actorRef) {
    return;
  }
  actorScope.system._unregister(actorRef);
  if (actorRef._processingStatus !== ProcessingStatus.Running) {
    actorScope.stopChild(actorRef);
    return;
  }
  actorScope.defer(() => {
    actorScope.stopChild(actorRef);
  });
}
function stopChild(actorRef) {
  function stop2(_args, _params) {}
  stop2.type = 'xstate.stopChild';
  stop2.actorRef = actorRef;
  stop2.resolve = resolveStop;
  stop2.execute = executeStop;
  return stop2;
}
function checkStateIn(snapshot2, _, { stateValue }) {
  if (typeof stateValue === 'string' && isStateId(stateValue)) {
    const target = snapshot2.machine.getStateNodeById(stateValue);
    return snapshot2._nodes.some((sn) => sn === target);
  }
  return snapshot2.matches(stateValue);
}
function stateIn(stateValue) {
  function stateIn2() {
    return false;
  }
  stateIn2.check = checkStateIn;
  stateIn2.stateValue = stateValue;
  return stateIn2;
}
function checkNot(snapshot2, { context, event: event2 }, { guards }) {
  return !evaluateGuard(guards[0], context, event2, snapshot2);
}
function not(guard) {
  function not2(_args, _params) {
    return false;
  }
  not2.check = checkNot;
  not2.guards = [guard];
  return not2;
}
function checkAnd(snapshot2, { context, event: event2 }, { guards }) {
  return guards.every((guard) => evaluateGuard(guard, context, event2, snapshot2));
}
function and(guards) {
  function and2(_args, _params) {
    return false;
  }
  and2.check = checkAnd;
  and2.guards = guards;
  return and2;
}
function checkOr(snapshot2, { context, event: event2 }, { guards }) {
  return guards.some((guard) => evaluateGuard(guard, context, event2, snapshot2));
}
function or(guards) {
  function or2(_args, _params) {
    return false;
  }
  or2.check = checkOr;
  or2.guards = guards;
  return or2;
}
function evaluateGuard(guard, context, event2, snapshot2) {
  const { machine } = snapshot2;
  const isInline = typeof guard === 'function';
  const resolved = isInline
    ? guard
    : machine.implementations.guards[typeof guard === 'string' ? guard : guard.type];
  if (!isInline && !resolved) {
    throw new Error(
      `Guard '${typeof guard === 'string' ? guard : guard.type}' is not implemented.'.`
    );
  }
  if (typeof resolved !== 'function') {
    return evaluateGuard(resolved, context, event2, snapshot2);
  }
  const guardArgs = {
    context,
    event: event2,
  };
  const guardParams =
    isInline || typeof guard === 'string'
      ? void 0
      : 'params' in guard
        ? typeof guard.params === 'function'
          ? guard.params({
              context,
              event: event2,
            })
          : guard.params
        : void 0;
  if (!('check' in resolved)) {
    return resolved(guardArgs, guardParams);
  }
  const builtinGuard = resolved;
  return builtinGuard.check(
    snapshot2,
    guardArgs,
    resolved
    // this holds all params
  );
}
function getChildren(stateNode) {
  return Object.values(stateNode.states).filter((sn) => sn.type !== 'history');
}
function getProperAncestors(stateNode, toStateNode) {
  const ancestors = [];
  if (toStateNode === stateNode) {
    return ancestors;
  }
  let m = stateNode.parent;
  while (m && m !== toStateNode) {
    ancestors.push(m);
    m = m.parent;
  }
  return ancestors;
}
function getAllStateNodes(stateNodes) {
  const nodeSet = new Set(stateNodes);
  const adjList = getAdjList(nodeSet);
  for (const s of nodeSet) {
    if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s).length)) {
      getInitialStateNodesWithTheirAncestors(s).forEach((sn) => nodeSet.add(sn));
    } else {
      if (s.type === 'parallel') {
        for (const child2 of getChildren(s)) {
          if (child2.type === 'history') {
            continue;
          }
          if (!nodeSet.has(child2)) {
            const initialStates = getInitialStateNodesWithTheirAncestors(child2);
            for (const initialStateNode of initialStates) {
              nodeSet.add(initialStateNode);
            }
          }
        }
      }
    }
  }
  for (const s of nodeSet) {
    let m = s.parent;
    while (m) {
      nodeSet.add(m);
      m = m.parent;
    }
  }
  return nodeSet;
}
function getValueFromAdj(baseNode, adjList) {
  const childStateNodes = adjList.get(baseNode);
  if (!childStateNodes) {
    return {};
  }
  if (baseNode.type === 'compound') {
    const childStateNode = childStateNodes[0];
    if (childStateNode) {
      if (isAtomicStateNode(childStateNode)) {
        return childStateNode.key;
      }
    } else {
      return {};
    }
  }
  const stateValue = {};
  for (const childStateNode of childStateNodes) {
    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);
  }
  return stateValue;
}
function getAdjList(stateNodes) {
  const adjList = /* @__PURE__ */ new Map();
  for (const s of stateNodes) {
    if (!adjList.has(s)) {
      adjList.set(s, []);
    }
    if (s.parent) {
      if (!adjList.has(s.parent)) {
        adjList.set(s.parent, []);
      }
      adjList.get(s.parent).push(s);
    }
  }
  return adjList;
}
function getStateValue(rootNode, stateNodes) {
  const config = getAllStateNodes(stateNodes);
  return getValueFromAdj(rootNode, getAdjList(config));
}
function isInFinalState(stateNodeSet, stateNode) {
  if (stateNode.type === 'compound') {
    return getChildren(stateNode).some((s) => s.type === 'final' && stateNodeSet.has(s));
  }
  if (stateNode.type === 'parallel') {
    return getChildren(stateNode).every((sn) => isInFinalState(stateNodeSet, sn));
  }
  return stateNode.type === 'final';
}
function getCandidates(stateNode, receivedEventType) {
  const candidates =
    stateNode.transitions.get(receivedEventType) ||
    [...stateNode.transitions.keys()]
      .filter((eventDescriptor) => {
        if (eventDescriptor === WILDCARD) {
          return true;
        }
        if (!eventDescriptor.endsWith('.*')) {
          return false;
        }
        const partialEventTokens = eventDescriptor.split('.');
        const eventTokens = receivedEventType.split('.');
        for (let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++) {
          const partialEventToken = partialEventTokens[tokenIndex];
          const eventToken = eventTokens[tokenIndex];
          if (partialEventToken === '*') {
            const isLastToken = tokenIndex === partialEventTokens.length - 1;
            return isLastToken;
          }
          if (partialEventToken !== eventToken) {
            return false;
          }
        }
        return true;
      })
      .sort((a, b) => b.length - a.length)
      .flatMap((key2) => stateNode.transitions.get(key2));
  return candidates;
}
function getDelayedTransitions(stateNode) {
  const afterConfig = stateNode.config.after;
  if (!afterConfig) {
    return [];
  }
  const mutateEntryExit = (delay2) => {
    const afterEvent = createAfterEvent(delay2, stateNode.id);
    const eventType = afterEvent.type;
    stateNode.entry.push(
      raise(afterEvent, {
        id: eventType,
        delay: delay2,
      })
    );
    stateNode.exit.push(cancel(eventType));
    return eventType;
  };
  const delayedTransitions = Object.keys(afterConfig).flatMap((delay2) => {
    const configTransition = afterConfig[delay2];
    const resolvedTransition =
      typeof configTransition === 'string'
        ? {
            target: configTransition,
          }
        : configTransition;
    const resolvedDelay = Number.isNaN(+delay2) ? delay2 : +delay2;
    const eventType = mutateEntryExit(resolvedDelay);
    return toArray2(resolvedTransition).map((transition3) => ({
      ...transition3,
      event: eventType,
      delay: resolvedDelay,
    }));
  });
  return delayedTransitions.map((delayedTransition) => {
    const { delay: delay2 } = delayedTransition;
    return {
      ...formatTransition(stateNode, delayedTransition.event, delayedTransition),
      delay: delay2,
    };
  });
}
function formatTransition(stateNode, descriptor, transitionConfig) {
  const normalizedTarget = normalizeTarget(transitionConfig.target);
  const reenter = transitionConfig.reenter ?? false;
  const target = resolveTarget(stateNode, normalizedTarget);
  const transition3 = {
    ...transitionConfig,
    actions: toArray2(transitionConfig.actions),
    guard: transitionConfig.guard,
    target,
    source: stateNode,
    reenter,
    eventType: descriptor,
    toJSON: () => ({
      ...transition3,
      source: `#${stateNode.id}`,
      target: target ? target.map((t) => `#${t.id}`) : void 0,
    }),
  };
  return transition3;
}
function formatTransitions(stateNode) {
  const transitions = /* @__PURE__ */ new Map();
  if (stateNode.config.on) {
    for (const descriptor of Object.keys(stateNode.config.on)) {
      if (descriptor === NULL_EVENT) {
        throw new Error(
          'Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.'
        );
      }
      const transitionsConfig = stateNode.config.on[descriptor];
      transitions.set(
        descriptor,
        toTransitionConfigArray(transitionsConfig).map((t) =>
          formatTransition(stateNode, descriptor, t)
        )
      );
    }
  }
  if (stateNode.config.onDone) {
    const descriptor = `xstate.done.state.${stateNode.id}`;
    transitions.set(
      descriptor,
      toTransitionConfigArray(stateNode.config.onDone).map((t) =>
        formatTransition(stateNode, descriptor, t)
      )
    );
  }
  for (const invokeDef of stateNode.invoke) {
    if (invokeDef.onDone) {
      const descriptor = `xstate.done.actor.${invokeDef.id}`;
      transitions.set(
        descriptor,
        toTransitionConfigArray(invokeDef.onDone).map((t) =>
          formatTransition(stateNode, descriptor, t)
        )
      );
    }
    if (invokeDef.onError) {
      const descriptor = `xstate.error.actor.${invokeDef.id}`;
      transitions.set(
        descriptor,
        toTransitionConfigArray(invokeDef.onError).map((t) =>
          formatTransition(stateNode, descriptor, t)
        )
      );
    }
    if (invokeDef.onSnapshot) {
      const descriptor = `xstate.snapshot.${invokeDef.id}`;
      transitions.set(
        descriptor,
        toTransitionConfigArray(invokeDef.onSnapshot).map((t) =>
          formatTransition(stateNode, descriptor, t)
        )
      );
    }
  }
  for (const delayedTransition of stateNode.after) {
    let existing = transitions.get(delayedTransition.eventType);
    if (!existing) {
      existing = [];
      transitions.set(delayedTransition.eventType, existing);
    }
    existing.push(delayedTransition);
  }
  return transitions;
}
function formatInitialTransition(stateNode, _target) {
  const resolvedTarget =
    typeof _target === 'string'
      ? stateNode.states[_target]
      : _target
        ? stateNode.states[_target.target]
        : void 0;
  if (!resolvedTarget && _target) {
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string
      `Initial state node "${_target}" not found on parent state node #${stateNode.id}`
    );
  }
  const transition3 = {
    source: stateNode,
    actions: !_target || typeof _target === 'string' ? [] : toArray2(_target.actions),
    eventType: null,
    reenter: false,
    target: resolvedTarget ? [resolvedTarget] : [],
    toJSON: () => ({
      ...transition3,
      source: `#${stateNode.id}`,
      target: resolvedTarget ? [`#${resolvedTarget.id}`] : [],
    }),
  };
  return transition3;
}
function resolveTarget(stateNode, targets) {
  if (targets === void 0) {
    return void 0;
  }
  return targets.map((target) => {
    if (typeof target !== 'string') {
      return target;
    }
    if (isStateId(target)) {
      return stateNode.machine.getStateNodeById(target);
    }
    const isInternalTarget = target[0] === STATE_DELIMITER;
    if (isInternalTarget && !stateNode.parent) {
      return getStateNodeByPath(stateNode, target.slice(1));
    }
    const resolvedTarget = isInternalTarget ? stateNode.key + target : target;
    if (stateNode.parent) {
      try {
        const targetStateNode = getStateNodeByPath(stateNode.parent, resolvedTarget);
        return targetStateNode;
      } catch (err) {
        throw new Error(`Invalid transition definition for state node '${stateNode.id}':
${err.message}`);
      }
    } else {
      throw new Error(
        `Invalid target: "${target}" is not a valid target from the root node. Did you mean ".${target}"?`
      );
    }
  });
}
function resolveHistoryDefaultTransition(stateNode) {
  const normalizedTarget = normalizeTarget(stateNode.config.target);
  if (!normalizedTarget) {
    return stateNode.parent.initial;
  }
  return {
    target: normalizedTarget.map((t) =>
      typeof t === 'string' ? getStateNodeByPath(stateNode.parent, t) : t
    ),
  };
}
function isHistoryNode(stateNode) {
  return stateNode.type === 'history';
}
function getInitialStateNodesWithTheirAncestors(stateNode) {
  const states = getInitialStateNodes(stateNode);
  for (const initialState of states) {
    for (const ancestor of getProperAncestors(initialState, stateNode)) {
      states.add(ancestor);
    }
  }
  return states;
}
function getInitialStateNodes(stateNode) {
  const set2 = /* @__PURE__ */ new Set();
  function iter(descStateNode) {
    if (set2.has(descStateNode)) {
      return;
    }
    set2.add(descStateNode);
    if (descStateNode.type === 'compound') {
      iter(descStateNode.initial.target[0]);
    } else if (descStateNode.type === 'parallel') {
      for (const child2 of getChildren(descStateNode)) {
        iter(child2);
      }
    }
  }
  iter(stateNode);
  return set2;
}
function getStateNode(stateNode, stateKey) {
  if (isStateId(stateKey)) {
    return stateNode.machine.getStateNodeById(stateKey);
  }
  if (!stateNode.states) {
    throw new Error(
      `Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`
    );
  }
  const result = stateNode.states[stateKey];
  if (!result) {
    throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);
  }
  return result;
}
function getStateNodeByPath(stateNode, statePath) {
  if (typeof statePath === 'string' && isStateId(statePath)) {
    try {
      return stateNode.machine.getStateNodeById(statePath);
    } catch {}
  }
  const arrayStatePath = toStatePath(statePath).slice();
  let currentStateNode = stateNode;
  while (arrayStatePath.length) {
    const key2 = arrayStatePath.shift();
    if (!key2.length) {
      break;
    }
    currentStateNode = getStateNode(currentStateNode, key2);
  }
  return currentStateNode;
}
function getStateNodes(stateNode, stateValue) {
  if (typeof stateValue === 'string') {
    const childStateNode = stateNode.states[stateValue];
    if (!childStateNode) {
      throw new Error(`State '${stateValue}' does not exist on '${stateNode.id}'`);
    }
    return [stateNode, childStateNode];
  }
  const childStateKeys = Object.keys(stateValue);
  const childStateNodes = childStateKeys
    .map((subStateKey) => getStateNode(stateNode, subStateKey))
    .filter(Boolean);
  return [stateNode.machine.root, stateNode].concat(
    childStateNodes,
    childStateKeys.reduce((allSubStateNodes, subStateKey) => {
      const subStateNode = getStateNode(stateNode, subStateKey);
      if (!subStateNode) {
        return allSubStateNodes;
      }
      const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);
      return allSubStateNodes.concat(subStateNodes);
    }, [])
  );
}
function transitionAtomicNode(stateNode, stateValue, snapshot2, event2) {
  const childStateNode = getStateNode(stateNode, stateValue);
  const next2 = childStateNode.next(snapshot2, event2);
  if (!next2 || !next2.length) {
    return stateNode.next(snapshot2, event2);
  }
  return next2;
}
function transitionCompoundNode(stateNode, stateValue, snapshot2, event2) {
  const subStateKeys = Object.keys(stateValue);
  const childStateNode = getStateNode(stateNode, subStateKeys[0]);
  const next2 = transitionNode(childStateNode, stateValue[subStateKeys[0]], snapshot2, event2);
  if (!next2 || !next2.length) {
    return stateNode.next(snapshot2, event2);
  }
  return next2;
}
function transitionParallelNode(stateNode, stateValue, snapshot2, event2) {
  const allInnerTransitions = [];
  for (const subStateKey of Object.keys(stateValue)) {
    const subStateValue = stateValue[subStateKey];
    if (!subStateValue) {
      continue;
    }
    const subStateNode = getStateNode(stateNode, subStateKey);
    const innerTransitions = transitionNode(subStateNode, subStateValue, snapshot2, event2);
    if (innerTransitions) {
      allInnerTransitions.push(...innerTransitions);
    }
  }
  if (!allInnerTransitions.length) {
    return stateNode.next(snapshot2, event2);
  }
  return allInnerTransitions;
}
function transitionNode(stateNode, stateValue, snapshot2, event2) {
  if (typeof stateValue === 'string') {
    return transitionAtomicNode(stateNode, stateValue, snapshot2, event2);
  }
  if (Object.keys(stateValue).length === 1) {
    return transitionCompoundNode(stateNode, stateValue, snapshot2, event2);
  }
  return transitionParallelNode(stateNode, stateValue, snapshot2, event2);
}
function getHistoryNodes(stateNode) {
  return Object.keys(stateNode.states)
    .map((key2) => stateNode.states[key2])
    .filter((sn) => sn.type === 'history');
}
function isDescendant(childStateNode, parentStateNode) {
  let marker = childStateNode;
  while (marker.parent && marker.parent !== parentStateNode) {
    marker = marker.parent;
  }
  return marker.parent === parentStateNode;
}
function hasIntersection(s1, s2) {
  const set1 = new Set(s1);
  const set2 = new Set(s2);
  for (const item of set1) {
    if (set2.has(item)) {
      return true;
    }
  }
  for (const item of set2) {
    if (set1.has(item)) {
      return true;
    }
  }
  return false;
}
function removeConflictingTransitions(enabledTransitions, stateNodeSet, historyValue) {
  const filteredTransitions = /* @__PURE__ */ new Set();
  for (const t1 of enabledTransitions) {
    let t1Preempted = false;
    const transitionsToRemove = /* @__PURE__ */ new Set();
    for (const t2 of filteredTransitions) {
      if (
        hasIntersection(
          computeExitSet([t1], stateNodeSet, historyValue),
          computeExitSet([t2], stateNodeSet, historyValue)
        )
      ) {
        if (isDescendant(t1.source, t2.source)) {
          transitionsToRemove.add(t2);
        } else {
          t1Preempted = true;
          break;
        }
      }
    }
    if (!t1Preempted) {
      for (const t3 of transitionsToRemove) {
        filteredTransitions.delete(t3);
      }
      filteredTransitions.add(t1);
    }
  }
  return Array.from(filteredTransitions);
}
function findLeastCommonAncestor(stateNodes) {
  const [head2, ...tail] = stateNodes;
  for (const ancestor of getProperAncestors(head2, void 0)) {
    if (tail.every((sn) => isDescendant(sn, ancestor))) {
      return ancestor;
    }
  }
}
function getEffectiveTargetStates(transition3, historyValue) {
  if (!transition3.target) {
    return [];
  }
  const targets = /* @__PURE__ */ new Set();
  for (const targetNode of transition3.target) {
    if (isHistoryNode(targetNode)) {
      if (historyValue[targetNode.id]) {
        for (const node of historyValue[targetNode.id]) {
          targets.add(node);
        }
      } else {
        for (const node of getEffectiveTargetStates(
          resolveHistoryDefaultTransition(targetNode),
          historyValue
        )) {
          targets.add(node);
        }
      }
    } else {
      targets.add(targetNode);
    }
  }
  return [...targets];
}
function getTransitionDomain(transition3, historyValue) {
  const targetStates = getEffectiveTargetStates(transition3, historyValue);
  if (!targetStates) {
    return;
  }
  if (
    !transition3.reenter &&
    targetStates.every(
      (target) => target === transition3.source || isDescendant(target, transition3.source)
    )
  ) {
    return transition3.source;
  }
  const lca = findLeastCommonAncestor(targetStates.concat(transition3.source));
  if (lca) {
    return lca;
  }
  if (transition3.reenter) {
    return;
  }
  return transition3.source.machine.root;
}
function computeExitSet(transitions, stateNodeSet, historyValue) {
  const statesToExit = /* @__PURE__ */ new Set();
  for (const t of transitions) {
    if (t.target?.length) {
      const domain = getTransitionDomain(t, historyValue);
      if (t.reenter && t.source === domain) {
        statesToExit.add(domain);
      }
      for (const stateNode of stateNodeSet) {
        if (isDescendant(stateNode, domain)) {
          statesToExit.add(stateNode);
        }
      }
    }
  }
  return [...statesToExit];
}
function areStateNodeCollectionsEqual(prevStateNodes, nextStateNodeSet) {
  if (prevStateNodes.length !== nextStateNodeSet.size) {
    return false;
  }
  for (const node of prevStateNodes) {
    if (!nextStateNodeSet.has(node)) {
      return false;
    }
  }
  return true;
}
function microstep(transitions, currentSnapshot, actorScope, event2, isInitial, internalQueue) {
  if (!transitions.length) {
    return currentSnapshot;
  }
  const mutStateNodeSet = new Set(currentSnapshot._nodes);
  let historyValue = currentSnapshot.historyValue;
  const filteredTransitions = removeConflictingTransitions(
    transitions,
    mutStateNodeSet,
    historyValue
  );
  let nextState = currentSnapshot;
  if (!isInitial) {
    [nextState, historyValue] = exitStates(
      nextState,
      event2,
      actorScope,
      filteredTransitions,
      mutStateNodeSet,
      historyValue,
      internalQueue,
      actorScope.actionExecutor
    );
  }
  nextState = resolveActionsAndContext(
    nextState,
    event2,
    actorScope,
    filteredTransitions.flatMap((t) => t.actions),
    internalQueue,
    void 0
  );
  nextState = enterStates(
    nextState,
    event2,
    actorScope,
    filteredTransitions,
    mutStateNodeSet,
    internalQueue,
    historyValue,
    isInitial
  );
  const nextStateNodes = [...mutStateNodeSet];
  if (nextState.status === 'done') {
    nextState = resolveActionsAndContext(
      nextState,
      event2,
      actorScope,
      nextStateNodes.sort((a, b) => b.order - a.order).flatMap((state2) => state2.exit),
      internalQueue,
      void 0
    );
  }
  try {
    if (
      historyValue === currentSnapshot.historyValue &&
      areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)
    ) {
      return nextState;
    }
    return cloneMachineSnapshot(nextState, {
      _nodes: nextStateNodes,
      historyValue,
    });
  } catch (e) {
    throw e;
  }
}
function getMachineOutput(snapshot2, event2, actorScope, rootNode, rootCompletionNode) {
  if (rootNode.output === void 0) {
    return;
  }
  const doneStateEvent = createDoneStateEvent(
    rootCompletionNode.id,
    rootCompletionNode.output !== void 0 && rootCompletionNode.parent
      ? resolveOutput(rootCompletionNode.output, snapshot2.context, event2, actorScope.self)
      : void 0
  );
  return resolveOutput(rootNode.output, snapshot2.context, doneStateEvent, actorScope.self);
}
function enterStates(
  currentSnapshot,
  event2,
  actorScope,
  filteredTransitions,
  mutStateNodeSet,
  internalQueue,
  historyValue,
  isInitial
) {
  let nextSnapshot = currentSnapshot;
  const statesToEnter = /* @__PURE__ */ new Set();
  const statesForDefaultEntry = /* @__PURE__ */ new Set();
  computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter);
  if (isInitial) {
    statesForDefaultEntry.add(currentSnapshot.machine.root);
  }
  const completedNodes = /* @__PURE__ */ new Set();
  for (const stateNodeToEnter of [...statesToEnter].sort((a, b) => a.order - b.order)) {
    mutStateNodeSet.add(stateNodeToEnter);
    const actions2 = [];
    actions2.push(...stateNodeToEnter.entry);
    for (const invokeDef of stateNodeToEnter.invoke) {
      actions2.push(
        spawnChild(invokeDef.src, {
          ...invokeDef,
          syncSnapshot: !!invokeDef.onSnapshot,
        })
      );
    }
    if (statesForDefaultEntry.has(stateNodeToEnter)) {
      const initialActions = stateNodeToEnter.initial.actions;
      actions2.push(...initialActions);
    }
    nextSnapshot = resolveActionsAndContext(
      nextSnapshot,
      event2,
      actorScope,
      actions2,
      internalQueue,
      stateNodeToEnter.invoke.map((invokeDef) => invokeDef.id)
    );
    if (stateNodeToEnter.type === 'final') {
      const parent = stateNodeToEnter.parent;
      let ancestorMarker = parent?.type === 'parallel' ? parent : parent?.parent;
      let rootCompletionNode = ancestorMarker || stateNodeToEnter;
      if (parent?.type === 'compound') {
        internalQueue.push(
          createDoneStateEvent(
            parent.id,
            stateNodeToEnter.output !== void 0
              ? resolveOutput(
                  stateNodeToEnter.output,
                  nextSnapshot.context,
                  event2,
                  actorScope.self
                )
              : void 0
          )
        );
      }
      while (
        ancestorMarker?.type === 'parallel' &&
        !completedNodes.has(ancestorMarker) &&
        isInFinalState(mutStateNodeSet, ancestorMarker)
      ) {
        completedNodes.add(ancestorMarker);
        internalQueue.push(createDoneStateEvent(ancestorMarker.id));
        rootCompletionNode = ancestorMarker;
        ancestorMarker = ancestorMarker.parent;
      }
      if (ancestorMarker) {
        continue;
      }
      nextSnapshot = cloneMachineSnapshot(nextSnapshot, {
        status: 'done',
        output: getMachineOutput(
          nextSnapshot,
          event2,
          actorScope,
          nextSnapshot.machine.root,
          rootCompletionNode
        ),
      });
    }
  }
  return nextSnapshot;
}
function computeEntrySet(transitions, historyValue, statesForDefaultEntry, statesToEnter) {
  for (const t of transitions) {
    const domain = getTransitionDomain(t, historyValue);
    for (const s of t.target || []) {
      if (
        !isHistoryNode(s) && // if the target is different than the source then it will *definitely* be entered
        (t.source !== s || // we know that the domain can't lie within the source
          // if it's different than the source then it's outside of it and it means that the target has to be entered as well
          t.source !== domain || // reentering transitions always enter the target, even if it's the source itself
          t.reenter)
      ) {
        statesToEnter.add(s);
        statesForDefaultEntry.add(s);
      }
      addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);
    }
    const targetStates = getEffectiveTargetStates(t, historyValue);
    for (const s of targetStates) {
      const ancestors = getProperAncestors(s, domain);
      if (domain?.type === 'parallel') {
        ancestors.push(domain);
      }
      addAncestorStatesToEnter(
        statesToEnter,
        historyValue,
        statesForDefaultEntry,
        ancestors,
        !t.source.parent && t.reenter ? void 0 : domain
      );
    }
  }
}
function addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {
  if (isHistoryNode(stateNode)) {
    if (historyValue[stateNode.id]) {
      const historyStateNodes = historyValue[stateNode.id];
      for (const s of historyStateNodes) {
        statesToEnter.add(s);
        addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);
      }
      for (const s of historyStateNodes) {
        addProperAncestorStatesToEnter(
          s,
          stateNode.parent,
          statesToEnter,
          historyValue,
          statesForDefaultEntry
        );
      }
    } else {
      const historyDefaultTransition = resolveHistoryDefaultTransition(stateNode);
      for (const s of historyDefaultTransition.target) {
        statesToEnter.add(s);
        if (historyDefaultTransition === stateNode.parent?.initial) {
          statesForDefaultEntry.add(stateNode.parent);
        }
        addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);
      }
      for (const s of historyDefaultTransition.target) {
        addProperAncestorStatesToEnter(
          s,
          stateNode.parent,
          statesToEnter,
          historyValue,
          statesForDefaultEntry
        );
      }
    }
  } else {
    if (stateNode.type === 'compound') {
      const [initialState] = stateNode.initial.target;
      if (!isHistoryNode(initialState)) {
        statesToEnter.add(initialState);
        statesForDefaultEntry.add(initialState);
      }
      addDescendantStatesToEnter(initialState, historyValue, statesForDefaultEntry, statesToEnter);
      addProperAncestorStatesToEnter(
        initialState,
        stateNode,
        statesToEnter,
        historyValue,
        statesForDefaultEntry
      );
    } else {
      if (stateNode.type === 'parallel') {
        for (const child2 of getChildren(stateNode).filter((sn) => !isHistoryNode(sn))) {
          if (![...statesToEnter].some((s) => isDescendant(s, child2))) {
            if (!isHistoryNode(child2)) {
              statesToEnter.add(child2);
              statesForDefaultEntry.add(child2);
            }
            addDescendantStatesToEnter(child2, historyValue, statesForDefaultEntry, statesToEnter);
          }
        }
      }
    }
  }
}
function addAncestorStatesToEnter(
  statesToEnter,
  historyValue,
  statesForDefaultEntry,
  ancestors,
  reentrancyDomain
) {
  for (const anc of ancestors) {
    if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {
      statesToEnter.add(anc);
    }
    if (anc.type === 'parallel') {
      for (const child2 of getChildren(anc).filter((sn) => !isHistoryNode(sn))) {
        if (![...statesToEnter].some((s) => isDescendant(s, child2))) {
          statesToEnter.add(child2);
          addDescendantStatesToEnter(child2, historyValue, statesForDefaultEntry, statesToEnter);
        }
      }
    }
  }
}
function addProperAncestorStatesToEnter(
  stateNode,
  toStateNode,
  statesToEnter,
  historyValue,
  statesForDefaultEntry
) {
  addAncestorStatesToEnter(
    statesToEnter,
    historyValue,
    statesForDefaultEntry,
    getProperAncestors(stateNode, toStateNode)
  );
}
function exitStates(
  currentSnapshot,
  event2,
  actorScope,
  transitions,
  mutStateNodeSet,
  historyValue,
  internalQueue,
  _actionExecutor
) {
  let nextSnapshot = currentSnapshot;
  const statesToExit = computeExitSet(transitions, mutStateNodeSet, historyValue);
  statesToExit.sort((a, b) => b.order - a.order);
  let changedHistory;
  for (const exitStateNode of statesToExit) {
    for (const historyNode of getHistoryNodes(exitStateNode)) {
      let predicate;
      if (historyNode.history === 'deep') {
        predicate = (sn) => isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);
      } else {
        predicate = (sn) => {
          return sn.parent === exitStateNode;
        };
      }
      changedHistory ??= {
        ...historyValue,
      };
      changedHistory[historyNode.id] = Array.from(mutStateNodeSet).filter(predicate);
    }
  }
  for (const s of statesToExit) {
    nextSnapshot = resolveActionsAndContext(
      nextSnapshot,
      event2,
      actorScope,
      [...s.exit, ...s.invoke.map((def) => stopChild(def.id))],
      internalQueue,
      void 0
    );
    mutStateNodeSet.delete(s);
  }
  return [nextSnapshot, changedHistory || historyValue];
}
function getAction(machine, actionType) {
  return machine.implementations.actions[actionType];
}
function resolveAndExecuteActionsWithContext(
  currentSnapshot,
  event2,
  actorScope,
  actions2,
  extra,
  retries
) {
  const { machine } = currentSnapshot;
  let intermediateSnapshot = currentSnapshot;
  for (const action2 of actions2) {
    const isInline = typeof action2 === 'function';
    const resolvedAction = isInline
      ? action2
      : // the existing type of `.actions` assumes non-nullable `TExpressionAction`
        // it's fine to cast this here to get a common type and lack of errors in the rest of the code
        // our logic below makes sure that we call those 2 "variants" correctly
        getAction(machine, typeof action2 === 'string' ? action2 : action2.type);
    const actionArgs = {
      context: intermediateSnapshot.context,
      event: event2,
      self: actorScope.self,
      system: actorScope.system,
    };
    const actionParams =
      isInline || typeof action2 === 'string'
        ? void 0
        : 'params' in action2
          ? typeof action2.params === 'function'
            ? action2.params({
                context: intermediateSnapshot.context,
                event: event2,
              })
            : action2.params
          : void 0;
    if (!resolvedAction || !('resolve' in resolvedAction)) {
      actorScope.actionExecutor({
        type:
          typeof action2 === 'string'
            ? action2
            : typeof action2 === 'object'
              ? action2.type
              : action2.name || '(anonymous)',
        info: actionArgs,
        params: actionParams,
        exec: resolvedAction,
      });
      continue;
    }
    const builtinAction = resolvedAction;
    const [nextState, params, actions3] = builtinAction.resolve(
      actorScope,
      intermediateSnapshot,
      actionArgs,
      actionParams,
      resolvedAction,
      // this holds all params
      extra
    );
    intermediateSnapshot = nextState;
    if ('retryResolve' in builtinAction) {
      retries?.push([builtinAction, params]);
    }
    if ('execute' in builtinAction) {
      actorScope.actionExecutor({
        type: builtinAction.type,
        info: actionArgs,
        params,
        exec: builtinAction.execute.bind(null, actorScope, params),
      });
    }
    if (actions3) {
      intermediateSnapshot = resolveAndExecuteActionsWithContext(
        intermediateSnapshot,
        event2,
        actorScope,
        actions3,
        extra,
        retries
      );
    }
  }
  return intermediateSnapshot;
}
function resolveActionsAndContext(
  currentSnapshot,
  event2,
  actorScope,
  actions2,
  internalQueue,
  deferredActorIds
) {
  const retries = deferredActorIds ? [] : void 0;
  const nextState = resolveAndExecuteActionsWithContext(
    currentSnapshot,
    event2,
    actorScope,
    actions2,
    {
      internalQueue,
      deferredActorIds,
    },
    retries
  );
  retries?.forEach(([builtinAction, params]) => {
    builtinAction.retryResolve(actorScope, nextState, params);
  });
  return nextState;
}
function macrostep(snapshot2, event2, actorScope, internalQueue) {
  let nextSnapshot = snapshot2;
  const microstates = [];
  function addMicrostate(microstate, event3, transitions) {
    actorScope.system._sendInspectionEvent({
      type: '@xstate.microstep',
      actorRef: actorScope.self,
      event: event3,
      snapshot: microstate,
      _transitions: transitions,
    });
    microstates.push(microstate);
  }
  if (event2.type === XSTATE_STOP) {
    nextSnapshot = cloneMachineSnapshot(stopChildren(nextSnapshot, event2, actorScope), {
      status: 'stopped',
    });
    addMicrostate(nextSnapshot, event2, []);
    return {
      snapshot: nextSnapshot,
      microstates,
    };
  }
  let nextEvent = event2;
  if (nextEvent.type !== XSTATE_INIT) {
    const currentEvent = nextEvent;
    const isErr = isErrorActorEvent(currentEvent);
    const transitions = selectTransitions(currentEvent, nextSnapshot);
    if (isErr && !transitions.length) {
      nextSnapshot = cloneMachineSnapshot(snapshot2, {
        status: 'error',
        error: currentEvent.error,
      });
      addMicrostate(nextSnapshot, currentEvent, []);
      return {
        snapshot: nextSnapshot,
        microstates,
      };
    }
    nextSnapshot = microstep(
      transitions,
      snapshot2,
      actorScope,
      nextEvent,
      false,
      // isInitial
      internalQueue
    );
    addMicrostate(nextSnapshot, currentEvent, transitions);
  }
  let shouldSelectEventlessTransitions = true;
  while (nextSnapshot.status === 'active') {
    let enabledTransitions = shouldSelectEventlessTransitions
      ? selectEventlessTransitions(nextSnapshot, nextEvent)
      : [];
    const previousState = enabledTransitions.length ? nextSnapshot : void 0;
    if (!enabledTransitions.length) {
      if (!internalQueue.length) {
        break;
      }
      nextEvent = internalQueue.shift();
      enabledTransitions = selectTransitions(nextEvent, nextSnapshot);
    }
    nextSnapshot = microstep(
      enabledTransitions,
      nextSnapshot,
      actorScope,
      nextEvent,
      false,
      internalQueue
    );
    shouldSelectEventlessTransitions = nextSnapshot !== previousState;
    addMicrostate(nextSnapshot, nextEvent, enabledTransitions);
  }
  if (nextSnapshot.status !== 'active') {
    stopChildren(nextSnapshot, nextEvent, actorScope);
  }
  return {
    snapshot: nextSnapshot,
    microstates,
  };
}
function stopChildren(nextState, event2, actorScope) {
  return resolveActionsAndContext(
    nextState,
    event2,
    actorScope,
    Object.values(nextState.children).map((child2) => stopChild(child2)),
    [],
    void 0
  );
}
function selectTransitions(event2, nextState) {
  return nextState.machine.getTransitionData(nextState, event2);
}
function selectEventlessTransitions(nextState, event2) {
  const enabledTransitionSet = /* @__PURE__ */ new Set();
  const atomicStates = nextState._nodes.filter(isAtomicStateNode);
  for (const stateNode of atomicStates) {
    loop: for (const s of [stateNode].concat(getProperAncestors(stateNode, void 0))) {
      if (!s.always) {
        continue;
      }
      for (const transition3 of s.always) {
        if (
          transition3.guard === void 0 ||
          evaluateGuard(transition3.guard, nextState.context, event2, nextState)
        ) {
          enabledTransitionSet.add(transition3);
          break loop;
        }
      }
    }
  }
  return removeConflictingTransitions(
    Array.from(enabledTransitionSet),
    new Set(nextState._nodes),
    nextState.historyValue
  );
}
function resolveStateValue(rootNode, stateValue) {
  const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));
  return getStateValue(rootNode, [...allStateNodes]);
}
function isMachineSnapshot(value) {
  return !!value && typeof value === 'object' && 'machine' in value && 'value' in value;
}
function createMachineSnapshot(config, machine) {
  return {
    status: config.status,
    output: config.output,
    error: config.error,
    machine,
    context: config.context,
    _nodes: config._nodes,
    value: getStateValue(machine.root, config._nodes),
    tags: new Set(config._nodes.flatMap((sn) => sn.tags)),
    children: config.children,
    historyValue: config.historyValue || {},
    matches: machineSnapshotMatches,
    hasTag: machineSnapshotHasTag,
    can: machineSnapshotCan,
    getMeta: machineSnapshotGetMeta,
    toJSON: machineSnapshotToJSON,
  };
}
function cloneMachineSnapshot(snapshot2, config = {}) {
  return createMachineSnapshot(
    {
      ...snapshot2,
      ...config,
    },
    snapshot2.machine
  );
}
function serializeHistoryValue(historyValue) {
  if (typeof historyValue !== 'object' || historyValue === null) {
    return {};
  }
  const result = {};
  for (const key2 in historyValue) {
    const value = historyValue[key2];
    if (Array.isArray(value)) {
      result[key2] = value.map((item) => ({
        id: item.id,
      }));
    }
  }
  return result;
}
function getPersistedSnapshot(snapshot2, options) {
  const {
    _nodes: nodes,
    tags,
    machine,
    children,
    context,
    can: can2,
    hasTag: hasTag2,
    matches: matches2,
    getMeta: getMeta2,
    toJSON: toJSON3,
    ...jsonValues
  } = snapshot2;
  const childrenJson = {};
  for (const id in children) {
    const child2 = children[id];
    childrenJson[id] = {
      snapshot: child2.getPersistedSnapshot(options),
      src: child2.src,
      systemId: child2.systemId,
      syncSnapshot: child2._syncSnapshot,
    };
  }
  const persisted = {
    ...jsonValues,
    context: persistContext(context),
    children: childrenJson,
    historyValue: serializeHistoryValue(jsonValues.historyValue),
  };
  return persisted;
}
function persistContext(contextPart) {
  let copy;
  for (const key2 in contextPart) {
    const value = contextPart[key2];
    if (value && typeof value === 'object') {
      if ('sessionId' in value && 'send' in value && 'ref' in value) {
        copy ??= Array.isArray(contextPart)
          ? contextPart.slice()
          : {
              ...contextPart,
            };
        copy[key2] = {
          xstate$$type: $$ACTOR_TYPE,
          id: value.id,
        };
      } else {
        const result = persistContext(value);
        if (result !== value) {
          copy ??= Array.isArray(contextPart)
            ? contextPart.slice()
            : {
                ...contextPart,
              };
          copy[key2] = result;
        }
      }
    }
  }
  return copy ?? contextPart;
}
function resolveRaise(
  _,
  snapshot2,
  args,
  actionParams,
  { event: eventOrExpr, id, delay: delay2 },
  { internalQueue }
) {
  const delaysMap = snapshot2.machine.implementations.delays;
  if (typeof eventOrExpr === 'string') {
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Only event objects may be used with raise; use raise({ type: "${eventOrExpr}" }) instead`
    );
  }
  const resolvedEvent =
    typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;
  let resolvedDelay;
  if (typeof delay2 === 'string') {
    const configDelay = delaysMap && delaysMap[delay2];
    resolvedDelay =
      typeof configDelay === 'function' ? configDelay(args, actionParams) : configDelay;
  } else {
    resolvedDelay = typeof delay2 === 'function' ? delay2(args, actionParams) : delay2;
  }
  if (typeof resolvedDelay !== 'number') {
    internalQueue.push(resolvedEvent);
  }
  return [
    snapshot2,
    {
      event: resolvedEvent,
      id,
      delay: resolvedDelay,
    },
    void 0,
  ];
}
function executeRaise(actorScope, params) {
  const { event: event2, delay: delay2, id } = params;
  if (typeof delay2 === 'number') {
    actorScope.defer(() => {
      const self3 = actorScope.self;
      actorScope.system.scheduler.schedule(self3, self3, event2, delay2, id);
    });
    return;
  }
}
function raise(eventOrExpr, options) {
  function raise2(_args, _params) {}
  raise2.type = 'xstate.raise';
  raise2.event = eventOrExpr;
  raise2.id = options?.id;
  raise2.delay = options?.delay;
  raise2.resolve = resolveRaise;
  raise2.execute = executeRaise;
  return raise2;
}
var Mailbox,
  STATE_DELIMITER,
  TARGETLESS_KEY,
  NULL_EVENT,
  STATE_IDENTIFIER,
  WILDCARD,
  XSTATE_INIT,
  XSTATE_ERROR,
  XSTATE_STOP,
  symbolObservable,
  idCounter,
  executingCustomAction,
  $$ACTOR_TYPE,
  ProcessingStatus,
  defaultOptions,
  Actor,
  interpret,
  stop,
  isAtomicStateNode,
  isStateId,
  machineSnapshotMatches,
  machineSnapshotHasTag,
  machineSnapshotCan,
  machineSnapshotToJSON,
  machineSnapshotGetMeta;
var init_raise_9ad1c5c6_esm = __esm({
  'node_modules/xstate/dist/raise-9ad1c5c6.esm.js'() {
    init_xstate_dev_esm();
    Mailbox = class {
      constructor(_process) {
        this._process = _process;
        this._active = false;
        this._current = null;
        this._last = null;
      }
      start() {
        this._active = true;
        this.flush();
      }
      clear() {
        if (this._current) {
          this._current.next = null;
          this._last = this._current;
        }
      }
      enqueue(event2) {
        const enqueued = {
          value: event2,
          next: null,
        };
        if (this._current) {
          this._last.next = enqueued;
          this._last = enqueued;
          return;
        }
        this._current = enqueued;
        this._last = enqueued;
        if (this._active) {
          this.flush();
        }
      }
      flush() {
        while (this._current) {
          const consumed = this._current;
          this._process(consumed.value);
          this._current = consumed.next;
        }
        this._last = null;
      }
    };
    STATE_DELIMITER = '.';
    TARGETLESS_KEY = '';
    NULL_EVENT = '';
    STATE_IDENTIFIER = '#';
    WILDCARD = '*';
    XSTATE_INIT = 'xstate.init';
    XSTATE_ERROR = 'xstate.error';
    XSTATE_STOP = 'xstate.stop';
    symbolObservable = (() =>
      (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();
    idCounter = 0;
    executingCustomAction = false;
    $$ACTOR_TYPE = 1;
    ProcessingStatus = /* @__PURE__ */ (function (ProcessingStatus2) {
      ProcessingStatus2[(ProcessingStatus2['NotStarted'] = 0)] = 'NotStarted';
      ProcessingStatus2[(ProcessingStatus2['Running'] = 1)] = 'Running';
      ProcessingStatus2[(ProcessingStatus2['Stopped'] = 2)] = 'Stopped';
      return ProcessingStatus2;
    })({});
    defaultOptions = {
      clock: {
        setTimeout: (fn, ms) => {
          return setTimeout(fn, ms);
        },
        clearTimeout: (id) => {
          return clearTimeout(id);
        },
      },
      logger: console.log.bind(console),
      devTools: false,
    };
    Actor = class {
      /**
       * Creates a new actor instance for the given logic with the provided options,
       * if any.
       *
       * @param logic The logic to create an actor from
       * @param options Actor options
       */
      constructor(logic, options) {
        this.logic = logic;
        this._snapshot = void 0;
        this.clock = void 0;
        this.options = void 0;
        this.id = void 0;
        this.mailbox = new Mailbox(this._process.bind(this));
        this.observers = /* @__PURE__ */ new Set();
        this.eventListeners = /* @__PURE__ */ new Map();
        this.logger = void 0;
        this._processingStatus = ProcessingStatus.NotStarted;
        this._parent = void 0;
        this._syncSnapshot = void 0;
        this.ref = void 0;
        this._actorScope = void 0;
        this.systemId = void 0;
        this.sessionId = void 0;
        this.system = void 0;
        this._doneEvent = void 0;
        this.src = void 0;
        this._deferred = [];
        const resolvedOptions = {
          ...defaultOptions,
          ...options,
        };
        const {
          clock,
          logger: logger4,
          parent,
          syncSnapshot,
          id,
          systemId,
          inspect: inspect2,
        } = resolvedOptions;
        this.system = parent
          ? parent.system
          : createSystem(this, {
              clock,
              logger: logger4,
            });
        if (inspect2 && !parent) {
          this.system.inspect(toObserver(inspect2));
        }
        this.sessionId = this.system._bookId();
        this.id = id ?? this.sessionId;
        this.logger = options?.logger ?? this.system._logger;
        this.clock = options?.clock ?? this.system._clock;
        this._parent = parent;
        this._syncSnapshot = syncSnapshot;
        this.options = resolvedOptions;
        this.src = resolvedOptions.src ?? logic;
        this.ref = this;
        this._actorScope = {
          self: this,
          id: this.id,
          sessionId: this.sessionId,
          logger: this.logger,
          defer: (fn) => {
            this._deferred.push(fn);
          },
          system: this.system,
          stopChild: (child2) => {
            if (child2._parent !== this) {
              throw new Error(
                `Cannot stop child actor ${child2.id} of ${this.id} because it is not a child`
              );
            }
            child2._stop();
          },
          emit: (emittedEvent) => {
            const listeners = this.eventListeners.get(emittedEvent.type);
            const wildcardListener = this.eventListeners.get('*');
            if (!listeners && !wildcardListener) {
              return;
            }
            const allListeners = [
              ...(listeners ? listeners.values() : []),
              ...(wildcardListener ? wildcardListener.values() : []),
            ];
            for (const handler of allListeners) {
              try {
                handler(emittedEvent);
              } catch (err) {
                reportUnhandledError(err);
              }
            }
          },
          actionExecutor: (action2) => {
            const exec = () => {
              this._actorScope.system._sendInspectionEvent({
                type: '@xstate.action',
                actorRef: this,
                action: {
                  type: action2.type,
                  params: action2.params,
                },
              });
              if (!action2.exec) {
                return;
              }
              const saveExecutingCustomAction = executingCustomAction;
              try {
                executingCustomAction = true;
                action2.exec(action2.info, action2.params);
              } finally {
                executingCustomAction = saveExecutingCustomAction;
              }
            };
            if (this._processingStatus === ProcessingStatus.Running) {
              exec();
            } else {
              this._deferred.push(exec);
            }
          },
        };
        this.send = this.send.bind(this);
        this.system._sendInspectionEvent({
          type: '@xstate.actor',
          actorRef: this,
        });
        if (systemId) {
          this.systemId = systemId;
          this.system._set(systemId, this);
        }
        this._initState(options?.snapshot ?? options?.state);
        if (systemId && this._snapshot.status !== 'active') {
          this.system._unregister(this);
        }
      }
      _initState(persistedState) {
        try {
          this._snapshot = persistedState
            ? this.logic.restoreSnapshot
              ? this.logic.restoreSnapshot(persistedState, this._actorScope)
              : persistedState
            : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);
        } catch (err) {
          this._snapshot = {
            status: 'error',
            output: void 0,
            error: err,
          };
        }
      }
      update(snapshot2, event2) {
        this._snapshot = snapshot2;
        let deferredFn;
        while ((deferredFn = this._deferred.shift())) {
          try {
            deferredFn();
          } catch (err) {
            this._deferred.length = 0;
            this._snapshot = {
              ...snapshot2,
              status: 'error',
              error: err,
            };
          }
        }
        switch (this._snapshot.status) {
          case 'active':
            for (const observer of this.observers) {
              try {
                observer.next?.(snapshot2);
              } catch (err) {
                reportUnhandledError(err);
              }
            }
            break;
          case 'done':
            for (const observer of this.observers) {
              try {
                observer.next?.(snapshot2);
              } catch (err) {
                reportUnhandledError(err);
              }
            }
            this._stopProcedure();
            this._complete();
            this._doneEvent = createDoneActorEvent(this.id, this._snapshot.output);
            if (this._parent) {
              this.system._relay(this, this._parent, this._doneEvent);
            }
            break;
          case 'error':
            this._error(this._snapshot.error);
            break;
        }
        this.system._sendInspectionEvent({
          type: '@xstate.snapshot',
          actorRef: this,
          event: event2,
          snapshot: snapshot2,
        });
      }
      /**
       * Subscribe an observer to an actors snapshot values.
       *
       * @remarks
       * The observer will receive the actors snapshot value when it is emitted.
       * The observer can be:
       *
       * - A plain function that receives the latest snapshot, or
       * - An observer object whose `.next(snapshot)` method receives the latest
       *   snapshot
       *
       * @example
       *
       * ```ts
       * // Observer as a plain function
       * const subscription = actor.subscribe((snapshot) => {
       *   console.log(snapshot);
       * });
       * ```
       *
       * @example
       *
       * ```ts
       * // Observer as an object
       * const subscription = actor.subscribe({
       *   next(snapshot) {
       *     console.log(snapshot);
       *   },
       *   error(err) {
       *     // ...
       *   },
       *   complete() {
       *     // ...
       *   }
       * });
       * ```
       *
       * The return value of `actor.subscribe(observer)` is a subscription object
       * that has an `.unsubscribe()` method. You can call
       * `subscription.unsubscribe()` to unsubscribe the observer:
       *
       * @example
       *
       * ```ts
       * const subscription = actor.subscribe((snapshot) => {
       *   // ...
       * });
       *
       * // Unsubscribe the observer
       * subscription.unsubscribe();
       * ```
       *
       * When the actor is stopped, all of its observers will automatically be
       * unsubscribed.
       *
       * @param observer - Either a plain function that receives the latest
       *   snapshot, or an observer object whose `.next(snapshot)` method receives
       *   the latest snapshot
       */
      subscribe(nextListenerOrObserver, errorListener, completeListener) {
        const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);
        if (this._processingStatus !== ProcessingStatus.Stopped) {
          this.observers.add(observer);
        } else {
          switch (this._snapshot.status) {
            case 'done':
              try {
                observer.complete?.();
              } catch (err) {
                reportUnhandledError(err);
              }
              break;
            case 'error': {
              const err = this._snapshot.error;
              if (!observer.error) {
                reportUnhandledError(err);
              } else {
                try {
                  observer.error(err);
                } catch (err2) {
                  reportUnhandledError(err2);
                }
              }
              break;
            }
          }
        }
        return {
          unsubscribe: () => {
            this.observers.delete(observer);
          },
        };
      }
      on(type, handler) {
        let listeners = this.eventListeners.get(type);
        if (!listeners) {
          listeners = /* @__PURE__ */ new Set();
          this.eventListeners.set(type, listeners);
        }
        const wrappedHandler = handler.bind(void 0);
        listeners.add(wrappedHandler);
        return {
          unsubscribe: () => {
            listeners.delete(wrappedHandler);
          },
        };
      }
      /** Starts the Actor from the initial state */
      start() {
        if (this._processingStatus === ProcessingStatus.Running) {
          return this;
        }
        if (this._syncSnapshot) {
          this.subscribe({
            next: (snapshot2) => {
              if (snapshot2.status === 'active') {
                this.system._relay(this, this._parent, {
                  type: `xstate.snapshot.${this.id}`,
                  snapshot: snapshot2,
                });
              }
            },
            error: () => {},
          });
        }
        this.system._register(this.sessionId, this);
        if (this.systemId) {
          this.system._set(this.systemId, this);
        }
        this._processingStatus = ProcessingStatus.Running;
        const initEvent = createInitEvent(this.options.input);
        this.system._sendInspectionEvent({
          type: '@xstate.event',
          sourceRef: this._parent,
          actorRef: this,
          event: initEvent,
        });
        const status = this._snapshot.status;
        switch (status) {
          case 'done':
            this.update(this._snapshot, initEvent);
            return this;
          case 'error':
            this._error(this._snapshot.error);
            return this;
        }
        if (!this._parent) {
          this.system.start();
        }
        if (this.logic.start) {
          try {
            this.logic.start(this._snapshot, this._actorScope);
          } catch (err) {
            this._snapshot = {
              ...this._snapshot,
              status: 'error',
              error: err,
            };
            this._error(err);
            return this;
          }
        }
        this.update(this._snapshot, initEvent);
        if (this.options.devTools) {
          this.attachDevTools();
        }
        this.mailbox.start();
        return this;
      }
      _process(event2) {
        let nextState;
        let caughtError;
        try {
          nextState = this.logic.transition(this._snapshot, event2, this._actorScope);
        } catch (err) {
          caughtError = {
            err,
          };
        }
        if (caughtError) {
          const { err } = caughtError;
          this._snapshot = {
            ...this._snapshot,
            status: 'error',
            error: err,
          };
          this._error(err);
          return;
        }
        this.update(nextState, event2);
        if (event2.type === XSTATE_STOP) {
          this._stopProcedure();
          this._complete();
        }
      }
      _stop() {
        if (this._processingStatus === ProcessingStatus.Stopped) {
          return this;
        }
        this.mailbox.clear();
        if (this._processingStatus === ProcessingStatus.NotStarted) {
          this._processingStatus = ProcessingStatus.Stopped;
          return this;
        }
        this.mailbox.enqueue({
          type: XSTATE_STOP,
        });
        return this;
      }
      /** Stops the Actor and unsubscribe all listeners. */
      stop() {
        if (this._parent) {
          throw new Error('A non-root actor cannot be stopped directly.');
        }
        return this._stop();
      }
      _complete() {
        for (const observer of this.observers) {
          try {
            observer.complete?.();
          } catch (err) {
            reportUnhandledError(err);
          }
        }
        this.observers.clear();
      }
      _reportError(err) {
        if (!this.observers.size) {
          if (!this._parent) {
            reportUnhandledError(err);
          }
          return;
        }
        let reportError = false;
        for (const observer of this.observers) {
          const errorListener = observer.error;
          reportError ||= !errorListener;
          try {
            errorListener?.(err);
          } catch (err2) {
            reportUnhandledError(err2);
          }
        }
        this.observers.clear();
        if (reportError) {
          reportUnhandledError(err);
        }
      }
      _error(err) {
        this._stopProcedure();
        this._reportError(err);
        if (this._parent) {
          this.system._relay(this, this._parent, createErrorActorEvent(this.id, err));
        }
      }
      // TODO: atm children don't belong entirely to the actor so
      // in a way - it's not even super aware of them
      // so we can't stop them from here but we really should!
      // right now, they are being stopped within the machine's transition
      // but that could throw and leave us with "orphaned" active actors
      _stopProcedure() {
        if (this._processingStatus !== ProcessingStatus.Running) {
          return this;
        }
        this.system.scheduler.cancelAll(this);
        this.mailbox.clear();
        this.mailbox = new Mailbox(this._process.bind(this));
        this._processingStatus = ProcessingStatus.Stopped;
        this.system._unregister(this);
        return this;
      }
      /** @internal */
      _send(event2) {
        if (this._processingStatus === ProcessingStatus.Stopped) {
          return;
        }
        this.mailbox.enqueue(event2);
      }
      /**
       * Sends an event to the running Actor to trigger a transition.
       *
       * @param event The event to send
       */
      send(event2) {
        this.system._relay(void 0, this, event2);
      }
      attachDevTools() {
        const { devTools } = this.options;
        if (devTools) {
          const resolvedDevToolsAdapter =
            typeof devTools === 'function' ? devTools : devToolsAdapter;
          resolvedDevToolsAdapter(this);
        }
      }
      toJSON() {
        return {
          xstate$$type: $$ACTOR_TYPE,
          id: this.id,
        };
      }
      /**
       * Obtain the internal state of the actor, which can be persisted.
       *
       * @remarks
       * The internal state can be persisted from any actor, not only machines.
       *
       * Note that the persisted state is not the same as the snapshot from
       * {@link Actor.getSnapshot}. Persisted state represents the internal state of
       * the actor, while snapshots represent the actor's last emitted value.
       *
       * Can be restored with {@link ActorOptions.state}
       * @see https://stately.ai/docs/persistence
       */
      getPersistedSnapshot(options) {
        return this.logic.getPersistedSnapshot(this._snapshot, options);
      }
      [symbolObservable]() {
        return this;
      }
      /**
       * Read an actors snapshot synchronously.
       *
       * @remarks
       * The snapshot represent an actor's last emitted value.
       *
       * When an actor receives an event, its internal state may change. An actor
       * may emit a snapshot when a state transition occurs.
       *
       * Note that some actors, such as callback actors generated with
       * `fromCallback`, will not emit snapshots.
       * @see {@link Actor.subscribe} to subscribe to an actors snapshot values.
       * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).
       */
      getSnapshot() {
        return this._snapshot;
      }
    };
    interpret = createActor;
    stop = stopChild;
    isAtomicStateNode = (stateNode) => stateNode.type === 'atomic' || stateNode.type === 'final';
    isStateId = (str2) => str2[0] === STATE_IDENTIFIER;
    machineSnapshotMatches = function matches(testValue) {
      return matchesState(testValue, this.value);
    };
    machineSnapshotHasTag = function hasTag(tag2) {
      return this.tags.has(tag2);
    };
    machineSnapshotCan = function can(event2) {
      const transitionData = this.machine.getTransitionData(this, event2);
      return (
        !!transitionData?.length && // Check that at least one transition is not forbidden
        transitionData.some((t) => t.target !== void 0 || t.actions.length)
      );
    };
    machineSnapshotToJSON = function toJSON2() {
      const {
        _nodes: nodes,
        tags,
        machine,
        getMeta: getMeta2,
        toJSON: toJSON3,
        can: can2,
        hasTag: hasTag2,
        matches: matches2,
        ...jsonValues
      } = this;
      return {
        ...jsonValues,
        tags: Array.from(tags),
      };
    };
    machineSnapshotGetMeta = function getMeta() {
      return this._nodes.reduce((acc, stateNode) => {
        if (stateNode.meta !== void 0) {
          acc[stateNode.id] = stateNode.meta;
        }
        return acc;
      }, {});
    };
  },
});

// node_modules/xstate/actors/dist/xstate-actors.esm.js
function fromTransition(transition3, initialContext) {
  return {
    config: transition3,
    transition: (snapshot2, event2, actorScope) => {
      return {
        ...snapshot2,
        context: transition3(snapshot2.context, event2, actorScope),
      };
    },
    getInitialSnapshot: (_, input) => {
      return {
        status: 'active',
        output: void 0,
        error: void 0,
        context:
          typeof initialContext === 'function'
            ? initialContext({
                input,
              })
            : initialContext,
      };
    },
    getPersistedSnapshot: (snapshot2) => snapshot2,
    restoreSnapshot: (snapshot2) => snapshot2,
  };
}
function fromCallback(callback) {
  const logic = {
    config: callback,
    start: (state2, actorScope) => {
      const { self: self3, system, emit: emit2 } = actorScope;
      const callbackState = {
        receivers: void 0,
        dispose: void 0,
      };
      instanceStates.set(self3, callbackState);
      callbackState.dispose = callback({
        input: state2.input,
        system,
        self: self3,
        sendBack: (event2) => {
          if (self3.getSnapshot().status === 'stopped') {
            return;
          }
          if (self3._parent) {
            system._relay(self3, self3._parent, event2);
          }
        },
        receive: (listener) => {
          callbackState.receivers ??= /* @__PURE__ */ new Set();
          callbackState.receivers.add(listener);
        },
        emit: emit2,
      });
    },
    transition: (state2, event2, actorScope) => {
      const callbackState = instanceStates.get(actorScope.self);
      if (event2.type === XSTATE_STOP) {
        state2 = {
          ...state2,
          status: 'stopped',
          error: void 0,
        };
        callbackState.dispose?.();
        return state2;
      }
      callbackState.receivers?.forEach((receiver) => receiver(event2));
      return state2;
    },
    getInitialSnapshot: (_, input) => {
      return {
        status: 'active',
        output: void 0,
        error: void 0,
        input,
      };
    },
    getPersistedSnapshot: (snapshot2) => snapshot2,
    restoreSnapshot: (snapshot2) => snapshot2,
  };
  return logic;
}
function fromObservable(observableCreator) {
  const logic = {
    config: observableCreator,
    transition: (snapshot2, event2) => {
      if (snapshot2.status !== 'active') {
        return snapshot2;
      }
      switch (event2.type) {
        case XSTATE_OBSERVABLE_NEXT: {
          const newSnapshot = {
            ...snapshot2,
            context: event2.data,
          };
          return newSnapshot;
        }
        case XSTATE_OBSERVABLE_ERROR:
          return {
            ...snapshot2,
            status: 'error',
            error: event2.data,
            input: void 0,
            _subscription: void 0,
          };
        case XSTATE_OBSERVABLE_COMPLETE:
          return {
            ...snapshot2,
            status: 'done',
            input: void 0,
            _subscription: void 0,
          };
        case XSTATE_STOP:
          snapshot2._subscription.unsubscribe();
          return {
            ...snapshot2,
            status: 'stopped',
            input: void 0,
            _subscription: void 0,
          };
        default:
          return snapshot2;
      }
    },
    getInitialSnapshot: (_, input) => {
      return {
        status: 'active',
        output: void 0,
        error: void 0,
        context: void 0,
        input,
        _subscription: void 0,
      };
    },
    start: (state2, { self: self3, system, emit: emit2 }) => {
      if (state2.status === 'done') {
        return;
      }
      state2._subscription = observableCreator({
        input: state2.input,
        system,
        self: self3,
        emit: emit2,
      }).subscribe({
        next: (value) => {
          system._relay(self3, self3, {
            type: XSTATE_OBSERVABLE_NEXT,
            data: value,
          });
        },
        error: (err) => {
          system._relay(self3, self3, {
            type: XSTATE_OBSERVABLE_ERROR,
            data: err,
          });
        },
        complete: () => {
          system._relay(self3, self3, {
            type: XSTATE_OBSERVABLE_COMPLETE,
          });
        },
      });
    },
    getPersistedSnapshot: ({ _subscription, ...state2 }) => state2,
    restoreSnapshot: (state2) => ({
      ...state2,
      _subscription: void 0,
    }),
  };
  return logic;
}
function fromEventObservable(lazyObservable) {
  const logic = {
    config: lazyObservable,
    transition: (state2, event2) => {
      if (state2.status !== 'active') {
        return state2;
      }
      switch (event2.type) {
        case XSTATE_OBSERVABLE_ERROR:
          return {
            ...state2,
            status: 'error',
            error: event2.data,
            input: void 0,
            _subscription: void 0,
          };
        case XSTATE_OBSERVABLE_COMPLETE:
          return {
            ...state2,
            status: 'done',
            input: void 0,
            _subscription: void 0,
          };
        case XSTATE_STOP:
          state2._subscription.unsubscribe();
          return {
            ...state2,
            status: 'stopped',
            input: void 0,
            _subscription: void 0,
          };
        default:
          return state2;
      }
    },
    getInitialSnapshot: (_, input) => {
      return {
        status: 'active',
        output: void 0,
        error: void 0,
        context: void 0,
        input,
        _subscription: void 0,
      };
    },
    start: (state2, { self: self3, system, emit: emit2 }) => {
      if (state2.status === 'done') {
        return;
      }
      state2._subscription = lazyObservable({
        input: state2.input,
        system,
        self: self3,
        emit: emit2,
      }).subscribe({
        next: (value) => {
          if (self3._parent) {
            system._relay(self3, self3._parent, value);
          }
        },
        error: (err) => {
          system._relay(self3, self3, {
            type: XSTATE_OBSERVABLE_ERROR,
            data: err,
          });
        },
        complete: () => {
          system._relay(self3, self3, {
            type: XSTATE_OBSERVABLE_COMPLETE,
          });
        },
      });
    },
    getPersistedSnapshot: ({ _subscription, ...snapshot2 }) => snapshot2,
    restoreSnapshot: (snapshot2) => ({
      ...snapshot2,
      _subscription: void 0,
    }),
  };
  return logic;
}
function fromPromise(promiseCreator) {
  const logic = {
    config: promiseCreator,
    transition: (state2, event2, scope) => {
      if (state2.status !== 'active') {
        return state2;
      }
      switch (event2.type) {
        case XSTATE_PROMISE_RESOLVE: {
          const resolvedValue = event2.data;
          return {
            ...state2,
            status: 'done',
            output: resolvedValue,
            input: void 0,
          };
        }
        case XSTATE_PROMISE_REJECT:
          return {
            ...state2,
            status: 'error',
            error: event2.data,
            input: void 0,
          };
        case XSTATE_STOP: {
          controllerMap.get(scope.self)?.abort();
          return {
            ...state2,
            status: 'stopped',
            input: void 0,
          };
        }
        default:
          return state2;
      }
    },
    start: (state2, { self: self3, system, emit: emit2 }) => {
      if (state2.status !== 'active') {
        return;
      }
      const controller = new AbortController();
      controllerMap.set(self3, controller);
      const resolvedPromise = Promise.resolve(
        promiseCreator({
          input: state2.input,
          system,
          self: self3,
          signal: controller.signal,
          emit: emit2,
        })
      );
      resolvedPromise.then(
        (response) => {
          if (self3.getSnapshot().status !== 'active') {
            return;
          }
          controllerMap.delete(self3);
          system._relay(self3, self3, {
            type: XSTATE_PROMISE_RESOLVE,
            data: response,
          });
        },
        (errorData) => {
          if (self3.getSnapshot().status !== 'active') {
            return;
          }
          controllerMap.delete(self3);
          system._relay(self3, self3, {
            type: XSTATE_PROMISE_REJECT,
            data: errorData,
          });
        }
      );
    },
    getInitialSnapshot: (_, input) => {
      return {
        status: 'active',
        output: void 0,
        error: void 0,
        input,
      };
    },
    getPersistedSnapshot: (snapshot2) => snapshot2,
    restoreSnapshot: (snapshot2) => snapshot2,
  };
  return logic;
}
function createEmptyActor() {
  return createActor(emptyLogic);
}
var instanceStates,
  XSTATE_OBSERVABLE_NEXT,
  XSTATE_OBSERVABLE_ERROR,
  XSTATE_OBSERVABLE_COMPLETE,
  XSTATE_PROMISE_RESOLVE,
  XSTATE_PROMISE_REJECT,
  controllerMap,
  emptyLogic;
var init_xstate_actors_esm = __esm({
  'node_modules/xstate/actors/dist/xstate-actors.esm.js'() {
    init_raise_9ad1c5c6_esm();
    init_xstate_dev_esm();
    instanceStates = /* @__PURE__ */ new WeakMap();
    XSTATE_OBSERVABLE_NEXT = 'xstate.observable.next';
    XSTATE_OBSERVABLE_ERROR = 'xstate.observable.error';
    XSTATE_OBSERVABLE_COMPLETE = 'xstate.observable.complete';
    XSTATE_PROMISE_RESOLVE = 'xstate.promise.resolve';
    XSTATE_PROMISE_REJECT = 'xstate.promise.reject';
    controllerMap = /* @__PURE__ */ new WeakMap();
    emptyLogic = fromTransition((_) => void 0, void 0);
  },
});

// node_modules/xstate/dist/assign-ab9cc19e.esm.js
function createSpawner(actorScope, { machine, context }, event2, spawnedChildren) {
  const spawn = (src, options) => {
    if (typeof src === 'string') {
      const logic = resolveReferencedActor(machine, src);
      if (!logic) {
        throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);
      }
      const actorRef = createActor(logic, {
        id: options?.id,
        parent: actorScope.self,
        syncSnapshot: options?.syncSnapshot,
        input:
          typeof options?.input === 'function'
            ? options.input({
                context,
                event: event2,
                self: actorScope.self,
              })
            : options?.input,
        src,
        systemId: options?.systemId,
      });
      spawnedChildren[actorRef.id] = actorRef;
      return actorRef;
    } else {
      const actorRef = createActor(src, {
        id: options?.id,
        parent: actorScope.self,
        syncSnapshot: options?.syncSnapshot,
        input: options?.input,
        src,
        systemId: options?.systemId,
      });
      return actorRef;
    }
  };
  return (src, options) => {
    const actorRef = spawn(src, options);
    spawnedChildren[actorRef.id] = actorRef;
    actorScope.defer(() => {
      if (actorRef._processingStatus === ProcessingStatus.Stopped) {
        return;
      }
      actorRef.start();
    });
    return actorRef;
  };
}
function resolveAssign(actorScope, snapshot2, actionArgs, actionParams, { assignment }) {
  if (!snapshot2.context) {
    throw new Error(
      'Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.'
    );
  }
  const spawnedChildren = {};
  const assignArgs = {
    context: snapshot2.context,
    event: actionArgs.event,
    spawn: createSpawner(actorScope, snapshot2, actionArgs.event, spawnedChildren),
    self: actorScope.self,
    system: actorScope.system,
  };
  let partialUpdate = {};
  if (typeof assignment === 'function') {
    partialUpdate = assignment(assignArgs, actionParams);
  } else {
    for (const key2 of Object.keys(assignment)) {
      const propAssignment = assignment[key2];
      partialUpdate[key2] =
        typeof propAssignment === 'function'
          ? propAssignment(assignArgs, actionParams)
          : propAssignment;
    }
  }
  const updatedContext = Object.assign({}, snapshot2.context, partialUpdate);
  return [
    cloneMachineSnapshot(snapshot2, {
      context: updatedContext,
      children: Object.keys(spawnedChildren).length
        ? {
            ...snapshot2.children,
            ...spawnedChildren,
          }
        : snapshot2.children,
    }),
    void 0,
    void 0,
  ];
}
function assign(assignment) {
  function assign3(_args, _params) {}
  assign3.type = 'xstate.assign';
  assign3.assignment = assignment;
  assign3.resolve = resolveAssign;
  return assign3;
}
var init_assign_ab9cc19e_esm = __esm({
  'node_modules/xstate/dist/assign-ab9cc19e.esm.js'() {
    init_raise_9ad1c5c6_esm();
  },
});

// node_modules/xstate/dist/StateMachine-37bc3882.esm.js
function memo(object, key2, fn) {
  let memoizedData = cache.get(object);
  if (!memoizedData) {
    memoizedData = {
      [key2]: fn(),
    };
    cache.set(object, memoizedData);
  } else if (!(key2 in memoizedData)) {
    memoizedData[key2] = fn();
  }
  return memoizedData[key2];
}
var cache, EMPTY_OBJECT, toSerializableAction, StateNode, STATE_IDENTIFIER2, StateMachine;
var init_StateMachine_37bc3882_esm = __esm({
  'node_modules/xstate/dist/StateMachine-37bc3882.esm.js'() {
    init_raise_9ad1c5c6_esm();
    init_assign_ab9cc19e_esm();
    cache = /* @__PURE__ */ new WeakMap();
    EMPTY_OBJECT = {};
    toSerializableAction = (action2) => {
      if (typeof action2 === 'string') {
        return {
          type: action2,
        };
      }
      if (typeof action2 === 'function') {
        if ('resolve' in action2) {
          return {
            type: action2.type,
          };
        }
        return {
          type: action2.name,
        };
      }
      return action2;
    };
    StateNode = class _StateNode {
      constructor(config, options) {
        this.config = config;
        this.key = void 0;
        this.id = void 0;
        this.type = void 0;
        this.path = void 0;
        this.states = void 0;
        this.history = void 0;
        this.entry = void 0;
        this.exit = void 0;
        this.parent = void 0;
        this.machine = void 0;
        this.meta = void 0;
        this.output = void 0;
        this.order = -1;
        this.description = void 0;
        this.tags = [];
        this.transitions = void 0;
        this.always = void 0;
        this.parent = options._parent;
        this.key = options._key;
        this.machine = options._machine;
        this.path = this.parent ? this.parent.path.concat(this.key) : [];
        this.id = this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER);
        this.type =
          this.config.type ||
          (this.config.states && Object.keys(this.config.states).length
            ? 'compound'
            : this.config.history
              ? 'history'
              : 'atomic');
        this.description = this.config.description;
        this.order = this.machine.idMap.size;
        this.machine.idMap.set(this.id, this);
        this.states = this.config.states
          ? mapValues(this.config.states, (stateConfig, key2) => {
              const stateNode = new _StateNode(stateConfig, {
                _parent: this,
                _key: key2,
                _machine: this.machine,
              });
              return stateNode;
            })
          : EMPTY_OBJECT;
        if (this.type === 'compound' && !this.config.initial) {
          throw new Error(
            `No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`
          );
        }
        this.history = this.config.history === true ? 'shallow' : this.config.history || false;
        this.entry = toArray2(this.config.entry).slice();
        this.exit = toArray2(this.config.exit).slice();
        this.meta = this.config.meta;
        this.output = this.type === 'final' || !this.parent ? this.config.output : void 0;
        this.tags = toArray2(config.tags).slice();
      }
      /** @internal */
      _initialize() {
        this.transitions = formatTransitions(this);
        if (this.config.always) {
          this.always = toTransitionConfigArray(this.config.always).map((t) =>
            formatTransition(this, NULL_EVENT, t)
          );
        }
        Object.keys(this.states).forEach((key2) => {
          this.states[key2]._initialize();
        });
      }
      /** The well-structured state node definition. */
      get definition() {
        return {
          id: this.id,
          key: this.key,
          version: this.machine.version,
          type: this.type,
          initial: this.initial
            ? {
                target: this.initial.target,
                source: this,
                actions: this.initial.actions.map(toSerializableAction),
                eventType: null,
                reenter: false,
                toJSON: () => ({
                  target: this.initial.target.map((t) => `#${t.id}`),
                  source: `#${this.id}`,
                  actions: this.initial.actions.map(toSerializableAction),
                  eventType: null,
                }),
              }
            : void 0,
          history: this.history,
          states: mapValues(this.states, (state2) => {
            return state2.definition;
          }),
          on: this.on,
          transitions: [...this.transitions.values()].flat().map((t) => ({
            ...t,
            actions: t.actions.map(toSerializableAction),
          })),
          entry: this.entry.map(toSerializableAction),
          exit: this.exit.map(toSerializableAction),
          meta: this.meta,
          order: this.order || -1,
          output: this.output,
          invoke: this.invoke,
          description: this.description,
          tags: this.tags,
        };
      }
      /** @internal */
      toJSON() {
        return this.definition;
      }
      /** The logic invoked as actors by this state node. */
      get invoke() {
        return memo(this, 'invoke', () =>
          toArray2(this.config.invoke).map((invokeConfig, i) => {
            const { src, systemId } = invokeConfig;
            const resolvedId = invokeConfig.id ?? createInvokeId(this.id, i);
            const sourceName =
              typeof src === 'string' ? src : `xstate.invoke.${createInvokeId(this.id, i)}`;
            return {
              ...invokeConfig,
              src: sourceName,
              id: resolvedId,
              systemId,
              toJSON() {
                const { onDone, onError, ...invokeDefValues } = invokeConfig;
                return {
                  ...invokeDefValues,
                  type: 'xstate.invoke',
                  src: sourceName,
                  id: resolvedId,
                };
              },
            };
          })
        );
      }
      /** The mapping of events to transitions. */
      get on() {
        return memo(this, 'on', () => {
          const transitions = this.transitions;
          return [...transitions]
            .flatMap(([descriptor, t]) => t.map((t2) => [descriptor, t2]))
            .reduce((map, [descriptor, transition3]) => {
              map[descriptor] = map[descriptor] || [];
              map[descriptor].push(transition3);
              return map;
            }, {});
        });
      }
      get after() {
        return memo(this, 'delayedTransitions', () => getDelayedTransitions(this));
      }
      get initial() {
        return memo(this, 'initial', () => formatInitialTransition(this, this.config.initial));
      }
      /** @internal */
      next(snapshot2, event2) {
        const eventType = event2.type;
        const actions2 = [];
        let selectedTransition;
        const candidates = memo(this, `candidates-${eventType}`, () =>
          getCandidates(this, eventType)
        );
        for (const candidate of candidates) {
          const { guard } = candidate;
          const resolvedContext = snapshot2.context;
          let guardPassed = false;
          try {
            guardPassed = !guard || evaluateGuard(guard, resolvedContext, event2, snapshot2);
          } catch (err) {
            const guardType =
              typeof guard === 'string' ? guard : typeof guard === 'object' ? guard.type : void 0;
            throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ''}in transition for event '${eventType}' in state node '${this.id}':
${err.message}`);
          }
          if (guardPassed) {
            actions2.push(...candidate.actions);
            selectedTransition = candidate;
            break;
          }
        }
        return selectedTransition ? [selectedTransition] : void 0;
      }
      /** All the event types accepted by this state node and its descendants. */
      get events() {
        return memo(this, 'events', () => {
          const { states } = this;
          const events = new Set(this.ownEvents);
          if (states) {
            for (const stateId of Object.keys(states)) {
              const state2 = states[stateId];
              if (state2.states) {
                for (const event2 of state2.events) {
                  events.add(`${event2}`);
                }
              }
            }
          }
          return Array.from(events);
        });
      }
      /**
       * All the events that have transitions directly from this state node.
       *
       * Excludes any inert events.
       */
      get ownEvents() {
        const events = new Set(
          [...this.transitions.keys()].filter((descriptor) => {
            return this.transitions
              .get(descriptor)
              .some(
                (transition3) =>
                  !(!transition3.target && !transition3.actions.length && !transition3.reenter)
              );
          })
        );
        return Array.from(events);
      }
    };
    STATE_IDENTIFIER2 = '#';
    StateMachine = class _StateMachine {
      constructor(config, implementations) {
        this.config = config;
        this.version = void 0;
        this.schemas = void 0;
        this.implementations = void 0;
        this.__xstatenode = true;
        this.idMap = /* @__PURE__ */ new Map();
        this.root = void 0;
        this.id = void 0;
        this.states = void 0;
        this.events = void 0;
        this.id = config.id || '(machine)';
        this.implementations = {
          actors: implementations?.actors ?? {},
          actions: implementations?.actions ?? {},
          delays: implementations?.delays ?? {},
          guards: implementations?.guards ?? {},
        };
        this.version = this.config.version;
        this.schemas = this.config.schemas;
        this.transition = this.transition.bind(this);
        this.getInitialSnapshot = this.getInitialSnapshot.bind(this);
        this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);
        this.restoreSnapshot = this.restoreSnapshot.bind(this);
        this.start = this.start.bind(this);
        this.root = new StateNode(config, {
          _key: this.id,
          _machine: this,
        });
        this.root._initialize();
        this.states = this.root.states;
        this.events = this.root.events;
      }
      /**
       * Clones this state machine with the provided implementations.
       *
       * @param implementations Options (`actions`, `guards`, `actors`, `delays`) to
       *   recursively merge with the existing options.
       * @returns A new `StateMachine` instance with the provided implementations.
       */
      provide(implementations) {
        const { actions: actions2, guards, actors, delays } = this.implementations;
        return new _StateMachine(this.config, {
          actions: {
            ...actions2,
            ...implementations.actions,
          },
          guards: {
            ...guards,
            ...implementations.guards,
          },
          actors: {
            ...actors,
            ...implementations.actors,
          },
          delays: {
            ...delays,
            ...implementations.delays,
          },
        });
      }
      resolveState(config) {
        const resolvedStateValue = resolveStateValue(this.root, config.value);
        const nodeSet = getAllStateNodes(getStateNodes(this.root, resolvedStateValue));
        return createMachineSnapshot(
          {
            _nodes: [...nodeSet],
            context: config.context || {},
            children: {},
            status: isInFinalState(nodeSet, this.root) ? 'done' : config.status || 'active',
            output: config.output,
            error: config.error,
            historyValue: config.historyValue,
          },
          this
        );
      }
      /**
       * Determines the next snapshot given the current `snapshot` and received
       * `event`. Calculates a full macrostep from all microsteps.
       *
       * @param snapshot The current snapshot
       * @param event The received event
       */
      transition(snapshot2, event2, actorScope) {
        return macrostep(snapshot2, event2, actorScope, []).snapshot;
      }
      /**
       * Determines the next state given the current `state` and `event`. Calculates
       * a microstep.
       *
       * @param state The current state
       * @param event The received event
       */
      microstep(snapshot2, event2, actorScope) {
        return macrostep(snapshot2, event2, actorScope, []).microstates;
      }
      getTransitionData(snapshot2, event2) {
        return transitionNode(this.root, snapshot2.value, snapshot2, event2) || [];
      }
      /**
       * The initial state _before_ evaluating any microsteps. This "pre-initial"
       * state is provided to initial actions executed in the initial state.
       */
      getPreInitialState(actorScope, initEvent, internalQueue) {
        const { context } = this.config;
        const preInitial = createMachineSnapshot(
          {
            context: typeof context !== 'function' && context ? context : {},
            _nodes: [this.root],
            children: {},
            status: 'active',
          },
          this
        );
        if (typeof context === 'function') {
          const assignment = ({ spawn, event: event2, self: self3 }) =>
            context({
              spawn,
              input: event2.input,
              self: self3,
            });
          return resolveActionsAndContext(
            preInitial,
            initEvent,
            actorScope,
            [assign(assignment)],
            internalQueue,
            void 0
          );
        }
        return preInitial;
      }
      /**
       * Returns the initial `State` instance, with reference to `self` as an
       * `ActorRef`.
       */
      getInitialSnapshot(actorScope, input) {
        const initEvent = createInitEvent(input);
        const internalQueue = [];
        const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);
        const nextState = microstep(
          [
            {
              target: [...getInitialStateNodes(this.root)],
              source: this.root,
              reenter: true,
              actions: [],
              eventType: null,
              toJSON: null,
              // TODO: fix
            },
          ],
          preInitialState,
          actorScope,
          initEvent,
          true,
          internalQueue
        );
        const { snapshot: macroState } = macrostep(nextState, initEvent, actorScope, internalQueue);
        return macroState;
      }
      start(snapshot2) {
        Object.values(snapshot2.children).forEach((child2) => {
          if (child2.getSnapshot().status === 'active') {
            child2.start();
          }
        });
      }
      getStateNodeById(stateId) {
        const fullPath = toStatePath(stateId);
        const relativePath = fullPath.slice(1);
        const resolvedStateId = isStateId(fullPath[0])
          ? fullPath[0].slice(STATE_IDENTIFIER2.length)
          : fullPath[0];
        const stateNode = this.idMap.get(resolvedStateId);
        if (!stateNode) {
          throw new Error(
            `Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`
          );
        }
        return getStateNodeByPath(stateNode, relativePath);
      }
      get definition() {
        return this.root.definition;
      }
      toJSON() {
        return this.definition;
      }
      getPersistedSnapshot(snapshot2, options) {
        return getPersistedSnapshot(snapshot2, options);
      }
      restoreSnapshot(snapshot2, _actorScope) {
        const children = {};
        const snapshotChildren = snapshot2.children;
        Object.keys(snapshotChildren).forEach((actorId) => {
          const actorData = snapshotChildren[actorId];
          const childState = actorData.snapshot;
          const src = actorData.src;
          const logic = typeof src === 'string' ? resolveReferencedActor(this, src) : src;
          if (!logic) {
            return;
          }
          const actorRef = createActor(logic, {
            id: actorId,
            parent: _actorScope.self,
            syncSnapshot: actorData.syncSnapshot,
            snapshot: childState,
            src,
            systemId: actorData.systemId,
          });
          children[actorId] = actorRef;
        });
        function resolveHistoryReferencedState(root, referenced) {
          if (referenced instanceof StateNode) {
            return referenced;
          }
          try {
            return root.machine.getStateNodeById(referenced.id);
          } catch {}
        }
        function reviveHistoryValue(root, historyValue) {
          if (!historyValue || typeof historyValue !== 'object') {
            return {};
          }
          const revived = {};
          for (const key2 in historyValue) {
            const arr = historyValue[key2];
            for (const item of arr) {
              const resolved = resolveHistoryReferencedState(root, item);
              if (!resolved) {
                continue;
              }
              revived[key2] ??= [];
              revived[key2].push(resolved);
            }
          }
          return revived;
        }
        const revivedHistoryValue = reviveHistoryValue(this.root, snapshot2.historyValue);
        const restoredSnapshot = createMachineSnapshot(
          {
            ...snapshot2,
            children,
            _nodes: Array.from(getAllStateNodes(getStateNodes(this.root, snapshot2.value))),
            historyValue: revivedHistoryValue,
          },
          this
        );
        const seen = /* @__PURE__ */ new Set();
        function reviveContext(contextPart, children2) {
          if (seen.has(contextPart)) {
            return;
          }
          seen.add(contextPart);
          for (const key2 in contextPart) {
            const value = contextPart[key2];
            if (value && typeof value === 'object') {
              if ('xstate$$type' in value && value.xstate$$type === $$ACTOR_TYPE) {
                contextPart[key2] = children2[value.id];
                continue;
              }
              reviveContext(value, children2);
            }
          }
        }
        reviveContext(restoredSnapshot.context, children);
        return restoredSnapshot;
      }
    };
  },
});

// node_modules/xstate/dist/log-7cbae384.esm.js
function resolveEmit(_, snapshot2, args, actionParams, { event: eventOrExpr }) {
  const resolvedEvent =
    typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;
  return [
    snapshot2,
    {
      event: resolvedEvent,
    },
    void 0,
  ];
}
function executeEmit(actorScope, { event: event2 }) {
  actorScope.defer(() => actorScope.emit(event2));
}
function emit(eventOrExpr) {
  function emit2(_args, _params) {}
  emit2.type = 'xstate.emit';
  emit2.event = eventOrExpr;
  emit2.resolve = resolveEmit;
  emit2.execute = executeEmit;
  return emit2;
}
function resolveSendTo(
  actorScope,
  snapshot2,
  args,
  actionParams,
  { to, event: eventOrExpr, id, delay: delay2 },
  extra
) {
  const delaysMap = snapshot2.machine.implementations.delays;
  if (typeof eventOrExpr === 'string') {
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Only event objects may be used with sendTo; use sendTo({ type: "${eventOrExpr}" }) instead`
    );
  }
  const resolvedEvent =
    typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;
  let resolvedDelay;
  if (typeof delay2 === 'string') {
    const configDelay = delaysMap && delaysMap[delay2];
    resolvedDelay =
      typeof configDelay === 'function' ? configDelay(args, actionParams) : configDelay;
  } else {
    resolvedDelay = typeof delay2 === 'function' ? delay2(args, actionParams) : delay2;
  }
  const resolvedTarget = typeof to === 'function' ? to(args, actionParams) : to;
  let targetActorRef;
  if (typeof resolvedTarget === 'string') {
    if (resolvedTarget === SpecialTargets.Parent) {
      targetActorRef = actorScope.self._parent;
    } else if (resolvedTarget === SpecialTargets.Internal) {
      targetActorRef = actorScope.self;
    } else if (resolvedTarget.startsWith('#_')) {
      targetActorRef = snapshot2.children[resolvedTarget.slice(2)];
    } else {
      targetActorRef = extra.deferredActorIds?.includes(resolvedTarget)
        ? resolvedTarget
        : snapshot2.children[resolvedTarget];
    }
    if (!targetActorRef) {
      throw new Error(
        `Unable to send event to actor '${resolvedTarget}' from machine '${snapshot2.machine.id}'.`
      );
    }
  } else {
    targetActorRef = resolvedTarget || actorScope.self;
  }
  return [
    snapshot2,
    {
      to: targetActorRef,
      targetId: typeof resolvedTarget === 'string' ? resolvedTarget : void 0,
      event: resolvedEvent,
      id,
      delay: resolvedDelay,
    },
    void 0,
  ];
}
function retryResolveSendTo(_, snapshot2, params) {
  if (typeof params.to === 'string') {
    params.to = snapshot2.children[params.to];
  }
}
function executeSendTo(actorScope, params) {
  actorScope.defer(() => {
    const { to, event: event2, delay: delay2, id } = params;
    if (typeof delay2 === 'number') {
      actorScope.system.scheduler.schedule(actorScope.self, to, event2, delay2, id);
      return;
    }
    actorScope.system._relay(
      actorScope.self,
      // at this point, in a deferred task, it should already be mutated by retryResolveSendTo
      // if it initially started as a string
      to,
      event2.type === XSTATE_ERROR ? createErrorActorEvent(actorScope.self.id, event2.data) : event2
    );
  });
}
function sendTo(to, eventOrExpr, options) {
  function sendTo2(_args, _params) {}
  sendTo2.type = 'xstate.sendTo';
  sendTo2.to = to;
  sendTo2.event = eventOrExpr;
  sendTo2.id = options?.id;
  sendTo2.delay = options?.delay;
  sendTo2.resolve = resolveSendTo;
  sendTo2.retryResolve = retryResolveSendTo;
  sendTo2.execute = executeSendTo;
  return sendTo2;
}
function sendParent(event2, options) {
  return sendTo(SpecialTargets.Parent, event2, options);
}
function forwardTo(target, options) {
  return sendTo(target, ({ event: event2 }) => event2, options);
}
function resolveEnqueueActions(actorScope, snapshot2, args, actionParams, { collect }) {
  const actions2 = [];
  const enqueue = function enqueue2(action2) {
    actions2.push(action2);
  };
  enqueue.assign = (...args2) => {
    actions2.push(assign(...args2));
  };
  enqueue.cancel = (...args2) => {
    actions2.push(cancel(...args2));
  };
  enqueue.raise = (...args2) => {
    actions2.push(raise(...args2));
  };
  enqueue.sendTo = (...args2) => {
    actions2.push(sendTo(...args2));
  };
  enqueue.sendParent = (...args2) => {
    actions2.push(sendParent(...args2));
  };
  enqueue.spawnChild = (...args2) => {
    actions2.push(spawnChild(...args2));
  };
  enqueue.stopChild = (...args2) => {
    actions2.push(stopChild(...args2));
  };
  enqueue.emit = (...args2) => {
    actions2.push(emit(...args2));
  };
  collect(
    {
      context: args.context,
      event: args.event,
      enqueue,
      check: (guard) => evaluateGuard(guard, snapshot2.context, args.event, snapshot2),
      self: actorScope.self,
      system: actorScope.system,
    },
    actionParams
  );
  return [snapshot2, void 0, actions2];
}
function enqueueActions(collect) {
  function enqueueActions2(_args, _params) {}
  enqueueActions2.type = 'xstate.enqueueActions';
  enqueueActions2.collect = collect;
  enqueueActions2.resolve = resolveEnqueueActions;
  return enqueueActions2;
}
function resolveLog(_, snapshot2, actionArgs, actionParams, { value, label }) {
  return [
    snapshot2,
    {
      value: typeof value === 'function' ? value(actionArgs, actionParams) : value,
      label,
    },
    void 0,
  ];
}
function executeLog({ logger: logger4 }, { value, label }) {
  if (label) {
    logger4(label, value);
  } else {
    logger4(value);
  }
}
function log(
  value = ({ context, event: event2 }) => ({
    context,
    event: event2,
  }),
  label
) {
  function log2(_args, _params) {}
  log2.type = 'xstate.log';
  log2.value = value;
  log2.label = label;
  log2.resolve = resolveLog;
  log2.execute = executeLog;
  return log2;
}
var SpecialTargets;
var init_log_7cbae384_esm = __esm({
  'node_modules/xstate/dist/log-7cbae384.esm.js'() {
    init_raise_9ad1c5c6_esm();
    init_assign_ab9cc19e_esm();
    SpecialTargets = /* @__PURE__ */ (function (SpecialTargets2) {
      SpecialTargets2['Parent'] = '#_parent';
      SpecialTargets2['Internal'] = '#_internal';
      return SpecialTargets2;
    })({});
  },
});

// node_modules/xstate/dist/xstate.esm.js
var xstate_esm_exports = {};
__export(xstate_esm_exports, {
  Actor: () => Actor,
  SimulatedClock: () => SimulatedClock,
  SpecialTargets: () => SpecialTargets,
  StateMachine: () => StateMachine,
  StateNode: () => StateNode,
  __unsafe_getAllOwnEventDescriptors: () => getAllOwnEventDescriptors,
  and: () => and,
  assertEvent: () => assertEvent,
  assign: () => assign,
  cancel: () => cancel,
  createActor: () => createActor,
  createEmptyActor: () => createEmptyActor,
  createMachine: () => createMachine,
  emit: () => emit,
  enqueueActions: () => enqueueActions,
  forwardTo: () => forwardTo,
  fromCallback: () => fromCallback,
  fromEventObservable: () => fromEventObservable,
  fromObservable: () => fromObservable,
  fromPromise: () => fromPromise,
  fromTransition: () => fromTransition,
  getInitialSnapshot: () => getInitialSnapshot,
  getNextSnapshot: () => getNextSnapshot,
  getStateNodes: () => getStateNodes,
  initialTransition: () => initialTransition,
  interpret: () => interpret,
  isMachineSnapshot: () => isMachineSnapshot,
  log: () => log,
  matchesState: () => matchesState,
  not: () => not,
  or: () => or,
  pathToStateValue: () => pathToStateValue,
  raise: () => raise,
  sendParent: () => sendParent,
  sendTo: () => sendTo,
  setup: () => setup,
  spawnChild: () => spawnChild,
  stateIn: () => stateIn,
  stop: () => stop,
  stopChild: () => stopChild,
  toObserver: () => toObserver,
  toPromise: () => toPromise,
  transition: () => transition,
  waitFor: () => waitFor,
});
function assertEvent(event2, type) {
  const types = toArray2(type);
  if (!types.includes(event2.type)) {
    const typesText =
      types.length === 1 ? `type "${types[0]}"` : `one of types "${types.join('", "')}"`;
    throw new Error(`Expected event ${JSON.stringify(event2)} to have ${typesText}`);
  }
}
function createMachine(config, implementations) {
  return new StateMachine(config, implementations);
}
function createInertActorScope(actorLogic) {
  const self3 = createActor(actorLogic);
  const inertActorScope = {
    self: self3,
    defer: () => {},
    id: '',
    logger: () => {},
    sessionId: '',
    stopChild: () => {},
    system: self3.system,
    emit: () => {},
    actionExecutor: () => {},
  };
  return inertActorScope;
}
function getInitialSnapshot(actorLogic, ...[input]) {
  const actorScope = createInertActorScope(actorLogic);
  return actorLogic.getInitialSnapshot(actorScope, input);
}
function getNextSnapshot(actorLogic, snapshot2, event2) {
  const inertActorScope = createInertActorScope(actorLogic);
  inertActorScope.self._snapshot = snapshot2;
  return actorLogic.transition(snapshot2, event2, inertActorScope);
}
function setup({ schemas, actors, actions: actions2, guards, delays }) {
  return {
    assign,
    sendTo,
    raise,
    log,
    cancel,
    stopChild,
    enqueueActions,
    emit,
    spawnChild,
    createStateConfig: (config) => config,
    createAction: (fn) => fn,
    createMachine: (config) =>
      createMachine(
        {
          ...config,
          schemas,
        },
        {
          actors,
          actions: actions2,
          guards,
          delays,
        }
      ),
  };
}
function toPromise(actor) {
  return new Promise((resolve, reject) => {
    actor.subscribe({
      complete: () => {
        resolve(actor.getSnapshot().output);
      },
      error: reject,
    });
  });
}
function transition(logic, snapshot2, event2) {
  const executableActions = [];
  const actorScope = createInertActorScope(logic);
  actorScope.actionExecutor = (action2) => {
    executableActions.push(action2);
  };
  const nextSnapshot = logic.transition(snapshot2, event2, actorScope);
  return [nextSnapshot, executableActions];
}
function initialTransition(logic, ...[input]) {
  const executableActions = [];
  const actorScope = createInertActorScope(logic);
  actorScope.actionExecutor = (action2) => {
    executableActions.push(action2);
  };
  const nextSnapshot = logic.getInitialSnapshot(actorScope, input);
  return [nextSnapshot, executableActions];
}
function waitFor(actorRef, predicate, options) {
  const resolvedOptions = {
    ...defaultWaitForOptions,
    ...options,
  };
  return new Promise((res, rej) => {
    const { signal } = resolvedOptions;
    if (signal?.aborted) {
      rej(signal.reason);
      return;
    }
    let done = false;
    const handle =
      resolvedOptions.timeout === Infinity
        ? void 0
        : setTimeout(() => {
            dispose();
            rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));
          }, resolvedOptions.timeout);
    const dispose = () => {
      clearTimeout(handle);
      done = true;
      sub?.unsubscribe();
      if (abortListener) {
        signal.removeEventListener('abort', abortListener);
      }
    };
    function checkEmitted(emitted) {
      if (predicate(emitted)) {
        dispose();
        res(emitted);
      }
    }
    let abortListener;
    let sub;
    checkEmitted(actorRef.getSnapshot());
    if (done) {
      return;
    }
    if (signal) {
      abortListener = () => {
        dispose();
        rej(signal.reason);
      };
      signal.addEventListener('abort', abortListener);
    }
    sub = actorRef.subscribe({
      next: checkEmitted,
      error: (err) => {
        dispose();
        rej(err);
      },
      complete: () => {
        dispose();
        rej(new Error(`Actor terminated without satisfying predicate`));
      },
    });
    if (done) {
      sub.unsubscribe();
    }
  });
}
var SimulatedClock, defaultWaitForOptions;
var init_xstate_esm = __esm({
  'node_modules/xstate/dist/xstate.esm.js'() {
    init_xstate_actors_esm();
    init_raise_9ad1c5c6_esm();
    init_raise_9ad1c5c6_esm();
    init_StateMachine_37bc3882_esm();
    init_StateMachine_37bc3882_esm();
    init_assign_ab9cc19e_esm();
    init_assign_ab9cc19e_esm();
    init_log_7cbae384_esm();
    init_log_7cbae384_esm();
    init_xstate_dev_esm();
    SimulatedClock = class {
      constructor() {
        this.timeouts = /* @__PURE__ */ new Map();
        this._now = 0;
        this._id = 0;
        this._flushing = false;
        this._flushingInvalidated = false;
      }
      now() {
        return this._now;
      }
      getId() {
        return this._id++;
      }
      setTimeout(fn, timeout) {
        this._flushingInvalidated = this._flushing;
        const id = this.getId();
        this.timeouts.set(id, {
          start: this.now(),
          timeout,
          fn,
        });
        return id;
      }
      clearTimeout(id) {
        this._flushingInvalidated = this._flushing;
        this.timeouts.delete(id);
      }
      set(time) {
        if (this._now > time) {
          throw new Error('Unable to travel back in time');
        }
        this._now = time;
        this.flushTimeouts();
      }
      flushTimeouts() {
        if (this._flushing) {
          this._flushingInvalidated = true;
          return;
        }
        this._flushing = true;
        const sorted = [...this.timeouts].sort(([_idA, timeoutA], [_idB, timeoutB]) => {
          const endA = timeoutA.start + timeoutA.timeout;
          const endB = timeoutB.start + timeoutB.timeout;
          return endB > endA ? -1 : 1;
        });
        for (const [id, timeout] of sorted) {
          if (this._flushingInvalidated) {
            this._flushingInvalidated = false;
            this._flushing = false;
            this.flushTimeouts();
            return;
          }
          if (this.now() - timeout.start >= timeout.timeout) {
            this.timeouts.delete(id);
            timeout.fn.call(null);
          }
        }
        this._flushing = false;
      }
      increment(ms) {
        this._now += ms;
        this.flushTimeouts();
      }
    };
    defaultWaitForOptions = {
      timeout: Infinity,
      // much more than 10 seconds
    };
  },
});

// src/fsm/logging/FSMLogger.ts
var FSMLogger_exports = {};
__export(FSMLogger_exports, {
  FSMComponent: () => FSMComponent,
  FSMLogger: () => FSMLogger,
  LOG_LEVEL_NAMES: () => LOG_LEVEL_NAMES,
  LogLevel: () => LogLevel,
  createComponentLogger: () => createComponentLogger,
  fsmLogger: () => fsmLogger,
});
function createComponentLogger(component2, instanceId) {
  return {
    debug: (message, context, data) =>
      fsmLogger.debug(component2, message, { component: component2, instanceId, ...context }, data),
    info: (message, context, data) =>
      fsmLogger.info(component2, message, { component: component2, instanceId, ...context }, data),
    warn: (message, context, data) =>
      fsmLogger.warn(component2, message, { component: component2, instanceId, ...context }, data),
    error: (message, context, data) =>
      fsmLogger.error(component2, message, { component: component2, instanceId, ...context }, data),
    logStateTransition: (fromState, toState, event2, machineId) =>
      fsmLogger.logStateTransition(
        component2,
        instanceId || 'unknown',
        fromState,
        toState,
        event2,
        machineId
      ),
    logEvent: (event2, currentState, machineId, data) =>
      fsmLogger.logFSMEvent(
        component2,
        instanceId || 'unknown',
        event2,
        currentState,
        machineId,
        data
      ),
    logError: (error, currentState, machineId) =>
      fsmLogger.logFSMError(component2, instanceId || 'unknown', error, currentState, machineId),
  };
}
var vscode4, LogLevel, LOG_LEVEL_NAMES, FSMComponent, DEFAULT_CONFIG, FSMLogger, fsmLogger;
var init_FSMLogger = __esm({
  'src/fsm/logging/FSMLogger.ts'() {
    'use strict';
    vscode4 = null;
    LogLevel = /* @__PURE__ */ ((LogLevel4) => {
      LogLevel4[(LogLevel4['DEBUG'] = 0)] = 'DEBUG';
      LogLevel4[(LogLevel4['INFO'] = 1)] = 'INFO';
      LogLevel4[(LogLevel4['WARN'] = 2)] = 'WARN';
      LogLevel4[(LogLevel4['ERROR'] = 3)] = 'ERROR';
      LogLevel4[(LogLevel4['OFF'] = 4)] = 'OFF';
      return LogLevel4;
    })(LogLevel || {});
    LOG_LEVEL_NAMES = {
      [0 /* DEBUG */]: 'DEBUG',
      [1 /* INFO */]: 'INFO',
      [2 /* WARN */]: 'WARN',
      [3 /* ERROR */]: 'ERROR',
      [4 /* OFF */]: 'OFF',
    };
    FSMComponent = /* @__PURE__ */ ((FSMComponent2) => {
      FSMComponent2['APPLICATION'] = 'APPLICATION';
      FSMComponent2['CONNECTION'] = 'CONNECTION';
      FSMComponent2['TIMER'] = 'TIMER';
      FSMComponent2['WEBVIEW'] = 'WEBVIEW';
      FSMComponent2['AUTH'] = 'AUTH';
      FSMComponent2['DATA'] = 'DATA';
      FSMComponent2['ADAPTER'] = 'ADAPTER';
      FSMComponent2['MACHINE'] = 'MACHINE';
      return FSMComponent2;
    })(FSMComponent || {});
    DEFAULT_CONFIG = {
      enabled: true,
      level: 0 /* DEBUG */,
      // More verbose logging by default
      components: {
        ['APPLICATION' /* APPLICATION */]: true,
        ['CONNECTION' /* CONNECTION */]: true,
        ['TIMER' /* TIMER */]: true,
        ['WEBVIEW' /* WEBVIEW */]: true,
        // Enable webview logging
        ['AUTH' /* AUTH */]: true,
        ['DATA' /* DATA */]: true,
        // Enable data logging
        ['ADAPTER' /* ADAPTER */]: true,
        // Enable adapter logging
        ['MACHINE' /* MACHINE */]: true,
        // Enable machine logging
      },
      destinations: {
        console: true,
        outputChannel: true,
        file: false,
      },
      includeTimestamp: true,
      includeStackTrace: false,
      maxLogEntries: 1e3,
      contextTracking: true,
    };
    FSMLogger = class _FSMLogger {
      static instance;
      config = DEFAULT_CONFIG;
      logBuffer = [];
      outputChannel;
      logCounter = 0;
      configListeners = [];
      constructor() {
        this.loadConfiguration();
      }
      static getInstance() {
        if (!_FSMLogger.instance) {
          _FSMLogger.instance = new _FSMLogger();
        }
        return _FSMLogger.instance;
      }
      // ============================================================================
      // CONFIGURATION MANAGEMENT
      // ============================================================================
      loadConfiguration() {
        try {
          if (typeof vscode4 !== 'undefined' && vscode4?.workspace) {
            const vscodeConfig = vscode4.workspace.getConfiguration(
              'azureDevOpsIntegration.logging'
            );
            this.config = {
              enabled: vscodeConfig.get('enabled', DEFAULT_CONFIG.enabled),
              level: vscodeConfig.get('level', DEFAULT_CONFIG.level),
              components: {
                ...DEFAULT_CONFIG.components,
                ...vscodeConfig.get('components', {}),
              },
              destinations: {
                ...DEFAULT_CONFIG.destinations,
                ...vscodeConfig.get('destinations', {}),
              },
              includeTimestamp: vscodeConfig.get(
                'includeTimestamp',
                DEFAULT_CONFIG.includeTimestamp
              ),
              includeStackTrace: vscodeConfig.get(
                'includeStackTrace',
                DEFAULT_CONFIG.includeStackTrace
              ),
              maxLogEntries: vscodeConfig.get('maxLogEntries', DEFAULT_CONFIG.maxLogEntries),
              contextTracking: vscodeConfig.get('contextTracking', DEFAULT_CONFIG.contextTracking),
            };
          } else {
            this.config = { ...DEFAULT_CONFIG };
          }
          this.configListeners.forEach((listener) => listener(this.config));
        } catch (error) {
          console.error('[FSMLogger] Failed to load configuration:', error);
          this.config = { ...DEFAULT_CONFIG };
        }
      }
      updateConfiguration(updates) {
        this.config = { ...this.config, ...updates };
        this.configListeners.forEach((listener) => listener(this.config));
        try {
          if (typeof vscode4 !== 'undefined' && vscode4?.workspace) {
            const vscodeConfig = vscode4.workspace.getConfiguration(
              'azureDevOpsIntegration.logging'
            );
            Object.entries(updates).forEach(([key2, value]) => {
              vscodeConfig.update(key2, value, vscode4.ConfigurationTarget.Global);
            });
          }
        } catch (error) {
          console.error('[FSMLogger] Failed to persist configuration:', error);
        }
      }
      onConfigurationChange(listener) {
        this.configListeners.push(listener);
        if (vscode4 && vscode4.Disposable) {
          return new vscode4.Disposable(() => {
            const index2 = this.configListeners.indexOf(listener);
            if (index2 >= 0) {
              this.configListeners.splice(index2, 1);
            }
          });
        } else {
          return {
            dispose: () => {
              const index2 = this.configListeners.indexOf(listener);
              if (index2 >= 0) {
                this.configListeners.splice(index2, 1);
              }
            },
          };
        }
      }
      // ============================================================================
      // OUTPUT CHANNEL MANAGEMENT
      // ============================================================================
      getOutputChannel() {
        if (!this.outputChannel) {
          if (typeof vscode4 !== 'undefined' && vscode4?.window) {
            this.outputChannel = vscode4.window.createOutputChannel('Azure DevOps Int (FSM)');
          } else {
            return null;
          }
        }
        return this.outputChannel;
      }
      // ============================================================================
      // CORE LOGGING METHODS
      // ============================================================================
      shouldLog(level, component2) {
        if (!this.config.enabled) return false;
        if (level < this.config.level) return false;
        if (!this.config.components[component2]) return false;
        return true;
      }
      createLogEntry(level, component2, message, context, data) {
        const entry = {
          id: `log_${++this.logCounter}`,
          timestamp: Date.now(),
          level,
          component: component2,
          message,
          context: this.config.contextTracking ? context : void 0,
          data,
        };
        if (this.config.includeStackTrace && level >= 2 /* WARN */) {
          entry.stackTrace = new Error().stack;
        }
        return entry;
      }
      formatLogEntry(entry) {
        const timestamp = this.config.includeTimestamp
          ? new Date(entry.timestamp).toISOString()
          : '';
        const level = LOG_LEVEL_NAMES[entry.level].padEnd(5);
        const component2 = `[${entry.component}]`.padEnd(12);
        let contextStr = '';
        if (entry.context) {
          const parts = [];
          if (entry.context.instanceId) parts.push(`id:${entry.context.instanceId}`);
          if (entry.context.connectionId) parts.push(`conn:${entry.context.connectionId}`);
          if (entry.context.state) parts.push(`state:${entry.context.state}`);
          if (entry.context.event) parts.push(`event:${entry.context.event}`);
          if (entry.context.machineId) parts.push(`machine:${entry.context.machineId}`);
          if (parts.length > 0) {
            contextStr = `{${parts.join(', ')}} `;
          }
        }
        let formatted = `${timestamp} ${level} ${component2} ${contextStr}${entry.message}`;
        if (entry.data) {
          formatted += `
  Data: ${JSON.stringify(entry.data, null, 2)}`;
        }
        if (entry.stackTrace && this.config.includeStackTrace) {
          formatted += `
  Stack: ${entry.stackTrace}`;
        }
        return formatted;
      }
      writeToDestinations(entry) {
        const formatted = this.formatLogEntry(entry);
        if (this.config.destinations.console) {
          const consoleMethod =
            entry.level >= 3 /* ERROR */
              ? 'error'
              : entry.level >= 2 /* WARN */
                ? 'warn'
                : entry.level >= 1 /* INFO */
                  ? 'info'
                  : 'log';
          const emoji =
            entry.level >= 3 /* ERROR */
              ? '\u{1F534}'
              : entry.level >= 2 /* WARN */
                ? '\u{1F7E1}'
                : entry.level >= 1 /* INFO */
                  ? '\u{1F7E2}'
                  : '\u{1F535}';
          const enhancedFormatted = `${emoji} [AzureDevOpsInt][FSM][${entry.component}] ${formatted}`;
          console.log(enhancedFormatted);
          if (consoleMethod !== 'log') {
            console[consoleMethod](`\u21B3 ${formatted}`);
          }
        }
        if (this.config.destinations.outputChannel) {
          const outputChannel2 = this.getOutputChannel();
          if (outputChannel2) {
            outputChannel2.appendLine(formatted);
          }
        }
        if (this.config.destinations.file) {
        }
      }
      addToBuffer(entry) {
        this.logBuffer.push(entry);
        if (this.logBuffer.length > this.config.maxLogEntries) {
          this.logBuffer = this.logBuffer.slice(-this.config.maxLogEntries);
        }
      }
      log(level, component2, message, context, data) {
        if (!this.shouldLog(level, component2)) return;
        const entry = this.createLogEntry(level, component2, message, context, data);
        this.addToBuffer(entry);
        this.writeToDestinations(entry);
      }
      // ============================================================================
      // PUBLIC LOGGING API
      // ============================================================================
      debug(component2, message, context, data) {
        this.log(0 /* DEBUG */, component2, message, context, data);
      }
      info(component2, message, context, data) {
        this.log(1 /* INFO */, component2, message, context, data);
      }
      warn(component2, message, context, data) {
        this.log(2 /* WARN */, component2, message, context, data);
      }
      error(component2, message, context, data) {
        this.log(3 /* ERROR */, component2, message, context, data);
      }
      // ============================================================================
      // FSM-SPECIFIC LOGGING HELPERS
      // ============================================================================
      logStateTransition(component2, instanceId, fromState, toState, event2, machineId) {
        this.info(component2, `State transition: ${fromState} \u2192 ${toState}`, {
          component: component2,
          instanceId,
          state: toState,
          event: event2,
          machineId,
        });
      }
      logFSMEvent(component2, instanceId, event2, currentState, machineId, data) {
        this.debug(
          component2,
          `Event: ${event2}`,
          {
            component: component2,
            instanceId,
            state: currentState,
            event: event2,
            machineId,
          },
          data
        );
      }
      logFSMError(component2, instanceId, error, currentState, machineId) {
        this.error(
          component2,
          `FSM Error: ${error.message}`,
          {
            component: component2,
            instanceId,
            state: currentState,
            machineId,
          },
          { error: error.stack }
        );
      }
      logConnectionActivity(connectionId, activity, state2, data) {
        this.info(
          'CONNECTION' /* CONNECTION */,
          activity,
          {
            component: 'CONNECTION' /* CONNECTION */,
            connectionId,
            state: state2,
          },
          data
        );
      }
      // ============================================================================
      // UTILITY METHODS
      // ============================================================================
      getLogBuffer() {
        return [...this.logBuffer];
      }
      clearLogBuffer() {
        this.logBuffer = [];
      }
      exportLogs() {
        return this.logBuffer.map((entry) => this.formatLogEntry(entry)).join('\n');
      }
      getConfiguration() {
        return { ...this.config };
      }
      showOutputChannel() {
        const outputChannel2 = this.getOutputChannel();
        if (outputChannel2) {
          outputChannel2.show(true);
        }
      }
      getStats() {
        const stats = {
          totalEntries: this.logBuffer.length,
          entriesByLevel: {},
          entriesByComponent: {},
        };
        Object.values(LogLevel).forEach((level) => {
          if (typeof level === 'number') {
            stats.entriesByLevel[level] = 0;
          }
        });
        Object.values(FSMComponent).forEach((component2) => {
          stats.entriesByComponent[component2] = 0;
        });
        this.logBuffer.forEach((entry) => {
          stats.entriesByLevel[entry.level]++;
          stats.entriesByComponent[entry.component]++;
        });
        return stats;
      }
    };
    fsmLogger = FSMLogger.getInstance();
  },
});

// src/fsm/logging/FSMTracer.ts
var FSMTracer_exports = {};
__export(FSMTracer_exports, {
  FSMTracer: () => FSMTracer,
  analyzeCurrentTrace: () => analyzeCurrentTrace,
  exportCurrentTrace: () => exportCurrentTrace,
  fsmTracer: () => fsmTracer,
  instrumentActor: () => instrumentActor,
  startTraceSession: () => startTraceSession,
  stopTraceSession: () => stopTraceSession,
});
function instrumentActor(actor, component2, machineId) {
  return fsmTracer.instrumentActor(actor, component2, machineId);
}
function startTraceSession(description) {
  return fsmTracer.startNewSession(description);
}
function stopTraceSession() {
  fsmTracer.stopCurrentSession();
}
function exportCurrentTrace() {
  const currentSession = fsmTracer.getCurrentSession();
  if (!currentSession) return void 0;
  return fsmTracer.exportSession(currentSession.id);
}
function analyzeCurrentTrace() {
  const currentSession = fsmTracer.getCurrentSession();
  if (!currentSession) return void 0;
  return fsmTracer.analyzeSession(currentSession.id);
}
var FSMTracer, fsmTracer;
var init_FSMTracer = __esm({
  'src/fsm/logging/FSMTracer.ts'() {
    'use strict';
    init_FSMLogger();
    FSMTracer = class _FSMTracer {
      static instance;
      sessions = /* @__PURE__ */ new Map();
      currentSession;
      isRecording = false;
      traceCounter = 0;
      maxEntriesPerSession = 1e4;
      subscribedActors = /* @__PURE__ */ new Map();
      constructor() {
        this.startNewSession('FSM Extension Startup');
      }
      static getInstance() {
        if (!_FSMTracer.instance) {
          _FSMTracer.instance = new _FSMTracer();
        }
        return _FSMTracer.instance;
      }
      // ============================================================================
      // SESSION MANAGEMENT
      // ============================================================================
      startNewSession(description) {
        const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        if (this.currentSession) {
          this.currentSession.endTime = Date.now();
        }
        this.currentSession = {
          id: sessionId,
          startTime: Date.now(),
          description: description || 'FSM Trace Session',
          entries: [],
          metadata: {
            extensionVersion: process.env.npm_package_version,
            nodeVersion: process.version,
          },
        };
        this.sessions.set(sessionId, this.currentSession);
        this.isRecording = true;
        fsmLogger.info('MACHINE' /* MACHINE */, `New trace session started: ${sessionId}`, {
          component: 'MACHINE' /* MACHINE */,
          machineId: sessionId,
        });
        return sessionId;
      }
      stopCurrentSession() {
        if (this.currentSession) {
          this.currentSession.endTime = Date.now();
          this.isRecording = false;
          fsmLogger.info(
            'MACHINE' /* MACHINE */,
            `Trace session ended: ${this.currentSession.id}`,
            {
              component: 'MACHINE' /* MACHINE */,
              machineId: this.currentSession.id,
            },
            {
              duration: this.currentSession.endTime - this.currentSession.startTime,
              entriesCount: this.currentSession.entries.length,
            }
          );
        }
      }
      getCurrentSession() {
        return this.currentSession;
      }
      getSession(sessionId) {
        return this.sessions.get(sessionId);
      }
      getAllSessions() {
        return Array.from(this.sessions.values());
      }
      // ============================================================================
      // ACTOR INSTRUMENTATION
      // ============================================================================
      instrumentActor(actor, component2, machineId) {
        if (!this.isRecording || !this.currentSession) {
          return () => {};
        }
        const actorId = `${component2}_${machineId || 'default'}_${Date.now()}`;
        let lastSnapshot;
        const subscription = actor.subscribe({
          next: (snapshot2) => {
            this.recordTransition(
              actor,
              component2,
              machineId || 'unknown',
              actorId,
              lastSnapshot,
              snapshot2
            );
            lastSnapshot = snapshot2;
          },
          error: (error) => {
            this.recordError(component2, machineId || 'unknown', actorId, error);
          },
        });
        const cleanup = () => {
          subscription.unsubscribe();
          this.subscribedActors.delete(actorId);
        };
        this.subscribedActors.set(actorId, cleanup);
        fsmLogger.debug('MACHINE' /* MACHINE */, `Actor instrumented: ${actorId}`, {
          component: component2,
          machineId,
        });
        return cleanup;
      }
      recordTransition(actor, component2, machineId, actorId, fromSnapshot, toSnapshot) {
        if (!this.isRecording || !this.currentSession) return;
        const entry = {
          id: `trace_${++this.traceCounter}`,
          timestamp: Date.now(),
          sessionId: this.currentSession.id,
          machineId,
          actorId,
          component: component2,
          event: toSnapshot._event || { type: 'unknown' },
          eventType: toSnapshot._event?.type || 'unknown',
          fromState: this.serializeState(fromSnapshot),
          toState: this.serializeState(toSnapshot),
          contextBefore: this.cloneObject(fromSnapshot?.context),
          contextAfter: this.cloneObject(toSnapshot.context),
        };
        this.addTraceEntry(entry);
      }
      recordError(component2, machineId, actorId, error) {
        if (!this.isRecording || !this.currentSession) return;
        const entry = {
          id: `trace_${++this.traceCounter}`,
          timestamp: Date.now(),
          sessionId: this.currentSession.id,
          machineId,
          actorId,
          component: component2,
          event: { type: 'ERROR' },
          eventType: 'ERROR',
          fromState: 'unknown',
          toState: 'error',
          contextBefore: null,
          contextAfter: null,
          error: error instanceof Error ? error.message : String(error),
        };
        this.addTraceEntry(entry);
      }
      addTraceEntry(entry) {
        if (!this.currentSession) return;
        this.currentSession.entries.push(entry);
        if (this.currentSession.entries.length > this.maxEntriesPerSession) {
          this.currentSession.entries = this.currentSession.entries.slice(
            -this.maxEntriesPerSession
          );
        }
        if (entry.eventType !== 'TICK' && entry.eventType !== 'HEARTBEAT') {
          fsmLogger.debug(
            'MACHINE' /* MACHINE */,
            `FSM Event: ${entry.eventType}`,
            {
              component: entry.component,
              machineId: entry.machineId,
              state: entry.toState,
              event: entry.eventType,
            },
            {
              fromState: entry.fromState,
              toState: entry.toState,
              contextChanged:
                JSON.stringify(entry.contextBefore) !== JSON.stringify(entry.contextAfter),
            }
          );
        }
      }
      // ============================================================================
      // REPLAY FUNCTIONALITY
      // ============================================================================
      async replaySession(sessionId, targetActor, options = {}) {
        const session = this.sessions.get(sessionId);
        if (!session) {
          throw new Error(`Session not found: ${sessionId}`);
        }
        const {
          startFromEntry = 0,
          endAtEntry = session.entries.length - 1,
          stepMode = false,
          delayMs = 100,
          skipErrors = false,
          onStateChange,
          onError,
        } = options;
        fsmLogger.info(
          'MACHINE' /* MACHINE */,
          `Starting replay of session: ${sessionId}`,
          {
            component: 'MACHINE' /* MACHINE */,
            machineId: sessionId,
          },
          {
            totalEntries: session.entries.length,
            startFrom: startFromEntry,
            endAt: endAtEntry,
          }
        );
        const entriesToReplay = session.entries.slice(startFromEntry, endAtEntry + 1);
        for (let i = 0; i < entriesToReplay.length; i++) {
          const entry = entriesToReplay[i];
          try {
            if (entry.event.type !== 'unknown' && entry.event.type !== 'ERROR') {
              targetActor.send(entry.event);
            }
            onStateChange?.(entry);
            if (!stepMode && delayMs > 0) {
              await new Promise((resolve) => setTimeout(resolve, delayMs));
            } else if (stepMode) {
              await this.waitForStep();
            }
          } catch (error) {
            if (skipErrors) {
              fsmLogger.warn('MACHINE' /* MACHINE */, `Replay error skipped: ${error}`, {
                component: 'MACHINE' /* MACHINE */,
                machineId: sessionId,
              });
              onError?.(entry, error);
            } else {
              throw error;
            }
          }
        }
        fsmLogger.info('MACHINE' /* MACHINE */, `Replay completed for session: ${sessionId}`);
      }
      async waitForStep() {
        return new Promise((resolve) => setTimeout(resolve, 1e3));
      }
      // ============================================================================
      // EXPORT/IMPORT FUNCTIONALITY
      // ============================================================================
      exportSession(sessionId) {
        const session = this.sessions.get(sessionId);
        if (!session) {
          throw new Error(`Session not found: ${sessionId}`);
        }
        return JSON.stringify(session, null, 2);
      }
      exportAllSessions() {
        const allSessions = Object.fromEntries(this.sessions);
        return JSON.stringify(allSessions, null, 2);
      }
      importSession(sessionData) {
        try {
          const session = JSON.parse(sessionData);
          if (!session.id || !session.entries || !Array.isArray(session.entries)) {
            throw new Error('Invalid session data format');
          }
          this.sessions.set(session.id, session);
          fsmLogger.info(
            'MACHINE' /* MACHINE */,
            `Session imported: ${session.id}`,
            {
              component: 'MACHINE' /* MACHINE */,
              machineId: session.id,
            },
            {
              entriesCount: session.entries.length,
              originalStartTime: session.startTime,
            }
          );
          return session.id;
        } catch (error) {
          throw new Error(`Failed to import session: ${error}`);
        }
      }
      // ============================================================================
      // ANALYSIS FUNCTIONALITY
      // ============================================================================
      analyzeSession(sessionId) {
        const session = this.sessions.get(sessionId);
        if (!session) {
          throw new Error(`Session not found: ${sessionId}`);
        }
        const entries = session.entries;
        const eventFrequency = {};
        const stateTransitions = {};
        const uniqueStates = /* @__PURE__ */ new Set();
        const transitions = [];
        let errors = 0;
        entries.forEach((entry, index2) => {
          eventFrequency[entry.eventType] = (eventFrequency[entry.eventType] || 0) + 1;
          uniqueStates.add(entry.fromState);
          uniqueStates.add(entry.toState);
          if (!stateTransitions[entry.fromState]) {
            stateTransitions[entry.fromState] = [];
          }
          if (!stateTransitions[entry.fromState].includes(entry.toState)) {
            stateTransitions[entry.fromState].push(entry.toState);
          }
          if (entry.error) {
            errors++;
          }
          if (index2 > 0) {
            const duration = entry.timestamp - entries[index2 - 1].timestamp;
            transitions.push({
              from: entry.fromState,
              to: entry.toState,
              event: entry.eventType,
              duration,
            });
          }
        });
        const avgTransitionTime =
          transitions.length > 0
            ? transitions.reduce((sum, t) => sum + t.duration, 0) / transitions.length
            : 0;
        const slowestTransitions = transitions.sort((a, b) => b.duration - a.duration).slice(0, 10);
        return {
          summary: {
            duration: (session.endTime || Date.now()) - session.startTime,
            totalEvents: entries.length,
            uniqueStates: uniqueStates.size,
            errors,
          },
          eventFrequency,
          stateTransitions,
          performance: {
            avgTransitionTime,
            slowestTransitions,
          },
        };
      }
      // ============================================================================
      // UTILITY METHODS
      // ============================================================================
      serializeState(snapshot2) {
        if (!snapshot2) return 'initial';
        const value = snapshot2.value;
        if (typeof value === 'string') {
          return value;
        } else if (typeof value === 'object' && value !== null) {
          return JSON.stringify(value);
        } else {
          return String(value);
        }
      }
      cloneObject(obj) {
        if (obj === null || obj === void 0) return obj;
        try {
          return JSON.parse(JSON.stringify(obj));
        } catch {
          return String(obj);
        }
      }
      cleanup() {
        this.subscribedActors.forEach((cleanup) => cleanup());
        this.subscribedActors.clear();
        this.stopCurrentSession();
        fsmLogger.info('MACHINE' /* MACHINE */, 'FSM Tracer cleaned up');
      }
      getStats() {
        return {
          sessionsCount: this.sessions.size,
          totalEntries: Array.from(this.sessions.values()).reduce(
            (sum, session) => sum + session.entries.length,
            0
          ),
          currentSessionEntries: this.currentSession?.entries.length || 0,
          instrumentedActors: this.subscribedActors.size,
        };
      }
    };
    fsmTracer = FSMTracer.getInstance();
  },
});

// src/fsm/services/extensionHostBridge.ts
function setExtensionContextRef(context) {
  extensionContextRef = context;
  globalThis.extensionContext = context;
}
function getExtensionContextRef() {
  return extensionContextRef;
}
function setRegisterAllCommands(fn) {
  registerAllCommandsFn = fn;
}
async function invokeRegisterAllCommands(context) {
  if (!registerAllCommandsFn) {
    return;
  }
  await registerAllCommandsFn(context);
}
function setForwardProviderMessage(fn) {
  forwardProviderMessageFn = fn;
}
function forwardProviderMessage(connectionId, message) {
  if (!forwardProviderMessageFn) {
    return;
  }
  forwardProviderMessageFn(connectionId, message);
}
function setGetSecretPAT(fn) {
  getSecretPATFn = fn;
}
async function getSecretPAT(context, connectionId) {
  if (!getSecretPATFn) {
    return void 0;
  }
  return getSecretPATFn(context, connectionId);
}
function setLoadedConnectionsReader(fn) {
  loadedConnectionsReader = fn;
}
function setActiveConnectionIdReader(fn) {
  activeConnectionIdReader = fn;
}
function setApplicationStoreBridge(options) {
  applicationActorAccessor = options.getActor;
  applicationEventDispatcher = options.send;
}
function getApplicationStoreActor() {
  return applicationActorAccessor ? applicationActorAccessor() : void 0;
}
function sendApplicationStoreEvent(event2) {
  if (!applicationEventDispatcher) {
    return;
  }
  applicationEventDispatcher(event2);
}
var extensionContextRef,
  registerAllCommandsFn,
  forwardProviderMessageFn,
  getSecretPATFn,
  loadedConnectionsReader,
  activeConnectionIdReader,
  applicationActorAccessor,
  applicationEventDispatcher;
var init_extensionHostBridge = __esm({
  'src/fsm/services/extensionHostBridge.ts'() {
    'use strict';
    loadedConnectionsReader = () => [];
    activeConnectionIdReader = () => null;
  },
});

// node_modules/svelte/src/internal/shared/utils.js
function run_all(arr) {
  for (var i = 0; i < arr.length; i++) {
    arr[i]();
  }
}
function deferred() {
  var resolve;
  var reject;
  var promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
var is_array,
  index_of,
  array_from,
  object_keys,
  define_property,
  get_descriptor,
  object_prototype,
  array_prototype,
  get_prototype_of,
  is_extensible,
  noop2;
var init_utils3 = __esm({
  'node_modules/svelte/src/internal/shared/utils.js'() {
    is_array = Array.isArray;
    index_of = Array.prototype.indexOf;
    array_from = Array.from;
    object_keys = Object.keys;
    define_property = Object.defineProperty;
    get_descriptor = Object.getOwnPropertyDescriptor;
    object_prototype = Object.prototype;
    array_prototype = Array.prototype;
    get_prototype_of = Object.getPrototypeOf;
    is_extensible = Object.isExtensible;
    noop2 = () => {};
  },
});

// node_modules/svelte/src/internal/client/reactivity/equality.js
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a, b) {
  return a != a
    ? b == b
    : a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}
var init_equality = __esm({
  'node_modules/svelte/src/internal/client/reactivity/equality.js'() {},
});

// node_modules/esm-env/browser-fallback.js
var init_browser_fallback = __esm({
  'node_modules/esm-env/browser-fallback.js'() {},
});

// node_modules/esm-env/dev-fallback.js
var node_env, dev_fallback_default;
var init_dev_fallback = __esm({
  'node_modules/esm-env/dev-fallback.js'() {
    node_env = globalThis.process?.env?.NODE_ENV;
    dev_fallback_default = node_env && !node_env.toLowerCase().startsWith('prod');
  },
});

// node_modules/esm-env/true.js
var init_true = __esm({
  'node_modules/esm-env/true.js'() {},
});

// node_modules/esm-env/index.js
var init_esm_env = __esm({
  'node_modules/esm-env/index.js'() {
    init_browser_fallback();
    init_dev_fallback();
    init_true();
  },
});

// node_modules/svelte/src/internal/client/constants.js
var DERIVED,
  EFFECT,
  RENDER_EFFECT,
  BLOCK_EFFECT,
  BRANCH_EFFECT,
  ROOT_EFFECT,
  BOUNDARY_EFFECT,
  UNOWNED,
  DISCONNECTED,
  CLEAN,
  DIRTY,
  MAYBE_DIRTY,
  INERT,
  DESTROYED,
  EFFECT_RAN,
  EFFECT_TRANSPARENT,
  INSPECT_EFFECT,
  HEAD_EFFECT,
  EFFECT_PRESERVED,
  USER_EFFECT,
  REACTION_IS_UPDATING,
  ASYNC,
  ERROR_VALUE,
  STATE_SYMBOL,
  LEGACY_PROPS,
  LOADING_ATTR_SYMBOL,
  PROXY_PATH_SYMBOL,
  STALE_REACTION,
  COMMENT_NODE;
var init_constants = __esm({
  'node_modules/svelte/src/internal/client/constants.js'() {
    DERIVED = 1 << 1;
    EFFECT = 1 << 2;
    RENDER_EFFECT = 1 << 3;
    BLOCK_EFFECT = 1 << 4;
    BRANCH_EFFECT = 1 << 5;
    ROOT_EFFECT = 1 << 6;
    BOUNDARY_EFFECT = 1 << 7;
    UNOWNED = 1 << 8;
    DISCONNECTED = 1 << 9;
    CLEAN = 1 << 10;
    DIRTY = 1 << 11;
    MAYBE_DIRTY = 1 << 12;
    INERT = 1 << 13;
    DESTROYED = 1 << 14;
    EFFECT_RAN = 1 << 15;
    EFFECT_TRANSPARENT = 1 << 16;
    INSPECT_EFFECT = 1 << 17;
    HEAD_EFFECT = 1 << 18;
    EFFECT_PRESERVED = 1 << 19;
    USER_EFFECT = 1 << 20;
    REACTION_IS_UPDATING = 1 << 21;
    ASYNC = 1 << 22;
    ERROR_VALUE = 1 << 23;
    STATE_SYMBOL = Symbol('$state');
    LEGACY_PROPS = Symbol('legacy props');
    LOADING_ATTR_SYMBOL = Symbol('');
    PROXY_PATH_SYMBOL = Symbol('proxy path');
    STALE_REACTION = new (class StaleReactionError extends Error {
      name = 'StaleReactionError';
      message = 'The reaction that called `getAbortSignal()` was re-run or destroyed';
    })();
    COMMENT_NODE = 8;
  },
});

// node_modules/svelte/src/internal/shared/errors.js
var init_errors = __esm({
  'node_modules/svelte/src/internal/shared/errors.js'() {
    init_esm_env();
  },
});

// node_modules/svelte/src/internal/client/errors.js
function derived_references_self() {
  if (dev_fallback_default) {
    const error = new Error(`derived_references_self
A derived value cannot reference itself recursively
https://svelte.dev/e/derived_references_self`);
    error.name = 'Svelte error';
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/derived_references_self`);
  }
}
function effect_update_depth_exceeded() {
  if (dev_fallback_default) {
    const error = new Error(`effect_update_depth_exceeded
Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
https://svelte.dev/e/effect_update_depth_exceeded`);
    error.name = 'Svelte error';
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
function flush_sync_in_effect() {
  if (dev_fallback_default) {
    const error = new Error(`flush_sync_in_effect
Cannot use \`flushSync\` inside an effect
https://svelte.dev/e/flush_sync_in_effect`);
    error.name = 'Svelte error';
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/flush_sync_in_effect`);
  }
}
function hydration_failed() {
  if (dev_fallback_default) {
    const error = new Error(`hydration_failed
Failed to hydrate the application
https://svelte.dev/e/hydration_failed`);
    error.name = 'Svelte error';
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/hydration_failed`);
  }
}
function rune_outside_svelte(rune) {
  if (dev_fallback_default) {
    const error = new Error(`rune_outside_svelte
The \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files
https://svelte.dev/e/rune_outside_svelte`);
    error.name = 'Svelte error';
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
  }
}
function state_descriptors_fixed() {
  if (dev_fallback_default) {
    const error = new Error(`state_descriptors_fixed
Property descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.
https://svelte.dev/e/state_descriptors_fixed`);
    error.name = 'Svelte error';
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
  }
}
function state_prototype_fixed() {
  if (dev_fallback_default) {
    const error = new Error(`state_prototype_fixed
Cannot set prototype of \`$state\` object
https://svelte.dev/e/state_prototype_fixed`);
    error.name = 'Svelte error';
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
  }
}
function state_unsafe_mutation() {
  if (dev_fallback_default) {
    const error = new Error(`state_unsafe_mutation
Updating state inside \`$derived(...)\`, \`$inspect(...)\` or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`
https://svelte.dev/e/state_unsafe_mutation`);
    error.name = 'Svelte error';
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}
function svelte_boundary_reset_onerror() {
  if (dev_fallback_default) {
    const error = new Error(`svelte_boundary_reset_onerror
A \`<svelte:boundary>\` \`reset\` function cannot be called while an error is still being handled
https://svelte.dev/e/svelte_boundary_reset_onerror`);
    error.name = 'Svelte error';
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
  }
}
var init_errors2 = __esm({
  'node_modules/svelte/src/internal/client/errors.js'() {
    init_esm_env();
    init_errors();
  },
});

// node_modules/svelte/src/constants.js
var EACH_INDEX_REACTIVE,
  EACH_IS_CONTROLLED,
  EACH_IS_ANIMATED,
  EACH_ITEM_IMMUTABLE,
  PROPS_IS_RUNES,
  PROPS_IS_UPDATED,
  PROPS_IS_BINDABLE,
  PROPS_IS_LAZY_INITIAL,
  TRANSITION_OUT,
  TRANSITION_GLOBAL,
  TEMPLATE_USE_IMPORT_NODE,
  TEMPLATE_USE_SVG,
  TEMPLATE_USE_MATHML,
  HYDRATION_START,
  HYDRATION_START_ELSE,
  HYDRATION_END,
  HYDRATION_ERROR,
  ELEMENT_PRESERVE_ATTRIBUTE_CASE,
  ELEMENT_IS_INPUT,
  UNINITIALIZED,
  FILENAME,
  HMR;
var init_constants2 = __esm({
  'node_modules/svelte/src/constants.js'() {
    EACH_INDEX_REACTIVE = 1 << 1;
    EACH_IS_CONTROLLED = 1 << 2;
    EACH_IS_ANIMATED = 1 << 3;
    EACH_ITEM_IMMUTABLE = 1 << 4;
    PROPS_IS_RUNES = 1 << 1;
    PROPS_IS_UPDATED = 1 << 2;
    PROPS_IS_BINDABLE = 1 << 3;
    PROPS_IS_LAZY_INITIAL = 1 << 4;
    TRANSITION_OUT = 1 << 1;
    TRANSITION_GLOBAL = 1 << 2;
    TEMPLATE_USE_IMPORT_NODE = 1 << 1;
    TEMPLATE_USE_SVG = 1 << 2;
    TEMPLATE_USE_MATHML = 1 << 3;
    HYDRATION_START = '[';
    HYDRATION_START_ELSE = '[!';
    HYDRATION_END = ']';
    HYDRATION_ERROR = {};
    ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
    ELEMENT_IS_INPUT = 1 << 2;
    UNINITIALIZED = Symbol();
    FILENAME = Symbol('filename');
    HMR = Symbol('hmr');
  },
});

// node_modules/svelte/src/internal/client/warnings.js
function await_reactivity_loss(name3) {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] await_reactivity_loss
%cDetected reactivity loss when reading \`${name3}\`. This happens when state is read in an async function after an earlier \`await\`
https://svelte.dev/e/await_reactivity_loss`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/await_reactivity_loss`);
  }
}
function hydration_mismatch(location) {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] hydration_mismatch
%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : 'Hydration failed because the initial UI does not match what was rendered on the server'}
https://svelte.dev/e/hydration_mismatch`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/hydration_mismatch`);
  }
}
function lifecycle_double_unmount() {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/lifecycle_double_unmount`);
  }
}
function state_proxy_equality_mismatch(operator) {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
  }
}
function state_proxy_unmount() {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] state_proxy_unmount
%cTried to unmount a state proxy, rather than a component
https://svelte.dev/e/state_proxy_unmount`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_unmount`);
  }
}
function svelte_boundary_reset_noop() {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] svelte_boundary_reset_noop
%cA \`<svelte:boundary>\` \`reset\` function only resets the boundary the first time it is called
https://svelte.dev/e/svelte_boundary_reset_noop`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/svelte_boundary_reset_noop`);
  }
}
var bold, normal;
var init_warnings = __esm({
  'node_modules/svelte/src/internal/client/warnings.js'() {
    init_esm_env();
    bold = 'font-weight: bold';
    normal = 'font-weight: normal';
  },
});

// node_modules/svelte/src/internal/client/dom/hydration.js
function set_hydrating(value) {
  hydrating = value;
}
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return (hydrate_node = node);
}
function hydrate_next() {
  return set_hydrate_node(
    /** @type {TemplateNode} */
    get_next_sibling(hydrate_node)
  );
}
function next(count = 1) {
  if (hydrating) {
    var i = count;
    var node = hydrate_node;
    while (i--) {
      node = /** @type {TemplateNode} */ get_next_sibling(node);
    }
    hydrate_node = node;
  }
}
function skip_nodes(remove = true) {
  var depth = 0;
  var node = hydrate_node;
  while (true) {
    if (node.nodeType === COMMENT_NODE) {
      var data =
        /** @type {Comment} */
        node.data;
      if (data === HYDRATION_END) {
        if (depth === 0) return node;
        depth -= 1;
      } else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
        depth += 1;
      }
    }
    var next2 =
      /** @type {TemplateNode} */
      get_next_sibling(node);
    if (remove) node.remove();
    node = next2;
  }
}
var hydrating, hydrate_node;
var init_hydration = __esm({
  'node_modules/svelte/src/internal/client/dom/hydration.js'() {
    init_constants();
    init_constants2();
    init_warnings();
    init_operations();
    hydrating = false;
  },
});

// node_modules/svelte/src/internal/flags/index.js
var async_mode_flag, legacy_mode_flag, tracing_mode_flag;
var init_flags = __esm({
  'node_modules/svelte/src/internal/flags/index.js'() {
    async_mode_flag = false;
    legacy_mode_flag = false;
    tracing_mode_flag = false;
  },
});

// node_modules/svelte/src/internal/shared/warnings.js
var init_warnings2 = __esm({
  'node_modules/svelte/src/internal/shared/warnings.js'() {
    init_esm_env();
  },
});

// node_modules/svelte/src/internal/shared/clone.js
var init_clone = __esm({
  'node_modules/svelte/src/internal/shared/clone.js'() {
    init_esm_env();
    init_warnings2();
    init_utils3();
  },
});

// node_modules/svelte/src/internal/client/dev/tracing.js
function get_stack(label) {
  let error = Error();
  const stack2 = error.stack;
  if (!stack2) return null;
  const lines = stack2.split('\n');
  const new_lines = ['\n'];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line === 'Error') {
      continue;
    }
    if (line.includes('validate_each_keys')) {
      return null;
    }
    if (line.includes('svelte/src/internal')) {
      continue;
    }
    new_lines.push(line);
  }
  if (new_lines.length === 1) {
    return null;
  }
  define_property(error, 'stack', {
    value: new_lines.join('\n'),
  });
  define_property(error, 'name', {
    // 'Error' suffix is required for stack traces to be rendered properly
    value: `${label}Error`,
  });
  return (
    /** @type {Error & { stack: string }} */
    error
  );
}
function tag(source2, label) {
  source2.label = label;
  tag_proxy(source2.v, label);
  return source2;
}
function tag_proxy(value, label) {
  value?.[PROXY_PATH_SYMBOL]?.(label);
  return value;
}
var tracing_expressions;
var init_tracing = __esm({
  'node_modules/svelte/src/internal/client/dev/tracing.js'() {
    init_constants2();
    init_clone();
    init_utils3();
    init_constants();
    init_effects();
    init_runtime();
    tracing_expressions = null;
  },
});

// node_modules/svelte/src/internal/client/context.js
function set_component_context(context) {
  component_context = context;
}
function set_dev_stack(stack2) {
  dev_stack = stack2;
}
function set_dev_current_component_function(fn) {
  dev_current_component_function = fn;
}
function push(props, runes = false, fn) {
  component_context = {
    p: component_context,
    c: null,
    e: null,
    s: props,
    x: null,
    l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null,
  };
  if (dev_fallback_default) {
    component_context.function = fn;
    dev_current_component_function = fn;
  }
}
function pop(component2) {
  var context =
    /** @type {ComponentContext} */
    component_context;
  var effects = context.e;
  if (effects !== null) {
    context.e = null;
    for (var fn of effects) {
      create_user_effect(fn);
    }
  }
  if (component2 !== void 0) {
    context.x = component2;
  }
  component_context = context.p;
  if (dev_fallback_default) {
    dev_current_component_function = component_context?.function ?? null;
  }
  return component2 ?? /** @type {T} */ {};
}
function is_runes() {
  return !legacy_mode_flag || (component_context !== null && component_context.l === null);
}
var component_context, dev_stack, dev_current_component_function;
var init_context = __esm({
  'node_modules/svelte/src/internal/client/context.js'() {
    init_esm_env();
    init_errors2();
    init_runtime();
    init_effects();
    init_flags();
    init_constants2();
    init_constants();
    component_context = null;
    dev_stack = null;
    dev_current_component_function = null;
  },
});

// node_modules/svelte/src/internal/client/dom/task.js
function run_micro_tasks() {
  var tasks = micro_tasks;
  micro_tasks = [];
  run_all(tasks);
}
function queue_micro_task(fn) {
  if (micro_tasks.length === 0 && !is_flushing_sync) {
    var tasks = micro_tasks;
    queueMicrotask(() => {
      if (tasks === micro_tasks) run_micro_tasks();
    });
  }
  micro_tasks.push(fn);
}
function flush_tasks() {
  while (micro_tasks.length > 0) {
    run_micro_tasks();
  }
}
var micro_tasks;
var init_task = __esm({
  'node_modules/svelte/src/internal/client/dom/task.js'() {
    init_utils3();
    init_batch();
    micro_tasks = [];
  },
});

// node_modules/svelte/src/internal/client/error-handling.js
function handle_error(error) {
  var effect2 = active_effect;
  if (effect2 === null) {
    active_reaction.f |= ERROR_VALUE;
    return error;
  }
  if (dev_fallback_default && error instanceof Error && !adjustments.has(error)) {
    adjustments.set(error, get_adjustments(error, effect2));
  }
  if ((effect2.f & EFFECT_RAN) === 0) {
    if ((effect2.f & BOUNDARY_EFFECT) === 0) {
      if (!effect2.parent && error instanceof Error) {
        apply_adjustments(error);
      }
      throw error;
    }
    effect2.b.error(error);
  } else {
    invoke_error_boundary(error, effect2);
  }
}
function invoke_error_boundary(error, effect2) {
  while (effect2 !== null) {
    if ((effect2.f & BOUNDARY_EFFECT) !== 0) {
      try {
        effect2.b.error(error);
        return;
      } catch (e) {
        error = e;
      }
    }
    effect2 = effect2.parent;
  }
  if (error instanceof Error) {
    apply_adjustments(error);
  }
  throw error;
}
function get_adjustments(error, effect2) {
  const message_descriptor = get_descriptor(error, 'message');
  if (message_descriptor && !message_descriptor.configurable) return;
  var indent = is_firefox ? '  ' : '	';
  var component_stack = `
${indent}in ${effect2.fn?.name || '<unknown>'}`;
  var context = effect2.ctx;
  while (context !== null) {
    component_stack += `
${indent}in ${context.function?.[FILENAME].split('/').pop()}`;
    context = context.p;
  }
  return {
    message:
      error.message +
      `
${component_stack}
`,
    stack: error.stack
      ?.split('\n')
      .filter((line) => !line.includes('svelte/src/internal'))
      .join('\n'),
  };
}
function apply_adjustments(error) {
  const adjusted = adjustments.get(error);
  if (adjusted) {
    define_property(error, 'message', {
      value: adjusted.message,
    });
    define_property(error, 'stack', {
      value: adjusted.stack,
    });
  }
}
var adjustments;
var init_error_handling = __esm({
  'node_modules/svelte/src/internal/client/error-handling.js'() {
    init_esm_env();
    init_constants2();
    init_operations();
    init_constants();
    init_utils3();
    init_runtime();
    adjustments = /* @__PURE__ */ new WeakMap();
  },
});

// node_modules/svelte/src/internal/client/reactivity/batch.js
function flushSync(fn) {
  if (async_mode_flag && active_effect !== null) {
    flush_sync_in_effect();
  }
  var was_flushing_sync = is_flushing_sync;
  is_flushing_sync = true;
  try {
    var result;
    if (fn) {
      if (current_batch !== null) {
        flush_effects();
      }
      result = fn();
    }
    while (true) {
      flush_tasks();
      if (queued_root_effects.length === 0) {
        current_batch?.flush();
        if (queued_root_effects.length === 0) {
          last_scheduled_effect = null;
          return (
            /** @type {T} */
            result
          );
        }
      }
      flush_effects();
    }
  } finally {
    is_flushing_sync = was_flushing_sync;
  }
}
function flush_effects() {
  var was_updating_effect = is_updating_effect;
  is_flushing = true;
  try {
    var flush_count = 0;
    set_is_updating_effect(true);
    while (queued_root_effects.length > 0) {
      var batch = Batch.ensure();
      if (flush_count++ > 1e3) {
        if (dev_fallback_default) {
          var updates = /* @__PURE__ */ new Map();
          for (const source2 of batch.current.keys()) {
            for (const [stack2, update2] of source2.updated ?? []) {
              var entry = updates.get(stack2);
              if (!entry) {
                entry = { error: update2.error, count: 0 };
                updates.set(stack2, entry);
              }
              entry.count += update2.count;
            }
          }
          for (const update2 of updates.values()) {
            console.error(update2.error);
          }
        }
        infinite_loop_guard();
      }
      batch.process(queued_root_effects);
      old_values.clear();
    }
  } finally {
    is_flushing = false;
    set_is_updating_effect(was_updating_effect);
    last_scheduled_effect = null;
  }
}
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error) {
    if (dev_fallback_default) {
      define_property(error, 'stack', { value: '' });
    }
    invoke_error_boundary(error, last_scheduled_effect);
  }
}
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0) return;
  var i = 0;
  while (i < length) {
    var effect2 = effects[i++];
    if ((effect2.f & (DESTROYED | INERT)) === 0 && is_dirty(effect2)) {
      eager_block_effects = [];
      update_effect(effect2);
      if (effect2.deps === null && effect2.first === null && effect2.nodes_start === null) {
        if (effect2.teardown === null && effect2.ac === null) {
          unlink_effect(effect2);
        } else {
          effect2.fn = null;
        }
      }
      if (eager_block_effects?.length > 0) {
        old_values.clear();
        for (const e of eager_block_effects) {
          update_effect(e);
        }
        eager_block_effects = [];
      }
    }
  }
  eager_block_effects = null;
}
function mark_effects(value, sources) {
  if (value.reactions !== null) {
    for (const reaction of value.reactions) {
      const flags2 = reaction.f;
      if ((flags2 & DERIVED) !== 0) {
        mark_effects(
          /** @type {Derived} */
          reaction,
          sources
        );
      } else if ((flags2 & (ASYNC | BLOCK_EFFECT)) !== 0 && depends_on(reaction, sources)) {
        set_signal_status(reaction, DIRTY);
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
}
function depends_on(reaction, sources) {
  if (reaction.deps !== null) {
    for (const dep of reaction.deps) {
      if (sources.includes(dep)) {
        return true;
      }
      if (
        (dep.f & DERIVED) !== 0 &&
        depends_on(
          /** @type {Derived} */
          dep,
          sources
        )
      ) {
        return true;
      }
    }
  }
  return false;
}
function schedule_effect(signal) {
  var effect2 = (last_scheduled_effect = signal);
  while (effect2.parent !== null) {
    effect2 = effect2.parent;
    var flags2 = effect2.f;
    if (is_flushing && effect2 === active_effect && (flags2 & BLOCK_EFFECT) !== 0) {
      return;
    }
    if ((flags2 & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags2 & CLEAN) === 0) return;
      effect2.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect2);
}
var batches,
  current_batch,
  previous_batch,
  batch_values,
  effect_pending_updates,
  queued_root_effects,
  last_scheduled_effect,
  is_flushing,
  is_flushing_sync,
  Batch,
  eager_block_effects;
var init_batch = __esm({
  'node_modules/svelte/src/internal/client/reactivity/batch.js'() {
    init_constants();
    init_flags();
    init_utils3();
    init_runtime();
    init_errors2();
    init_task();
    init_esm_env();
    init_error_handling();
    init_sources();
    init_effects();
    batches = /* @__PURE__ */ new Set();
    current_batch = null;
    previous_batch = null;
    batch_values = null;
    effect_pending_updates = /* @__PURE__ */ new Set();
    queued_root_effects = [];
    last_scheduled_effect = null;
    is_flushing = false;
    is_flushing_sync = false;
    Batch = class _Batch {
      /**
       * The current values of any sources that are updated in this batch
       * They keys of this map are identical to `this.#previous`
       * @type {Map<Source, any>}
       */
      current = /* @__PURE__ */ new Map();
      /**
       * The values of any sources that are updated in this batch _before_ those updates took place.
       * They keys of this map are identical to `this.#current`
       * @type {Map<Source, any>}
       */
      #previous = /* @__PURE__ */ new Map();
      /**
       * When the batch is committed (and the DOM is updated), we need to remove old branches
       * and append new ones by calling the functions added inside (if/each/key/etc) blocks
       * @type {Set<() => void>}
       */
      #callbacks = /* @__PURE__ */ new Set();
      /**
       * The number of async effects that are currently in flight
       */
      #pending = 0;
      /**
       * A deferred that resolves when the batch is committed, used with `settled()`
       * TODO replace with Promise.withResolvers once supported widely enough
       * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
       */
      #deferred = null;
      /**
       * Async effects inside a newly-created `<svelte:boundary>`
       *  these do not prevent the batch from committing
       * @type {Effect[]}
       */
      #boundary_async_effects = [];
      /**
       * Template effects and `$effect.pre` effects, which run when
       * a batch is committed
       * @type {Effect[]}
       */
      #render_effects = [];
      /**
       * The same as `#render_effects`, but for `$effect` (which runs after)
       * @type {Effect[]}
       */
      #effects = [];
      /**
       * Block effects, which may need to re-run on subsequent flushes
       * in order to update internal sources (e.g. each block items)
       * @type {Effect[]}
       */
      #block_effects = [];
      /**
       * Deferred effects (which run after async work has completed) that are DIRTY
       * @type {Effect[]}
       */
      #dirty_effects = [];
      /**
       * Deferred effects that are MAYBE_DIRTY
       * @type {Effect[]}
       */
      #maybe_dirty_effects = [];
      /**
       * A set of branches that still exist, but will be destroyed when this batch
       * is committed  we skip over these during `process`
       * @type {Set<Effect>}
       */
      skipped_effects = /* @__PURE__ */ new Set();
      /**
       *
       * @param {Effect[]} root_effects
       */
      process(root_effects) {
        queued_root_effects = [];
        previous_batch = null;
        this.apply();
        for (const root of root_effects) {
          this.#traverse_effect_tree(root);
        }
        if (this.#pending === 0) {
          var previous_batch_sources = batch_values;
          this.#commit();
          var render_effects = this.#render_effects;
          var effects = this.#effects;
          this.#render_effects = [];
          this.#effects = [];
          this.#block_effects = [];
          previous_batch = this;
          current_batch = null;
          batch_values = previous_batch_sources;
          flush_queued_effects(render_effects);
          flush_queued_effects(effects);
          previous_batch = null;
          this.#deferred?.resolve();
        } else {
          this.#defer_effects(this.#render_effects);
          this.#defer_effects(this.#effects);
          this.#defer_effects(this.#block_effects);
        }
        batch_values = null;
        for (const effect2 of this.#boundary_async_effects) {
          update_effect(effect2);
        }
        this.#boundary_async_effects = [];
      }
      /**
       * Traverse the effect tree, executing effects or stashing
       * them for later execution as appropriate
       * @param {Effect} root
       */
      #traverse_effect_tree(root) {
        root.f ^= CLEAN;
        var effect2 = root.first;
        while (effect2 !== null) {
          var flags2 = effect2.f;
          var is_branch = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
          var is_skippable_branch = is_branch && (flags2 & CLEAN) !== 0;
          var skip =
            is_skippable_branch || (flags2 & INERT) !== 0 || this.skipped_effects.has(effect2);
          if (!skip && effect2.fn !== null) {
            if (is_branch) {
              effect2.f ^= CLEAN;
            } else if ((flags2 & EFFECT) !== 0) {
              this.#effects.push(effect2);
            } else if (async_mode_flag && (flags2 & RENDER_EFFECT) !== 0) {
              this.#render_effects.push(effect2);
            } else if ((flags2 & CLEAN) === 0) {
              if ((flags2 & ASYNC) !== 0 && effect2.b?.is_pending()) {
                this.#boundary_async_effects.push(effect2);
              } else if (is_dirty(effect2)) {
                if ((effect2.f & BLOCK_EFFECT) !== 0) this.#block_effects.push(effect2);
                update_effect(effect2);
              }
            }
            var child2 = effect2.first;
            if (child2 !== null) {
              effect2 = child2;
              continue;
            }
          }
          var parent = effect2.parent;
          effect2 = effect2.next;
          while (effect2 === null && parent !== null) {
            effect2 = parent.next;
            parent = parent.parent;
          }
        }
      }
      /**
       * @param {Effect[]} effects
       */
      #defer_effects(effects) {
        for (const e of effects) {
          const target = (e.f & DIRTY) !== 0 ? this.#dirty_effects : this.#maybe_dirty_effects;
          target.push(e);
          set_signal_status(e, CLEAN);
        }
        effects.length = 0;
      }
      /**
       * Associate a change to a given source with the current
       * batch, noting its previous and current values
       * @param {Source} source
       * @param {any} value
       */
      capture(source2, value) {
        if (!this.#previous.has(source2)) {
          this.#previous.set(source2, value);
        }
        this.current.set(source2, source2.v);
        batch_values?.set(source2, source2.v);
      }
      activate() {
        current_batch = this;
      }
      deactivate() {
        current_batch = null;
        batch_values = null;
      }
      flush() {
        if (queued_root_effects.length > 0) {
          this.activate();
          flush_effects();
          if (current_batch !== null && current_batch !== this) {
            return;
          }
        } else if (this.#pending === 0) {
          this.#commit();
        }
        this.deactivate();
        for (const update2 of effect_pending_updates) {
          effect_pending_updates.delete(update2);
          update2();
          if (current_batch !== null) {
            break;
          }
        }
      }
      /**
       * Append and remove branches to/from the DOM
       */
      #commit() {
        for (const fn of this.#callbacks) {
          fn();
        }
        this.#callbacks.clear();
        if (batches.size > 1) {
          this.#previous.clear();
          let is_earlier = true;
          for (const batch of batches) {
            if (batch === this) {
              is_earlier = false;
              continue;
            }
            const sources = [];
            for (const [source2, value] of this.current) {
              if (batch.current.has(source2)) {
                if (is_earlier && value !== batch.current.get(source2)) {
                  batch.current.set(source2, value);
                } else {
                  continue;
                }
              }
              sources.push(source2);
            }
            if (sources.length === 0) {
              continue;
            }
            const others = [...batch.current.keys()].filter((s) => !this.current.has(s));
            if (others.length > 0) {
              for (const source2 of sources) {
                mark_effects(source2, others);
              }
              if (queued_root_effects.length > 0) {
                current_batch = batch;
                batch.apply();
                for (const root of queued_root_effects) {
                  batch.#traverse_effect_tree(root);
                }
                queued_root_effects = [];
                batch.deactivate();
              }
            }
          }
          current_batch = null;
        }
        batches.delete(this);
      }
      increment() {
        this.#pending += 1;
      }
      decrement() {
        this.#pending -= 1;
        for (const e of this.#dirty_effects) {
          set_signal_status(e, DIRTY);
          schedule_effect(e);
        }
        for (const e of this.#maybe_dirty_effects) {
          set_signal_status(e, MAYBE_DIRTY);
          schedule_effect(e);
        }
        this.flush();
      }
      /** @param {() => void} fn */
      add_callback(fn) {
        this.#callbacks.add(fn);
      }
      settled() {
        return (this.#deferred ??= deferred()).promise;
      }
      static ensure() {
        if (current_batch === null) {
          const batch = (current_batch = new _Batch());
          batches.add(current_batch);
          if (!is_flushing_sync) {
            _Batch.enqueue(() => {
              if (current_batch !== batch) {
                return;
              }
              batch.flush();
            });
          }
        }
        return current_batch;
      }
      /** @param {() => void} task */
      static enqueue(task) {
        queue_micro_task(task);
      }
      apply() {
        if (!async_mode_flag || batches.size === 1) return;
        batch_values = new Map(this.current);
        for (const batch of batches) {
          if (batch === this) continue;
          for (const [source2, previous] of batch.#previous) {
            if (!batch_values.has(source2)) {
              batch_values.set(source2, previous);
            }
          }
        }
      }
    };
    eager_block_effects = null;
  },
});

// node_modules/svelte/src/reactivity/create-subscriber.js
function createSubscriber(start) {
  let subscribers = 0;
  let version4 = source(0);
  let stop2;
  if (dev_fallback_default) {
    tag(version4, 'createSubscriber version');
  }
  return () => {
    if (effect_tracking()) {
      get(version4);
      render_effect(() => {
        if (subscribers === 0) {
          stop2 = untrack(() => start(() => increment(version4)));
        }
        subscribers += 1;
        return () => {
          queue_micro_task(() => {
            subscribers -= 1;
            if (subscribers === 0) {
              stop2?.();
              stop2 = void 0;
              increment(version4);
            }
          });
        };
      });
    }
  };
}
var init_create_subscriber = __esm({
  'node_modules/svelte/src/reactivity/create-subscriber.js'() {
    init_runtime();
    init_effects();
    init_sources();
    init_tracing();
    init_esm_env();
    init_task();
  },
});

// node_modules/svelte/src/internal/client/dom/blocks/boundary.js
function boundary(node, props, children) {
  new Boundary(node, props, children);
}
function move_effect(effect2, fragment) {
  var node = effect2.nodes_start;
  var end = effect2.nodes_end;
  while (node !== null) {
    var next2 =
      node === end
        ? null
        : /** @type {TemplateNode} */
          get_next_sibling(node);
    fragment.append(node);
    node = next2;
  }
}
var flags, Boundary;
var init_boundary = __esm({
  'node_modules/svelte/src/internal/client/dom/blocks/boundary.js'() {
    init_constants();
    init_constants2();
    init_context();
    init_error_handling();
    init_effects();
    init_runtime();
    init_hydration();
    init_operations();
    init_task();
    init_errors2();
    init_warnings();
    init_esm_env();
    init_batch();
    init_sources();
    init_tracing();
    init_create_subscriber();
    flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;
    Boundary = class {
      /** @type {Boundary | null} */
      parent;
      #pending = false;
      /** @type {TemplateNode} */
      #anchor;
      /** @type {TemplateNode | null} */
      #hydrate_open = hydrating ? hydrate_node : null;
      /** @type {BoundaryProps} */
      #props;
      /** @type {((anchor: Node) => void)} */
      #children;
      /** @type {Effect} */
      #effect;
      /** @type {Effect | null} */
      #main_effect = null;
      /** @type {Effect | null} */
      #pending_effect = null;
      /** @type {Effect | null} */
      #failed_effect = null;
      /** @type {DocumentFragment | null} */
      #offscreen_fragment = null;
      #local_pending_count = 0;
      #pending_count = 0;
      #is_creating_fallback = false;
      /**
       * A source containing the number of pending async deriveds/expressions.
       * Only created if `$effect.pending()` is used inside the boundary,
       * otherwise updating the source results in needless `Batch.ensure()`
       * calls followed by no-op flushes
       * @type {Source<number> | null}
       */
      #effect_pending = null;
      #effect_pending_update = () => {
        if (this.#effect_pending) {
          internal_set(this.#effect_pending, this.#local_pending_count);
        }
      };
      #effect_pending_subscriber = createSubscriber(() => {
        this.#effect_pending = source(this.#local_pending_count);
        if (dev_fallback_default) {
          tag(this.#effect_pending, '$effect.pending()');
        }
        return () => {
          this.#effect_pending = null;
        };
      });
      /**
       * @param {TemplateNode} node
       * @param {BoundaryProps} props
       * @param {((anchor: Node) => void)} children
       */
      constructor(node, props, children) {
        this.#anchor = node;
        this.#props = props;
        this.#children = children;
        this.parent = /** @type {Effect} */ active_effect.b;
        this.#pending = !!this.#props.pending;
        this.#effect = block(() => {
          active_effect.b = this;
          if (hydrating) {
            const comment2 = this.#hydrate_open;
            hydrate_next();
            const server_rendered_pending =
              /** @type {Comment} */
              comment2.nodeType === COMMENT_NODE &&
              /** @type {Comment} */
              comment2.data === HYDRATION_START_ELSE;
            if (server_rendered_pending) {
              this.#hydrate_pending_content();
            } else {
              this.#hydrate_resolved_content();
            }
          } else {
            try {
              this.#main_effect = branch(() => children(this.#anchor));
            } catch (error) {
              this.error(error);
            }
            if (this.#pending_count > 0) {
              this.#show_pending_snippet();
            } else {
              this.#pending = false;
            }
          }
        }, flags);
        if (hydrating) {
          this.#anchor = hydrate_node;
        }
      }
      #hydrate_resolved_content() {
        try {
          this.#main_effect = branch(() => this.#children(this.#anchor));
        } catch (error) {
          this.error(error);
        }
        this.#pending = false;
      }
      #hydrate_pending_content() {
        const pending2 = this.#props.pending;
        if (!pending2) {
          return;
        }
        this.#pending_effect = branch(() => pending2(this.#anchor));
        Batch.enqueue(() => {
          this.#main_effect = this.#run(() => {
            Batch.ensure();
            return branch(() => this.#children(this.#anchor));
          });
          if (this.#pending_count > 0) {
            this.#show_pending_snippet();
          } else {
            pause_effect(
              /** @type {Effect} */
              this.#pending_effect,
              () => {
                this.#pending_effect = null;
              }
            );
            this.#pending = false;
          }
        });
      }
      /**
       * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
       * @returns {boolean}
       */
      is_pending() {
        return this.#pending || (!!this.parent && this.parent.is_pending());
      }
      has_pending_snippet() {
        return !!this.#props.pending;
      }
      /**
       * @param {() => Effect | null} fn
       */
      #run(fn) {
        var previous_effect = active_effect;
        var previous_reaction = active_reaction;
        var previous_ctx = component_context;
        set_active_effect(this.#effect);
        set_active_reaction(this.#effect);
        set_component_context(this.#effect.ctx);
        try {
          return fn();
        } catch (e) {
          handle_error(e);
          return null;
        } finally {
          set_active_effect(previous_effect);
          set_active_reaction(previous_reaction);
          set_component_context(previous_ctx);
        }
      }
      #show_pending_snippet() {
        const pending2 =
          /** @type {(anchor: Node) => void} */
          this.#props.pending;
        if (this.#main_effect !== null) {
          this.#offscreen_fragment = document.createDocumentFragment();
          move_effect(this.#main_effect, this.#offscreen_fragment);
        }
        if (this.#pending_effect === null) {
          this.#pending_effect = branch(() => pending2(this.#anchor));
        }
      }
      /**
       * Updates the pending count associated with the currently visible pending snippet,
       * if any, such that we can replace the snippet with content once work is done
       * @param {1 | -1} d
       */
      #update_pending_count(d) {
        if (!this.has_pending_snippet()) {
          if (this.parent) {
            this.parent.#update_pending_count(d);
          }
          return;
        }
        this.#pending_count += d;
        if (this.#pending_count === 0) {
          this.#pending = false;
          if (this.#pending_effect) {
            pause_effect(this.#pending_effect, () => {
              this.#pending_effect = null;
            });
          }
          if (this.#offscreen_fragment) {
            this.#anchor.before(this.#offscreen_fragment);
            this.#offscreen_fragment = null;
          }
          queue_micro_task(() => {
            Batch.ensure().flush();
          });
        }
      }
      /**
       * Update the source that powers `$effect.pending()` inside this boundary,
       * and controls when the current `pending` snippet (if any) is removed.
       * Do not call from inside the class
       * @param {1 | -1} d
       */
      update_pending_count(d) {
        this.#update_pending_count(d);
        this.#local_pending_count += d;
        effect_pending_updates.add(this.#effect_pending_update);
      }
      get_effect_pending() {
        this.#effect_pending_subscriber();
        return get(
          /** @type {Source<number>} */
          this.#effect_pending
        );
      }
      /** @param {unknown} error */
      error(error) {
        var onerror = this.#props.onerror;
        let failed = this.#props.failed;
        if (this.#is_creating_fallback || (!onerror && !failed)) {
          throw error;
        }
        if (this.#main_effect) {
          destroy_effect(this.#main_effect);
          this.#main_effect = null;
        }
        if (this.#pending_effect) {
          destroy_effect(this.#pending_effect);
          this.#pending_effect = null;
        }
        if (this.#failed_effect) {
          destroy_effect(this.#failed_effect);
          this.#failed_effect = null;
        }
        if (hydrating) {
          set_hydrate_node(
            /** @type {TemplateNode} */
            this.#hydrate_open
          );
          next();
          set_hydrate_node(skip_nodes());
        }
        var did_reset = false;
        var calling_on_error = false;
        const reset2 = () => {
          if (did_reset) {
            svelte_boundary_reset_noop();
            return;
          }
          did_reset = true;
          if (calling_on_error) {
            svelte_boundary_reset_onerror();
          }
          Batch.ensure();
          this.#local_pending_count = 0;
          if (this.#failed_effect !== null) {
            pause_effect(this.#failed_effect, () => {
              this.#failed_effect = null;
            });
          }
          this.#pending = this.has_pending_snippet();
          this.#main_effect = this.#run(() => {
            this.#is_creating_fallback = false;
            return branch(() => this.#children(this.#anchor));
          });
          if (this.#pending_count > 0) {
            this.#show_pending_snippet();
          } else {
            this.#pending = false;
          }
        };
        var previous_reaction = active_reaction;
        try {
          set_active_reaction(null);
          calling_on_error = true;
          onerror?.(error, reset2);
          calling_on_error = false;
        } catch (error2) {
          invoke_error_boundary(error2, this.#effect && this.#effect.parent);
        } finally {
          set_active_reaction(previous_reaction);
        }
        if (failed) {
          queue_micro_task(() => {
            this.#failed_effect = this.#run(() => {
              this.#is_creating_fallback = true;
              try {
                return branch(() => {
                  failed(
                    this.#anchor,
                    () => error,
                    () => reset2
                  );
                });
              } catch (error2) {
                invoke_error_boundary(
                  error2,
                  /** @type {Effect} */
                  this.#effect.parent
                );
                return null;
              } finally {
                this.#is_creating_fallback = false;
              }
            });
          });
        }
      }
    };
  },
});

// node_modules/svelte/src/internal/client/reactivity/async.js
var init_async = __esm({
  'node_modules/svelte/src/internal/client/reactivity/async.js'() {
    init_constants();
    init_esm_env();
    init_context();
    init_boundary();
    init_error_handling();
    init_runtime();
    init_batch();
    init_deriveds();
    init_effects();
    init_hydration();
  },
});

// node_modules/svelte/src/internal/client/reactivity/deriveds.js
function destroy_derived_effects(derived3) {
  var effects = derived3.effects;
  if (effects !== null) {
    derived3.effects = null;
    for (var i = 0; i < effects.length; i += 1) {
      destroy_effect(
        /** @type {Effect} */
        effects[i]
      );
    }
  }
}
function get_derived_parent_effect(derived3) {
  var parent = derived3.parent;
  while (parent !== null) {
    if ((parent.f & DERIVED) === 0) {
      return (
        /** @type {Effect} */
        parent
      );
    }
    parent = parent.parent;
  }
  return null;
}
function execute_derived(derived3) {
  var value;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived3));
  if (dev_fallback_default) {
    let prev_inspect_effects = inspect_effects;
    set_inspect_effects(/* @__PURE__ */ new Set());
    try {
      if (stack.includes(derived3)) {
        derived_references_self();
      }
      stack.push(derived3);
      destroy_derived_effects(derived3);
      value = update_reaction(derived3);
    } finally {
      set_active_effect(prev_active_effect);
      set_inspect_effects(prev_inspect_effects);
      stack.pop();
    }
  } else {
    try {
      destroy_derived_effects(derived3);
      value = update_reaction(derived3);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value;
}
function update_derived(derived3) {
  var value = execute_derived(derived3);
  if (!derived3.equals(value)) {
    derived3.v = value;
    derived3.wv = increment_write_version();
  }
  if (is_destroying_effect) {
    return;
  }
  if (batch_values !== null) {
    batch_values.set(derived3, derived3.v);
  } else {
    var status =
      (skip_reaction || (derived3.f & UNOWNED) !== 0) && derived3.deps !== null
        ? MAYBE_DIRTY
        : CLEAN;
    set_signal_status(derived3, status);
  }
}
var current_async_effect, recent_async_deriveds, stack;
var init_deriveds = __esm({
  'node_modules/svelte/src/internal/client/reactivity/deriveds.js'() {
    init_esm_env();
    init_constants();
    init_runtime();
    init_equality();
    init_errors2();
    init_warnings();
    init_effects();
    init_sources();
    init_tracing();
    init_flags();
    init_boundary();
    init_context();
    init_constants2();
    init_batch();
    init_async();
    init_utils3();
    current_async_effect = null;
    recent_async_deriveds = /* @__PURE__ */ new Set();
    stack = [];
  },
});

// node_modules/svelte/src/internal/client/reactivity/sources.js
function set_inspect_effects(v) {
  inspect_effects = v;
}
function set_inspect_effects_deferred() {
  inspect_effects_deferred = true;
}
function source(v, stack2) {
  var signal = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v,
    reactions: null,
    equals,
    rv: 0,
    wv: 0,
  };
  if (dev_fallback_default && tracing_mode_flag) {
    signal.created = stack2 ?? get_stack('CreatedAt');
    signal.updated = null;
    signal.set_during_effect = false;
    signal.trace = null;
  }
  return signal;
}
// @__NO_SIDE_EFFECTS__
function state(v, stack2) {
  const s = source(v, stack2);
  push_reaction_value(s);
  return s;
}
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value, immutable = false, trackable = true) {
  const s = source(initial_value);
  if (!immutable) {
    s.equals = safe_equals;
  }
  if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
    (component_context.l.s ??= []).push(s);
  }
  return s;
}
function set(source2, value, should_proxy = false) {
  if (
    active_reaction !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
    // to ensure we error if state is set inside an inspect effect
    (!untracking || (active_reaction.f & INSPECT_EFFECT) !== 0) &&
    is_runes() &&
    (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | INSPECT_EFFECT)) !== 0 &&
    !current_sources?.includes(source2)
  ) {
    state_unsafe_mutation();
  }
  let new_value = should_proxy ? proxy(value) : value;
  if (dev_fallback_default) {
    tag_proxy(
      new_value,
      /** @type {string} */
      source2.label
    );
  }
  return internal_set(source2, new_value);
}
function internal_set(source2, value) {
  if (!source2.equals(value)) {
    var old_value = source2.v;
    if (is_destroying_effect) {
      old_values.set(source2, value);
    } else {
      old_values.set(source2, old_value);
    }
    source2.v = value;
    var batch = Batch.ensure();
    batch.capture(source2, old_value);
    if (dev_fallback_default) {
      if (tracing_mode_flag || active_effect !== null) {
        const error = get_stack('UpdatedAt');
        if (error !== null) {
          source2.updated ??= /* @__PURE__ */ new Map();
          let entry = source2.updated.get(error.stack);
          if (!entry) {
            entry = { error, count: 0 };
            source2.updated.set(error.stack, entry);
          }
          entry.count++;
        }
      }
      if (active_effect !== null) {
        source2.set_during_effect = true;
      }
    }
    if ((source2.f & DERIVED) !== 0) {
      if ((source2.f & DIRTY) !== 0) {
        execute_derived(
          /** @type {Derived} */
          source2
        );
      }
      set_signal_status(source2, (source2.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (
      is_runes() &&
      active_effect !== null &&
      (active_effect.f & CLEAN) !== 0 &&
      (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0
    ) {
      if (untracked_writes === null) {
        set_untracked_writes([source2]);
      } else {
        untracked_writes.push(source2);
      }
    }
    if (dev_fallback_default && inspect_effects.size > 0 && !inspect_effects_deferred) {
      flush_inspect_effects();
    }
  }
  return value;
}
function flush_inspect_effects() {
  inspect_effects_deferred = false;
  const inspects = Array.from(inspect_effects);
  for (const effect2 of inspects) {
    if ((effect2.f & CLEAN) !== 0) {
      set_signal_status(effect2, MAYBE_DIRTY);
    }
    if (is_dirty(effect2)) {
      update_effect(effect2);
    }
  }
  inspect_effects.clear();
}
function increment(source2) {
  set(source2, source2.v + 1);
}
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  var runes = is_runes();
  var length = reactions.length;
  for (var i = 0; i < length; i++) {
    var reaction = reactions[i];
    var flags2 = reaction.f;
    if (!runes && reaction === active_effect) continue;
    if (dev_fallback_default && (flags2 & INSPECT_EFFECT) !== 0) {
      inspect_effects.add(reaction);
      continue;
    }
    var not_dirty = (flags2 & DIRTY) === 0;
    if (not_dirty) {
      set_signal_status(reaction, status);
    }
    if ((flags2 & DERIVED) !== 0) {
      mark_reactions(
        /** @type {Derived} */
        reaction,
        MAYBE_DIRTY
      );
    } else if (not_dirty) {
      if ((flags2 & BLOCK_EFFECT) !== 0) {
        if (eager_block_effects !== null) {
          eager_block_effects.push(
            /** @type {Effect} */
            reaction
          );
        }
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
var inspect_effects, old_values, inspect_effects_deferred;
var init_sources = __esm({
  'node_modules/svelte/src/internal/client/reactivity/sources.js'() {
    init_esm_env();
    init_runtime();
    init_equality();
    init_constants();
    init_errors2();
    init_flags();
    init_tracing();
    init_context();
    init_batch();
    init_proxy();
    init_deriveds();
    inspect_effects = /* @__PURE__ */ new Set();
    old_values = /* @__PURE__ */ new Map();
    inspect_effects_deferred = false;
  },
});

// node_modules/svelte/src/internal/client/proxy.js
function proxy(value) {
  if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {
    return value;
  }
  const prototype3 = get_prototype_of(value);
  if (prototype3 !== object_prototype && prototype3 !== array_prototype) {
    return value;
  }
  var sources = /* @__PURE__ */ new Map();
  var is_proxied_array = is_array(value);
  var version4 = state(0);
  var stack2 = dev_fallback_default && tracing_mode_flag ? get_stack('CreatedAt') : null;
  var parent_version = update_version;
  var with_parent = (fn) => {
    if (update_version === parent_version) {
      return fn();
    }
    var reaction = active_reaction;
    var version5 = update_version;
    set_active_reaction(null);
    set_update_version(parent_version);
    var result = fn();
    set_active_reaction(reaction);
    set_update_version(version5);
    return result;
  };
  if (is_proxied_array) {
    sources.set(
      'length',
      state(
        /** @type {any[]} */
        value.length,
        stack2
      )
    );
    if (dev_fallback_default) {
      value =
        /** @type {any} */
        inspectable_array(
          /** @type {any[]} */
          value
        );
    }
  }
  var path5 = '';
  let updating = false;
  function update_path(new_path) {
    if (updating) return;
    updating = true;
    path5 = new_path;
    tag(version4, `${path5} version`);
    for (const [prop2, source2] of sources) {
      tag(source2, get_label(path5, prop2));
    }
    updating = false;
  }
  return new Proxy(
    /** @type {any} */
    value,
    {
      defineProperty(_, prop2, descriptor) {
        if (
          !('value' in descriptor) ||
          descriptor.configurable === false ||
          descriptor.enumerable === false ||
          descriptor.writable === false
        ) {
          state_descriptors_fixed();
        }
        var s = sources.get(prop2);
        if (s === void 0) {
          s = with_parent(() => {
            var s2 = state(descriptor.value, stack2);
            sources.set(prop2, s2);
            if (dev_fallback_default && typeof prop2 === 'string') {
              tag(s2, get_label(path5, prop2));
            }
            return s2;
          });
        } else {
          set(s, descriptor.value, true);
        }
        return true;
      },
      deleteProperty(target, prop2) {
        var s = sources.get(prop2);
        if (s === void 0) {
          if (prop2 in target) {
            const s2 = with_parent(() => state(UNINITIALIZED, stack2));
            sources.set(prop2, s2);
            increment(version4);
            if (dev_fallback_default) {
              tag(s2, get_label(path5, prop2));
            }
          }
        } else {
          set(s, UNINITIALIZED);
          increment(version4);
        }
        return true;
      },
      get(target, prop2, receiver) {
        if (prop2 === STATE_SYMBOL) {
          return value;
        }
        if (dev_fallback_default && prop2 === PROXY_PATH_SYMBOL) {
          return update_path;
        }
        var s = sources.get(prop2);
        var exists = prop2 in target;
        if (s === void 0 && (!exists || get_descriptor(target, prop2)?.writable)) {
          s = with_parent(() => {
            var p = proxy(exists ? target[prop2] : UNINITIALIZED);
            var s2 = state(p, stack2);
            if (dev_fallback_default) {
              tag(s2, get_label(path5, prop2));
            }
            return s2;
          });
          sources.set(prop2, s);
        }
        if (s !== void 0) {
          var v = get(s);
          return v === UNINITIALIZED ? void 0 : v;
        }
        return Reflect.get(target, prop2, receiver);
      },
      getOwnPropertyDescriptor(target, prop2) {
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor && 'value' in descriptor) {
          var s = sources.get(prop2);
          if (s) descriptor.value = get(s);
        } else if (descriptor === void 0) {
          var source2 = sources.get(prop2);
          var value2 = source2?.v;
          if (source2 !== void 0 && value2 !== UNINITIALIZED) {
            return {
              enumerable: true,
              configurable: true,
              value: value2,
              writable: true,
            };
          }
        }
        return descriptor;
      },
      has(target, prop2) {
        if (prop2 === STATE_SYMBOL) {
          return true;
        }
        var s = sources.get(prop2);
        var has2 = (s !== void 0 && s.v !== UNINITIALIZED) || Reflect.has(target, prop2);
        if (
          s !== void 0 ||
          (active_effect !== null && (!has2 || get_descriptor(target, prop2)?.writable))
        ) {
          if (s === void 0) {
            s = with_parent(() => {
              var p = has2 ? proxy(target[prop2]) : UNINITIALIZED;
              var s2 = state(p, stack2);
              if (dev_fallback_default) {
                tag(s2, get_label(path5, prop2));
              }
              return s2;
            });
            sources.set(prop2, s);
          }
          var value2 = get(s);
          if (value2 === UNINITIALIZED) {
            return false;
          }
        }
        return has2;
      },
      set(target, prop2, value2, receiver) {
        var s = sources.get(prop2);
        var has2 = prop2 in target;
        if (is_proxied_array && prop2 === 'length') {
          for (var i = value2; i < /** @type {Source<number>} */ s.v; i += 1) {
            var other_s = sources.get(i + '');
            if (other_s !== void 0) {
              set(other_s, UNINITIALIZED);
            } else if (i in target) {
              other_s = with_parent(() => state(UNINITIALIZED, stack2));
              sources.set(i + '', other_s);
              if (dev_fallback_default) {
                tag(other_s, get_label(path5, i));
              }
            }
          }
        }
        if (s === void 0) {
          if (!has2 || get_descriptor(target, prop2)?.writable) {
            s = with_parent(() => state(void 0, stack2));
            if (dev_fallback_default) {
              tag(s, get_label(path5, prop2));
            }
            set(s, proxy(value2));
            sources.set(prop2, s);
          }
        } else {
          has2 = s.v !== UNINITIALIZED;
          var p = with_parent(() => proxy(value2));
          set(s, p);
        }
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor?.set) {
          descriptor.set.call(receiver, value2);
        }
        if (!has2) {
          if (is_proxied_array && typeof prop2 === 'string') {
            var ls =
              /** @type {Source<number>} */
              sources.get('length');
            var n = Number(prop2);
            if (Number.isInteger(n) && n >= ls.v) {
              set(ls, n + 1);
            }
          }
          increment(version4);
        }
        return true;
      },
      ownKeys(target) {
        get(version4);
        var own_keys = Reflect.ownKeys(target).filter((key3) => {
          var source3 = sources.get(key3);
          return source3 === void 0 || source3.v !== UNINITIALIZED;
        });
        for (var [key2, source2] of sources) {
          if (source2.v !== UNINITIALIZED && !(key2 in target)) {
            own_keys.push(key2);
          }
        }
        return own_keys;
      },
      setPrototypeOf() {
        state_prototype_fixed();
      },
    }
  );
}
function get_label(path5, prop2) {
  if (typeof prop2 === 'symbol') return `${path5}[Symbol(${prop2.description ?? ''})]`;
  if (regex_is_valid_identifier.test(prop2)) return `${path5}.${prop2}`;
  return /^\d+$/.test(prop2) ? `${path5}[${prop2}]` : `${path5}['${prop2}']`;
}
function get_proxied_value(value) {
  try {
    if (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {
      return value[STATE_SYMBOL];
    }
  } catch {}
  return value;
}
function inspectable_array(array) {
  return new Proxy(array, {
    get(target, prop2, receiver) {
      var value = Reflect.get(target, prop2, receiver);
      if (
        !ARRAY_MUTATING_METHODS.has(
          /** @type {string} */
          prop2
        )
      ) {
        return value;
      }
      return function (...args) {
        set_inspect_effects_deferred();
        var result = value.apply(this, args);
        flush_inspect_effects();
        return result;
      };
    },
  });
}
var regex_is_valid_identifier, ARRAY_MUTATING_METHODS;
var init_proxy = __esm({
  'node_modules/svelte/src/internal/client/proxy.js'() {
    init_esm_env();
    init_runtime();
    init_utils3();
    init_sources();
    init_constants();
    init_constants2();
    init_errors2();
    init_tracing();
    init_flags();
    regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
    ARRAY_MUTATING_METHODS = /* @__PURE__ */ new Set([
      'copyWithin',
      'fill',
      'pop',
      'push',
      'reverse',
      'shift',
      'sort',
      'splice',
      'unshift',
    ]);
  },
});

// node_modules/svelte/src/internal/client/dev/equality.js
function init_array_prototype_warnings() {
  const array_prototype2 = Array.prototype;
  const cleanup = Array.__svelte_cleanup;
  if (cleanup) {
    cleanup();
  }
  const { indexOf, lastIndexOf, includes } = array_prototype2;
  array_prototype2.indexOf = function (item, from_index) {
    const index2 = indexOf.call(this, item, from_index);
    if (index2 === -1) {
      for (let i = from_index ?? 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch('array.indexOf(...)');
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.lastIndexOf = function (item, from_index) {
    const index2 = lastIndexOf.call(this, item, from_index ?? this.length - 1);
    if (index2 === -1) {
      for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch('array.lastIndexOf(...)');
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.includes = function (item, from_index) {
    const has2 = includes.call(this, item, from_index);
    if (!has2) {
      for (let i = 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch('array.includes(...)');
          break;
        }
      }
    }
    return has2;
  };
  Array.__svelte_cleanup = () => {
    array_prototype2.indexOf = indexOf;
    array_prototype2.lastIndexOf = lastIndexOf;
    array_prototype2.includes = includes;
  };
}
var init_equality2 = __esm({
  'node_modules/svelte/src/internal/client/dev/equality.js'() {
    init_warnings();
    init_proxy();
  },
});

// node_modules/svelte/src/internal/client/dom/operations.js
function init_operations2() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  $document = document;
  is_firefox = /Firefox/.test(navigator.userAgent);
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  var text_prototype = Text.prototype;
  first_child_getter = get_descriptor(node_prototype, 'firstChild').get;
  next_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;
  if (is_extensible(element_prototype)) {
    element_prototype.__click = void 0;
    element_prototype.__className = void 0;
    element_prototype.__attributes = null;
    element_prototype.__style = void 0;
    element_prototype.__e = void 0;
  }
  if (is_extensible(text_prototype)) {
    text_prototype.__t = void 0;
  }
  if (dev_fallback_default) {
    element_prototype.__svelte_meta = null;
    init_array_prototype_warnings();
  }
}
function create_text(value = '') {
  return document.createTextNode(value);
}
// @__NO_SIDE_EFFECTS__
function get_first_child(node) {
  return first_child_getter.call(node);
}
// @__NO_SIDE_EFFECTS__
function get_next_sibling(node) {
  return next_sibling_getter.call(node);
}
function clear_text_content(node) {
  node.textContent = '';
}
var $window, $document, is_firefox, first_child_getter, next_sibling_getter;
var init_operations = __esm({
  'node_modules/svelte/src/internal/client/dom/operations.js'() {
    init_hydration();
    init_esm_env();
    init_equality2();
    init_utils3();
    init_runtime();
    init_flags();
    init_constants();
    init_batch();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/misc.js
var init_misc = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/misc.js'() {
    init_hydration();
    init_operations();
    init_task();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js
function without_reactive_context(fn) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    return fn();
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
var init_shared = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js'() {
    init_effects();
    init_runtime();
    init_misc();
  },
});

// node_modules/svelte/src/internal/client/reactivity/effects.js
function push_effect(effect2, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect2;
  } else {
    parent_last.next = effect2;
    effect2.prev = parent_last;
    parent_effect.last = effect2;
  }
}
function create_effect(type, fn, sync, push2 = true) {
  var parent = active_effect;
  if (dev_fallback_default) {
    while (parent !== null && (parent.f & INSPECT_EFFECT) !== 0) {
      parent = parent.parent;
    }
  }
  if (parent !== null && (parent.f & INERT) !== 0) {
    type |= INERT;
  }
  var effect2 = {
    ctx: component_context,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: type | DIRTY,
    first: null,
    fn,
    last: null,
    next: null,
    parent,
    b: parent && parent.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null,
  };
  if (dev_fallback_default) {
    effect2.component_function = dev_current_component_function;
  }
  if (sync) {
    try {
      update_effect(effect2);
      effect2.f |= EFFECT_RAN;
    } catch (e2) {
      destroy_effect(effect2);
      throw e2;
    }
  } else if (fn !== null) {
    schedule_effect(effect2);
  }
  if (push2) {
    var e = effect2;
    if (
      sync &&
      e.deps === null &&
      e.teardown === null &&
      e.nodes_start === null &&
      e.first === e.last && // either `null`, or a singular child
      (e.f & EFFECT_PRESERVED) === 0
    ) {
      e = e.first;
    }
    if (e !== null) {
      e.parent = parent;
      if (parent !== null) {
        push_effect(e, parent);
      }
      if (
        active_reaction !== null &&
        (active_reaction.f & DERIVED) !== 0 &&
        (type & ROOT_EFFECT) === 0
      ) {
        var derived3 =
          /** @type {Derived} */
          active_reaction;
        (derived3.effects ??= []).push(e);
      }
    }
  }
  return effect2;
}
function effect_tracking() {
  return active_reaction !== null && !untracking;
}
function create_user_effect(fn) {
  return create_effect(EFFECT | USER_EFFECT, fn, false);
}
function effect_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return () => {
    destroy_effect(effect2);
  };
}
function component_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return (options = {}) => {
    return new Promise((fulfil) => {
      if (options.outro) {
        pause_effect(effect2, () => {
          destroy_effect(effect2);
          fulfil(void 0);
        });
      } else {
        destroy_effect(effect2);
        fulfil(void 0);
      }
    });
  };
}
function render_effect(fn, flags2 = 0) {
  return create_effect(RENDER_EFFECT | flags2, fn, true);
}
function block(fn, flags2 = 0) {
  var effect2 = create_effect(BLOCK_EFFECT | flags2, fn, true);
  if (dev_fallback_default) {
    effect2.dev_stack = dev_stack;
  }
  return effect2;
}
function branch(fn, push2 = true) {
  return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true, push2);
}
function execute_effect_teardown(effect2) {
  var teardown2 = effect2.teardown;
  if (teardown2 !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown2.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
function destroy_effect_children(signal, remove_dom = false) {
  var effect2 = signal.first;
  signal.first = signal.last = null;
  while (effect2 !== null) {
    const controller = effect2.ac;
    if (controller !== null) {
      without_reactive_context(() => {
        controller.abort(STALE_REACTION);
      });
    }
    var next2 = effect2.next;
    if ((effect2.f & ROOT_EFFECT) !== 0) {
      effect2.parent = null;
    } else {
      destroy_effect(effect2, remove_dom);
    }
    effect2 = next2;
  }
}
function destroy_block_effect_children(signal) {
  var effect2 = signal.first;
  while (effect2 !== null) {
    var next2 = effect2.next;
    if ((effect2.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect2);
    }
    effect2 = next2;
  }
}
function destroy_effect(effect2, remove_dom = true) {
  var removed = false;
  if (
    (remove_dom || (effect2.f & HEAD_EFFECT) !== 0) &&
    effect2.nodes_start !== null &&
    effect2.nodes_end !== null
  ) {
    remove_effect_dom(
      effect2.nodes_start,
      /** @type {TemplateNode} */
      effect2.nodes_end
    );
    removed = true;
  }
  destroy_effect_children(effect2, remove_dom && !removed);
  remove_reactions(effect2, 0);
  set_signal_status(effect2, DESTROYED);
  var transitions = effect2.transitions;
  if (transitions !== null) {
    for (const transition3 of transitions) {
      transition3.stop();
    }
  }
  execute_effect_teardown(effect2);
  var parent = effect2.parent;
  if (parent !== null && parent.first !== null) {
    unlink_effect(effect2);
  }
  if (dev_fallback_default) {
    effect2.component_function = null;
  }
  effect2.next =
    effect2.prev =
    effect2.teardown =
    effect2.ctx =
    effect2.deps =
    effect2.fn =
    effect2.nodes_start =
    effect2.nodes_end =
    effect2.ac =
      null;
}
function remove_effect_dom(node, end) {
  while (node !== null) {
    var next2 =
      node === end
        ? null
        : /** @type {TemplateNode} */
          get_next_sibling(node);
    node.remove();
    node = next2;
  }
}
function unlink_effect(effect2) {
  var parent = effect2.parent;
  var prev = effect2.prev;
  var next2 = effect2.next;
  if (prev !== null) prev.next = next2;
  if (next2 !== null) next2.prev = prev;
  if (parent !== null) {
    if (parent.first === effect2) parent.first = next2;
    if (parent.last === effect2) parent.last = prev;
  }
}
function pause_effect(effect2, callback) {
  var transitions = [];
  pause_children(effect2, transitions, true);
  run_out_transitions(transitions, () => {
    destroy_effect(effect2);
    if (callback) callback();
  });
}
function run_out_transitions(transitions, fn) {
  var remaining = transitions.length;
  if (remaining > 0) {
    var check = () => --remaining || fn();
    for (var transition3 of transitions) {
      transition3.out(check);
    }
  } else {
    fn();
  }
}
function pause_children(effect2, transitions, local) {
  if ((effect2.f & INERT) !== 0) return;
  effect2.f ^= INERT;
  if (effect2.transitions !== null) {
    for (const transition3 of effect2.transitions) {
      if (transition3.is_global || local) {
        transitions.push(transition3);
      }
    }
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    pause_children(child2, transitions, transparent ? local : false);
    child2 = sibling2;
  }
}
var init_effects = __esm({
  'node_modules/svelte/src/internal/client/reactivity/effects.js'() {
    init_runtime();
    init_constants();
    init_errors2();
    init_esm_env();
    init_utils3();
    init_operations();
    init_context();
    init_batch();
    init_async();
    init_shared();
  },
});

// node_modules/svelte/src/internal/client/legacy.js
var captured_signals;
var init_legacy = __esm({
  'node_modules/svelte/src/internal/client/legacy.js'() {
    init_sources();
    init_runtime();
    captured_signals = null;
  },
});

// node_modules/svelte/src/internal/client/runtime.js
function set_is_updating_effect(value) {
  is_updating_effect = value;
}
function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
function set_active_effect(effect2) {
  active_effect = effect2;
}
function push_reaction_value(value) {
  if (active_reaction !== null && (!async_mode_flag || (active_reaction.f & DERIVED) !== 0)) {
    if (current_sources === null) {
      current_sources = [value];
    } else {
      current_sources.push(value);
    }
  }
}
function set_untracked_writes(value) {
  untracked_writes = value;
}
function set_update_version(value) {
  update_version = value;
}
function increment_write_version() {
  return ++write_version;
}
function is_dirty(reaction) {
  var flags2 = reaction.f;
  if ((flags2 & DIRTY) !== 0) {
    return true;
  }
  if ((flags2 & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    var is_unowned = (flags2 & UNOWNED) !== 0;
    if (dependencies !== null) {
      var i;
      var dependency;
      var is_disconnected = (flags2 & DISCONNECTED) !== 0;
      var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
      var length = dependencies.length;
      if (
        (is_disconnected || is_unowned_connected) &&
        (active_effect === null || (active_effect.f & DESTROYED) === 0)
      ) {
        var derived3 =
          /** @type {Derived} */
          reaction;
        var parent = derived3.parent;
        for (i = 0; i < length; i++) {
          dependency = dependencies[i];
          if (is_disconnected || !dependency?.reactions?.includes(derived3)) {
            (dependency.reactions ??= []).push(derived3);
          }
        }
        if (is_disconnected) {
          derived3.f ^= DISCONNECTED;
        }
        if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
          derived3.f ^= UNOWNED;
        }
      }
      for (i = 0; i < length; i++) {
        dependency = dependencies[i];
        if (
          is_dirty(
            /** @type {Derived} */
            dependency
          )
        ) {
          update_derived(
            /** @type {Derived} */
            dependency
          );
        }
        if (dependency.wv > reaction.wv) {
          return true;
        }
      }
    }
    if (!is_unowned || (active_effect !== null && !skip_reaction)) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
function schedule_possible_effect_self_invalidation(signal, effect2, root = true) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  if (!async_mode_flag && current_sources?.includes(signal)) {
    return;
  }
  for (var i = 0; i < reactions.length; i++) {
    var reaction = reactions[i];
    if ((reaction.f & DERIVED) !== 0) {
      schedule_possible_effect_self_invalidation(
        /** @type {Derived} */
        reaction,
        effect2,
        false
      );
    } else if (effect2 === reaction) {
      if (root) {
        set_signal_status(reaction, DIRTY);
      } else if ((reaction.f & CLEAN) !== 0) {
        set_signal_status(reaction, MAYBE_DIRTY);
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
function update_reaction(reaction) {
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_skip_reaction = skip_reaction;
  var previous_sources = current_sources;
  var previous_component_context = component_context;
  var previous_untracking = untracking;
  var previous_update_version = update_version;
  var flags2 = reaction.f;
  new_deps = /** @type {null | Value[]} */ null;
  skipped_deps = 0;
  untracked_writes = null;
  skip_reaction =
    (flags2 & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
  active_reaction = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  current_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  update_version = ++read_version;
  if (reaction.ac !== null) {
    without_reactive_context(() => {
      reaction.ac.abort(STALE_REACTION);
    });
    reaction.ac = null;
  }
  try {
    reaction.f |= REACTION_IS_UPDATING;
    var fn =
      /** @type {Function} */
      reaction.fn;
    var result = fn();
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i = 0; i < new_deps.length; i++) {
          deps[skipped_deps + i] = new_deps[i];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (
        !skip_reaction || // Deriveds that already have reactions can cleanup, so we still add them as reactions
        ((flags2 & DERIVED) !== 0 &&
          /** @type {import('#client').Derived} */
          reaction.reactions !== null)
      ) {
        for (i = skipped_deps; i < deps.length; i++) {
          (deps[i].reactions ??= []).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (
      is_runes() &&
      untracked_writes !== null &&
      !untracking &&
      deps !== null &&
      (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0
    ) {
      for (i = 0; i < /** @type {Source[]} */ untracked_writes.length; i++) {
        schedule_possible_effect_self_invalidation(
          untracked_writes[i],
          /** @type {Effect} */
          reaction
        );
      }
    }
    if (previous_reaction !== null && previous_reaction !== reaction) {
      read_version++;
      if (untracked_writes !== null) {
        if (previous_untracked_writes === null) {
          previous_untracked_writes = untracked_writes;
        } else {
          previous_untracked_writes.push(.../** @type {Source[]} */ untracked_writes);
        }
      }
    }
    if ((reaction.f & ERROR_VALUE) !== 0) {
      reaction.f ^= ERROR_VALUE;
    }
    return result;
  } catch (error) {
    return handle_error(error);
  } finally {
    reaction.f ^= REACTION_IS_UPDATING;
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    skip_reaction = previous_skip_reaction;
    current_sources = previous_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    update_version = previous_update_version;
  }
}
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index2 = index_of.call(reactions, signal);
    if (index2 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index2] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (
    reactions === null &&
    (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
    // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
    // allows us to skip the expensive work of disconnecting and immediately reconnecting it
    (new_deps === null || !new_deps.includes(dependency))
  ) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
      dependency.f ^= DISCONNECTED;
    }
    destroy_derived_effects(
      /** @type {Derived} **/
      dependency
    );
    remove_reactions(
      /** @type {Derived} **/
      dependency,
      0
    );
  }
}
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null) return;
  for (var i = start_index; i < dependencies.length; i++) {
    remove_reaction(signal, dependencies[i]);
  }
}
function update_effect(effect2) {
  var flags2 = effect2.f;
  if ((flags2 & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect2, CLEAN);
  var previous_effect = active_effect;
  var was_updating_effect = is_updating_effect;
  active_effect = effect2;
  is_updating_effect = true;
  if (dev_fallback_default) {
    var previous_component_fn = dev_current_component_function;
    set_dev_current_component_function(effect2.component_function);
    var previous_stack =
      /** @type {any} */
      dev_stack;
    set_dev_stack(effect2.dev_stack ?? dev_stack);
  }
  try {
    if ((flags2 & BLOCK_EFFECT) !== 0) {
      destroy_block_effect_children(effect2);
    } else {
      destroy_effect_children(effect2);
    }
    execute_effect_teardown(effect2);
    var teardown2 = update_reaction(effect2);
    effect2.teardown = typeof teardown2 === 'function' ? teardown2 : null;
    effect2.wv = write_version;
    if (
      dev_fallback_default &&
      tracing_mode_flag &&
      (effect2.f & DIRTY) !== 0 &&
      effect2.deps !== null
    ) {
      for (var dep of effect2.deps) {
        if (dep.set_during_effect) {
          dep.wv = increment_write_version();
          dep.set_during_effect = false;
        }
      }
    }
  } finally {
    is_updating_effect = was_updating_effect;
    active_effect = previous_effect;
    if (dev_fallback_default) {
      set_dev_current_component_function(previous_component_fn);
      set_dev_stack(previous_stack);
    }
  }
}
function get(signal) {
  var flags2 = signal.f;
  var is_derived = (flags2 & DERIVED) !== 0;
  captured_signals?.add(signal);
  if (active_reaction !== null && !untracking) {
    var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;
    if (!destroyed && !current_sources?.includes(signal)) {
      var deps = active_reaction.deps;
      if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
        if (signal.rv < read_version) {
          signal.rv = read_version;
          if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
            skipped_deps++;
          } else if (new_deps === null) {
            new_deps = [signal];
          } else if (!skip_reaction || !new_deps.includes(signal)) {
            new_deps.push(signal);
          }
        }
      } else {
        (active_reaction.deps ??= []).push(signal);
        var reactions = signal.reactions;
        if (reactions === null) {
          signal.reactions = [active_reaction];
        } else if (!reactions.includes(active_reaction)) {
          reactions.push(active_reaction);
        }
      }
    }
  } else if (
    is_derived &&
    /** @type {Derived} */
    signal.deps === null &&
    /** @type {Derived} */
    signal.effects === null
  ) {
    var derived3 =
      /** @type {Derived} */
      signal;
    var parent = derived3.parent;
    if (parent !== null && (parent.f & UNOWNED) === 0) {
      derived3.f ^= UNOWNED;
    }
  }
  if (dev_fallback_default) {
    if (current_async_effect) {
      var tracking = (current_async_effect.f & REACTION_IS_UPDATING) !== 0;
      var was_read = current_async_effect.deps?.includes(signal);
      if (!tracking && !untracking && !was_read) {
        await_reactivity_loss(
          /** @type {string} */
          signal.label
        );
        var trace2 = get_stack('TracedAt');
        if (trace2) console.warn(trace2);
      }
    }
    recent_async_deriveds.delete(signal);
    if (
      tracing_mode_flag &&
      !untracking &&
      tracing_expressions !== null &&
      active_reaction !== null &&
      tracing_expressions.reaction === active_reaction
    ) {
      if (signal.trace) {
        signal.trace();
      } else {
        trace2 = get_stack('TracedAt');
        if (trace2) {
          var entry = tracing_expressions.entries.get(signal);
          if (entry === void 0) {
            entry = { traces: [] };
            tracing_expressions.entries.set(signal, entry);
          }
          var last = entry.traces[entry.traces.length - 1];
          if (trace2.stack !== last?.stack) {
            entry.traces.push(trace2);
          }
        }
      }
    }
  }
  if (is_destroying_effect) {
    if (old_values.has(signal)) {
      return old_values.get(signal);
    }
    if (is_derived) {
      derived3 = /** @type {Derived} */ signal;
      var value = derived3.v;
      if (
        ((derived3.f & CLEAN) === 0 && derived3.reactions !== null) ||
        depends_on_old_values(derived3)
      ) {
        value = execute_derived(derived3);
      }
      old_values.set(derived3, value);
      return value;
    }
  } else if (is_derived) {
    derived3 = /** @type {Derived} */ signal;
    if (batch_values?.has(derived3)) {
      return batch_values.get(derived3);
    }
    if (is_dirty(derived3)) {
      update_derived(derived3);
    }
  }
  if (batch_values?.has(signal)) {
    return batch_values.get(signal);
  }
  if ((signal.f & ERROR_VALUE) !== 0) {
    throw signal.v;
  }
  return signal.v;
}
function depends_on_old_values(derived3) {
  if (derived3.v === UNINITIALIZED) return true;
  if (derived3.deps === null) return false;
  for (const dep of derived3.deps) {
    if (old_values.has(dep)) {
      return true;
    }
    if (
      (dep.f & DERIVED) !== 0 &&
      depends_on_old_values(
        /** @type {Derived} */
        dep
      )
    ) {
      return true;
    }
  }
  return false;
}
function untrack(fn) {
  var previous_untracking = untracking;
  try {
    untracking = true;
    return fn();
  } finally {
    untracking = previous_untracking;
  }
}
function set_signal_status(signal, status) {
  signal.f = (signal.f & STATUS_MASK) | status;
}
var is_updating_effect,
  is_destroying_effect,
  active_reaction,
  untracking,
  active_effect,
  current_sources,
  new_deps,
  skipped_deps,
  untracked_writes,
  write_version,
  read_version,
  update_version,
  skip_reaction,
  STATUS_MASK;
var init_runtime = __esm({
  'node_modules/svelte/src/internal/client/runtime.js'() {
    init_esm_env();
    init_utils3();
    init_effects();
    init_constants();
    init_sources();
    init_deriveds();
    init_flags();
    init_tracing();
    init_context();
    init_warnings();
    init_batch();
    init_error_handling();
    init_constants2();
    init_legacy();
    init_shared();
    is_updating_effect = false;
    is_destroying_effect = false;
    active_reaction = null;
    untracking = false;
    active_effect = null;
    current_sources = null;
    new_deps = null;
    skipped_deps = 0;
    untracked_writes = null;
    write_version = 1;
    read_version = 0;
    update_version = read_version;
    skip_reaction = false;
    STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
  },
});

// node_modules/svelte/src/attachments/index.js
var init_attachments = __esm({
  'node_modules/svelte/src/attachments/index.js'() {
    init_client();
    init_constants2();
    init_index_client();
    init_effects();
  },
});

// node_modules/svelte/src/utils.js
function is_passive_event(name3) {
  return PASSIVE_EVENTS.includes(name3);
}
var DOM_BOOLEAN_ATTRIBUTES, DOM_PROPERTIES, PASSIVE_EVENTS, STATE_CREATION_RUNES, RUNES;
var init_utils4 = __esm({
  'node_modules/svelte/src/utils.js'() {
    DOM_BOOLEAN_ATTRIBUTES = [
      'allowfullscreen',
      'async',
      'autofocus',
      'autoplay',
      'checked',
      'controls',
      'default',
      'disabled',
      'formnovalidate',
      'indeterminate',
      'inert',
      'ismap',
      'loop',
      'multiple',
      'muted',
      'nomodule',
      'novalidate',
      'open',
      'playsinline',
      'readonly',
      'required',
      'reversed',
      'seamless',
      'selected',
      'webkitdirectory',
      'defer',
      'disablepictureinpicture',
      'disableremoteplayback',
    ];
    DOM_PROPERTIES = [
      ...DOM_BOOLEAN_ATTRIBUTES,
      'formNoValidate',
      'isMap',
      'noModule',
      'playsInline',
      'readOnly',
      'value',
      'volume',
      'defaultValue',
      'defaultChecked',
      'srcObject',
      'noValidate',
      'allowFullscreen',
      'disablePictureInPicture',
      'disableRemotePlayback',
    ];
    PASSIVE_EVENTS = ['touchstart', 'touchmove'];
    STATE_CREATION_RUNES = /** @type {const} */ ['$state', '$state.raw', '$derived', '$derived.by'];
    RUNES =
      /** @type {const} */
      [
        ...STATE_CREATION_RUNES,
        '$state.snapshot',
        '$props',
        '$props.id',
        '$bindable',
        '$effect',
        '$effect.pre',
        '$effect.tracking',
        '$effect.root',
        '$effect.pending',
        '$inspect',
        '$inspect().with',
        '$inspect.trace',
        '$host',
      ];
  },
});

// node_modules/svelte/src/internal/client/dev/assign.js
var init_assign = __esm({
  'node_modules/svelte/src/internal/client/dev/assign.js'() {
    init_utils4();
    init_runtime();
    init_warnings();
  },
});

// node_modules/svelte/src/internal/client/dev/css.js
var init_css = __esm({
  'node_modules/svelte/src/internal/client/dev/css.js'() {},
});

// node_modules/svelte/src/internal/client/dev/elements.js
var init_elements = __esm({
  'node_modules/svelte/src/internal/client/dev/elements.js'() {
    init_constants();
    init_constants2();
    init_hydration();
    init_context();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/events.js
function handle_event_propagation(event2) {
  var handler_element = this;
  var owner_document =
    /** @type {Node} */
    handler_element.ownerDocument;
  var event_name = event2.type;
  var path5 = event2.composedPath?.() || [];
  var current_target =
    /** @type {null | Element} */
    path5[0] || event2.target;
  last_propagated_event = event2;
  var path_idx = 0;
  var handled_at = last_propagated_event === event2 && event2.__root;
  if (handled_at) {
    var at_idx = path5.indexOf(handled_at);
    if (
      at_idx !== -1 &&
      (handler_element === document || handler_element === /** @type {any} */ window)
    ) {
      event2.__root = handler_element;
      return;
    }
    var handler_idx = path5.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */ path5[path_idx] || event2.target;
  if (current_target === handler_element) return;
  define_property(event2, 'currentTarget', {
    configurable: true,
    get() {
      return current_target || owner_document;
    },
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element =
        current_target.assignedSlot ||
        current_target.parentNode ||
        /** @type {any} */
        current_target.host ||
        null;
      try {
        var delegated = current_target['__' + event_name];
        if (
          delegated != null &&
          (!(/** @type {any} */ current_target.disabled) || // DOM could've been updated already by the time this is reached, so we check this as well
            // -> the target could not have been disabled because it emits the event in the first place
            event2.target === current_target)
        ) {
          if (is_array(delegated)) {
            var [fn, ...data] = delegated;
            fn.apply(current_target, [event2, ...data]);
          } else {
            delegated.call(current_target, event2);
          }
        }
      } catch (error) {
        if (throw_error) {
          other_errors.push(error);
        } else {
          throw_error = error;
        }
      }
      if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error of other_errors) {
        queueMicrotask(() => {
          throw error;
        });
      }
      throw throw_error;
    }
  } finally {
    event2.__root = handler_element;
    delete event2.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
var all_registered_events, root_event_handles, last_propagated_event;
var init_events = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/events.js'() {
    init_effects();
    init_utils3();
    init_hydration();
    init_task();
    init_constants2();
    init_warnings();
    init_runtime();
    init_shared();
    all_registered_events = /* @__PURE__ */ new Set();
    root_event_handles = /* @__PURE__ */ new Set();
    last_propagated_event = null;
  },
});

// node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js
function reset_head_anchor() {
  head_anchor = void 0;
}
var head_anchor;
var init_svelte_head = __esm({
  'node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js'() {
    init_hydration();
    init_operations();
    init_effects();
    init_constants();
    init_constants2();
  },
});

// node_modules/svelte/src/internal/client/dom/reconciler.js
var init_reconciler = __esm({
  'node_modules/svelte/src/internal/client/dom/reconciler.js'() {},
});

// node_modules/svelte/src/internal/client/dom/template.js
function assign_nodes(start, end) {
  var effect2 =
    /** @type {Effect} */
    active_effect;
  if (effect2.nodes_start === null) {
    effect2.nodes_start = start;
    effect2.nodes_end = end;
  }
}
function append2(anchor, dom) {
  if (hydrating) {
    active_effect.nodes_end = hydrate_node;
    hydrate_next();
    return;
  }
  if (anchor === null) {
    return;
  }
  anchor.before(
    /** @type {Node} */
    dom
  );
}
var init_template = __esm({
  'node_modules/svelte/src/internal/client/dom/template.js'() {
    init_hydration();
    init_operations();
    init_reconciler();
    init_runtime();
    init_constants2();
    init_constants();
  },
});

// node_modules/svelte/src/internal/client/render.js
function mount(component2, options) {
  return _mount(component2, options);
}
function hydrate(component2, options) {
  init_operations2();
  options.intro = options.intro ?? false;
  const target = options.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor =
      /** @type {TemplateNode} */
      get_first_child(target);
    while (
      anchor &&
      (anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */ anchor.data !== HYDRATION_START)
    ) {
      anchor = /** @type {TemplateNode} */ get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(
      /** @type {Comment} */
      anchor
    );
    const instance = _mount(component2, { ...options, anchor });
    set_hydrating(false);
    return (
      /**  @type {Exports} */
      instance
    );
  } catch (error) {
    if (
      error instanceof Error &&
      error.message.split('\n').some((line) => line.startsWith('https://svelte.dev/e/'))
    ) {
      throw error;
    }
    if (error !== HYDRATION_ERROR) {
      console.warn('Failed to hydrate: ', error);
    }
    if (options.recover === false) {
      hydration_failed();
    }
    init_operations2();
    clear_text_content(target);
    set_hydrating(false);
    return mount(component2, options);
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
    reset_head_anchor();
  }
}
function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
  init_operations2();
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = (events2) => {
    for (var i = 0; i < events2.length; i++) {
      var event_name = events2[i];
      if (registered_events.has(event_name)) continue;
      registered_events.add(event_name);
      var passive2 = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
      var n = document_listeners.get(event_name);
      if (n === void 0) {
        document.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n + 1);
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component2 = void 0;
  var unmount2 = component_root(() => {
    var anchor_node = anchor ?? target.appendChild(create_text());
    boundary(
      /** @type {TemplateNode} */
      anchor_node,
      {
        pending: () => {},
      },
      (anchor_node2) => {
        if (context) {
          push({});
          var ctx =
            /** @type {ComponentContext} */
            component_context;
          ctx.c = context;
        }
        if (events) {
          props.$$events = events;
        }
        if (hydrating) {
          assign_nodes(
            /** @type {TemplateNode} */
            anchor_node2,
            null
          );
        }
        should_intro = intro;
        component2 = Component(anchor_node2, props) || {};
        should_intro = true;
        if (hydrating) {
          active_effect.nodes_end = hydrate_node;
          if (
            hydrate_node === null ||
            hydrate_node.nodeType !== COMMENT_NODE ||
            /** @type {Comment} */
            hydrate_node.data !== HYDRATION_END
          ) {
            hydration_mismatch();
            throw HYDRATION_ERROR;
          }
        }
        if (context) {
          pop();
        }
      }
    );
    return () => {
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n =
          /** @type {number} */
          document_listeners.get(event_name);
        if (--n === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n);
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        anchor_node.parentNode?.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component2, unmount2);
  return component2;
}
function unmount(component2, options) {
  const fn = mounted_components.get(component2);
  if (fn) {
    mounted_components.delete(component2);
    return fn(options);
  }
  if (dev_fallback_default) {
    if (STATE_SYMBOL in component2) {
      state_proxy_unmount();
    } else {
      lifecycle_double_unmount();
    }
  }
  return Promise.resolve();
}
var should_intro, document_listeners, mounted_components;
var init_render = __esm({
  'node_modules/svelte/src/internal/client/render.js'() {
    init_esm_env();
    init_operations();
    init_constants2();
    init_runtime();
    init_context();
    init_effects();
    init_hydration();
    init_utils3();
    init_events();
    init_svelte_head();
    init_warnings();
    init_errors2();
    init_template();
    init_utils4();
    init_constants();
    init_boundary();
    should_intro = true;
    document_listeners = /* @__PURE__ */ new Map();
    mounted_components = /* @__PURE__ */ new WeakMap();
  },
});

// node_modules/svelte/src/internal/client/dev/hmr.js
var init_hmr = __esm({
  'node_modules/svelte/src/internal/client/dev/hmr.js'() {
    init_constants2();
    init_constants();
    init_hydration();
    init_effects();
    init_sources();
    init_render();
    init_runtime();
  },
});

// node_modules/svelte/src/internal/client/dev/ownership.js
var init_ownership = __esm({
  'node_modules/svelte/src/internal/client/dev/ownership.js'() {
    init_utils3();
    init_constants();
    init_constants2();
    init_context();
    init_warnings();
    init_utils4();
  },
});

// node_modules/svelte/src/internal/client/dev/legacy.js
var init_legacy2 = __esm({
  'node_modules/svelte/src/internal/client/dev/legacy.js'() {
    init_errors2();
    init_context();
    init_constants2();
  },
});

// node_modules/svelte/src/internal/client/dev/inspect.js
var init_inspect = __esm({
  'node_modules/svelte/src/internal/client/dev/inspect.js'() {
    init_constants2();
    init_clone();
    init_effects();
    init_runtime();
  },
});

// node_modules/svelte/src/internal/client/dom/blocks/async.js
var init_async2 = __esm({
  'node_modules/svelte/src/internal/client/dom/blocks/async.js'() {
    init_async();
    init_runtime();
    init_hydration();
    init_boundary();
  },
});

// node_modules/svelte/src/internal/client/dev/validation.js
var init_validation = __esm({
  'node_modules/svelte/src/internal/client/dev/validation.js'() {
    init_errors2();
  },
});

// node_modules/svelte/src/internal/client/dom/blocks/await.js
var init_await = __esm({
  'node_modules/svelte/src/internal/client/dom/blocks/await.js'() {
    init_esm_env();
    init_utils3();
    init_effects();
    init_sources();
    init_runtime();
    init_hydration();
    init_task();
    init_constants2();
    init_context();
    init_batch();
  },
});

// node_modules/svelte/src/internal/client/dom/blocks/if.js
var init_if = __esm({
  'node_modules/svelte/src/internal/client/dom/blocks/if.js'() {
    init_constants();
    init_hydration();
    init_effects();
    init_constants2();
    init_operations();
    init_batch();
  },
});

// node_modules/svelte/src/internal/client/dom/blocks/key.js
var init_key = __esm({
  'node_modules/svelte/src/internal/client/dom/blocks/key.js'() {
    init_constants2();
    init_effects();
    init_equality();
    init_context();
    init_hydration();
    init_operations();
    init_batch();
  },
});

// node_modules/svelte/src/internal/client/dom/blocks/css-props.js
var init_css_props = __esm({
  'node_modules/svelte/src/internal/client/dom/blocks/css-props.js'() {
    init_effects();
    init_hydration();
    init_operations();
  },
});

// node_modules/svelte/src/internal/client/dom/blocks/each.js
var init_each = __esm({
  'node_modules/svelte/src/internal/client/dom/blocks/each.js'() {
    init_constants2();
    init_hydration();
    init_operations();
    init_effects();
    init_sources();
    init_utils3();
    init_constants();
    init_task();
    init_runtime();
    init_esm_env();
    init_deriveds();
    init_batch();
  },
});

// node_modules/svelte/src/internal/client/dom/blocks/html.js
var init_html = __esm({
  'node_modules/svelte/src/internal/client/dom/blocks/html.js'() {
    init_constants2();
    init_effects();
    init_hydration();
    init_reconciler();
    init_template();
    init_warnings();
    init_utils4();
    init_esm_env();
    init_context();
    init_operations();
    init_runtime();
    init_constants();
  },
});

// node_modules/svelte/src/internal/client/dom/blocks/slot.js
var init_slot = __esm({
  'node_modules/svelte/src/internal/client/dom/blocks/slot.js'() {
    init_hydration();
  },
});

// node_modules/svelte/src/internal/shared/validate.js
var init_validate = __esm({
  'node_modules/svelte/src/internal/shared/validate.js'() {
    init_utils4();
    init_warnings2();
    init_errors();
    init_errors();
  },
});

// node_modules/svelte/src/internal/client/dom/blocks/snippet.js
var init_snippet = __esm({
  'node_modules/svelte/src/internal/client/dom/blocks/snippet.js'() {
    init_constants();
    init_effects();
    init_context();
    init_hydration();
    init_reconciler();
    init_template();
    init_warnings();
    init_errors2();
    init_esm_env();
    init_operations();
    init_utils3();
    init_validate();
  },
});

// node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js
var init_svelte_component = __esm({
  'node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js'() {
    init_constants();
    init_effects();
    init_batch();
    init_hydration();
    init_operations();
  },
});

// node_modules/svelte/src/internal/client/dom/blocks/svelte-element.js
var init_svelte_element = __esm({
  'node_modules/svelte/src/internal/client/dom/blocks/svelte-element.js'() {
    init_constants2();
    init_hydration();
    init_operations();
    init_effects();
    init_render();
    init_each();
    init_runtime();
    init_context();
    init_esm_env();
    init_constants();
    init_template();
    init_utils4();
  },
});

// node_modules/svelte/src/internal/client/dom/css.js
var init_css2 = __esm({
  'node_modules/svelte/src/internal/client/dom/css.js'() {
    init_esm_env();
    init_css();
    init_effects();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/actions.js
var init_actions = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/actions.js'() {
    init_effects();
    init_equality();
    init_runtime();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/attachments.js
var init_attachments2 = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/attachments.js'() {
    init_effects();
  },
});

// node_modules/svelte/src/escaping.js
var init_escaping = __esm({
  'node_modules/svelte/src/escaping.js'() {},
});

// node_modules/clsx/dist/clsx.mjs
var init_clsx = __esm({
  'node_modules/clsx/dist/clsx.mjs'() {},
});

// node_modules/svelte/src/internal/shared/attributes.js
var whitespace;
var init_attributes = __esm({
  'node_modules/svelte/src/internal/shared/attributes.js'() {
    init_escaping();
    init_clsx();
    whitespace = [...' 	\n\r\f\xA0\v\uFEFF'];
  },
});

// node_modules/svelte/src/internal/client/dom/elements/class.js
var init_class = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/class.js'() {
    init_attributes();
    init_hydration();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/style.js
var init_style = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/style.js'() {
    init_attributes();
    init_hydration();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/select.js
var init_select = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/bindings/select.js'() {
    init_effects();
    init_shared();
    init_proxy();
    init_utils3();
    init_warnings();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/attributes.js
var CLASS, STYLE, IS_CUSTOM_ELEMENT, IS_HTML;
var init_attributes2 = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/attributes.js'() {
    init_esm_env();
    init_hydration();
    init_utils3();
    init_events();
    init_misc();
    init_warnings();
    init_constants();
    init_task();
    init_utils4();
    init_runtime();
    init_attachments2();
    init_attributes();
    init_class();
    init_style();
    init_constants2();
    init_effects();
    init_select();
    init_async();
    CLASS = Symbol('class');
    STYLE = Symbol('style');
    IS_CUSTOM_ELEMENT = Symbol('is custom element');
    IS_HTML = Symbol('is html');
  },
});

// node_modules/svelte/src/internal/client/timing.js
var init_timing = __esm({
  'node_modules/svelte/src/internal/client/timing.js'() {
    init_utils3();
    init_esm_env();
  },
});

// node_modules/svelte/src/internal/client/loop.js
var init_loop = __esm({
  'node_modules/svelte/src/internal/client/loop.js'() {
    init_timing();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/transitions.js
var init_transitions = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/transitions.js'() {
    init_utils3();
    init_effects();
    init_runtime();
    init_loop();
    init_render();
    init_each();
    init_constants2();
    init_constants();
    init_task();
    init_shared();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/document.js
var init_document = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/bindings/document.js'() {
    init_shared();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/input.js
var init_input = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/bindings/input.js'() {
    init_esm_env();
    init_effects();
    init_shared();
    init_errors2();
    init_proxy();
    init_task();
    init_hydration();
    init_runtime();
    init_context();
    init_batch();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/media.js
var init_media = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/bindings/media.js'() {
    init_effects();
    init_shared();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/navigator.js
var init_navigator = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/bindings/navigator.js'() {
    init_shared();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/props.js
var init_props = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/bindings/props.js'() {
    init_effects();
    init_utils3();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/size.js
var init_size = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/bindings/size.js'() {
    init_effects();
    init_runtime();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/this.js
var init_this = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/bindings/this.js'() {
    init_constants();
    init_effects();
    init_runtime();
    init_task();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/universal.js
var init_universal = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/bindings/universal.js'() {
    init_effects();
    init_shared();
  },
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/window.js
var init_window = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/bindings/window.js'() {
    init_effects();
    init_shared();
  },
});

// node_modules/svelte/src/internal/client/dom/legacy/event-modifiers.js
var init_event_modifiers = __esm({
  'node_modules/svelte/src/internal/client/dom/legacy/event-modifiers.js'() {
    init_utils3();
    init_effects();
    init_events();
  },
});

// node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js
var init_lifecycle = __esm({
  'node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js'() {
    init_utils3();
    init_context();
    init_deriveds();
    init_effects();
    init_runtime();
  },
});

// node_modules/svelte/src/internal/client/dom/legacy/misc.js
var init_misc2 = __esm({
  'node_modules/svelte/src/internal/client/dom/legacy/misc.js'() {
    init_sources();
    init_runtime();
    init_utils3();
  },
});

// node_modules/svelte/src/internal/client/reactivity/store.js
var IS_UNMOUNTED;
var init_store = __esm({
  'node_modules/svelte/src/internal/client/reactivity/store.js'() {
    init_utils5();
    init_shared2();
    init_utils3();
    init_runtime();
    init_effects();
    init_sources();
    init_esm_env();
    IS_UNMOUNTED = Symbol();
  },
});

// node_modules/svelte/src/internal/client/reactivity/props.js
var init_props2 = __esm({
  'node_modules/svelte/src/internal/client/reactivity/props.js'() {
    init_esm_env();
    init_constants2();
    init_utils3();
    init_sources();
    init_deriveds();
    init_runtime();
    init_errors2();
    init_constants();
    init_proxy();
    init_store();
    init_flags();
  },
});

// node_modules/svelte/src/internal/client/validate.js
var init_validate2 = __esm({
  'node_modules/svelte/src/internal/client/validate.js'() {
    init_context();
    init_utils3();
    init_errors2();
    init_constants2();
    init_effects();
    init_warnings();
    init_store();
  },
});

// node_modules/svelte/src/legacy/legacy-client.js
function createClassComponent(options) {
  return new Svelte4Component(options);
}
var Svelte4Component;
var init_legacy_client = __esm({
  'node_modules/svelte/src/legacy/legacy-client.js'() {
    init_constants();
    init_effects();
    init_sources();
    init_render();
    init_runtime();
    init_batch();
    init_utils3();
    init_errors2();
    init_warnings();
    init_esm_env();
    init_constants2();
    init_context();
    init_flags();
    init_event_modifiers();
    Svelte4Component = class {
      /** @type {any} */
      #events;
      /** @type {Record<string, any>} */
      #instance;
      /**
       * @param {ComponentConstructorOptions & {
       *  component: any;
       * }} options
       */
      constructor(options) {
        var sources = /* @__PURE__ */ new Map();
        var add_source = (key2, value) => {
          var s = mutable_source(value, false, false);
          sources.set(key2, s);
          return s;
        };
        const props = new Proxy(
          { ...(options.props || {}), $$events: {} },
          {
            get(target, prop2) {
              return get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
            },
            has(target, prop2) {
              if (prop2 === LEGACY_PROPS) return true;
              get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
              return Reflect.has(target, prop2);
            },
            set(target, prop2, value) {
              set(sources.get(prop2) ?? add_source(prop2, value), value);
              return Reflect.set(target, prop2, value);
            },
          }
        );
        this.#instance = (options.hydrate ? hydrate : mount)(options.component, {
          target: options.target,
          anchor: options.anchor,
          props,
          context: options.context,
          intro: options.intro ?? false,
          recover: options.recover,
        });
        if (!async_mode_flag && (!options?.props?.$$host || options.sync === false)) {
          flushSync();
        }
        this.#events = props.$$events;
        for (const key2 of Object.keys(this.#instance)) {
          if (key2 === '$set' || key2 === '$destroy' || key2 === '$on') continue;
          define_property(this, key2, {
            get() {
              return this.#instance[key2];
            },
            /** @param {any} value */
            set(value) {
              this.#instance[key2] = value;
            },
            enumerable: true,
          });
        }
        this.#instance.$set =
          /** @param {Record<string, any>} next */
          (next2) => {
            Object.assign(props, next2);
          };
        this.#instance.$destroy = () => {
          unmount(this.#instance);
        };
      }
      /** @param {Record<string, any>} props */
      $set(props) {
        this.#instance.$set(props);
      }
      /**
       * @param {string} event
       * @param {(...args: any[]) => any} callback
       * @returns {any}
       */
      $on(event2, callback) {
        this.#events[event2] = this.#events[event2] || [];
        const cb = (...args) => callback.call(this, ...args);
        this.#events[event2].push(cb);
        return () => {
          this.#events[event2] = this.#events[event2].filter(
            /** @param {any} fn */
            (fn) => fn !== cb
          );
        };
      }
      $destroy() {
        this.#instance.$destroy();
      }
    };
  },
});

// node_modules/svelte/src/internal/client/dom/elements/custom-element.js
function get_custom_element_value(prop2, value, props_definition, transform) {
  const type = props_definition[prop2]?.type;
  value = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;
  if (!transform || !props_definition[prop2]) {
    return value;
  } else if (transform === 'toAttribute') {
    switch (type) {
      case 'Object':
      case 'Array':
        return value == null ? null : JSON.stringify(value);
      case 'Boolean':
        return value ? '' : null;
      case 'Number':
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case 'Object':
      case 'Array':
        return value && JSON.parse(value);
      case 'Boolean':
        return value;
      // conversion already handled above
      case 'Number':
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach((node) => {
    result[
      /** @type {Element} node */
      node.slot || 'default'
    ] = true;
  });
  return result;
}
var SvelteElement;
var init_custom_element = __esm({
  'node_modules/svelte/src/internal/client/dom/elements/custom-element.js'() {
    init_legacy_client();
    init_effects();
    init_template();
    init_utils3();
    if (typeof HTMLElement === 'function') {
      SvelteElement = class extends HTMLElement {
        /** The Svelte component constructor */
        $$ctor;
        /** Slots */
        $$s;
        /** @type {any} The Svelte component instance */
        $$c;
        /** Whether or not the custom element is connected */
        $$cn = false;
        /** @type {Record<string, any>} Component props data */
        $$d = {};
        /** `true` if currently in the process of reflecting component props back to attributes */
        $$r = false;
        /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
        $$p_d = {};
        /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
        $$l = {};
        /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
        $$l_u = /* @__PURE__ */ new Map();
        /** @type {any} The managed render effect for reflecting attributes */
        $$me;
        /**
         * @param {*} $$componentCtor
         * @param {*} $$slots
         * @param {*} use_shadow_dom
         */
        constructor($$componentCtor, $$slots, use_shadow_dom) {
          super();
          this.$$ctor = $$componentCtor;
          this.$$s = $$slots;
          if (use_shadow_dom) {
            this.attachShadow({ mode: 'open' });
          }
        }
        /**
         * @param {string} type
         * @param {EventListenerOrEventListenerObject} listener
         * @param {boolean | AddEventListenerOptions} [options]
         */
        addEventListener(type, listener, options) {
          this.$$l[type] = this.$$l[type] || [];
          this.$$l[type].push(listener);
          if (this.$$c) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
          super.addEventListener(type, listener, options);
        }
        /**
         * @param {string} type
         * @param {EventListenerOrEventListenerObject} listener
         * @param {boolean | AddEventListenerOptions} [options]
         */
        removeEventListener(type, listener, options) {
          super.removeEventListener(type, listener, options);
          if (this.$$c) {
            const unsub = this.$$l_u.get(listener);
            if (unsub) {
              unsub();
              this.$$l_u.delete(listener);
            }
          }
        }
        async connectedCallback() {
          this.$$cn = true;
          if (!this.$$c) {
            let create_slot = function (name3) {
              return (anchor) => {
                const slot2 = document.createElement('slot');
                if (name3 !== 'default') slot2.name = name3;
                append2(anchor, slot2);
              };
            };
            await Promise.resolve();
            if (!this.$$cn || this.$$c) {
              return;
            }
            const $$slots = {};
            const existing_slots = get_custom_elements_slots(this);
            for (const name3 of this.$$s) {
              if (name3 in existing_slots) {
                if (name3 === 'default' && !this.$$d.children) {
                  this.$$d.children = create_slot(name3);
                  $$slots.default = true;
                } else {
                  $$slots[name3] = create_slot(name3);
                }
              }
            }
            for (const attribute of this.attributes) {
              const name3 = this.$$g_p(attribute.name);
              if (!(name3 in this.$$d)) {
                this.$$d[name3] = get_custom_element_value(
                  name3,
                  attribute.value,
                  this.$$p_d,
                  'toProp'
                );
              }
            }
            for (const key2 in this.$$p_d) {
              if (!(key2 in this.$$d) && this[key2] !== void 0) {
                this.$$d[key2] = this[key2];
                delete this[key2];
              }
            }
            this.$$c = createClassComponent({
              component: this.$$ctor,
              target: this.shadowRoot || this,
              props: {
                ...this.$$d,
                $$slots,
                $$host: this,
              },
            });
            this.$$me = effect_root(() => {
              render_effect(() => {
                this.$$r = true;
                for (const key2 of object_keys(this.$$c)) {
                  if (!this.$$p_d[key2]?.reflect) continue;
                  this.$$d[key2] = this.$$c[key2];
                  const attribute_value = get_custom_element_value(
                    key2,
                    this.$$d[key2],
                    this.$$p_d,
                    'toAttribute'
                  );
                  if (attribute_value == null) {
                    this.removeAttribute(this.$$p_d[key2].attribute || key2);
                  } else {
                    this.setAttribute(this.$$p_d[key2].attribute || key2, attribute_value);
                  }
                }
                this.$$r = false;
              });
            });
            for (const type in this.$$l) {
              for (const listener of this.$$l[type]) {
                const unsub = this.$$c.$on(type, listener);
                this.$$l_u.set(listener, unsub);
              }
            }
            this.$$l = {};
          }
        }
        // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
        // and setting attributes through setAttribute etc, this is helpful
        /**
         * @param {string} attr
         * @param {string} _oldValue
         * @param {string} newValue
         */
        attributeChangedCallback(attr2, _oldValue, newValue) {
          if (this.$$r) return;
          attr2 = this.$$g_p(attr2);
          this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, 'toProp');
          this.$$c?.$set({ [attr2]: this.$$d[attr2] });
        }
        disconnectedCallback() {
          this.$$cn = false;
          Promise.resolve().then(() => {
            if (!this.$$cn && this.$$c) {
              this.$$c.$destroy();
              this.$$me();
              this.$$c = void 0;
            }
          });
        }
        /**
         * @param {string} attribute_name
         */
        $$g_p(attribute_name) {
          return (
            object_keys(this.$$p_d).find(
              (key2) =>
                this.$$p_d[key2].attribute === attribute_name ||
                (!this.$$p_d[key2].attribute && key2.toLowerCase() === attribute_name)
            ) || attribute_name
          );
        }
      };
    }
  },
});

// node_modules/svelte/src/internal/client/dev/console-log.js
var init_console_log = __esm({
  'node_modules/svelte/src/internal/client/dev/console-log.js'() {
    init_constants();
    init_clone();
    init_warnings();
    init_runtime();
  },
});

// node_modules/svelte/src/internal/client/index.js
var init_client = __esm({
  'node_modules/svelte/src/internal/client/index.js'() {
    init_attachments();
    init_constants2();
    init_context();
    init_assign();
    init_css();
    init_elements();
    init_hmr();
    init_ownership();
    init_legacy2();
    init_tracing();
    init_inspect();
    init_async2();
    init_validation();
    init_await();
    init_if();
    init_key();
    init_css_props();
    init_each();
    init_html();
    init_slot();
    init_snippet();
    init_svelte_component();
    init_svelte_element();
    init_svelte_head();
    init_css2();
    init_actions();
    init_attachments2();
    init_attributes2();
    init_class();
    init_events();
    init_misc();
    init_style();
    init_transitions();
    init_document();
    init_input();
    init_media();
    init_navigator();
    init_props();
    init_select();
    init_size();
    init_this();
    init_universal();
    init_window();
    init_hydration();
    init_event_modifiers();
    init_lifecycle();
    init_misc2();
    init_template();
    init_async();
    init_batch();
    init_deriveds();
    init_effects();
    init_sources();
    init_props2();
    init_store();
    init_boundary();
    init_legacy();
    init_render();
    init_runtime();
    init_validate2();
    init_timing();
    init_proxy();
    init_custom_element();
    init_operations();
    init_attributes();
    init_clone();
    init_utils3();
    init_validate();
    init_equality2();
    init_console_log();
    init_error_handling();
  },
});

// node_modules/svelte/src/index-client.js
var init_index_client = __esm({
  'node_modules/svelte/src/index-client.js'() {
    init_runtime();
    init_utils3();
    init_client();
    init_errors2();
    init_flags();
    init_context();
    init_esm_env();
    init_batch();
    init_context();
    init_render();
    init_runtime();
    init_snippet();
    if (dev_fallback_default) {
      let throw_rune_error = function (rune) {
        if (!(rune in globalThis)) {
          let value;
          Object.defineProperty(globalThis, rune, {
            configurable: true,
            // eslint-disable-next-line getter-return
            get: () => {
              if (value !== void 0) {
                return value;
              }
              rune_outside_svelte(rune);
            },
            set: (v) => {
              value = v;
            },
          });
        }
      };
      throw_rune_error('$state');
      throw_rune_error('$effect');
      throw_rune_error('$derived');
      throw_rune_error('$inspect');
      throw_rune_error('$props');
      throw_rune_error('$bindable');
    }
  },
});

// node_modules/svelte/src/store/utils.js
function subscribe_to_store(store, run2, invalidate) {
  if (store == null) {
    run2(void 0);
    if (invalidate) invalidate(void 0);
    return noop2;
  }
  const unsub = untrack(() =>
    store.subscribe(
      run2,
      // @ts-expect-error
      invalidate
    )
  );
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
var init_utils5 = __esm({
  'node_modules/svelte/src/store/utils.js'() {
    init_index_client();
    init_utils3();
  },
});

// node_modules/svelte/src/store/shared/index.js
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe,
  };
}
function writable(value, start = noop2) {
  let stop2 = null;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop2) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set2(
      fn(
        /** @type {T} */
        value
      )
    );
  }
  function subscribe(run2, invalidate = noop2) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop2 = start(set2, update2) || noop2;
    }
    run2(
      /** @type {T} */
      value
    );
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop2) {
        stop2();
        stop2 = null;
      }
    };
  }
  return { set: set2, update: update2, subscribe };
}
function derived2(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error('derived() expects stores as input, got a falsy value');
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set2, update2) => {
    let started = false;
    const values = [];
    let pending2 = 0;
    let cleanup = noop2;
    const sync = () => {
      if (pending2) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set2, update2);
      if (auto) {
        set2(result);
      } else {
        cleanup = typeof result === 'function' ? result : noop2;
      }
    };
    const unsubscribers = stores_array.map((store, i) =>
      subscribe_to_store(
        store,
        (value) => {
          values[i] = value;
          pending2 &= ~(1 << i);
          if (started) {
            sync();
          }
        },
        () => {
          pending2 |= 1 << i;
        }
      )
    );
    started = true;
    sync();
    return function stop2() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}
var subscriber_queue;
var init_shared2 = __esm({
  'node_modules/svelte/src/store/shared/index.js'() {
    init_utils3();
    init_equality();
    init_utils5();
    subscriber_queue = [];
  },
});

// node_modules/svelte/src/store/index-server.js
var init_index_server = __esm({
  'node_modules/svelte/src/store/index-server.js'() {
    init_shared2();
    init_shared2();
  },
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  'node_modules/fast-safe-stringify/index.js'(exports, module) {
    module.exports = stringify4;
    stringify4.default = stringify4;
    stringify4.stable = deterministicStringify;
    stringify4.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = '[...]';
    var CIRCULAR_REPLACE_NODE = '[Circular]';
    var arr = [];
    var replacerStack = [];
    function defaultOptions2() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER,
      };
    }
    function stringify4(obj, replacer, spacer, options) {
      if (typeof options === 'undefined') {
        options = defaultOptions2();
      }
      decirc(obj, '', 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify(
          '[unable to serialize, circular reference is too complex to analyze]'
        );
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace]);
        }
      } else {
        parent[k] = replace;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack2, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === 'object' && val !== null) {
        for (i = 0; i < stack2.length; i++) {
          if (stack2[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack2.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack2, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key2 = keys[i];
            decirc(val[key2], key2, i, stack2, val, depth, options);
          }
        }
        stack2.pop();
      }
    }
    function compareFunction(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === 'undefined') {
        options = defaultOptions2();
      }
      var tmp = deterministicDecirc(obj, '', 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify(
          '[unable to serialize, circular reference is too complex to analyze]'
        );
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k, edgeIndex, stack2, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === 'object' && val !== null) {
        for (i = 0; i < stack2.length; i++) {
          if (stack2[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === 'function') {
            return;
          }
        } catch (_) {
          return;
        }
        if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack2.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack2, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys.length; i++) {
            var key2 = keys[i];
            deterministicDecirc(val[key2], key2, i, stack2, val, depth, options);
            tmp[key2] = val[key2];
          }
          if (typeof parent !== 'undefined') {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp;
          }
        }
        stack2.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer =
        typeof replacer !== 'undefined'
          ? replacer
          : function (k, v) {
              return v;
            };
      return function (key2, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key2 && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break;
            }
          }
        }
        return replacer.call(this, key2, val);
      };
    }
  },
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  'node_modules/safe-stable-stringify/index.js'(exports, module) {
    'use strict';
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    var stringify4 = configure();
    stringify4.configure = configure;
    stringify4.stringify = stringify4;
    stringify4.default = stringify4;
    exports.stringify = stringify4;
    exports.configure = configure;
    module.exports = stringify4;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str2) {
      if (str2.length < 5e3 && !strEscapeSequencesRegExp.test(str2)) {
        return `"${str2}"`;
      }
      return JSON.stringify(str2);
    }
    function sort(array, comparator) {
      if (array.length > 200 || comparator) {
        return array.sort(comparator);
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace2 = separator === ',' ? '' : ' ';
      let res = `"0":${whitespace2}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace2}${array[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty2.call(options, 'circularValue')) {
        const circularValue = options.circularValue;
        if (typeof circularValue === 'string') {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError('Converting circular structure to JSON');
            },
          };
        }
        throw new TypeError(
          'The "circularValue" argument must be of type string or the value null or undefined'
        );
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options) {
      let value;
      if (hasOwnProperty2.call(options, 'deterministic')) {
        value = options.deterministic;
        if (typeof value !== 'boolean' && typeof value !== 'function') {
          throw new TypeError(
            'The "deterministic" argument must be of type boolean or comparator function'
          );
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options, key2) {
      let value;
      if (hasOwnProperty2.call(options, key2)) {
        value = options[key2];
        if (typeof value !== 'boolean') {
          throw new TypeError(`The "${key2}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key2) {
      let value;
      if (hasOwnProperty2.call(options, key2)) {
        value = options[key2];
        if (typeof value !== 'number') {
          throw new TypeError(`The "${key2}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key2}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key2}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return '1 item';
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === 'string' || typeof value === 'number') {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty2.call(options, 'strict')) {
        const value = options.strict;
        if (typeof value !== 'boolean') {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== 'function') message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!('circularValue' in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, 'bigint');
      const deterministic = getDeterministicOption(options);
      const comparator = typeof deterministic === 'function' ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options, 'maximumDepth');
      const maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth');
      function stringifyFnReplacer(key2, parent, stack2, replacer, spacer, indentation) {
        let value = parent[key2];
        if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
          value = value.toJSON(key2);
        }
        value = replacer.call(parent, key2, value);
        switch (typeof value) {
          case 'string':
            return strEscape(value);
          case 'object': {
            if (value === null) {
              return 'null';
            }
            if (stack2.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = '';
            let join3 = ',';
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return '[]';
              }
              if (maximumDepth < stack2.length + 1) {
                return '"[Array]"';
              }
              stack2.push(value);
              if (spacer !== '') {
                indentation += spacer;
                res += `
${indentation}`;
                join3 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(
                  String(i),
                  value,
                  stack2,
                  replacer,
                  spacer,
                  indentation
                );
                res += tmp2 !== void 0 ? tmp2 : 'null';
                res += join3;
              }
              const tmp = stringifyFnReplacer(
                String(i),
                value,
                stack2,
                replacer,
                spacer,
                indentation
              );
              res += tmp !== void 0 ? tmp : 'null';
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join3}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== '') {
                res += `
${originalIndentation}`;
              }
              stack2.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return '{}';
            }
            if (maximumDepth < stack2.length + 1) {
              return '"[Object]"';
            }
            let whitespace2 = '';
            let separator = '';
            if (spacer !== '') {
              indentation += spacer;
              join3 = `,
${indentation}`;
              whitespace2 = ' ';
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = sort(keys, comparator);
            }
            stack2.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key3 = keys[i];
              const tmp = stringifyFnReplacer(key3, value, stack2, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key3)}:${whitespace2}${tmp}`;
                separator = join3;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace2}"${getItemCount(removedKeys)} not stringified"`;
              separator = join3;
            }
            if (spacer !== '' && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack2.pop();
            return `{${res}}`;
          }
          case 'number':
            return isFinite(value) ? String(value) : fail ? fail(value) : 'null';
          case 'boolean':
            return value === true ? 'true' : 'false';
          case 'undefined':
            return void 0;
          case 'bigint':
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key2, value, stack2, replacer, spacer, indentation) {
        if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
          value = value.toJSON(key2);
        }
        switch (typeof value) {
          case 'string':
            return strEscape(value);
          case 'object': {
            if (value === null) {
              return 'null';
            }
            if (stack2.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = '';
            let join3 = ',';
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return '[]';
              }
              if (maximumDepth < stack2.length + 1) {
                return '"[Array]"';
              }
              stack2.push(value);
              if (spacer !== '') {
                indentation += spacer;
                res += `
${indentation}`;
                join3 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(
                  String(i),
                  value[i],
                  stack2,
                  replacer,
                  spacer,
                  indentation
                );
                res += tmp2 !== void 0 ? tmp2 : 'null';
                res += join3;
              }
              const tmp = stringifyArrayReplacer(
                String(i),
                value[i],
                stack2,
                replacer,
                spacer,
                indentation
              );
              res += tmp !== void 0 ? tmp : 'null';
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join3}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== '') {
                res += `
${originalIndentation}`;
              }
              stack2.pop();
              return `[${res}]`;
            }
            stack2.push(value);
            let whitespace2 = '';
            if (spacer !== '') {
              indentation += spacer;
              join3 = `,
${indentation}`;
              whitespace2 = ' ';
            }
            let separator = '';
            for (const key3 of replacer) {
              const tmp = stringifyArrayReplacer(
                key3,
                value[key3],
                stack2,
                replacer,
                spacer,
                indentation
              );
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key3)}:${whitespace2}${tmp}`;
                separator = join3;
              }
            }
            if (spacer !== '' && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack2.pop();
            return `{${res}}`;
          }
          case 'number':
            return isFinite(value) ? String(value) : fail ? fail(value) : 'null';
          case 'boolean':
            return value === true ? 'true' : 'false';
          case 'undefined':
            return void 0;
          case 'bigint':
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key2, value, stack2, spacer, indentation) {
        switch (typeof value) {
          case 'string':
            return strEscape(value);
          case 'object': {
            if (value === null) {
              return 'null';
            }
            if (typeof value.toJSON === 'function') {
              value = value.toJSON(key2);
              if (typeof value !== 'object') {
                return stringifyIndent(key2, value, stack2, spacer, indentation);
              }
              if (value === null) {
                return 'null';
              }
            }
            if (stack2.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return '[]';
              }
              if (maximumDepth < stack2.length + 1) {
                return '"[Array]"';
              }
              stack2.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join4 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack2, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : 'null';
                res2 += join4;
              }
              const tmp = stringifyIndent(String(i), value[i], stack2, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : 'null';
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join4}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack2.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return '{}';
            }
            if (maximumDepth < stack2.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join3 = `,
${indentation}`;
            let res = '';
            let separator = '';
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join3, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join3;
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack2.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key3 = keys[i];
              const tmp = stringifyIndent(key3, value[key3], stack2, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key3)}: ${tmp}`;
                separator = join3;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join3;
            }
            if (separator !== '') {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack2.pop();
            return `{${res}}`;
          }
          case 'number':
            return isFinite(value) ? String(value) : fail ? fail(value) : 'null';
          case 'boolean':
            return value === true ? 'true' : 'false';
          case 'undefined':
            return void 0;
          case 'bigint':
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key2, value, stack2) {
        switch (typeof value) {
          case 'string':
            return strEscape(value);
          case 'object': {
            if (value === null) {
              return 'null';
            }
            if (typeof value.toJSON === 'function') {
              value = value.toJSON(key2);
              if (typeof value !== 'object') {
                return stringifySimple(key2, value, stack2);
              }
              if (value === null) {
                return 'null';
              }
            }
            if (stack2.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = '';
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return '[]';
              }
              if (maximumDepth < stack2.length + 1) {
                return '"[Array]"';
              }
              stack2.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack2);
                res += tmp2 !== void 0 ? tmp2 : 'null';
                res += ',';
              }
              const tmp = stringifySimple(String(i), value[i], stack2);
              res += tmp !== void 0 ? tmp : 'null';
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack2.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return '{}';
            }
            if (maximumDepth < stack2.length + 1) {
              return '"[Object]"';
            }
            let separator = '';
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ',', maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ',';
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack2.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key3 = keys[i];
              const tmp = stringifySimple(key3, value[key3], stack2);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key3)}:${tmp}`;
                separator = ',';
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack2.pop();
            return `{${res}}`;
          }
          case 'number':
            return isFinite(value) ? String(value) : fail ? fail(value) : 'null';
          case 'boolean':
            return value === true ? 'true' : 'false';
          case 'undefined':
            return void 0;
          case 'bigint':
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify5(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = '';
          if (typeof space === 'number') {
            spacer = ' '.repeat(Math.min(space, 10));
          } else if (typeof space === 'string') {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === 'function') {
              return stringifyFnReplacer('', { '': value }, [], replacer, spacer, '');
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer(
                '',
                value,
                [],
                getUniqueReplacerSet(replacer),
                spacer,
                ''
              );
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent('', value, [], spacer, '');
          }
        }
        return stringifySimple('', value, []);
      }
      return stringify5;
    }
  },
});

// node_modules/partysocket/dist/index.js
var require_dist = __commonJS({
  'node_modules/partysocket/dist/index.js'(exports, module) {
    'use strict';
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all3) => {
      for (var name3 in all3) __defProp2(target, name3, { get: all3[name3], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if ((from && typeof from === 'object') || typeof from === 'function') {
        for (let key2 of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key2) && key2 !== except)
            __defProp2(to, key2, {
              get: () => from[key2],
              enumerable: !(desc = __getOwnPropDesc2(from, key2)) || desc.enumerable,
            });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, '__esModule', { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      WebSocket: () => ReconnectingWebSocket,
      default: () => PartySocket,
    });
    module.exports = __toCommonJS2(src_exports);
    if (!globalThis.EventTarget || !globalThis.Event) {
      console.error(`
  PartySocket requires a global 'EventTarget' class to be available!
  You can polyfill this global by adding this to your code before any partysocket imports: 
  
  \`\`\`
  import 'partysocket/event-target-polyfill';
  \`\`\`
  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.
`);
    }
    var ErrorEvent = class extends Event {
      message;
      error;
      constructor(error, target) {
        super('error', target);
        this.message = error.message;
        this.error = error;
      }
    };
    var CloseEvent = class extends Event {
      code;
      reason;
      wasClean = true;
      constructor(code = 1e3, reason = '', target) {
        super('close', target);
        this.code = code;
        this.reason = reason;
      }
    };
    var Events = {
      Event,
      ErrorEvent,
      CloseEvent,
    };
    function assert(condition, msg) {
      if (!condition) {
        throw new Error(msg);
      }
    }
    function cloneEventBrowser(e) {
      return new e.constructor(e.type, e);
    }
    function cloneEventNode(e) {
      if ('data' in e) {
        const evt2 = new MessageEvent(e.type, e);
        return evt2;
      }
      if ('code' in e || 'reason' in e) {
        const evt2 = new CloseEvent(
          // @ts-expect-error we need to fix event/listener types
          e.code || 1999,
          // @ts-expect-error we need to fix event/listener types
          e.reason || 'unknown reason',
          e
        );
        return evt2;
      }
      if ('error' in e) {
        const evt2 = new ErrorEvent(e.error, e);
        return evt2;
      }
      const evt = new Event(e.type, e);
      return evt;
    }
    var isNode =
      typeof process !== 'undefined' &&
      typeof process.versions?.node !== 'undefined' &&
      typeof document === 'undefined';
    var cloneEvent = isNode ? cloneEventNode : cloneEventBrowser;
    var DEFAULT = {
      maxReconnectionDelay: 1e4,
      minReconnectionDelay: 1e3 + Math.random() * 4e3,
      minUptime: 5e3,
      reconnectionDelayGrowFactor: 1.3,
      connectionTimeout: 4e3,
      maxRetries: Infinity,
      maxEnqueuedMessages: Infinity,
      startClosed: false,
      debug: false,
    };
    var didWarnAboutMissingWebSocket = false;
    var ReconnectingWebSocket = class _ReconnectingWebSocket extends EventTarget {
      _ws;
      _retryCount = -1;
      _uptimeTimeout;
      _connectTimeout;
      _shouldReconnect = true;
      _connectLock = false;
      _binaryType = 'blob';
      _closeCalled = false;
      _messageQueue = [];
      _debugLogger = console.log.bind(console);
      _url;
      _protocols;
      _options;
      constructor(url2, protocols, options = {}) {
        super();
        this._url = url2;
        this._protocols = protocols;
        this._options = options;
        if (this._options.startClosed) {
          this._shouldReconnect = false;
        }
        if (this._options.debugLogger) {
          this._debugLogger = this._options.debugLogger;
        }
        this._connect();
      }
      static get CONNECTING() {
        return 0;
      }
      static get OPEN() {
        return 1;
      }
      static get CLOSING() {
        return 2;
      }
      static get CLOSED() {
        return 3;
      }
      get CONNECTING() {
        return _ReconnectingWebSocket.CONNECTING;
      }
      get OPEN() {
        return _ReconnectingWebSocket.OPEN;
      }
      get CLOSING() {
        return _ReconnectingWebSocket.CLOSING;
      }
      get CLOSED() {
        return _ReconnectingWebSocket.CLOSED;
      }
      get binaryType() {
        return this._ws ? this._ws.binaryType : this._binaryType;
      }
      set binaryType(value) {
        this._binaryType = value;
        if (this._ws) {
          this._ws.binaryType = value;
        }
      }
      /**
       * Returns the number or connection retries
       */
      get retryCount() {
        return Math.max(this._retryCount, 0);
      }
      /**
       * The number of bytes of data that have been queued using calls to send() but not yet
       * transmitted to the network. This value resets to zero once all queued data has been sent.
       * This value does not reset to zero when the connection is closed; if you keep calling send(),
       * this will continue to climb. Read only
       */
      get bufferedAmount() {
        const bytes = this._messageQueue.reduce((acc, message) => {
          if (typeof message === 'string') {
            acc += message.length;
          } else if (message instanceof Blob) {
            acc += message.size;
          } else {
            acc += message.byteLength;
          }
          return acc;
        }, 0);
        return bytes + (this._ws ? this._ws.bufferedAmount : 0);
      }
      /**
       * The extensions selected by the server. This is currently only the empty string or a list of
       * extensions as negotiated by the connection
       */
      get extensions() {
        return this._ws ? this._ws.extensions : '';
      }
      /**
       * A string indicating the name of the sub-protocol the server selected;
       * this will be one of the strings specified in the protocols parameter when creating the
       * WebSocket object
       */
      get protocol() {
        return this._ws ? this._ws.protocol : '';
      }
      /**
       * The current state of the connection; this is one of the Ready state constants
       */
      get readyState() {
        if (this._ws) {
          return this._ws.readyState;
        }
        return this._options.startClosed
          ? _ReconnectingWebSocket.CLOSED
          : _ReconnectingWebSocket.CONNECTING;
      }
      /**
       * The URL as resolved by the constructor
       */
      get url() {
        return this._ws ? this._ws.url : '';
      }
      /**
       * Whether the websocket object is now in reconnectable state
       */
      get shouldReconnect() {
        return this._shouldReconnect;
      }
      /**
       * An event listener to be called when the WebSocket connection's readyState changes to CLOSED
       */
      onclose = null;
      /**
       * An event listener to be called when an error occurs
       */
      onerror = null;
      /**
       * An event listener to be called when a message is received from the server
       */
      onmessage = null;
      /**
       * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
       * this indicates that the connection is ready to send and receive data
       */
      onopen = null;
      /**
       * Closes the WebSocket connection or connection attempt, if any. If the connection is already
       * CLOSED, this method does nothing
       */
      close(code = 1e3, reason) {
        this._closeCalled = true;
        this._shouldReconnect = false;
        this._clearTimeouts();
        if (!this._ws) {
          this._debug('close enqueued: no ws instance');
          return;
        }
        if (this._ws.readyState === this.CLOSED) {
          this._debug('close: already closed');
          return;
        }
        this._ws.close(code, reason);
      }
      /**
       * Closes the WebSocket connection or connection attempt and connects again.
       * Resets retry counter;
       */
      reconnect(code, reason) {
        this._shouldReconnect = true;
        this._closeCalled = false;
        this._retryCount = -1;
        if (!this._ws || this._ws.readyState === this.CLOSED) {
          this._connect();
        } else {
          this._disconnect(code, reason);
          this._connect();
        }
      }
      /**
       * Enqueue specified data to be transmitted to the server over the WebSocket connection
       */
      send(data) {
        if (this._ws && this._ws.readyState === this.OPEN) {
          this._debug('send', data);
          this._ws.send(data);
        } else {
          const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } = this._options;
          if (this._messageQueue.length < maxEnqueuedMessages) {
            this._debug('enqueue', data);
            this._messageQueue.push(data);
          }
        }
      }
      _debug(...args) {
        if (this._options.debug) {
          this._debugLogger('RWS>', ...args);
        }
      }
      _getNextDelay() {
        const {
          reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor,
          minReconnectionDelay = DEFAULT.minReconnectionDelay,
          maxReconnectionDelay = DEFAULT.maxReconnectionDelay,
        } = this._options;
        let delay2 = 0;
        if (this._retryCount > 0) {
          delay2 =
            minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
          if (delay2 > maxReconnectionDelay) {
            delay2 = maxReconnectionDelay;
          }
        }
        this._debug('next delay', delay2);
        return delay2;
      }
      _wait() {
        return new Promise((resolve) => {
          setTimeout(resolve, this._getNextDelay());
        });
      }
      _getNextProtocols(protocolsProvider) {
        if (!protocolsProvider) return Promise.resolve(null);
        if (typeof protocolsProvider === 'string' || Array.isArray(protocolsProvider)) {
          return Promise.resolve(protocolsProvider);
        }
        if (typeof protocolsProvider === 'function') {
          const protocols = protocolsProvider();
          if (!protocols) return Promise.resolve(null);
          if (typeof protocols === 'string' || Array.isArray(protocols)) {
            return Promise.resolve(protocols);
          }
          if (protocols.then) {
            return protocols;
          }
        }
        throw Error('Invalid protocols');
      }
      _getNextUrl(urlProvider) {
        if (typeof urlProvider === 'string') {
          return Promise.resolve(urlProvider);
        }
        if (typeof urlProvider === 'function') {
          const url2 = urlProvider();
          if (typeof url2 === 'string') {
            return Promise.resolve(url2);
          }
          if (url2.then) {
            return url2;
          }
        }
        throw Error('Invalid URL');
      }
      _connect() {
        if (this._connectLock || !this._shouldReconnect) {
          return;
        }
        this._connectLock = true;
        const { maxRetries = DEFAULT.maxRetries, connectionTimeout = DEFAULT.connectionTimeout } =
          this._options;
        if (this._retryCount >= maxRetries) {
          this._debug('max retries reached', this._retryCount, '>=', maxRetries);
          return;
        }
        this._retryCount++;
        this._debug('connect', this._retryCount);
        this._removeListeners();
        this._wait()
          .then(() =>
            Promise.all([
              this._getNextUrl(this._url),
              this._getNextProtocols(this._protocols || null),
            ])
          )
          .then(([url2, protocols]) => {
            if (this._closeCalled) {
              this._connectLock = false;
              return;
            }
            if (
              !this._options.WebSocket &&
              typeof WebSocket === 'undefined' &&
              !didWarnAboutMissingWebSocket
            ) {
              console.error(`\u203C\uFE0F No WebSocket implementation available. You should define options.WebSocket. 

For example, if you're using node.js, run \`npm install ws\`, and then in your code:

import PartySocket from 'partysocket';
import WS from 'ws';

const partysocket = new PartySocket({
  host: "127.0.0.1:1999",
  room: "test-room",
  WebSocket: WS
});

`);
              didWarnAboutMissingWebSocket = true;
            }
            const WS = this._options.WebSocket || WebSocket;
            this._debug('connect', { url: url2, protocols });
            this._ws = protocols ? new WS(url2, protocols) : new WS(url2);
            this._ws.binaryType = this._binaryType;
            this._connectLock = false;
            this._addListeners();
            this._connectTimeout = setTimeout(() => this._handleTimeout(), connectionTimeout);
          })
          .catch((err) => {
            this._connectLock = false;
            this._handleError(new Events.ErrorEvent(Error(err.message), this));
          });
      }
      _handleTimeout() {
        this._debug('timeout event');
        this._handleError(new Events.ErrorEvent(Error('TIMEOUT'), this));
      }
      _disconnect(code = 1e3, reason) {
        this._clearTimeouts();
        if (!this._ws) {
          return;
        }
        this._removeListeners();
        try {
          this._ws.close(code, reason);
          this._handleClose(new Events.CloseEvent(code, reason, this));
        } catch (error) {}
      }
      _acceptOpen() {
        this._debug('accept open');
        this._retryCount = 0;
      }
      _handleOpen = (event2) => {
        this._debug('open event');
        const { minUptime = DEFAULT.minUptime } = this._options;
        clearTimeout(this._connectTimeout);
        this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);
        assert(this._ws, 'WebSocket is not defined');
        this._ws.binaryType = this._binaryType;
        this._messageQueue.forEach((message) => this._ws?.send(message));
        this._messageQueue = [];
        if (this.onopen) {
          this.onopen(event2);
        }
        this.dispatchEvent(cloneEvent(event2));
      };
      _handleMessage = (event2) => {
        this._debug('message event');
        if (this.onmessage) {
          this.onmessage(event2);
        }
        this.dispatchEvent(cloneEvent(event2));
      };
      _handleError = (event2) => {
        this._debug('error event', event2.message);
        this._disconnect(void 0, event2.message === 'TIMEOUT' ? 'timeout' : void 0);
        if (this.onerror) {
          this.onerror(event2);
        }
        this._debug('exec error listeners');
        this.dispatchEvent(cloneEvent(event2));
        this._connect();
      };
      _handleClose = (event2) => {
        this._debug('close event');
        this._clearTimeouts();
        if (this._shouldReconnect) {
          this._connect();
        }
        if (this.onclose) {
          this.onclose(event2);
        }
        this.dispatchEvent(cloneEvent(event2));
      };
      _removeListeners() {
        if (!this._ws) {
          return;
        }
        this._debug('removeListeners');
        this._ws.removeEventListener('open', this._handleOpen);
        this._ws.removeEventListener('close', this._handleClose);
        this._ws.removeEventListener('message', this._handleMessage);
        this._ws.removeEventListener('error', this._handleError);
      }
      _addListeners() {
        if (!this._ws) {
          return;
        }
        this._debug('addListeners');
        this._ws.addEventListener('open', this._handleOpen);
        this._ws.addEventListener('close', this._handleClose);
        this._ws.addEventListener('message', this._handleMessage);
        this._ws.addEventListener('error', this._handleError);
      }
      _clearTimeouts() {
        clearTimeout(this._connectTimeout);
        clearTimeout(this._uptimeTimeout);
      }
    };
    var valueIsNotNil = (keyValuePair) => keyValuePair[1] !== null && keyValuePair[1] !== void 0;
    function generateUUID() {
      if (typeof crypto !== 'undefined' && crypto.randomUUID) {
        return crypto.randomUUID();
      }
      let d = /* @__PURE__ */ new Date().getTime();
      let d2 =
        (typeof performance !== 'undefined' && performance.now && performance.now() * 1e3) || 0;
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        let r = Math.random() * 16;
        if (d > 0) {
          r = (d + r) % 16 | 0;
          d = Math.floor(d / 16);
        } else {
          r = (d2 + r) % 16 | 0;
          d2 = Math.floor(d2 / 16);
        }
        return (c === 'x' ? r : (r & 3) | 8).toString(16);
      });
    }
    function getPartyInfo(partySocketOptions, defaultProtocol, defaultParams = {}) {
      const {
        host: rawHost,
        path: rawPath,
        protocol: rawProtocol,
        room,
        party,
        query,
      } = partySocketOptions;
      let host = rawHost.replace(/^(http|https|ws|wss):\/\//, '');
      if (host.endsWith('/')) {
        host = host.slice(0, -1);
      }
      if (rawPath && rawPath.startsWith('/')) {
        throw new Error('path must not start with a slash');
      }
      const name3 = party ?? 'main';
      const path5 = rawPath ? `/${rawPath}` : '';
      const protocol =
        rawProtocol ||
        (host.startsWith('localhost:') ||
        host.startsWith('127.0.0.1:') ||
        host.startsWith('192.168.') ||
        host.startsWith('10.') ||
        (host.startsWith('172.') && host.split('.')[1] >= '16' && host.split('.')[1] <= '31') ||
        host.startsWith('[::ffff:7f00:1]:')
          ? // http / ws
            defaultProtocol
          : // https / wss
            defaultProtocol + 's');
      const baseUrl = `${protocol}://${host}/${party ? `parties/${party}` : 'party'}/${room}${path5}`;
      const makeUrl = (query2 = {}) =>
        `${baseUrl}?${new URLSearchParams([
          ...Object.entries(defaultParams),
          ...Object.entries(query2).filter(valueIsNotNil),
        ])}`;
      const urlProvider =
        typeof query === 'function' ? async () => makeUrl(await query()) : makeUrl(query);
      return {
        host,
        path: path5,
        room,
        name: name3,
        protocol,
        partyUrl: baseUrl,
        urlProvider,
      };
    }
    var PartySocket = class extends ReconnectingWebSocket {
      constructor(partySocketOptions) {
        const wsOptions = getWSOptions(partySocketOptions);
        super(wsOptions.urlProvider, wsOptions.protocols, wsOptions.socketOptions);
        this.partySocketOptions = partySocketOptions;
        this.setWSProperties(wsOptions);
      }
      _pk;
      _pkurl;
      name;
      room;
      host;
      path;
      updateProperties(partySocketOptions) {
        const wsOptions = getWSOptions({
          ...this.partySocketOptions,
          ...partySocketOptions,
          host: partySocketOptions.host ?? this.host,
          room: partySocketOptions.room ?? this.room,
          path: partySocketOptions.path ?? this.path,
        });
        this._url = wsOptions.urlProvider;
        this._protocols = wsOptions.protocols;
        this._options = wsOptions.socketOptions;
        this.setWSProperties(wsOptions);
      }
      setWSProperties(wsOptions) {
        const { _pk, _pkurl, name: name3, room, host, path: path5 } = wsOptions;
        this._pk = _pk;
        this._pkurl = _pkurl;
        this.name = name3;
        this.room = room;
        this.host = host;
        this.path = path5;
      }
      reconnect(code, reason) {
        if (!this.room || !this.host) {
          throw new Error(
            'The room and host must be set before connecting, use `updateProperties` method to set them or pass them to the constructor.'
          );
        }
        super.reconnect(code, reason);
      }
      get id() {
        return this._pk;
      }
      /**
       * Exposes the static PartyKit room URL without applying query parameters.
       * To access the currently connected WebSocket url, use PartySocket#url.
       */
      get roomUrl() {
        return this._pkurl;
      }
      // a `fetch` method that uses (almost) the same options as `PartySocket`
      static async fetch(options, init2) {
        const party = getPartyInfo(options, 'http');
        const url2 =
          typeof party.urlProvider === 'string' ? party.urlProvider : await party.urlProvider();
        const doFetch = options.fetch ?? fetch;
        return doFetch(url2, init2);
      }
    };
    function getWSOptions(partySocketOptions) {
      const {
        id,
        host: _host,
        path: _path,
        party: _party,
        room: _room,
        protocol: _protocol,
        query: _query,
        protocols,
        ...socketOptions
      } = partySocketOptions;
      const _pk = id || generateUUID();
      const party = getPartyInfo(partySocketOptions, 'ws', { _pk });
      return {
        _pk,
        _pkurl: party.partyUrl,
        name: party.name,
        room: party.room,
        host: party.host,
        path: party.path,
        protocols,
        socketOptions,
        urlProvider: party.urlProvider,
      };
    }
  },
});

// node_modules/superjson/dist/double-indexed-kv.js
var require_double_indexed_kv = __commonJS({
  'node_modules/superjson/dist/double-indexed-kv.js'(exports) {
    'use strict';
    exports.__esModule = true;
    exports.DoubleIndexedKV = void 0;
    var DoubleIndexedKV =
      /** @class */
      (function () {
        function DoubleIndexedKV2() {
          this.keyToValue = /* @__PURE__ */ new Map();
          this.valueToKey = /* @__PURE__ */ new Map();
        }
        DoubleIndexedKV2.prototype.set = function (key2, value) {
          this.keyToValue.set(key2, value);
          this.valueToKey.set(value, key2);
        };
        DoubleIndexedKV2.prototype.getByKey = function (key2) {
          return this.keyToValue.get(key2);
        };
        DoubleIndexedKV2.prototype.getByValue = function (value) {
          return this.valueToKey.get(value);
        };
        DoubleIndexedKV2.prototype.clear = function () {
          this.keyToValue.clear();
          this.valueToKey.clear();
        };
        return DoubleIndexedKV2;
      })();
    exports.DoubleIndexedKV = DoubleIndexedKV;
  },
});

// node_modules/superjson/dist/registry.js
var require_registry = __commonJS({
  'node_modules/superjson/dist/registry.js'(exports) {
    'use strict';
    exports.__esModule = true;
    exports.Registry = void 0;
    var double_indexed_kv_1 = require_double_indexed_kv();
    var Registry =
      /** @class */
      (function () {
        function Registry2(generateIdentifier) {
          this.generateIdentifier = generateIdentifier;
          this.kv = new double_indexed_kv_1.DoubleIndexedKV();
        }
        Registry2.prototype.register = function (value, identifier) {
          if (this.kv.getByValue(value)) {
            return;
          }
          if (!identifier) {
            identifier = this.generateIdentifier(value);
          }
          this.kv.set(identifier, value);
        };
        Registry2.prototype.clear = function () {
          this.kv.clear();
        };
        Registry2.prototype.getIdentifier = function (value) {
          return this.kv.getByValue(value);
        };
        Registry2.prototype.getValue = function (identifier) {
          return this.kv.getByKey(identifier);
        };
        return Registry2;
      })();
    exports.Registry = Registry;
  },
});

// node_modules/superjson/dist/class-registry.js
var require_class_registry = __commonJS({
  'node_modules/superjson/dist/class-registry.js'(exports) {
    'use strict';
    var __extends =
      (exports && exports.__extends) ||
      /* @__PURE__ */ (function () {
        var extendStatics = function (d, b) {
          extendStatics =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (d2, b2) {
                d2.__proto__ = b2;
              }) ||
            function (d2, b2) {
              for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
            };
          return extendStatics(d, b);
        };
        return function (d, b) {
          if (typeof b !== 'function' && b !== null)
            throw new TypeError(
              'Class extends value ' + String(b) + ' is not a constructor or null'
            );
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
        };
      })();
    exports.__esModule = true;
    exports.ClassRegistry = void 0;
    var registry_1 = require_registry();
    var ClassRegistry =
      /** @class */
      (function (_super) {
        __extends(ClassRegistry2, _super);
        function ClassRegistry2() {
          var _this =
            _super.call(this, function (c) {
              return c.name;
            }) || this;
          _this.classToAllowedProps = /* @__PURE__ */ new Map();
          return _this;
        }
        ClassRegistry2.prototype.register = function (value, options) {
          if (typeof options === 'object') {
            if (options.allowProps) {
              this.classToAllowedProps.set(value, options.allowProps);
            }
            _super.prototype.register.call(this, value, options.identifier);
          } else {
            _super.prototype.register.call(this, value, options);
          }
        };
        ClassRegistry2.prototype.getAllowedProps = function (value) {
          return this.classToAllowedProps.get(value);
        };
        return ClassRegistry2;
      })(registry_1.Registry);
    exports.ClassRegistry = ClassRegistry;
  },
});

// node_modules/superjson/dist/util.js
var require_util = __commonJS({
  'node_modules/superjson/dist/util.js'(exports) {
    'use strict';
    var __read =
      (exports && exports.__read) ||
      function (o, n) {
        var m = typeof Symbol === 'function' && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o),
          r,
          ar = [],
          e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i['return'])) m.call(i);
          } finally {
            if (e) throw e.error;
          }
        }
        return ar;
      };
    exports.__esModule = true;
    exports.findArr = exports.includes = exports.forEach = exports.find = void 0;
    function valuesOfObj(record) {
      if ('values' in Object) {
        return Object.values(record);
      }
      var values = [];
      for (var key2 in record) {
        if (record.hasOwnProperty(key2)) {
          values.push(record[key2]);
        }
      }
      return values;
    }
    function find(record, predicate) {
      var values = valuesOfObj(record);
      if ('find' in values) {
        return values.find(predicate);
      }
      var valuesNotNever = values;
      for (var i = 0; i < valuesNotNever.length; i++) {
        var value = valuesNotNever[i];
        if (predicate(value)) {
          return value;
        }
      }
      return void 0;
    }
    exports.find = find;
    function forEach2(record, run2) {
      Object.entries(record).forEach(function (_a3) {
        var _b = __read(_a3, 2),
          key2 = _b[0],
          value = _b[1];
        return run2(value, key2);
      });
    }
    exports.forEach = forEach2;
    function includes(arr, value) {
      return arr.indexOf(value) !== -1;
    }
    exports.includes = includes;
    function findArr(record, predicate) {
      for (var i = 0; i < record.length; i++) {
        var value = record[i];
        if (predicate(value)) {
          return value;
        }
      }
      return void 0;
    }
    exports.findArr = findArr;
  },
});

// node_modules/superjson/dist/custom-transformer-registry.js
var require_custom_transformer_registry = __commonJS({
  'node_modules/superjson/dist/custom-transformer-registry.js'(exports) {
    'use strict';
    exports.__esModule = true;
    exports.CustomTransformerRegistry = void 0;
    var util_1 = require_util();
    var CustomTransformerRegistry =
      /** @class */
      (function () {
        function CustomTransformerRegistry2() {
          this.transfomers = {};
        }
        CustomTransformerRegistry2.prototype.register = function (transformer) {
          this.transfomers[transformer.name] = transformer;
        };
        CustomTransformerRegistry2.prototype.findApplicable = function (v) {
          return util_1.find(this.transfomers, function (transformer) {
            return transformer.isApplicable(v);
          });
        };
        CustomTransformerRegistry2.prototype.findByName = function (name3) {
          return this.transfomers[name3];
        };
        return CustomTransformerRegistry2;
      })();
    exports.CustomTransformerRegistry = CustomTransformerRegistry;
  },
});

// node_modules/superjson/dist/is.js
var require_is = __commonJS({
  'node_modules/superjson/dist/is.js'(exports) {
    'use strict';
    exports.__esModule = true;
    exports.isURL =
      exports.isTypedArray =
      exports.isInfinite =
      exports.isBigint =
      exports.isPrimitive =
      exports.isNaNValue =
      exports.isError =
      exports.isDate =
      exports.isSymbol =
      exports.isSet =
      exports.isMap =
      exports.isRegExp =
      exports.isBoolean =
      exports.isNumber =
      exports.isString =
      exports.isArray =
      exports.isEmptyObject =
      exports.isPlainObject =
      exports.isNull =
      exports.isUndefined =
        void 0;
    var getType = function (payload) {
      return Object.prototype.toString.call(payload).slice(8, -1);
    };
    var isUndefined2 = function (payload) {
      return typeof payload === 'undefined';
    };
    exports.isUndefined = isUndefined2;
    var isNull = function (payload) {
      return payload === null;
    };
    exports.isNull = isNull;
    var isPlainObject2 = function (payload) {
      if (typeof payload !== 'object' || payload === null) return false;
      if (payload === Object.prototype) return false;
      if (Object.getPrototypeOf(payload) === null) return true;
      return Object.getPrototypeOf(payload) === Object.prototype;
    };
    exports.isPlainObject = isPlainObject2;
    var isEmptyObject2 = function (payload) {
      return exports.isPlainObject(payload) && Object.keys(payload).length === 0;
    };
    exports.isEmptyObject = isEmptyObject2;
    var isArray4 = function (payload) {
      return Array.isArray(payload);
    };
    exports.isArray = isArray4;
    var isString2 = function (payload) {
      return typeof payload === 'string';
    };
    exports.isString = isString2;
    var isNumber2 = function (payload) {
      return typeof payload === 'number' && !isNaN(payload);
    };
    exports.isNumber = isNumber2;
    var isBoolean2 = function (payload) {
      return typeof payload === 'boolean';
    };
    exports.isBoolean = isBoolean2;
    var isRegExp2 = function (payload) {
      return payload instanceof RegExp;
    };
    exports.isRegExp = isRegExp2;
    var isMap = function (payload) {
      return payload instanceof Map;
    };
    exports.isMap = isMap;
    var isSet = function (payload) {
      return payload instanceof Set;
    };
    exports.isSet = isSet;
    var isSymbol = function (payload) {
      return getType(payload) === 'Symbol';
    };
    exports.isSymbol = isSymbol;
    var isDate2 = function (payload) {
      return payload instanceof Date && !isNaN(payload.valueOf());
    };
    exports.isDate = isDate2;
    var isError = function (payload) {
      return payload instanceof Error;
    };
    exports.isError = isError;
    var isNaNValue = function (payload) {
      return typeof payload === 'number' && isNaN(payload);
    };
    exports.isNaNValue = isNaNValue;
    var isPrimitive = function (payload) {
      return (
        exports.isBoolean(payload) ||
        exports.isNull(payload) ||
        exports.isUndefined(payload) ||
        exports.isNumber(payload) ||
        exports.isString(payload) ||
        exports.isSymbol(payload)
      );
    };
    exports.isPrimitive = isPrimitive;
    var isBigint = function (payload) {
      return typeof payload === 'bigint';
    };
    exports.isBigint = isBigint;
    var isInfinite = function (payload) {
      return payload === Infinity || payload === -Infinity;
    };
    exports.isInfinite = isInfinite;
    var isTypedArray2 = function (payload) {
      return ArrayBuffer.isView(payload) && !(payload instanceof DataView);
    };
    exports.isTypedArray = isTypedArray2;
    var isURL = function (payload) {
      return payload instanceof URL;
    };
    exports.isURL = isURL;
  },
});

// node_modules/superjson/dist/pathstringifier.js
var require_pathstringifier = __commonJS({
  'node_modules/superjson/dist/pathstringifier.js'(exports) {
    'use strict';
    exports.__esModule = true;
    exports.parsePath = exports.stringifyPath = exports.escapeKey = void 0;
    var escapeKey = function (key2) {
      return key2.replace(/\./g, '\\.');
    };
    exports.escapeKey = escapeKey;
    var stringifyPath = function (path5) {
      return path5.map(String).map(exports.escapeKey).join('.');
    };
    exports.stringifyPath = stringifyPath;
    var parsePath = function (string) {
      var result = [];
      var segment = '';
      for (var i = 0; i < string.length; i++) {
        var char = string.charAt(i);
        var isEscapedDot = char === '\\' && string.charAt(i + 1) === '.';
        if (isEscapedDot) {
          segment += '.';
          i++;
          continue;
        }
        var isEndOfSegment = char === '.';
        if (isEndOfSegment) {
          result.push(segment);
          segment = '';
          continue;
        }
        segment += char;
      }
      var lastSegment = segment;
      result.push(lastSegment);
      return result;
    };
    exports.parsePath = parsePath;
  },
});

// node_modules/superjson/dist/transformer.js
var require_transformer = __commonJS({
  'node_modules/superjson/dist/transformer.js'(exports) {
    'use strict';
    var __assign =
      (exports && exports.__assign) ||
      function () {
        __assign =
          Object.assign ||
          function (t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
          };
        return __assign.apply(this, arguments);
      };
    var __read =
      (exports && exports.__read) ||
      function (o, n) {
        var m = typeof Symbol === 'function' && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o),
          r,
          ar = [],
          e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i['return'])) m.call(i);
          } finally {
            if (e) throw e.error;
          }
        }
        return ar;
      };
    var __spreadArray =
      (exports && exports.__spreadArray) ||
      function (to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
        return to;
      };
    exports.__esModule = true;
    exports.untransformValue =
      exports.transformValue =
      exports.isInstanceOfRegisteredClass =
        void 0;
    var is_1 = require_is();
    var util_1 = require_util();
    function simpleTransformation(isApplicable, annotation, transform, untransform) {
      return {
        isApplicable,
        annotation,
        transform,
        untransform,
      };
    }
    var simpleRules = [
      simpleTransformation(
        is_1.isUndefined,
        'undefined',
        function () {
          return null;
        },
        function () {
          return void 0;
        }
      ),
      simpleTransformation(
        is_1.isBigint,
        'bigint',
        function (v) {
          return v.toString();
        },
        function (v) {
          if (typeof BigInt !== 'undefined') {
            return BigInt(v);
          }
          console.error('Please add a BigInt polyfill.');
          return v;
        }
      ),
      simpleTransformation(
        is_1.isDate,
        'Date',
        function (v) {
          return v.toISOString();
        },
        function (v) {
          return new Date(v);
        }
      ),
      simpleTransformation(
        is_1.isError,
        'Error',
        function (v, superJson) {
          var baseError = {
            name: v.name,
            message: v.message,
          };
          superJson.allowedErrorProps.forEach(function (prop2) {
            baseError[prop2] = v[prop2];
          });
          return baseError;
        },
        function (v, superJson) {
          var e = new Error(v.message);
          e.name = v.name;
          e.stack = v.stack;
          superJson.allowedErrorProps.forEach(function (prop2) {
            e[prop2] = v[prop2];
          });
          return e;
        }
      ),
      simpleTransformation(
        is_1.isRegExp,
        'regexp',
        function (v) {
          return '' + v;
        },
        function (regex) {
          var body = regex.slice(1, regex.lastIndexOf('/'));
          var flags2 = regex.slice(regex.lastIndexOf('/') + 1);
          return new RegExp(body, flags2);
        }
      ),
      simpleTransformation(
        is_1.isSet,
        'set',
        // (sets only exist in es6+)
        // eslint-disable-next-line es5/no-es6-methods
        function (v) {
          return __spreadArray([], __read(v.values()));
        },
        function (v) {
          return new Set(v);
        }
      ),
      simpleTransformation(
        is_1.isMap,
        'map',
        function (v) {
          return __spreadArray([], __read(v.entries()));
        },
        function (v) {
          return new Map(v);
        }
      ),
      simpleTransformation(
        function (v) {
          return is_1.isNaNValue(v) || is_1.isInfinite(v);
        },
        'number',
        function (v) {
          if (is_1.isNaNValue(v)) {
            return 'NaN';
          }
          if (v > 0) {
            return 'Infinity';
          } else {
            return '-Infinity';
          }
        },
        Number
      ),
      simpleTransformation(
        function (v) {
          return v === 0 && 1 / v === -Infinity;
        },
        'number',
        function () {
          return '-0';
        },
        Number
      ),
      simpleTransformation(
        is_1.isURL,
        'URL',
        function (v) {
          return v.toString();
        },
        function (v) {
          return new URL(v);
        }
      ),
    ];
    function compositeTransformation(isApplicable, annotation, transform, untransform) {
      return {
        isApplicable,
        annotation,
        transform,
        untransform,
      };
    }
    var symbolRule = compositeTransformation(
      function (s, superJson) {
        if (is_1.isSymbol(s)) {
          var isRegistered = !!superJson.symbolRegistry.getIdentifier(s);
          return isRegistered;
        }
        return false;
      },
      function (s, superJson) {
        var identifier = superJson.symbolRegistry.getIdentifier(s);
        return ['symbol', identifier];
      },
      function (v) {
        return v.description;
      },
      function (_, a, superJson) {
        var value = superJson.symbolRegistry.getValue(a[1]);
        if (!value) {
          throw new Error('Trying to deserialize unknown symbol');
        }
        return value;
      }
    );
    var constructorToName = [
      Int8Array,
      Uint8Array,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array,
      Uint8ClampedArray,
    ].reduce(function (obj, ctor) {
      obj[ctor.name] = ctor;
      return obj;
    }, {});
    var typedArrayRule = compositeTransformation(
      is_1.isTypedArray,
      function (v) {
        return ['typed-array', v.constructor.name];
      },
      function (v) {
        return __spreadArray([], __read(v));
      },
      function (v, a) {
        var ctor = constructorToName[a[1]];
        if (!ctor) {
          throw new Error('Trying to deserialize unknown typed array');
        }
        return new ctor(v);
      }
    );
    function isInstanceOfRegisteredClass(potentialClass, superJson) {
      if (
        potentialClass === null || potentialClass === void 0 ? void 0 : potentialClass.constructor
      ) {
        var isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);
        return isRegistered;
      }
      return false;
    }
    exports.isInstanceOfRegisteredClass = isInstanceOfRegisteredClass;
    var classRule = compositeTransformation(
      isInstanceOfRegisteredClass,
      function (clazz, superJson) {
        var identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
        return ['class', identifier];
      },
      function (clazz, superJson) {
        var allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
        if (!allowedProps) {
          return __assign({}, clazz);
        }
        var result = {};
        allowedProps.forEach(function (prop2) {
          result[prop2] = clazz[prop2];
        });
        return result;
      },
      function (v, a, superJson) {
        var clazz = superJson.classRegistry.getValue(a[1]);
        if (!clazz) {
          throw new Error(
            'Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564'
          );
        }
        return Object.assign(Object.create(clazz.prototype), v);
      }
    );
    var customRule = compositeTransformation(
      function (value, superJson) {
        return !!superJson.customTransformerRegistry.findApplicable(value);
      },
      function (value, superJson) {
        var transformer = superJson.customTransformerRegistry.findApplicable(value);
        return ['custom', transformer.name];
      },
      function (value, superJson) {
        var transformer = superJson.customTransformerRegistry.findApplicable(value);
        return transformer.serialize(value);
      },
      function (v, a, superJson) {
        var transformer = superJson.customTransformerRegistry.findByName(a[1]);
        if (!transformer) {
          throw new Error('Trying to deserialize unknown custom value');
        }
        return transformer.deserialize(v);
      }
    );
    var compositeRules = [classRule, symbolRule, customRule, typedArrayRule];
    var transformValue = function (value, superJson) {
      var applicableCompositeRule = util_1.findArr(compositeRules, function (rule) {
        return rule.isApplicable(value, superJson);
      });
      if (applicableCompositeRule) {
        return {
          value: applicableCompositeRule.transform(value, superJson),
          type: applicableCompositeRule.annotation(value, superJson),
        };
      }
      var applicableSimpleRule = util_1.findArr(simpleRules, function (rule) {
        return rule.isApplicable(value, superJson);
      });
      if (applicableSimpleRule) {
        return {
          value: applicableSimpleRule.transform(value, superJson),
          type: applicableSimpleRule.annotation,
        };
      }
      return void 0;
    };
    exports.transformValue = transformValue;
    var simpleRulesByAnnotation = {};
    simpleRules.forEach(function (rule) {
      simpleRulesByAnnotation[rule.annotation] = rule;
    });
    var untransformValue = function (json, type, superJson) {
      if (is_1.isArray(type)) {
        switch (type[0]) {
          case 'symbol':
            return symbolRule.untransform(json, type, superJson);
          case 'class':
            return classRule.untransform(json, type, superJson);
          case 'custom':
            return customRule.untransform(json, type, superJson);
          case 'typed-array':
            return typedArrayRule.untransform(json, type, superJson);
          default:
            throw new Error('Unknown transformation: ' + type);
        }
      } else {
        var transformation = simpleRulesByAnnotation[type];
        if (!transformation) {
          throw new Error('Unknown transformation: ' + type);
        }
        return transformation.untransform(json, superJson);
      }
    };
    exports.untransformValue = untransformValue;
  },
});

// node_modules/superjson/dist/accessDeep.js
var require_accessDeep = __commonJS({
  'node_modules/superjson/dist/accessDeep.js'(exports) {
    'use strict';
    exports.__esModule = true;
    exports.setDeep = exports.getDeep = void 0;
    var is_1 = require_is();
    var util_1 = require_util();
    var getNthKey = function (value, n) {
      var keys = value.keys();
      while (n > 0) {
        keys.next();
        n--;
      }
      return keys.next().value;
    };
    function validatePath(path5) {
      if (util_1.includes(path5, '__proto__')) {
        throw new Error('__proto__ is not allowed as a property');
      }
      if (util_1.includes(path5, 'prototype')) {
        throw new Error('prototype is not allowed as a property');
      }
      if (util_1.includes(path5, 'constructor')) {
        throw new Error('constructor is not allowed as a property');
      }
    }
    var getDeep = function (object, path5) {
      validatePath(path5);
      for (var i = 0; i < path5.length; i++) {
        var key2 = path5[i];
        if (is_1.isSet(object)) {
          object = getNthKey(object, +key2);
        } else if (is_1.isMap(object)) {
          var row = +key2;
          var type = +path5[++i] === 0 ? 'key' : 'value';
          var keyOfRow = getNthKey(object, row);
          switch (type) {
            case 'key':
              object = keyOfRow;
              break;
            case 'value':
              object = object.get(keyOfRow);
              break;
          }
        } else {
          object = object[key2];
        }
      }
      return object;
    };
    exports.getDeep = getDeep;
    var setDeep = function (object, path5, mapper) {
      validatePath(path5);
      if (path5.length === 0) {
        return mapper(object);
      }
      var parent = object;
      for (var i = 0; i < path5.length - 1; i++) {
        var key2 = path5[i];
        if (is_1.isArray(parent)) {
          var index2 = +key2;
          parent = parent[index2];
        } else if (is_1.isPlainObject(parent)) {
          parent = parent[key2];
        } else if (is_1.isSet(parent)) {
          var row = +key2;
          parent = getNthKey(parent, row);
        } else if (is_1.isMap(parent)) {
          var isEnd = i === path5.length - 2;
          if (isEnd) {
            break;
          }
          var row = +key2;
          var type = +path5[++i] === 0 ? 'key' : 'value';
          var keyOfRow = getNthKey(parent, row);
          switch (type) {
            case 'key':
              parent = keyOfRow;
              break;
            case 'value':
              parent = parent.get(keyOfRow);
              break;
          }
        }
      }
      var lastKey = path5[path5.length - 1];
      if (is_1.isArray(parent)) {
        parent[+lastKey] = mapper(parent[+lastKey]);
      } else if (is_1.isPlainObject(parent)) {
        parent[lastKey] = mapper(parent[lastKey]);
      }
      if (is_1.isSet(parent)) {
        var oldValue = getNthKey(parent, +lastKey);
        var newValue = mapper(oldValue);
        if (oldValue !== newValue) {
          parent['delete'](oldValue);
          parent.add(newValue);
        }
      }
      if (is_1.isMap(parent)) {
        var row = +path5[path5.length - 2];
        var keyToRow = getNthKey(parent, row);
        var type = +lastKey === 0 ? 'key' : 'value';
        switch (type) {
          case 'key': {
            var newKey = mapper(keyToRow);
            parent.set(newKey, parent.get(keyToRow));
            if (newKey !== keyToRow) {
              parent['delete'](keyToRow);
            }
            break;
          }
          case 'value': {
            parent.set(keyToRow, mapper(parent.get(keyToRow)));
            break;
          }
        }
      }
      return object;
    };
    exports.setDeep = setDeep;
  },
});

// node_modules/superjson/dist/plainer.js
var require_plainer = __commonJS({
  'node_modules/superjson/dist/plainer.js'(exports) {
    'use strict';
    var __read =
      (exports && exports.__read) ||
      function (o, n) {
        var m = typeof Symbol === 'function' && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o),
          r,
          ar = [],
          e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i['return'])) m.call(i);
          } finally {
            if (e) throw e.error;
          }
        }
        return ar;
      };
    var __spreadArray =
      (exports && exports.__spreadArray) ||
      function (to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
        return to;
      };
    exports.__esModule = true;
    exports.walker =
      exports.generateReferentialEqualityAnnotations =
      exports.applyReferentialEqualityAnnotations =
      exports.applyValueAnnotations =
        void 0;
    var is_1 = require_is();
    var pathstringifier_1 = require_pathstringifier();
    var transformer_1 = require_transformer();
    var util_1 = require_util();
    var pathstringifier_2 = require_pathstringifier();
    var accessDeep_1 = require_accessDeep();
    function traverse(tree, walker2, origin2) {
      if (origin2 === void 0) {
        origin2 = [];
      }
      if (!tree) {
        return;
      }
      if (!is_1.isArray(tree)) {
        util_1.forEach(tree, function (subtree, key2) {
          return traverse(
            subtree,
            walker2,
            __spreadArray(
              __spreadArray([], __read(origin2)),
              __read(pathstringifier_2.parsePath(key2))
            )
          );
        });
        return;
      }
      var _a3 = __read(tree, 2),
        nodeValue = _a3[0],
        children = _a3[1];
      if (children) {
        util_1.forEach(children, function (child2, key2) {
          traverse(
            child2,
            walker2,
            __spreadArray(
              __spreadArray([], __read(origin2)),
              __read(pathstringifier_2.parsePath(key2))
            )
          );
        });
      }
      walker2(nodeValue, origin2);
    }
    function applyValueAnnotations(plain, annotations, superJson) {
      traverse(annotations, function (type, path5) {
        plain = accessDeep_1.setDeep(plain, path5, function (v) {
          return transformer_1.untransformValue(v, type, superJson);
        });
      });
      return plain;
    }
    exports.applyValueAnnotations = applyValueAnnotations;
    function applyReferentialEqualityAnnotations(plain, annotations) {
      function apply2(identicalPaths, path5) {
        var object = accessDeep_1.getDeep(plain, pathstringifier_2.parsePath(path5));
        identicalPaths.map(pathstringifier_2.parsePath).forEach(function (identicalObjectPath) {
          plain = accessDeep_1.setDeep(plain, identicalObjectPath, function () {
            return object;
          });
        });
      }
      if (is_1.isArray(annotations)) {
        var _a3 = __read(annotations, 2),
          root = _a3[0],
          other = _a3[1];
        root.forEach(function (identicalPath) {
          plain = accessDeep_1.setDeep(
            plain,
            pathstringifier_2.parsePath(identicalPath),
            function () {
              return plain;
            }
          );
        });
        if (other) {
          util_1.forEach(other, apply2);
        }
      } else {
        util_1.forEach(annotations, apply2);
      }
      return plain;
    }
    exports.applyReferentialEqualityAnnotations = applyReferentialEqualityAnnotations;
    var isDeep = function (object, superJson) {
      return (
        is_1.isPlainObject(object) ||
        is_1.isArray(object) ||
        is_1.isMap(object) ||
        is_1.isSet(object) ||
        transformer_1.isInstanceOfRegisteredClass(object, superJson)
      );
    };
    function addIdentity(object, path5, identities) {
      var existingSet = identities.get(object);
      if (existingSet) {
        existingSet.push(path5);
      } else {
        identities.set(object, [path5]);
      }
    }
    function generateReferentialEqualityAnnotations(identitites, dedupe) {
      var result = {};
      var rootEqualityPaths = void 0;
      identitites.forEach(function (paths) {
        if (paths.length <= 1) {
          return;
        }
        if (!dedupe) {
          paths = paths
            .map(function (path5) {
              return path5.map(String);
            })
            .sort(function (a, b) {
              return a.length - b.length;
            });
        }
        var _a3 = __read(paths),
          representativePath = _a3[0],
          identicalPaths = _a3.slice(1);
        if (representativePath.length === 0) {
          rootEqualityPaths = identicalPaths.map(pathstringifier_1.stringifyPath);
        } else {
          result[pathstringifier_1.stringifyPath(representativePath)] = identicalPaths.map(
            pathstringifier_1.stringifyPath
          );
        }
      });
      if (rootEqualityPaths) {
        if (is_1.isEmptyObject(result)) {
          return [rootEqualityPaths];
        } else {
          return [rootEqualityPaths, result];
        }
      } else {
        return is_1.isEmptyObject(result) ? void 0 : result;
      }
    }
    exports.generateReferentialEqualityAnnotations = generateReferentialEqualityAnnotations;
    var walker = function (
      object,
      identities,
      superJson,
      dedupe,
      path5,
      objectsInThisPath,
      seenObjects
    ) {
      var _a3;
      if (path5 === void 0) {
        path5 = [];
      }
      if (objectsInThisPath === void 0) {
        objectsInThisPath = [];
      }
      if (seenObjects === void 0) {
        seenObjects = /* @__PURE__ */ new Map();
      }
      var primitive = is_1.isPrimitive(object);
      if (!primitive) {
        addIdentity(object, path5, identities);
        var seen = seenObjects.get(object);
        if (seen) {
          return dedupe
            ? {
                transformedValue: null,
              }
            : seen;
        }
      }
      if (!isDeep(object, superJson)) {
        var transformed_1 = transformer_1.transformValue(object, superJson);
        var result_1 = transformed_1
          ? {
              transformedValue: transformed_1.value,
              annotations: [transformed_1.type],
            }
          : {
              transformedValue: object,
            };
        if (!primitive) {
          seenObjects.set(object, result_1);
        }
        return result_1;
      }
      if (util_1.includes(objectsInThisPath, object)) {
        return {
          transformedValue: null,
        };
      }
      var transformationResult = transformer_1.transformValue(object, superJson);
      var transformed =
        (_a3 =
          transformationResult === null || transformationResult === void 0
            ? void 0
            : transformationResult.value) !== null && _a3 !== void 0
          ? _a3
          : object;
      var transformedValue = is_1.isArray(transformed) ? [] : {};
      var innerAnnotations = {};
      util_1.forEach(transformed, function (value, index2) {
        var recursiveResult = exports.walker(
          value,
          identities,
          superJson,
          dedupe,
          __spreadArray(__spreadArray([], __read(path5)), [index2]),
          __spreadArray(__spreadArray([], __read(objectsInThisPath)), [object]),
          seenObjects
        );
        transformedValue[index2] = recursiveResult.transformedValue;
        if (is_1.isArray(recursiveResult.annotations)) {
          innerAnnotations[index2] = recursiveResult.annotations;
        } else if (is_1.isPlainObject(recursiveResult.annotations)) {
          util_1.forEach(recursiveResult.annotations, function (tree, key2) {
            innerAnnotations[pathstringifier_1.escapeKey(index2) + '.' + key2] = tree;
          });
        }
      });
      var result = is_1.isEmptyObject(innerAnnotations)
        ? {
            transformedValue,
            annotations: !!transformationResult ? [transformationResult.type] : void 0,
          }
        : {
            transformedValue,
            annotations: !!transformationResult
              ? [transformationResult.type, innerAnnotations]
              : innerAnnotations,
          };
      if (!primitive) {
        seenObjects.set(object, result);
      }
      return result;
    };
    exports.walker = walker;
  },
});

// node_modules/is-what/dist/cjs/index.cjs
var require_cjs = __commonJS({
  'node_modules/is-what/dist/cjs/index.cjs'(exports) {
    'use strict';
    function getType(payload) {
      return Object.prototype.toString.call(payload).slice(8, -1);
    }
    function isAnyObject(payload) {
      return getType(payload) === 'Object';
    }
    function isArray4(payload) {
      return getType(payload) === 'Array';
    }
    function isBlob2(payload) {
      return getType(payload) === 'Blob';
    }
    function isBoolean2(payload) {
      return getType(payload) === 'Boolean';
    }
    function isDate2(payload) {
      return getType(payload) === 'Date' && !isNaN(payload);
    }
    function isEmptyArray(payload) {
      return isArray4(payload) && payload.length === 0;
    }
    function isPlainObject2(payload) {
      if (getType(payload) !== 'Object') return false;
      const prototype3 = Object.getPrototypeOf(payload);
      return !!prototype3 && prototype3.constructor === Object && prototype3 === Object.prototype;
    }
    function isEmptyObject2(payload) {
      return isPlainObject2(payload) && Object.keys(payload).length === 0;
    }
    function isEmptyString(payload) {
      return payload === '';
    }
    function isError(payload) {
      return getType(payload) === 'Error' || payload instanceof Error;
    }
    function isFile2(payload) {
      return getType(payload) === 'File';
    }
    function isFullArray(payload) {
      return isArray4(payload) && payload.length > 0;
    }
    function isFullObject(payload) {
      return isPlainObject2(payload) && Object.keys(payload).length > 0;
    }
    function isString2(payload) {
      return getType(payload) === 'String';
    }
    function isFullString(payload) {
      return isString2(payload) && payload !== '';
    }
    function isFunction3(payload) {
      return typeof payload === 'function';
    }
    function isType(payload, type) {
      if (!(type instanceof Function)) {
        throw new TypeError('Type must be a function');
      }
      if (!Object.prototype.hasOwnProperty.call(type, 'prototype')) {
        throw new TypeError('Type is not a class');
      }
      const name3 = type.name;
      return getType(payload) === name3 || Boolean(payload && payload.constructor === type);
    }
    function isInstanceOf(value, classOrClassName) {
      if (typeof classOrClassName === 'function') {
        for (let p = value; p; p = Object.getPrototypeOf(p)) {
          if (isType(p, classOrClassName)) {
            return true;
          }
        }
        return false;
      } else {
        for (let p = value; p; p = Object.getPrototypeOf(p)) {
          if (getType(p) === classOrClassName) {
            return true;
          }
        }
        return false;
      }
    }
    function isMap(payload) {
      return getType(payload) === 'Map';
    }
    function isNaNValue(payload) {
      return getType(payload) === 'Number' && isNaN(payload);
    }
    function isNumber2(payload) {
      return getType(payload) === 'Number' && !isNaN(payload);
    }
    function isNegativeNumber(payload) {
      return isNumber2(payload) && payload < 0;
    }
    function isNull(payload) {
      return getType(payload) === 'Null';
    }
    function isOneOf(a, b, c, d, e) {
      return (value) =>
        a(value) || b(value) || (!!c && c(value)) || (!!d && d(value)) || (!!e && e(value));
    }
    function isUndefined2(payload) {
      return getType(payload) === 'Undefined';
    }
    var isNullOrUndefined = isOneOf(isNull, isUndefined2);
    function isObject2(payload) {
      return isPlainObject2(payload);
    }
    function isObjectLike(payload) {
      return isAnyObject(payload);
    }
    function isPositiveNumber(payload) {
      return isNumber2(payload) && payload > 0;
    }
    function isSymbol(payload) {
      return getType(payload) === 'Symbol';
    }
    function isPrimitive(payload) {
      return (
        isBoolean2(payload) ||
        isNull(payload) ||
        isUndefined2(payload) ||
        isNumber2(payload) ||
        isString2(payload) ||
        isSymbol(payload)
      );
    }
    function isPromise(payload) {
      return getType(payload) === 'Promise';
    }
    function isRegExp2(payload) {
      return getType(payload) === 'RegExp';
    }
    function isSet(payload) {
      return getType(payload) === 'Set';
    }
    function isWeakMap(payload) {
      return getType(payload) === 'WeakMap';
    }
    function isWeakSet(payload) {
      return getType(payload) === 'WeakSet';
    }
    exports.getType = getType;
    exports.isAnyObject = isAnyObject;
    exports.isArray = isArray4;
    exports.isBlob = isBlob2;
    exports.isBoolean = isBoolean2;
    exports.isDate = isDate2;
    exports.isEmptyArray = isEmptyArray;
    exports.isEmptyObject = isEmptyObject2;
    exports.isEmptyString = isEmptyString;
    exports.isError = isError;
    exports.isFile = isFile2;
    exports.isFullArray = isFullArray;
    exports.isFullObject = isFullObject;
    exports.isFullString = isFullString;
    exports.isFunction = isFunction3;
    exports.isInstanceOf = isInstanceOf;
    exports.isMap = isMap;
    exports.isNaNValue = isNaNValue;
    exports.isNegativeNumber = isNegativeNumber;
    exports.isNull = isNull;
    exports.isNullOrUndefined = isNullOrUndefined;
    exports.isNumber = isNumber2;
    exports.isObject = isObject2;
    exports.isObjectLike = isObjectLike;
    exports.isOneOf = isOneOf;
    exports.isPlainObject = isPlainObject2;
    exports.isPositiveNumber = isPositiveNumber;
    exports.isPrimitive = isPrimitive;
    exports.isPromise = isPromise;
    exports.isRegExp = isRegExp2;
    exports.isSet = isSet;
    exports.isString = isString2;
    exports.isSymbol = isSymbol;
    exports.isType = isType;
    exports.isUndefined = isUndefined2;
    exports.isWeakMap = isWeakMap;
    exports.isWeakSet = isWeakSet;
  },
});

// node_modules/copy-anything/dist/cjs/index.cjs
var require_cjs2 = __commonJS({
  'node_modules/copy-anything/dist/cjs/index.cjs'(exports) {
    'use strict';
    var isWhat = require_cjs();
    function assignProp(carry, key2, newVal, originalObject, includeNonenumerable) {
      const propType = {}.propertyIsEnumerable.call(originalObject, key2)
        ? 'enumerable'
        : 'nonenumerable';
      if (propType === 'enumerable') carry[key2] = newVal;
      if (includeNonenumerable && propType === 'nonenumerable') {
        Object.defineProperty(carry, key2, {
          value: newVal,
          enumerable: false,
          writable: true,
          configurable: true,
        });
      }
    }
    function copy(target, options = {}) {
      if (isWhat.isArray(target)) {
        return target.map((item) => copy(item, options));
      }
      if (!isWhat.isPlainObject(target)) {
        return target;
      }
      const props = Object.getOwnPropertyNames(target);
      const symbols = Object.getOwnPropertySymbols(target);
      return [...props, ...symbols].reduce((carry, key2) => {
        if (isWhat.isArray(options.props) && !options.props.includes(key2)) {
          return carry;
        }
        const val = target[key2];
        const newVal = copy(val, options);
        assignProp(carry, key2, newVal, target, options.nonenumerable);
        return carry;
      }, {});
    }
    exports.copy = copy;
  },
});

// node_modules/superjson/dist/index.js
var require_dist2 = __commonJS({
  'node_modules/superjson/dist/index.js'(exports) {
    'use strict';
    var __assign =
      (exports && exports.__assign) ||
      function () {
        __assign =
          Object.assign ||
          function (t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
          };
        return __assign.apply(this, arguments);
      };
    var __read =
      (exports && exports.__read) ||
      function (o, n) {
        var m = typeof Symbol === 'function' && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o),
          r,
          ar = [],
          e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i['return'])) m.call(i);
          } finally {
            if (e) throw e.error;
          }
        }
        return ar;
      };
    var __spreadArray =
      (exports && exports.__spreadArray) ||
      function (to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
        return to;
      };
    exports.__esModule = true;
    exports.allowErrorProps =
      exports.registerSymbol =
      exports.registerCustom =
      exports.registerClass =
      exports.parse =
      exports.stringify =
      exports.deserialize =
      exports.serialize =
      exports.SuperJSON =
        void 0;
    var class_registry_1 = require_class_registry();
    var registry_1 = require_registry();
    var custom_transformer_registry_1 = require_custom_transformer_registry();
    var plainer_1 = require_plainer();
    var copy_anything_1 = require_cjs2();
    var SuperJSON =
      /** @class */
      (function () {
        function SuperJSON2(_a3) {
          var _b = _a3 === void 0 ? {} : _a3,
            _c = _b.dedupe,
            dedupe = _c === void 0 ? false : _c;
          this.classRegistry = new class_registry_1.ClassRegistry();
          this.symbolRegistry = new registry_1.Registry(function (s) {
            var _a4;
            return (_a4 = s.description) !== null && _a4 !== void 0 ? _a4 : '';
          });
          this.customTransformerRegistry =
            new custom_transformer_registry_1.CustomTransformerRegistry();
          this.allowedErrorProps = [];
          this.dedupe = dedupe;
        }
        SuperJSON2.prototype.serialize = function (object) {
          var identities = /* @__PURE__ */ new Map();
          var output = plainer_1.walker(object, identities, this, this.dedupe);
          var res = {
            json: output.transformedValue,
          };
          if (output.annotations) {
            res.meta = __assign(__assign({}, res.meta), { values: output.annotations });
          }
          var equalityAnnotations = plainer_1.generateReferentialEqualityAnnotations(
            identities,
            this.dedupe
          );
          if (equalityAnnotations) {
            res.meta = __assign(__assign({}, res.meta), {
              referentialEqualities: equalityAnnotations,
            });
          }
          return res;
        };
        SuperJSON2.prototype.deserialize = function (payload) {
          var json = payload.json,
            meta = payload.meta;
          var result = copy_anything_1.copy(json);
          if (meta === null || meta === void 0 ? void 0 : meta.values) {
            result = plainer_1.applyValueAnnotations(result, meta.values, this);
          }
          if (meta === null || meta === void 0 ? void 0 : meta.referentialEqualities) {
            result = plainer_1.applyReferentialEqualityAnnotations(
              result,
              meta.referentialEqualities
            );
          }
          return result;
        };
        SuperJSON2.prototype.stringify = function (object) {
          return JSON.stringify(this.serialize(object));
        };
        SuperJSON2.prototype.parse = function (string) {
          return this.deserialize(JSON.parse(string));
        };
        SuperJSON2.prototype.registerClass = function (v, options) {
          this.classRegistry.register(v, options);
        };
        SuperJSON2.prototype.registerSymbol = function (v, identifier) {
          this.symbolRegistry.register(v, identifier);
        };
        SuperJSON2.prototype.registerCustom = function (transformer, name3) {
          this.customTransformerRegistry.register(__assign({ name: name3 }, transformer));
        };
        SuperJSON2.prototype.allowErrorProps = function () {
          var _a3;
          var props = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            props[_i] = arguments[_i];
          }
          (_a3 = this.allowedErrorProps).push.apply(_a3, __spreadArray([], __read(props)));
        };
        SuperJSON2.defaultInstance = new SuperJSON2();
        SuperJSON2.serialize = SuperJSON2.defaultInstance.serialize.bind(
          SuperJSON2.defaultInstance
        );
        SuperJSON2.deserialize = SuperJSON2.defaultInstance.deserialize.bind(
          SuperJSON2.defaultInstance
        );
        SuperJSON2.stringify = SuperJSON2.defaultInstance.stringify.bind(
          SuperJSON2.defaultInstance
        );
        SuperJSON2.parse = SuperJSON2.defaultInstance.parse.bind(SuperJSON2.defaultInstance);
        SuperJSON2.registerClass = SuperJSON2.defaultInstance.registerClass.bind(
          SuperJSON2.defaultInstance
        );
        SuperJSON2.registerSymbol = SuperJSON2.defaultInstance.registerSymbol.bind(
          SuperJSON2.defaultInstance
        );
        SuperJSON2.registerCustom = SuperJSON2.defaultInstance.registerCustom.bind(
          SuperJSON2.defaultInstance
        );
        SuperJSON2.allowErrorProps = SuperJSON2.defaultInstance.allowErrorProps.bind(
          SuperJSON2.defaultInstance
        );
        return SuperJSON2;
      })();
    exports.SuperJSON = SuperJSON;
    exports['default'] = SuperJSON;
    exports.serialize = SuperJSON.serialize;
    exports.deserialize = SuperJSON.deserialize;
    exports.stringify = SuperJSON.stringify;
    exports.parse = SuperJSON.parse;
    exports.registerClass = SuperJSON.registerClass;
    exports.registerCustom = SuperJSON.registerCustom;
    exports.registerSymbol = SuperJSON.registerSymbol;
    exports.allowErrorProps = SuperJSON.allowErrorProps;
  },
});

// node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/rng.js
import crypto3 from 'crypto';
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto3.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, (poolPtr += 16));
}
var rnds8Pool, poolPtr;
var init_rng = __esm({
  'node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/rng.js'() {
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  },
});

// node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  'node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/regex.js'() {
    regex_default =
      /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  },
});

// node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid === 'string' && regex_default.test(uuid);
}
var validate_default;
var init_validate3 = __esm({
  'node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/validate.js'() {
    init_regex();
    validate_default = validate;
  },
});

// node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/stringify.js
function unsafeStringify(arr, offset = 0) {
  return (
    byteToHex[arr[offset + 0]] +
    byteToHex[arr[offset + 1]] +
    byteToHex[arr[offset + 2]] +
    byteToHex[arr[offset + 3]] +
    '-' +
    byteToHex[arr[offset + 4]] +
    byteToHex[arr[offset + 5]] +
    '-' +
    byteToHex[arr[offset + 6]] +
    byteToHex[arr[offset + 7]] +
    '-' +
    byteToHex[arr[offset + 8]] +
    byteToHex[arr[offset + 9]] +
    '-' +
    byteToHex[arr[offset + 10]] +
    byteToHex[arr[offset + 11]] +
    byteToHex[arr[offset + 12]] +
    byteToHex[arr[offset + 13]] +
    byteToHex[arr[offset + 14]] +
    byteToHex[arr[offset + 15]]
  );
}
function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset);
  if (!validate_default(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  'node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/stringify.js'() {
    init_validate3();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    stringify_default = stringify;
  },
});

// node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  let i = (buf && offset) || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [
        seedBytes[0] | 1,
        seedBytes[1],
        seedBytes[2],
        seedBytes[3],
        seedBytes[4],
        seedBytes[5],
      ];
    }
    if (clockseq == null) {
      clockseq = _clockseq = ((seedBytes[6] << 8) | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = (clockseq + 1) & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = (tl >>> 24) & 255;
  b[i++] = (tl >>> 16) & 255;
  b[i++] = (tl >>> 8) & 255;
  b[i++] = tl & 255;
  const tmh = ((msecs / 4294967296) * 1e4) & 268435455;
  b[i++] = (tmh >>> 8) & 255;
  b[i++] = tmh & 255;
  b[i++] = ((tmh >>> 24) & 15) | 16;
  b[i++] = (tmh >>> 16) & 255;
  b[i++] = (clockseq >>> 8) | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || unsafeStringify(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  'node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/v1.js'() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  },
});

// node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError('Invalid UUID');
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = (v >>> 16) & 255;
  arr[2] = (v >>> 8) & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = ((v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776) & 255;
  arr[11] = (v / 4294967296) & 255;
  arr[12] = (v >>> 24) & 255;
  arr[13] = (v >>> 16) & 255;
  arr[14] = (v >>> 8) & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  'node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/parse.js'() {
    init_validate3();
    parse_default = parse;
  },
});

// node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str2) {
  str2 = unescape(encodeURIComponent(str2));
  const bytes = [];
  for (let i = 0; i < str2.length; ++i) {
    bytes.push(str2.charCodeAt(i));
  }
  return bytes;
}
function v35(name3, version4, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }
    if (typeof namespace === 'string') {
      namespace = parse_default(namespace);
    }
    if (
      ((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !==
      16
    ) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = (bytes[6] & 15) | version4;
    bytes[8] = (bytes[8] & 63) | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name3;
  } catch (err) {}
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  'node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/v35.js'() {
    init_stringify();
    init_parse();
    DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
    URL2 = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
  },
});

// node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/md5.js
import crypto4 from 'crypto';
function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }
  return crypto4.createHash('md5').update(bytes).digest();
}
var md5_default;
var init_md5 = __esm({
  'node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/md5.js'() {
    md5_default = md5;
  },
});

// node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/v3.js
var v3, v3_default;
var init_v3 = __esm({
  'node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/v3.js'() {
    init_v35();
    init_md5();
    v3 = v35('v3', 48, md5_default);
    v3_default = v3;
  },
});

// node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/native.js
import crypto5 from 'crypto';
var native_default;
var init_native = __esm({
  'node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/native.js'() {
    native_default = {
      randomUUID: crypto5.randomUUID,
    };
  },
});

// node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = (rnds[6] & 15) | 64;
  rnds[8] = (rnds[8] & 63) | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default;
var init_v4 = __esm({
  'node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/v4.js'() {
    init_native();
    init_rng();
    init_stringify();
    v4_default = v4;
  },
});

// node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/sha1.js
import crypto6 from 'crypto';
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }
  return crypto6.createHash('sha1').update(bytes).digest();
}
var sha1_default;
var init_sha1 = __esm({
  'node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/sha1.js'() {
    sha1_default = sha1;
  },
});

// node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esm({
  'node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/v5.js'() {
    init_v35();
    init_sha1();
    v5 = v35('v5', 80, sha1_default);
    v5_default = v5;
  },
});

// node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/nil.js
var nil_default;
var init_nil = __esm({
  'node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/nil.js'() {
    nil_default = '00000000-0000-0000-0000-000000000000';
  },
});

// node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError('Invalid UUID');
  }
  return parseInt(uuid.slice(14, 15), 16);
}
var version_default;
var init_version = __esm({
  'node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/version.js'() {
    init_validate3();
    version_default = version;
  },
});

// node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/index.js
var esm_node_exports = {};
__export(esm_node_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default,
});
var init_esm_node = __esm({
  'node_modules/@statelyai/inspect/node_modules/uuid/dist/esm-node/index.js'() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate3();
    init_stringify();
    init_parse();
  },
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  'node_modules/ws/lib/constants.js'(exports, module) {
    'use strict';
    var BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];
    var hasBlob = typeof Blob !== 'undefined';
    if (hasBlob) BINARY_TYPES.push('blob');
    module.exports = {
      BINARY_TYPES,
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
      hasBlob,
      kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
      kListener: Symbol('kListener'),
      kStatusCode: Symbol('status-code'),
      kWebSocket: Symbol('websocket'),
      NOOP: () => {},
    };
  },
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  'node_modules/ws/lib/buffer-util.js'(exports, module) {
    'use strict';
    var { EMPTY_BUFFER } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source2, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source2[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data)) return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask,
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = __require('bufferutil');
        module.exports.mask = function (source2, mask, output, offset, length) {
          if (length < 48) _mask(source2, mask, output, offset, length);
          else bufferUtil.mask(source2, mask, output, offset, length);
        };
        module.exports.unmask = function (buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {}
    }
  },
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  'node_modules/ws/lib/limiter.js'(exports, module) {
    'use strict';
    var kDone = Symbol('kDone');
    var kRun = Symbol('kRun');
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module.exports = Limiter;
  },
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  'node_modules/ws/lib/permessage-deflate.js'(exports, module) {
    'use strict';
    var zlib2 = __require('zlib');
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol('permessage-deflate');
    var kTotalLength = Symbol('total-length');
    var kCallback = Symbol('callback');
    var kBuffers = Symbol('buffers');
    var kError = Symbol('error');
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency =
            this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return 'permessage-deflate';
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer
          ? this.acceptAsServer(configurations)
          : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(new Error('The deflate stream was closed while data was being processed'));
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (
            (opts.serverNoContextTakeover === false && params.server_no_context_takeover) ||
            (params.server_max_window_bits &&
              (opts.serverMaxWindowBits === false ||
                (typeof opts.serverMaxWindowBits === 'number' &&
                  opts.serverMaxWindowBits > params.server_max_window_bits))) ||
            (typeof opts.clientMaxWindowBits === 'number' && !params.client_max_window_bits)
          ) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error('None of the extension offers can be accepted');
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === 'number') {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === 'number') {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === 'number') {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (
          this._options.clientMaxWindowBits === false ||
          (typeof this._options.clientMaxWindowBits === 'number' &&
            params.client_max_window_bits > this._options.clientMaxWindowBits)
        ) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key2) => {
            let value = params[key2];
            if (value.length > 1) {
              throw new Error(`Parameter "${key2}" must have only a single value`);
            }
            value = value[0];
            if (key2 === 'client_max_window_bits') {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key2}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key2}": ${value}`);
              }
            } else if (key2 === 'server_max_window_bits') {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key2}": ${value}`);
              }
              value = num;
            } else if (
              key2 === 'client_no_context_takeover' ||
              key2 === 'server_no_context_takeover'
            ) {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key2}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key2}"`);
            }
            params[key2] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? 'client' : 'server';
        if (!this._inflate) {
          const key2 = `${endpoint}_max_window_bits`;
          const windowBits =
            typeof this.params[key2] !== 'number' ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key2];
          this._inflate = zlib2.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits,
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on('error', inflateOnError);
          this._inflate.on('data', inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? 'server' : 'client';
        if (!this._deflate) {
          const key2 = `${endpoint}_max_window_bits`;
          const windowBits =
            typeof this.params[key2] !== 'number' ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key2];
          this._deflate = zlib2.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits,
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on('data', deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib2.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (
        this[kPerMessageDeflate]._maxPayload < 1 ||
        this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
      ) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError('Max payload size exceeded');
      this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
      this[kError][kStatusCode] = 1009;
      this.removeListener('data', inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      if (this[kError]) {
        this[kCallback](this[kError]);
        return;
      }
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  },
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  'node_modules/ws/lib/validation.js'(exports, module) {
    'use strict';
    var { isUtf8 } = __require('buffer');
    var { hasBlob } = require_constants();
    var tokenChars = [
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      // 0 - 15
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      // 16 - 31
      0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,
      // 32 - 47
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
      // 48 - 63
      0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      // 64 - 79
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,
      // 80 - 95
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      // 96 - 111
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0,
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return (
        (code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006) ||
        (code >= 3e3 && code <= 4999)
      );
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (
            i + 2 >= len ||
            (buf[i + 1] & 192) !== 128 ||
            (buf[i + 2] & 192) !== 128 ||
            (buf[i] === 224 && (buf[i + 1] & 224) === 128) || // Overlong
            (buf[i] === 237 && (buf[i + 1] & 224) === 160)
          ) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (
            i + 3 >= len ||
            (buf[i + 1] & 192) !== 128 ||
            (buf[i + 2] & 192) !== 128 ||
            (buf[i + 3] & 192) !== 128 ||
            (buf[i] === 240 && (buf[i + 1] & 240) === 128) || // Overlong
            (buf[i] === 244 && buf[i + 1] > 143) ||
            buf[i] > 244
          ) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    function isBlob2(value) {
      return (
        hasBlob &&
        typeof value === 'object' &&
        typeof value.arrayBuffer === 'function' &&
        typeof value.type === 'string' &&
        typeof value.stream === 'function' &&
        (value[Symbol.toStringTag] === 'Blob' || value[Symbol.toStringTag] === 'File')
      );
    }
    module.exports = {
      isBlob: isBlob2,
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars,
    };
    if (isUtf8) {
      module.exports.isValidUTF8 = function (buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = __require('utf-8-validate');
        module.exports.isValidUTF8 = function (buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {}
    }
  },
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  'node_modules/ws/lib/receiver.js'(exports, module) {
    'use strict';
    var { Writable } = __require('stream');
    var PerMessageDeflate = require_permessage_deflate();
    var { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents =
          options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length) return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored) cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(
            RangeError,
            'RSV2 and RSV3 must be clear',
            true,
            1002,
            'WS_ERR_UNEXPECTED_RSV_2_3'
          );
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(
            RangeError,
            'RSV1 must be clear',
            true,
            1002,
            'WS_ERR_UNEXPECTED_RSV_1'
          );
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(
              RangeError,
              'RSV1 must be clear',
              true,
              1002,
              'WS_ERR_UNEXPECTED_RSV_1'
            );
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(
              RangeError,
              'invalid opcode 0',
              true,
              1002,
              'WS_ERR_INVALID_OPCODE'
            );
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              'WS_ERR_INVALID_OPCODE'
            );
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(
              RangeError,
              'FIN must be set',
              true,
              1002,
              'WS_ERR_EXPECTED_FIN'
            );
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(
              RangeError,
              'RSV1 must be clear',
              true,
              1002,
              'WS_ERR_UNEXPECTED_RSV_1'
            );
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || (this._opcode === 8 && this._payloadLength === 1)) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
            );
            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            'WS_ERR_INVALID_OPCODE'
          );
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(
              RangeError,
              'MASK must be set',
              true,
              1002,
              'WS_ERR_EXPECTED_MASK'
            );
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(
            RangeError,
            'MASK must be clear',
            true,
            1002,
            'WS_ERR_UNEXPECTED_MASK'
          );
          cb(error);
          return;
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            'Unsupported WebSocket frame: payload length > 2^53 - 1',
            false,
            1009,
            'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
          );
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              'Max payload size exceeded',
              false,
              1009,
              'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
            );
            cb(error);
            return;
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (
            this._masked &&
            (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
          ) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(
                RangeError,
                'Max payload size exceeded',
                false,
                1009,
                'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
              );
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO) this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === 'nodebuffer') {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === 'arraybuffer') {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else if (this._binaryType === 'blob') {
            data = new Blob(fragments);
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit('message', data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit('message', data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(
              Error,
              'invalid UTF-8 sequence',
              true,
              1007,
              'WS_ERR_INVALID_UTF8'
            );
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit('message', buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit('message', buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit('conclude', 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                'WS_ERR_INVALID_CLOSE_CODE'
              );
              cb(error);
              return;
            }
            const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(
                Error,
                'invalid UTF-8 sequence',
                true,
                1007,
                'WS_ERR_INVALID_UTF8'
              );
              cb(error);
              return;
            }
            this._loop = false;
            this.emit('conclude', code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? 'ping' : 'pong', data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? 'ping' : 'pong', data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module.exports = Receiver;
  },
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  'node_modules/ws/lib/sender.js'(exports, module) {
    'use strict';
    var { Duplex } = __require('stream');
    var { randomFillSync } = __require('crypto');
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants();
    var { isBlob: isBlob2, isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol('kByteLength');
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var DEFAULT = 0;
    var DEFLATING = 1;
    var GET_BLOB_DATA = 2;
    var Sender = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions3, generateMask) {
        this._extensions = extensions3 || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._queue = [];
        this._state = DEFAULT;
        this.onerror = NOOP;
        this[kWebSocket] = void 0;
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge2 = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === 'string') {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge2 = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge2 ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask) return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [target, data];
        if (merge2) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
          throw new TypeError('First argument must be a valid error code number');
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError('The message must not be greater than 123 bytes');
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === 'string') {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false,
        };
        if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === 'string') {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob2(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError('The data size must not be greater than 125 bytes');
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false,
        };
        if (isBlob2(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === 'string') {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob2(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError('The data size must not be greater than 125 bytes');
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false,
        };
        if (isBlob2(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === 'string') {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob2(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (
            rsv1 &&
            perMessageDeflate &&
            perMessageDeflate.params[
              perMessageDeflate._isServer
                ? 'server_no_context_takeover'
                : 'client_no_context_takeover'
            ]
          ) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1,
        };
        if (isBlob2(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
          } else {
            this.getBlobData(data, this._compress, opts, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      }
      /**
       * Gets the contents of a blob as binary data.
       *
       * @param {Blob} blob The blob
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     the data
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      getBlobData(blob, compress, options, cb) {
        this._bufferedBytes += options[kByteLength];
        this._state = GET_BLOB_DATA;
        blob
          .arrayBuffer()
          .then((arrayBuffer) => {
            if (this._socket.destroyed) {
              const err = new Error('The socket was closed while the blob was being read');
              process.nextTick(callCallbacks, this, err, cb);
              return;
            }
            this._bufferedBytes -= options[kByteLength];
            const data = toBuffer(arrayBuffer);
            if (!compress) {
              this._state = DEFAULT;
              this.sendFrame(_Sender.frame(data, options), cb);
              this.dequeue();
            } else {
              this.dispatch(data, compress, options, cb);
            }
          })
          .catch((err) => {
            process.nextTick(onError, this, err, cb);
          });
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._state = DEFLATING;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error('The socket was closed while data was being compressed');
            callCallbacks(this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._state = DEFAULT;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (this._state === DEFAULT && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {(Buffer | String)[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module.exports = Sender;
    function callCallbacks(sender, err, cb) {
      if (typeof cb === 'function') cb(err);
      for (let i = 0; i < sender._queue.length; i++) {
        const params = sender._queue[i];
        const callback = params[params.length - 1];
        if (typeof callback === 'function') callback(err);
      }
    }
    function onError(sender, err, cb) {
      callCallbacks(sender, err, cb);
      sender.onerror(err);
    }
  },
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  'node_modules/ws/lib/event-target.js'(exports, module) {
    'use strict';
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol('kCode');
    var kData = Symbol('kData');
    var kError = Symbol('kError');
    var kMessage = Symbol('kMessage');
    var kReason = Symbol('kReason');
    var kTarget = Symbol('kTarget');
    var kType = Symbol('kType');
    var kWasClean = Symbol('kWasClean');
    var Event2 = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event2.prototype, 'target', { enumerable: true });
    Object.defineProperty(Event2.prototype, 'type', { enumerable: true });
    var CloseEvent = class extends Event2 {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? '' : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });
    var ErrorEvent = class extends Event2 {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? '' : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });
    var MessageEvent2 = class extends Event2 {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent2.prototype, 'data', { enumerable: true });
    var EventTarget2 = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (
            !options[kForOnEventAttribute] &&
            listener[kListener] === handler &&
            !listener[kForOnEventAttribute]
          ) {
            return;
          }
        }
        let wrapper;
        if (type === 'message') {
          wrapper = function onMessage(data, isBinary) {
            const event2 = new MessageEvent2('message', {
              data: isBinary ? data : data.toString(),
            });
            event2[kTarget] = this;
            callListener(handler, this, event2);
          };
        } else if (type === 'close') {
          wrapper = function onClose(code, message) {
            const event2 = new CloseEvent('close', {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent,
            });
            event2[kTarget] = this;
            callListener(handler, this, event2);
          };
        } else if (type === 'error') {
          wrapper = function onError(error) {
            const event2 = new ErrorEvent('error', {
              error,
              message: error.message,
            });
            event2[kTarget] = this;
            callListener(handler, this, event2);
          };
        } else if (type === 'open') {
          wrapper = function onOpen() {
            const event2 = new Event2('open');
            event2[kTarget] = this;
            callListener(handler, this, event2);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      },
    };
    module.exports = {
      CloseEvent,
      ErrorEvent,
      Event: Event2,
      EventTarget: EventTarget2,
      MessageEvent: MessageEvent2,
    };
    function callListener(listener, thisArg, event2) {
      if (typeof listener === 'object' && listener.handleEvent) {
        listener.handleEvent.call(listener, event2);
      } else {
        listener.call(thisArg, event2);
      }
    }
  },
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  'node_modules/ws/lib/extension.js'(exports, module) {
    'use strict';
    var { tokenChars } = require_validation();
    function push2(dest, name3, elem) {
      if (dest[name3] === void 0) dest[name3] = [elem];
      else dest[name3].push(elem);
    }
    function parse2(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            const name3 = header.slice(start, end);
            if (code === 44) {
              push2(offers, name3, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name3;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            push2(params, header.slice(start, end), true);
            if (code === 44) {
              push2(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1) start = i;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1) start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, '');
              mustUnescape = false;
            }
            push2(params, paramName, value);
            if (code === 44) {
              push2(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError('Unexpected end of input');
      }
      if (end === -1) end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push2(offers, token, params);
      } else {
        if (paramName === void 0) {
          push2(params, token, true);
        } else if (mustUnescape) {
          push2(params, paramName, token.replace(/\\/g, ''));
        } else {
          push2(params, paramName, token);
        }
        push2(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions3) {
      return Object.keys(extensions3)
        .map((extension) => {
          let configurations = extensions3[extension];
          if (!Array.isArray(configurations)) configurations = [configurations];
          return configurations
            .map((params) => {
              return [extension]
                .concat(
                  Object.keys(params).map((k) => {
                    let values = params[k];
                    if (!Array.isArray(values)) values = [values];
                    return values.map((v) => (v === true ? k : `${k}=${v}`)).join('; ');
                  })
                )
                .join('; ');
            })
            .join(', ');
        })
        .join(', ');
    }
    module.exports = { format, parse: parse2 };
  },
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  'node_modules/ws/lib/websocket.js'(exports, module) {
    'use strict';
    var EventEmitter2 = __require('events');
    var https3 = __require('https');
    var http4 = __require('http');
    var net = __require('net');
    var tls = __require('tls');
    var { randomBytes, createHash } = __require('crypto');
    var { Duplex, Readable: Readable2 } = __require('stream');
    var { URL: URL3 } = __require('url');
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var { isBlob: isBlob2 } = require_validation();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP,
    } = require_constants();
    var {
      EventTarget: {
        addEventListener: addEventListener2,
        removeEventListener: removeEventListener2,
      },
    } = require_event_target();
    var { format, parse: parse2 } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol('kAborted');
    var protocolVersions = [8, 13];
    var readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class _WebSocket extends EventEmitter2 {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._errorEmitted = false;
        this._extensions = {};
        this._paused = false;
        this._protocol = '';
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === 'object' && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._isServer = true;
        }
      }
      /**
       * For historical reasons, the custom "nodebuffer" type is used by the default
       * instead of "blob".
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head2, options) {
        const receiver = new Receiver({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation,
        });
        const sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._sender = sender;
        this._socket = socket;
        receiver[kWebSocket] = this;
        sender[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on('conclude', receiverOnConclude);
        receiver.on('drain', receiverOnDrain);
        receiver.on('error', receiverOnError);
        receiver.on('message', receiverOnMessage);
        receiver.on('ping', receiverOnPing);
        receiver.on('pong', receiverOnPong);
        sender.onerror = senderOnError;
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();
        if (head2.length > 0) socket.unshift(head2);
        socket.on('close', socketOnClose);
        socket.on('data', socketOnData);
        socket.on('end', socketOnEnd);
        socket.on('error', socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit('open');
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit('close', this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit('close', this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = 'WebSocket was closed before the connection was established';
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (
            this._closeFrameSent &&
            (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
          ) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        setCloseTimer(this);
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
        }
        if (typeof data === 'function') {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === 'function') {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === 'number') data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
        }
        if (typeof data === 'function') {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === 'function') {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === 'number') data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
        }
        if (typeof options === 'function') {
          cb = options;
          options = {};
        }
        if (typeof data === 'number') data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== 'string',
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options,
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = 'WebSocket was closed before the connection was established';
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, 'CONNECTING', {
      enumerable: true,
      value: readyStates.indexOf('CONNECTING'),
    });
    Object.defineProperty(WebSocket2.prototype, 'CONNECTING', {
      enumerable: true,
      value: readyStates.indexOf('CONNECTING'),
    });
    Object.defineProperty(WebSocket2, 'OPEN', {
      enumerable: true,
      value: readyStates.indexOf('OPEN'),
    });
    Object.defineProperty(WebSocket2.prototype, 'OPEN', {
      enumerable: true,
      value: readyStates.indexOf('OPEN'),
    });
    Object.defineProperty(WebSocket2, 'CLOSING', {
      enumerable: true,
      value: readyStates.indexOf('CLOSING'),
    });
    Object.defineProperty(WebSocket2.prototype, 'CLOSING', {
      enumerable: true,
      value: readyStates.indexOf('CLOSING'),
    });
    Object.defineProperty(WebSocket2, 'CLOSED', {
      enumerable: true,
      value: readyStates.indexOf('CLOSED'),
    });
    Object.defineProperty(WebSocket2.prototype, 'CLOSED', {
      enumerable: true,
      value: readyStates.indexOf('CLOSED'),
    });
    [
      'binaryType',
      'bufferedAmount',
      'extensions',
      'isPaused',
      'protocol',
      'readyState',
      'url',
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ['open', 'error', 'close', 'message'].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== 'function') return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true,
          });
        },
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener2;
    WebSocket2.prototype.removeEventListener = removeEventListener2;
    module.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: 'GET',
        host: void 0,
        path: void 0,
        port: void 0,
      };
      websocket._autoPong = opts.autoPong;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(', ')})`
        );
      }
      let parsedUrl;
      if (address instanceof URL3) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL3(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }
      if (parsedUrl.protocol === 'http:') {
        parsedUrl.protocol = 'ws:';
      } else if (parsedUrl.protocol === 'https:') {
        parsedUrl.protocol = 'wss:';
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === 'wss:';
      const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
      let invalidUrlMessage;
      if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = 'The URL contains a fragment identifier';
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key2 = randomBytes(16).toString('base64');
      const request = isSecure ? https3.request : http4.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith('[')
        ? parsedUrl.hostname.slice(1, -1)
        : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        'Sec-WebSocket-Version': opts.protocolVersion,
        'Sec-WebSocket-Key': key2,
        Connection: 'Upgrade',
        Upgrade: 'websocket',
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers['Sec-WebSocket-Extensions'] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer(),
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (
            typeof protocol !== 'string' ||
            !subprotocolRegex.test(protocol) ||
            protocolSet.has(protocol)
          ) {
            throw new SyntaxError('An invalid or duplicated subprotocol was specified');
          }
          protocolSet.add(protocol);
        }
        opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers['Sec-WebSocket-Origin'] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(':');
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key3, value] of Object.entries(headers)) {
              options.headers[key3.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount('redirect') === 0) {
          const isSameHost = isIpcUrl
            ? websocket._originalIpc
              ? opts.socketPath === websocket._originalHostOrSocketPath
              : false
            : websocket._originalIpc
              ? false
              : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || (websocket._originalSecure && !isSecure)) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost) delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = 'Basic ' + Buffer.from(opts.auth).toString('base64');
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit('redirect', websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on('timeout', () => {
          abortHandshake(websocket, req, 'Opening handshake has timed out');
        });
      }
      req.on('error', (err) => {
        if (req === null || req[kAborted]) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on('response', (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, 'Maximum redirects exceeded');
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL3(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit('unexpected-response', req, res)) {
          abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        }
      });
      req.on('upgrade', (res, socket, head2) => {
        websocket.emit('upgrade', res);
        if (websocket.readyState !== WebSocket2.CONNECTING) return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== 'websocket') {
          abortHandshake(websocket, socket, 'Invalid Upgrade header');
          return;
        }
        const digest = createHash('sha1')
          .update(key2 + GUID)
          .digest('base64');
        if (res.headers['sec-websocket-accept'] !== digest) {
          abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
          return;
        }
        const serverProt = res.headers['sec-websocket-protocol'];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = 'Server sent a subprotocol but none was requested';
          } else if (!protocolSet.has(serverProt)) {
            protError = 'Server sent an invalid subprotocol';
          }
        } else if (protocolSet.size) {
          protError = 'Server sent no subprotocol';
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers['sec-websocket-extensions'];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message =
              'Server sent a Sec-WebSocket-Extensions header but no extension was requested';
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions3;
          try {
            extensions3 = parse2(secWebSocketExtensions);
          } catch (err) {
            const message = 'Invalid Sec-WebSocket-Extensions header';
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions3);
          if (
            extensionNames.length !== 1 ||
            extensionNames[0] !== PerMessageDeflate.extensionName
          ) {
            const message = 'Server indicated an extension that was not requested';
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions3[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = 'Invalid Sec-WebSocket-Extensions header';
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head2, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation,
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket._errorEmitted = true;
      websocket.emit('error', err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== '') {
        options.servername = net.isIP(options.host) ? '' : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream4, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream4.setHeader) {
        stream4[kAborted] = true;
        stream4.abort();
        if (stream4.socket && !stream4.socket.destroyed) {
          stream4.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream4.destroy(err);
        stream4.once('error', websocket.emit.bind(websocket, 'error'));
        stream4.once('close', websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = isBlob2(data) ? data.size : toBuffer(data).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener('data', socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005) websocket.close();
      else websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused) websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener('data', socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit('error', err);
      }
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit('message', data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
      websocket.emit('ping', data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit('pong', data);
    }
    function resume(stream4) {
      stream4.resume();
    }
    function senderOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket.readyState === WebSocket2.CLOSED) return;
      if (websocket.readyState === WebSocket2.OPEN) {
        websocket._readyState = WebSocket2.CLOSING;
        setCloseTimer(websocket);
      }
      this._socket.end();
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit('error', err);
      }
    }
    function setCloseTimer(websocket) {
      websocket._closeTimer = setTimeout(
        websocket._socket.destroy.bind(websocket._socket),
        closeTimeout
      );
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener('close', socketOnClose);
      this.removeListener('data', socketOnData);
      this.removeListener('end', socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (
        !this._readableState.endEmitted &&
        !websocket._closeFrameReceived &&
        !websocket._receiver._writableState.errorEmitted &&
        (chunk = websocket._socket.read()) !== null
      ) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (
        websocket._receiver._writableState.finished ||
        websocket._receiver._writableState.errorEmitted
      ) {
        websocket.emitClose();
      } else {
        websocket._receiver.on('error', receiverOnFinish);
        websocket._receiver.on('finish', receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener('error', socketOnError);
      this.on('error', NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  },
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  'node_modules/ws/lib/stream.js'(exports, module) {
    'use strict';
    var WebSocket2 = require_websocket();
    var { Duplex } = __require('stream');
    function emitClose(stream4) {
      stream4.emit('close');
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener('error', duplexOnError);
      this.destroy();
      if (this.listenerCount('error') === 0) {
        this.emit('error', err);
      }
    }
    function createWebSocketStream(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false,
      });
      ws.on('message', function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data)) ws.pause();
      });
      ws.once('error', function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once('close', function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function (err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once('error', function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once('close', function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function (callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once('open', function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once('finish', function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function () {
        if (ws.isPaused) ws.resume();
      };
      duplex._write = function (chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once('open', function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on('end', duplexOnEnd);
      duplex.on('error', duplexOnError);
      return duplex;
    }
    module.exports = createWebSocketStream;
  },
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  'node_modules/ws/lib/subprotocol.js'(exports, module) {
    'use strict';
    var { tokenChars } = require_validation();
    function parse2(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1) end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1) end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError('Unexpected end of input');
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module.exports = { parse: parse2 };
  },
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  'node_modules/ws/lib/websocket-server.js'(exports, module) {
    'use strict';
    var EventEmitter2 = __require('events');
    var http4 = __require('http');
    var { Duplex } = __require('stream');
    var { createHash } = __require('crypto');
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter2 {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options,
        };
        if (
          (options.port == null && !options.server && !options.noServer) ||
          (options.port != null && (options.server || options.noServer)) ||
          (options.server && options.noServer)
        ) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http4.createServer((req, res) => {
            const body = http4.STATUS_CODES[426];
            res.writeHead(426, {
              'Content-Length': body.length,
              'Content-Type': 'text/plain',
            });
            res.end(body);
          });
          this._server.listen(options.port, options.host, options.backlog, callback);
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, 'connection');
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, 'listening'),
            error: this.emit.bind(this, 'error'),
            upgrade: (req, socket, head2) => {
              this.handleUpgrade(req, socket, head2, emitConnection);
            },
          });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once('close', () => {
              cb(new Error('The server is not running'));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once('close', cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index2 = req.url.indexOf('?');
          const pathname = index2 !== -1 ? req.url.slice(0, index2) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head2, cb) {
        socket.on('error', socketOnError);
        const key2 = req.headers['sec-websocket-key'];
        const upgrade = req.headers.upgrade;
        const version4 = +req.headers['sec-websocket-version'];
        if (req.method !== 'GET') {
          const message = 'Invalid HTTP method';
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== 'websocket') {
          const message = 'Invalid Upgrade header';
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key2 === void 0 || !keyRegex.test(key2)) {
          const message = 'Missing or invalid Sec-WebSocket-Key header';
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version4 !== 13 && version4 !== 8) {
          const message = 'Missing or invalid Sec-WebSocket-Version header';
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
            'Sec-WebSocket-Version': '13, 8',
          });
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = 'Invalid Sec-WebSocket-Protocol header';
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
        const extensions3 = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions3[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = 'Invalid or unacceptable Sec-WebSocket-Extensions header';
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version4 === 8 ? 'sec-websocket-origin' : 'origin'}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req,
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(extensions3, key2, protocols, req, socket, head2, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions3, key2, protocols, req, socket, head2, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions3, key2, protocols, req, socket, head2, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            'server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration'
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash('sha1')
          .update(key2 + GUID)
          .digest('base64');
        const headers = [
          'HTTP/1.1 101 Switching Protocols',
          'Upgrade: websocket',
          'Connection: Upgrade',
          `Sec-WebSocket-Accept: ${digest}`,
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols
            ? this.options.handleProtocols(protocols, req)
            : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions3[PerMessageDeflate.extensionName]) {
          const params = extensions3[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params],
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions3;
        }
        this.emit('headers', headers, req);
        socket.write(headers.concat('\r\n').join('\r\n'));
        socket.removeListener('error', socketOnError);
        ws.setSocket(socket, head2, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation,
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on('close', () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event2 of Object.keys(map)) server.on(event2, map[event2]);
      return function removeListeners() {
        for (const event2 of Object.keys(map)) {
          server.removeListener(event2, map[event2]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit('close');
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http4.STATUS_CODES[code];
      headers = {
        Connection: 'close',
        'Content-Type': 'text/html',
        'Content-Length': Buffer.byteLength(message),
        ...headers,
      };
      socket.once('finish', socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http4.STATUS_CODES[code]}\r
` +
          Object.keys(headers)
            .map((h) => `${h}: ${headers[h]}`)
            .join('\r\n') +
          '\r\n\r\n' +
          message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
      if (server.listenerCount('wsClientError')) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit('wsClientError', err, socket, req);
      } else {
        abortHandshake(socket, code, message, headers);
      }
    }
  },
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  'node_modules/ws/index.js'(exports, module) {
    'use strict';
    var WebSocket2 = require_websocket();
    WebSocket2.createWebSocketStream = require_stream();
    WebSocket2.Server = require_websocket_server();
    WebSocket2.Receiver = require_receiver();
    WebSocket2.Sender = require_sender();
    WebSocket2.WebSocket = WebSocket2;
    WebSocket2.WebSocketServer = WebSocket2.Server;
    module.exports = WebSocket2;
  },
});

// node_modules/isomorphic-ws/node.js
var require_node2 = __commonJS({
  'node_modules/isomorphic-ws/node.js'(exports, module) {
    'use strict';
    module.exports = require_ws();
  },
});

// node_modules/@statelyai/inspect/dist/index.js
var require_dist3 = __commonJS({
  'node_modules/@statelyai/inspect/dist/index.js'(exports, module) {
    'use strict';
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all3) => {
      for (var name3 in all3) __defProp2(target, name3, { get: all3[name3], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if ((from && typeof from === 'object') || typeof from === 'function') {
        for (let key2 of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key2) && key2 !== except)
            __defProp2(to, key2, {
              get: () => from[key2],
              enumerable: !(desc = __getOwnPropDesc2(from, key2)) || desc.enumerable,
            });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (
      (target = mod != null ? __create2(__getProtoOf2(mod)) : {}),
      __copyProps2(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule
          ? __defProp2(target, 'default', { value: mod, enumerable: true })
          : target,
        mod
      )
    );
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, '__esModule', { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      createBrowserInspector: () => createBrowserInspector2,
      createBrowserReceiver: () => createBrowserReceiver,
      createInspector: () => createInspector,
      createSkyInspector: () => createSkyInspector,
      createWebSocketInspector: () => createWebSocketInspector,
      createWebSocketReceiver: () => createWebSocketReceiver,
    });
    module.exports = __toCommonJS2(src_exports);
    var import_fast_safe_stringify = __toESM2(require_fast_safe_stringify());
    var import_xstate8 = (init_xstate_esm(), __toCommonJS(xstate_esm_exports));
    function toEventObject(event2) {
      if (typeof event2 === 'string') {
        return { type: event2 };
      }
      return event2;
    }
    var isNode =
      typeof process !== 'undefined' &&
      typeof process.versions?.node !== 'undefined' &&
      typeof document === 'undefined';
    var package_default = {
      devDependencies: {
        '@changesets/changelog-github': '^0.5.0',
        '@changesets/cli': '^2.27.7',
        '@types/jsdom': '^21.1.7',
        '@types/uuid': '^9.0.8',
        jsdom: '^23.2.0',
        tsup: '^8.1.0',
        typescript: '^5.5.3',
        vitest: '^1.6.0',
        xstate: '^5.14.0',
      },
      name: '@statelyai/inspect',
      version: '0.4.0',
      description: 'Inspection utilities for state, actors, workflows, and state machines.',
      main: 'dist/index.js',
      repository: 'https://github.com/statelyai/inspect.git',
      author: 'David Khourshid <davidkpiano@gmail.com>',
      license: 'MIT',
      dependencies: {
        'fast-safe-stringify': '^2.1.1',
        'isomorphic-ws': '^5.0.0',
        partysocket: '^0.0.25',
        'safe-stable-stringify': '^2.4.3',
        superjson: '^1.13.3',
        uuid: '^9.0.1',
      },
      peerDependencies: {
        xstate: '^5.5.1',
      },
      scripts: {
        build: 'tsup src/index.ts --dts',
        watch: 'tsup src/index.ts --dts --watch',
        test: 'vitest',
        prepublishOnly: 'tsup src/index.ts --dts',
        changeset: 'changeset',
        release: 'changeset publish',
        version: 'changeset version',
        dev: 'yarn build && ./scripts/dev.sh',
      },
      publishConfig: {
        access: 'public',
      },
      packageManager: 'pnpm@8.11.0',
    };
    function idleCallback(cb) {
      if (typeof window !== 'undefined') {
        const raf2 = window.requestIdleCallback || window.requestAnimationFrame;
        raf2(cb);
      } else {
        setTimeout(cb, 0);
      }
    }
    var import_safe_stable_stringify = __toESM2(require_safe_stable_stringify());
    function getRoot(actorRef) {
      let marker = actorRef;
      do {
        marker = marker._parent;
      } while (marker?._parent);
      return marker;
    }
    function getRootId(actorRefOrId) {
      const rootActorRef =
        typeof actorRefOrId === 'string' ? void 0 : getRoot(actorRefOrId)?.sessionId;
      return rootActorRef ?? void 0;
    }
    var defaultInspectorOptions = {
      filter: () => true,
      serialize: (event2) => event2,
      autoStart: true,
      maxDeferredEvents: 200,
      sanitizeEvent: (event2) => event2,
      sanitizeContext: (context) => context,
    };
    function createInspector(adapter2, options) {
      function sendAdapter(inspectionEvent) {
        if (options?.filter && !options.filter(inspectionEvent)) {
          return;
        }
        const sanitizedEvent =
          options?.sanitizeContext || options?.sanitizeEvent
            ? inspectionEvent
            : {
                ...inspectionEvent,
              };
        if (
          options?.sanitizeContext &&
          (sanitizedEvent.type === '@xstate.actor' || sanitizedEvent.type === '@xstate.snapshot')
        ) {
          sanitizedEvent.snapshot = {
            ...sanitizedEvent.snapshot,
            // @ts-ignore
            context: options.sanitizeContext(
              // @ts-ignore
              sanitizedEvent.snapshot.context
            ),
          };
        }
        if (
          options?.sanitizeEvent &&
          (sanitizedEvent.type === '@xstate.event' || sanitizedEvent.type === '@xstate.snapshot')
        ) {
          sanitizedEvent.event = options.sanitizeEvent(sanitizedEvent.event);
        }
        const serializedEvent = options?.serialize?.(sanitizedEvent) ?? sanitizedEvent;
        adapter2.send(serializedEvent);
      }
      const inspector = {
        adapter: adapter2,
        actor: (actorRef, snapshot2, info) => {
          const sessionId = typeof actorRef === 'string' ? actorRef : actorRef.sessionId;
          const definitionObject = actorRef?.logic?.config;
          const definition = definitionObject
            ? (0, import_safe_stable_stringify.default)(definitionObject)
            : void 0;
          const rootId =
            (info?.rootId ?? typeof actorRef === 'string') ? void 0 : getRootId(actorRef);
          const parentId =
            (info?.parentId ?? typeof actorRef === 'string') ? void 0 : actorRef._parent?.sessionId;
          const name3 = definitionObject ? definitionObject.id : sessionId;
          sendAdapter({
            type: '@xstate.actor',
            name: name3,
            sessionId,
            createdAt: Date.now().toString(),
            _version: package_default.version,
            rootId,
            parentId,
            id: null,
            definition,
            snapshot: snapshot2 ?? { status: 'active' },
          });
        },
        event: (target, event2, info) => {
          const sessionId = typeof target === 'string' ? target : target.sessionId;
          const sourceId = !info?.source
            ? void 0
            : typeof info.source === 'string'
              ? info.source
              : info.source.sessionId;
          sendAdapter({
            type: '@xstate.event',
            sourceId,
            sessionId,
            event: toEventObject(event2),
            id: Math.random().toString(),
            createdAt: Date.now().toString(),
            rootId: 'anonymous',
            _version: package_default.version,
          });
        },
        snapshot: (actor, snapshot2, info) => {
          const sessionId = typeof actor === 'string' ? actor : actor.sessionId;
          sendAdapter({
            type: '@xstate.snapshot',
            snapshot: {
              status: 'active',
              ...snapshot2,
            },
            event: info?.event ?? { type: '' },
            sessionId,
            id: null,
            createdAt: Date.now().toString(),
            rootId: 'anonymous',
            _version: package_default.version,
          });
        },
        inspect: {
          next: (event2) => {
            idleCallback(function inspectNext() {
              const convertedEvent = convertXStateEvent(event2);
              if (convertedEvent) {
                sendAdapter(convertedEvent);
              }
            });
          },
        },
        start() {
          adapter2.start?.();
        },
        stop() {
          adapter2.stop?.();
        },
      };
      return inspector;
    }
    function convertXStateEvent(inspectionEvent) {
      switch (inspectionEvent.type) {
        case '@xstate.actor': {
          const actorRef = inspectionEvent.actorRef;
          const logic = actorRef?.logic;
          const definitionObject = logic?.config;
          let name3 = actorRef.id;
          if (name3 === actorRef.sessionId && definitionObject) {
            name3 = definitionObject.id;
          }
          const definitionString =
            typeof definitionObject === 'object'
              ? (0, import_safe_stable_stringify.default)(definitionObject, (_key, value) => {
                  if (typeof value === 'function') {
                    return { type: value.name };
                  }
                  return value;
                })
              : (0, import_safe_stable_stringify.default)({
                  id: name3,
                });
          return {
            name: name3,
            type: '@xstate.actor',
            definition: definitionString,
            _version: package_default.version,
            createdAt: Date.now().toString(),
            id: null,
            rootId: inspectionEvent.rootId,
            parentId: inspectionEvent.actorRef._parent?.sessionId,
            sessionId: inspectionEvent.actorRef.sessionId,
            snapshot: inspectionEvent.actorRef.getSnapshot(),
          };
        }
        case '@xstate.event': {
          return {
            type: '@xstate.event',
            event: inspectionEvent.event,
            sourceId: inspectionEvent.sourceRef?.sessionId,
            // sessionId: inspectionEvent.targetRef.sessionId,
            sessionId: inspectionEvent.actorRef.sessionId,
            _version: package_default.version,
            createdAt: Date.now().toString(),
            id: null,
            rootId: inspectionEvent.rootId,
          };
        }
        case '@xstate.snapshot': {
          return {
            type: '@xstate.snapshot',
            event: inspectionEvent.event,
            snapshot: JSON.parse(
              (0, import_safe_stable_stringify.default)(inspectionEvent.snapshot)
            ),
            sessionId: inspectionEvent.actorRef.sessionId,
            _version: package_default.version,
            createdAt: Date.now().toString(),
            id: null,
            rootId: inspectionEvent.rootId,
          };
        }
        default: {
          if (inspectionEvent.type.startsWith('@xstate.')) {
            return void 0;
          }
          console.warn(`Unhandled inspection event type: ${inspectionEvent.type}`);
          return void 0;
        }
      }
    }
    var UselessAdapter = class {
      constructor() {}
      start() {}
      stop() {}
      send(_event) {}
    };
    var CONNECTION_EVENT = '@statelyai.connected';
    function isEventObject(event2) {
      return typeof event2 === 'object' && event2 !== null && typeof event2.type === 'string';
    }
    function isStatelyInspectionEvent(event2) {
      return (
        typeof event2 === 'object' &&
        event2 !== null &&
        typeof event2.type === 'string' &&
        typeof event2._version === 'string'
      );
    }
    function createBrowserInspector2(options) {
      const resolvedWindow = options?.window ?? (typeof window === 'undefined' ? void 0 : window);
      if (!resolvedWindow) {
        console.error('Window does not exist; inspector cannot be started.');
        return new UselessAdapter();
      }
      const resolvedOptions = {
        ...defaultInspectorOptions,
        url: 'https://stately.ai/inspect',
        filter: () => true,
        serialize: (inspectionEvent) =>
          JSON.parse((0, import_fast_safe_stringify.default)(inspectionEvent)),
        autoStart: true,
        iframe: null,
        ...options,
        window: resolvedWindow,
      };
      const adapter2 = new BrowserAdapter(resolvedOptions);
      const inspector = createInspector(adapter2, resolvedOptions);
      if (resolvedOptions.autoStart) {
        inspector.start();
      }
      return inspector;
    }
    var defaultBrowserReceiverOptions = {
      replayCount: 0,
      window: typeof window !== 'undefined' ? window : void 0,
    };
    function createBrowserReceiver(options) {
      const resolvedOptions = {
        ...defaultBrowserReceiverOptions,
        ...options,
      };
      const browserWindow = resolvedOptions.window;
      const targetWindow =
        browserWindow.self === browserWindow.top ? browserWindow.opener : browserWindow.parent;
      const observers = /* @__PURE__ */ new Set();
      browserWindow.addEventListener('message', (event2) => {
        if (!isStatelyInspectionEvent(event2.data)) {
          return;
        }
        observers.forEach((observer) => observer.next?.(event2.data));
      });
      const receiver = {
        subscribe(observerOrFn) {
          const observer = (0, import_xstate8.toObserver)(observerOrFn);
          observers.add(observer);
          return {
            unsubscribe() {
              observers.delete(observer);
            },
          };
        },
      };
      if (targetWindow) {
        targetWindow.postMessage(
          {
            type: CONNECTION_EVENT,
          },
          '*'
        );
      }
      return receiver;
    }
    var BrowserAdapter = class {
      constructor(options) {
        this.options = options;
      }
      status = 'disconnected';
      deferredEvents = [];
      targetWindow = null;
      start() {
        this.targetWindow = this.options.iframe
          ? null
          : this.options.window.open(String(this.options.url), 'xstateinspector');
        if (this.options.iframe) {
          this.options.iframe.addEventListener('load', () => {
            this.targetWindow = this.options.iframe?.contentWindow ?? null;
          });
          this.options.iframe?.setAttribute('src', String(this.options.url));
        }
        this.options.window.addEventListener('message', (event2) => {
          if (isEventObject(event2.data) && event2.data.type === '@statelyai.connected') {
            this.status = 'connected';
            this.deferredEvents.forEach((event22) => {
              const serializedEvent = this.options.serialize(event22);
              this.targetWindow?.postMessage(serializedEvent, '*');
            });
          }
        });
      }
      stop() {
        this.targetWindow?.postMessage({ type: '@statelyai.disconnected' }, '*');
        this.status = 'disconnected';
      }
      send(event2) {
        const shouldSendEvent = this.options.filter(event2);
        if (!shouldSendEvent) {
          return;
        }
        if (this.options.send) {
          this.options.send(event2);
        } else if (this.status === 'connected') {
          const serializedEvent = this.options.serialize(event2);
          this.targetWindow?.postMessage(serializedEvent, '*');
        }
        this.deferredEvents.push(event2);
        if (this.deferredEvents.length > this.options.maxDeferredEvents) {
          this.deferredEvents.shift();
        }
      }
    };
    var import_partysocket = __toESM2(require_dist());
    var import_superjson = require_dist2();
    var import_uuid3 = (init_esm_node(), __toCommonJS(esm_node_exports));
    var isDevMode = false;
    function createSkyInspector(options = {}) {
      const { host, apiBaseURL } = {
        host: isDevMode ? 'localhost:1999' : 'stately-sky-beta.mellson.partykit.dev',
        apiBaseURL: isDevMode
          ? 'http://localhost:3000/registry/api/sky'
          : 'https://stately.ai/registry/api/sky',
      };
      const server = apiBaseURL.replace('/api/sky', '');
      const { apiKey, onerror, ...inspectorOptions } = options;
      const sessionId = (0, import_uuid3.v4)();
      const room = `inspect-${sessionId}`;
      const socket = new import_partysocket.default({
        host,
        room,
        WebSocket: isNode ? require_node2() : void 0,
      });
      const liveInspectUrl = `${server}/inspect/${sessionId}`;
      socket.onerror = onerror ?? console.error;
      socket.onopen = () => {
        console.log('Connected to Sky, link to your live inspect session:');
        console.log(liveInspectUrl);
      };
      if (isNode) {
        return createInspector({
          ...inspectorOptions,
          send(event2) {
            const skyEvent = apiKey ? { apiKey, ...event2 } : event2;
            socket.send((0, import_superjson.stringify)(skyEvent));
          },
        });
      } else {
        return createBrowserInspector2({
          ...inspectorOptions,
          url: liveInspectUrl,
          send(event2) {
            const skyEvent = apiKey ? { apiKey, ...event2 } : event2;
            socket.send((0, import_superjson.stringify)(skyEvent));
          },
        });
      }
    }
    var import_isomorphic_ws = __toESM2(require_node2());
    var import_safe_stable_stringify2 = __toESM2(require_safe_stable_stringify());
    var import_xstate22 = (init_xstate_esm(), __toCommonJS(xstate_esm_exports));
    var WebSocketAdapter = class {
      ws;
      status = 'closed';
      deferredEvents = [];
      options;
      constructor(options) {
        this.options = {
          ...defaultInspectorOptions,
          filter: () => true,
          serialize: (inspectionEvent) =>
            JSON.parse((0, import_safe_stable_stringify2.default)(inspectionEvent)),
          autoStart: true,
          url: 'ws://localhost:8080',
          ...options,
        };
      }
      start() {
        const start = () => {
          this.ws = new import_isomorphic_ws.default(this.options.url);
          this.ws.onopen = () => {
            console.log('websocket open');
            this.status = 'open';
            this.deferredEvents.forEach((inspectionEvent) => {
              const preSerializedEvent = defaultInspectorOptions.serialize(inspectionEvent);
              const serializedEvent = this.options.serialize(preSerializedEvent);
              this.ws.send((0, import_safe_stable_stringify2.default)(serializedEvent));
            });
          };
          this.ws.onclose = () => {
            console.log('websocket closed');
          };
          this.ws.onerror = async (event2) => {
            console.error('websocket error', event2);
            await new Promise((res) => setTimeout(res, 5e3));
            console.warn('restarting');
            start();
          };
          this.ws.onmessage = (event2) => {
            if (typeof event2.data !== 'string') {
              return;
            }
            console.log('message', event2.data);
          };
        };
        start();
      }
      stop() {
        this.ws.close();
        this.status = 'closed';
      }
      send(inspectionEvent) {
        if (this.status === 'open') {
          this.ws.send((0, import_safe_stable_stringify2.default)(inspectionEvent));
        } else {
          this.deferredEvents.push(inspectionEvent);
          if (this.deferredEvents.length > this.options.maxDeferredEvents) {
            this.deferredEvents.shift();
          }
        }
      }
    };
    function createWebSocketInspector(options) {
      const adapter2 = new WebSocketAdapter(options);
      const inspector = createInspector(adapter2, options);
      return inspector;
    }
    function createWebSocketReceiver(options) {
      const resolvedOptions = {
        server: 'ws://localhost:8080',
        ...options,
      };
      const observers = /* @__PURE__ */ new Set();
      const ws = new import_isomorphic_ws.default(resolvedOptions.server);
      ws.onopen = () => {
        console.log('websocket open');
        ws.onmessage = (event2) => {
          if (typeof event2.data !== 'string') {
            return;
          }
          console.log('message', event2.data);
          const eventData = JSON.parse(event2.data);
          observers.forEach((observer) => {
            observer.next?.(eventData);
          });
        };
      };
      const receiver = {
        subscribe(observerOrFn) {
          const observer = (0, import_xstate22.toObserver)(observerOrFn);
          observers.add(observer);
          return {
            unsubscribe() {
              observers.delete(observer);
            },
          };
        },
      };
      return receiver;
    }
  },
});

// src/fsm/config.ts
var import_inspect2, logger, FSM_CONFIG;
var init_config = __esm({
  'src/fsm/config.ts'() {
    'use strict';
    import_inspect2 = __toESM(require_dist3());
    init_FSMLogger();
    logger = createComponentLogger('APPLICATION' /* APPLICATION */, 'fsmConfig');
    FSM_CONFIG = {
      // Development settings - TRACING ENABLED BY DEFAULT
      enableInspector: true,
      // Always enable for debugging
      enableLogging: true,
      // Always enable for debugging
      // Timer settings
      timer: {
        tickIntervalMs: 1e3,
        inactivityCheckMs: 1e4,
        inactivityTimeoutSec: 300,
        // 5 minutes
        defaultElapsedLimitHours: 3.5,
        pomodoroMinutes: 25,
        pomodoroBreakMinutes: 5,
      },
      // Connection settings
      connection: {
        maxRetries: 3,
        retryDelayMs: 5e3,
        healthCheckIntervalMs: 3e4,
        connectionTimeoutMs: 1e4,
      },
      // Webview settings
      webview: {
        refreshIntervalMs: 6e4,
        maxWorkItems: 1e3,
        loadingTimeoutMs: 15e3,
      },
      // Feature flags for gradual rollout
      features: {
        useTimerFSM: process.env.USE_TIMER_FSM === 'true',
        useConnectionFSM: process.env.USE_CONNECTION_FSM === 'true',
        useWebviewFSM: process.env.USE_WEBVIEW_FSM === 'true',
        useMessageRouter: process.env.USE_MESSAGE_ROUTER === 'true',
      },
    };
  },
});

// src/fsm/machines/timerMachine.ts
var logger2, timerMachine;
var init_timerMachine = __esm({
  'src/fsm/machines/timerMachine.ts'() {
    'use strict';
    init_xstate_esm();
    init_config();
    init_FSMLogger();
    logger2 = createComponentLogger('MACHINE' /* MACHINE */, 'timerMachine');
    timerMachine = createMachine({
      id: 'timer',
      initial: 'idle',
      types: {},
      context: {
        elapsedSeconds: 0,
        isPaused: false,
        lastActivity: Date.now(),
        inactivityTimeoutSec: FSM_CONFIG.timer.inactivityTimeoutSec,
        defaultElapsedLimitHours: FSM_CONFIG.timer.defaultElapsedLimitHours,
        pomodoroEnabled: false,
        pomodoroCount: 0,
      },
      states: {
        idle: {
          on: {
            START: {
              target: 'running',
              guard: ({ context }) => !context.workItemId,
              actions: assign(({ event: event2, context }) => {
                if (event2.type === 'START') {
                  return {
                    workItemId: event2.workItemId,
                    workItemTitle: event2.workItemTitle,
                    startTime: Date.now(),
                    elapsedSeconds: 0,
                    isPaused: false,
                    lastActivity: Date.now(),
                  };
                }
                return context;
              }),
            },
          },
        },
        running: {
          entry: assign(() => ({ lastActivity: Date.now() })),
          on: {
            TICK: {
              actions: assign(({ context }) => {
                if (!context.startTime || context.isPaused) return context;
                const elapsed = Math.floor((Date.now() - context.startTime) / 1e3);
                const cappedElapsed = Math.min(elapsed, context.defaultElapsedLimitHours * 3600);
                return {
                  elapsedSeconds: Math.max(0, cappedElapsed),
                };
              }),
            },
            PAUSE: {
              target: 'paused',
              actions: assign(() => ({ isPaused: true })),
            },
            STOP: {
              target: 'idle',
              actions: assign(() => ({
                workItemId: void 0,
                workItemTitle: void 0,
                startTime: void 0,
                elapsedSeconds: 0,
                isPaused: false,
                pomodoroCount: 0,
              })),
            },
            ACTIVITY: {
              actions: assign(() => ({ lastActivity: Date.now() })),
            },
            INACTIVITY_TIMEOUT: {
              target: 'paused',
              actions: [
                assign(() => ({ isPaused: true })),
                () => logger2.info('Timer paused due to inactivity'),
              ],
            },
          },
        },
        paused: {
          on: {
            RESUME: {
              target: 'running',
              actions: [
                assign(({ context }) => ({
                  isPaused: false,
                  startTime: context.startTime
                    ? Date.now() - context.elapsedSeconds * 1e3
                    : Date.now(),
                  lastActivity: Date.now(),
                })),
              ],
            },
            STOP: {
              target: 'idle',
              actions: assign(() => ({
                workItemId: void 0,
                workItemTitle: void 0,
                startTime: void 0,
                elapsedSeconds: 0,
                isPaused: false,
                pomodoroCount: 0,
              })),
            },
            ACTIVITY: [
              {
                target: 'running',
                guard: ({ context }) => context.isPaused && context.lastActivity > 0,
                actions: [
                  assign(({ context }) => ({
                    isPaused: false,
                    startTime: context.startTime
                      ? Date.now() - context.elapsedSeconds * 1e3
                      : Date.now(),
                    lastActivity: Date.now(),
                  })),
                ],
              },
              {
                actions: assign(() => ({ lastActivity: Date.now() })),
              },
            ],
          },
        },
      },
    });
  },
});

// src/fsm/machines/applicationMachine.ts
function initializeTimerActor(context) {
  try {
    const timerActor = createActor(timerMachine, { id: 'timer' });
    context.timerActor = timerActor;
    timerActor.start();
  } catch (error) {
    console.error('[ApplicationFSM] Failed to initialize timer actor:', error);
  }
}
function activateConnection(context, connectionId) {
  if (context.isDeactivating) {
    console.log(
      `[ApplicationFSM] Skipping connection activation - extension is deactivating (connectionId: ${connectionId})`
    );
    return;
  }
  const actor = context.connectionActors.get(connectionId);
  if (actor) {
    actor.send({ type: 'CONNECT' });
  } else {
    console.warn(`[ApplicationFSM] Connection actor not found: ${connectionId}`);
  }
}
function startAuthentication(context, connectionId) {
  if (context.isDeactivating) {
    console.log(
      `[ApplicationFSM] Skipping authentication - extension is deactivating (connectionId: ${connectionId})`
    );
    return;
  }
  const authActor = context.authActors.get(connectionId);
  if (authActor) {
    authActor.send({ type: 'START_AUTH' });
  } else {
    console.warn(`[ApplicationFSM] Auth actor not found: ${connectionId}`);
  }
}
function notifyWebviewReady(context) {
  if (context.isDeactivating) {
    console.log(`[ApplicationFSM] Skipping webview notification - extension is deactivating`);
    return;
  }
  if (context.webviewActor) {
    context.webviewActor.send({ type: 'PANEL_READY' });
  }
}
function routeWebviewMessage(context, message) {
  if (context.isDeactivating) {
    console.log(
      `[ApplicationFSM] Skipping webview message routing - extension is deactivating (message type: ${message.type})`
    );
    return;
  }
  switch (message.type) {
    case 'timer:start':
    case 'timer:stop':
    case 'timer:pause':
      if (context.timerActor) {
        context.timerActor.send({ type: message.type.split(':')[1].toUpperCase() });
      }
      break;
    case 'connection:select':
      break;
    default:
  }
}
async function performActivation({ input }) {
  try {
    if (typeof window !== 'undefined') {
      return { success: true };
    }
    const extensionContext = getExtensionContextRef();
    if (!extensionContext) {
      throw new Error('Extension context not available for command registration');
    }
    await invokeRegisterAllCommands(extensionContext);
    return { success: true, connections: [] };
  } catch (error) {
    console.error('[ApplicationFSM] Activation failed:', error);
    throw new Error(`Activation failed: ${error instanceof Error ? error.message : String(error)}`);
  }
}
async function performDeactivation({ input }) {
  try {
    if (input?.timerActor) {
      input.timerActor.stop();
    }
    if (input?.connectionActors) {
      input.connectionActors.forEach((actor) => actor.stop());
    }
    if (input?.authActors) {
      input.authActors.forEach((actor) => actor.stop());
    }
    if (input?.dataActor) {
      input.dataActor.stop();
    }
    if (input?.webviewActor) {
      input.webviewActor.stop();
    }
    return { success: true };
  } catch (error) {
    console.error('[ApplicationFSM] Deactivation failed:', error);
    throw new Error(
      `Deactivation failed: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
async function setupUI({ input }) {
  try {
    if (typeof window !== 'undefined') {
      return { connections: [] };
    }
    const vscode9 = await import('vscode');
    const config = vscode9.workspace.getConfiguration('azureDevOpsIntegration');
    const rawConnections = config.get('connections', []);
    const connections3 = rawConnections.filter(
      (conn) => conn && conn.id && conn.organization && conn.project
    );
    return { success: true, connections: connections3 };
  } catch (error) {
    console.error('[ApplicationFSM] UI setup failed:', error);
    throw new Error(`UI setup failed: ${error instanceof Error ? error.message : String(error)}`);
  }
}
async function loadData({ input }) {
  try {
    if (!input.activeConnectionId) {
      return { workItems: [], connectionId: null };
    }
    const connectionState = input.connectionStates.get(input.activeConnectionId);
    if (!connectionState?.provider) {
      return { workItems: [], connectionId: input.activeConnectionId };
    }
    const workItems = connectionState.provider.getWorkItems();
    if (workItems.length === 0) {
      await connectionState.provider.refresh();
      const refreshedWorkItems = connectionState.provider.getWorkItems();
      return {
        workItems: refreshedWorkItems,
        connectionId: input.activeConnectionId,
        query: connectionState.provider.currentQuery || 'My Activity',
      };
    }
    return {
      workItems,
      connectionId: input.activeConnectionId,
      query: connectionState.provider.currentQuery || 'My Activity',
    };
  } catch (error) {
    console.error('[ApplicationFSM] Data loading failed:', error);
    throw new Error(
      `Data loading failed: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
async function recoverFromError({ input }) {
  try {
    return { recovered: true };
  } catch (error) {
    console.error('[ApplicationFSM] Error recovery failed:', error);
    throw new Error(
      `Error recovery failed: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
var connectionMachine, authMachine, dataSyncMachine, webviewMachine, applicationMachine;
var init_applicationMachine = __esm({
  'src/fsm/machines/applicationMachine.ts'() {
    'use strict';
    init_xstate_esm();
    init_timerMachine();
    init_extensionHostBridge();
    connectionMachine = createMachine(
      {
        id: 'connection',
        types: {},
        initial: 'disconnected',
        context: {
          connectionId: '',
          config: {},
          authMethod: 'pat',
          isConnected: false,
          retryCount: 0,
        },
        states: {
          disconnected: {
            on: {
              CONNECT: 'authenticating',
              RESET: {
                target: 'disconnected',
                actions: assign({
                  retryCount: 0,
                  lastError: void 0,
                }),
              },
            },
          },
          authenticating: {
            invoke: {
              src: 'authenticateConnection',
              onDone: {
                target: 'creating_client',
                actions: assign({
                  credential: ({ event: event2 }) => event2.output.credential,
                }),
              },
              onError: {
                target: 'auth_failed',
                actions: assign({
                  lastError: ({ event: event2 }) =>
                    event2.error?.message || 'Authentication failed',
                  retryCount: ({ context }) => context.retryCount + 1,
                }),
              },
            },
          },
          creating_client: {
            invoke: {
              src: 'createClient',
              onDone: {
                target: 'creating_provider',
                actions: assign({
                  client: ({ event: event2 }) => event2.output,
                }),
              },
              onError: {
                target: 'connection_failed',
                actions: assign({
                  lastError: ({ event: event2 }) =>
                    event2.error?.message || 'Client creation failed',
                }),
              },
            },
          },
          creating_provider: {
            invoke: {
              src: 'createProvider',
              onDone: {
                target: 'connected',
                actions: assign({
                  provider: ({ event: event2 }) => event2.output,
                  isConnected: true,
                  retryCount: 0,
                  lastError: void 0,
                }),
              },
              onError: {
                target: 'connection_failed',
                actions: assign({
                  lastError: ({ event: event2 }) =>
                    event2.error?.message || 'Provider creation failed',
                }),
              },
            },
          },
          connected: {
            on: {
              DISCONNECT: 'disconnected',
              CONNECTION_FAILED: 'connection_failed',
            },
            entry: 'notifyConnectionSuccess',
          },
          auth_failed: {
            on: {
              RETRY: {
                target: 'authenticating',
                guard: 'canRetry',
              },
              CONNECT: 'authenticating',
              DISCONNECT: 'disconnected',
            },
            entry: 'notifyAuthFailure',
          },
          connection_failed: {
            on: {
              RETRY: {
                target: 'authenticating',
                guard: 'canRetry',
              },
              CONNECT: 'authenticating',
              DISCONNECT: 'disconnected',
            },
            entry: 'notifyConnectionFailure',
          },
        },
      },
      {
        guards: {
          canRetry: ({ context }) => context.retryCount < 3,
        },
        actions: {
          notifyConnectionSuccess: () => {},
          notifyAuthFailure: () => {},
          notifyConnectionFailure: () => {},
        },
        actors: {
          authenticateConnection: fromPromise(async ({ input }) => {
            return { credential: 'mock-credential' };
          }),
          createClient: fromPromise(async ({ input }) => {
            return { client: 'mock-client' };
          }),
          createProvider: fromPromise(async ({ input }) => {
            return { provider: 'mock-provider' };
          }),
        },
      }
    );
    authMachine = createMachine(
      {
        id: 'auth',
        types: {},
        initial: 'unauthenticated',
        context: {
          connectionId: '',
          authMethod: 'pat',
          isInteractive: false,
        },
        states: {
          unauthenticated: {
            on: {
              START_AUTH: [
                {
                  target: 'device_code_flow',
                  guard: 'isEntraAuth',
                },
                {
                  target: 'pat_auth',
                  guard: 'isPATAuth',
                },
              ],
            },
          },
          pat_auth: {
            invoke: {
              src: 'getPATToken',
              onDone: {
                target: 'authenticated',
                actions: assign({
                  token: ({ event: event2 }) => event2.output,
                }),
              },
              onError: {
                target: 'auth_failed',
                actions: assign({
                  lastError: ({ event: event2 }) =>
                    event2.error?.message || 'PAT authentication failed',
                }),
              },
            },
          },
          device_code_flow: {
            initial: 'requesting_code',
            states: {
              requesting_code: {
                invoke: {
                  src: 'requestDeviceCode',
                  onDone: {
                    target: 'waiting_for_user',
                    actions: assign({
                      deviceCode: ({ event: event2 }) => event2.output.deviceCode,
                      verificationUrl: ({ event: event2 }) => event2.output.verificationUrl,
                    }),
                  },
                  onError: {
                    target: '#auth.auth_failed',
                    actions: assign({
                      lastError: ({ event: event2 }) =>
                        event2.error?.message || 'Device code request failed',
                    }),
                  },
                },
              },
              waiting_for_user: {
                entry: 'showDeviceCodePrompt',
                invoke: {
                  src: 'pollForToken',
                  onDone: {
                    target: '#auth.authenticated',
                    actions: assign({
                      token: ({ event: event2 }) => event2.output.token,
                      expiresAt: ({ event: event2 }) => event2.output.expiresAt,
                      refreshToken: ({ event: event2 }) => event2.output.refreshToken,
                    }),
                  },
                  onError: {
                    target: '#auth.auth_failed',
                    actions: assign({
                      lastError: ({ event: event2 }) =>
                        event2.error?.message || 'Token polling failed',
                    }),
                  },
                },
                on: {
                  AUTH_CANCELLED: '#auth.auth_failed',
                },
              },
            },
          },
          authenticated: {
            on: {
              TOKEN_EXPIRED: 'refreshing_token',
              REFRESH_TOKEN: 'refreshing_token',
            },
            entry: 'notifyAuthSuccess',
          },
          refreshing_token: {
            invoke: {
              src: 'refreshToken',
              onDone: {
                target: 'authenticated',
                actions: assign({
                  token: ({ event: event2 }) => event2.output.token,
                  expiresAt: ({ event: event2 }) => event2.output.expiresAt,
                }),
              },
              onError: {
                target: 'unauthenticated',
                actions: assign({
                  token: void 0,
                  refreshToken: void 0,
                  lastError: ({ event: event2 }) => event2.error?.message || 'Token refresh failed',
                }),
              },
            },
          },
          auth_failed: {
            on: {
              START_AUTH: 'unauthenticated',
            },
            entry: 'notifyAuthFailure',
          },
        },
      },
      {
        guards: {
          isEntraAuth: ({ context }) => context.authMethod === 'entra',
          isPATAuth: ({ context }) => context.authMethod === 'pat',
        },
        actions: {
          showDeviceCodePrompt: ({ context }) => {},
          notifyAuthSuccess: () => {},
          notifyAuthFailure: () => {},
        },
        actors: {
          getPATToken: fromPromise(async ({ input }) => {
            return { token: 'mock-pat-token' };
          }),
          requestDeviceCode: fromPromise(async ({ input }) => {
            return {
              deviceCode: 'mock-device-code',
              verificationUrl: 'https://microsoft.com/devicelogin',
            };
          }),
          pollForToken: fromPromise(async ({ input }) => {
            return {
              token: 'mock-access-token',
              expiresAt: /* @__PURE__ */ new Date(),
              refreshToken: 'mock-refresh-token',
            };
          }),
          refreshToken: fromPromise(async ({ input }) => {
            return { token: 'mock-refreshed-token', expiresAt: /* @__PURE__ */ new Date() };
          }),
        },
      }
    );
    dataSyncMachine = createMachine(
      {
        id: 'dataSync',
        types: {},
        initial: 'idle',
        context: {
          workItems: [],
          isLoading: false,
          hasError: false,
          retryCount: 0,
        },
        states: {
          idle: {
            on: {
              LOAD_DATA: {
                target: 'loading',
                actions: assign({
                  connectionId: ({ event: event2 }) => event2.connectionId,
                  query: ({ event: event2 }) => event2.query,
                  isLoading: true,
                  hasError: false,
                }),
              },
            },
          },
          loading: {
            invoke: {
              src: 'loadWorkItems',
              onDone: {
                target: 'loaded',
                actions: assign({
                  workItems: ({ event: event2 }) => event2.output,
                  isLoading: false,
                  hasError: false,
                  lastSyncTime: () => /* @__PURE__ */ new Date(),
                  retryCount: 0,
                }),
              },
              onError: {
                target: 'error',
                actions: assign({
                  isLoading: false,
                  hasError: true,
                  errorMessage: ({ event: event2 }) =>
                    event2.error?.message || 'Data loading failed',
                  retryCount: ({ context }) => context.retryCount + 1,
                }),
              },
            },
            on: {
              CLEAR_DATA: 'idle',
            },
          },
          loaded: {
            on: {
              REFRESH_DATA: {
                target: 'loading',
                actions: assign({
                  isLoading: true,
                  hasError: false,
                }),
              },
              LOAD_DATA: {
                target: 'loading',
                actions: assign({
                  connectionId: ({ event: event2 }) => event2.connectionId,
                  query: ({ event: event2 }) => event2.query,
                  isLoading: true,
                  hasError: false,
                }),
              },
              CLEAR_DATA: {
                target: 'idle',
                actions: assign({
                  workItems: [],
                  connectionId: void 0,
                  query: void 0,
                }),
              },
            },
            entry: 'notifyDataLoaded',
          },
          error: {
            on: {
              RETRY: {
                target: 'loading',
                guard: 'canRetry',
                actions: assign({
                  hasError: false,
                  errorMessage: void 0,
                }),
              },
              LOAD_DATA: {
                target: 'loading',
                actions: assign({
                  connectionId: ({ event: event2 }) => event2.connectionId,
                  query: ({ event: event2 }) => event2.query,
                  isLoading: true,
                  hasError: false,
                }),
              },
              CLEAR_DATA: 'idle',
            },
            entry: 'notifyDataError',
          },
        },
      },
      {
        guards: {
          canRetry: ({ context }) => context.retryCount < 3,
        },
        actions: {
          notifyDataLoaded: () => {},
          notifyDataError: () => {},
        },
        actors: {
          loadWorkItems: fromPromise(async ({ input }) => {
            return [];
          }),
        },
      }
    );
    webviewMachine = createMachine(
      {
        id: 'webview',
        types: {},
        initial: 'not_created',
        context: {
          isReady: false,
          pendingMessages: [],
        },
        states: {
          not_created: {
            on: {
              CREATE_PANEL: 'creating',
            },
          },
          creating: {
            invoke: {
              src: 'createWebviewPanel',
              onDone: {
                target: 'initializing',
                actions: assign({
                  panel: ({ event: event2 }) => event2.output,
                }),
              },
              onError: {
                target: 'error',
                actions: assign({
                  lastError: ({ event: event2 }) =>
                    event2.error?.message || 'Panel creation failed',
                }),
              },
            },
          },
          initializing: {
            on: {
              PANEL_READY: {
                target: 'ready',
                actions: assign({
                  isReady: true,
                }),
              },
              ERROR: {
                target: 'error',
                actions: assign({
                  lastError: ({ event: event2 }) => event2.error,
                }),
              },
            },
            entry: 'setupPanelListeners',
          },
          ready: {
            on: {
              SEND_MESSAGE: {
                actions: 'sendMessageToPanel',
              },
              RECEIVE_MESSAGE: {
                actions: 'handleMessageFromPanel',
              },
              PANEL_DISPOSED: 'not_created',
              ERROR: 'error',
            },
            entry: 'flushPendingMessages',
          },
          error: {
            on: {
              CREATE_PANEL: 'creating',
            },
          },
        },
      },
      {
        actions: {
          setupPanelListeners: () => {},
          sendMessageToPanel: ({ context, event: event2 }) => {
            if (event2.type === 'SEND_MESSAGE') {
              if (context.isReady && context.panel) {
                context.panel.webview.postMessage(event2.message);
              } else {
                context.pendingMessages.push(event2.message);
              }
            }
          },
          handleMessageFromPanel: ({ event: event2 }) => {},
          flushPendingMessages: ({ context }) => {
            context.pendingMessages.forEach((message) => {
              context.panel?.webview.postMessage(message);
            });
            context.pendingMessages = [];
          },
        },
        actors: {
          createWebviewPanel: fromPromise(async () => {
            return { panel: 'mock-webview-panel' };
          }),
        },
      }
    );
    applicationMachine = createMachine(
      {
        id: 'application',
        types: {},
        initial: 'inactive',
        context: {
          isActivated: false,
          isDeactivating: false,
          connections: [],
          connectionStates: /* @__PURE__ */ new Map(),
          pendingAuthReminders: /* @__PURE__ */ new Map(),
          connectionActors: /* @__PURE__ */ new Map(),
          authActors: /* @__PURE__ */ new Map(),
          errorRecoveryAttempts: 0,
          webviewPanel: void 0,
          pendingWorkItems: void 0,
        },
        states: {
          inactive: {
            on: {
              ACTIVATE: {
                target: 'activating',
                actions: 'storeExtensionContext',
              },
            },
          },
          activating: {
            invoke: {
              src: 'performActivation',
              input: ({ context }) => context,
              onDone: {
                target: 'active',
                actions: 'markActivated',
              },
              onError: {
                target: 'activation_failed',
                actions: 'recordActivationError',
              },
            },
          },
          active: {
            initial: 'setup',
            states: {
              setup: {
                // Sequential setup: first connections, then panel, then ready for data
                entry: ['initializeChildActors'],
                initial: 'loading_connections',
                onDone: {
                  target: 'ready',
                },
                states: {
                  loading_connections: {
                    invoke: {
                      src: 'setupUI',
                      onDone: {
                        target: 'waiting_for_panel',
                        actions: 'loadConnectionsFromUISetup',
                      },
                      onError: 'setup_error',
                    },
                  },
                  waiting_for_panel: {
                    on: {
                      UPDATE_WEBVIEW_PANEL: {
                        target: 'panel_ready',
                        actions: [
                          'updateWebviewPanelInContext',
                          'syncPendingDataIfAvailable',
                          'clearPendingData',
                        ],
                      },
                    },
                  },
                  panel_ready: {
                    type: 'final',
                  },
                  setup_error: {
                    on: {
                      RETRY: 'loading_connections',
                    },
                  },
                },
                on: {
                  // Handle connection events during setup
                  CONNECTION_SELECTED: {
                    actions: 'delegateConnectionActivation',
                  },
                  AUTHENTICATION_REQUIRED: {
                    actions: 'delegateAuthenticationStart',
                  },
                  AUTHENTICATION_SUCCESS: {
                    actions: 'recordAuthenticationSuccess',
                  },
                  AUTHENTICATION_FAILED: {
                    actions: 'recordAuthenticationFailure',
                  },
                  AUTH_REMINDER_SET: {
                    actions: 'recordAuthReminder',
                  },
                  AUTH_REMINDER_CLEARED: {
                    actions: 'clearAuthReminder',
                  },
                  AUTH_REMINDER_DISMISSED: {
                    actions: 'dismissAuthReminder',
                  },
                },
              },
              ready: {
                // Normal operation: panel and connections guaranteed to exist
                initial: 'data_loading',
                states: {
                  data_loading: {
                    entry: ['checkForDataLoading', 'logAllEvents'],
                    on: {
                      CONNECTION_ESTABLISHED: {
                        actions: 'updateConnectionState',
                        // No transition - stay in data_loading until WORK_ITEMS_LOADED
                      },
                      WORK_ITEMS_LOADED: {
                        target: 'data_synced',
                        actions: ['syncDataToWebview'],
                      },
                    },
                  },
                  data_synced: {
                    on: {
                      REFRESH_DATA: 'data_loading',
                      WORK_ITEMS_LOADED: {
                        actions: ['syncDataToWebview'],
                      },
                    },
                  },
                },
                on: {
                  // Handle webview events during normal operation
                  WEBVIEW_READY: {
                    actions: 'notifyWebviewReady',
                  },
                  WEBVIEW_MESSAGE: {
                    actions: 'routeWebviewMessage',
                  },
                  UPDATE_WEBVIEW_PANEL: {
                    actions: [
                      'updateWebviewPanelInContext',
                      'syncPendingDataIfAvailable',
                      'clearPendingData',
                    ],
                  },
                  // DEBUG: Catch WORK_ITEMS_LOADED events at ready state level
                  WORK_ITEMS_LOADED: {
                    actions: ['syncDataToWebview'],
                  },
                  // Connection changes trigger updating state
                  CONNECTION_SELECTED: {
                    target: 'updating',
                    actions: 'delegateConnectionActivation',
                  },
                  AUTHENTICATION_REQUIRED: {
                    actions: 'delegateAuthenticationStart',
                  },
                  AUTHENTICATION_SUCCESS: {
                    actions: 'recordAuthenticationSuccess',
                  },
                  AUTHENTICATION_FAILED: {
                    actions: 'recordAuthenticationFailure',
                  },
                  AUTH_REMINDER_SET: {
                    actions: 'recordAuthReminder',
                  },
                  AUTH_REMINDER_CLEARED: {
                    actions: 'clearAuthReminder',
                  },
                  AUTH_REMINDER_DISMISSED: {
                    actions: 'dismissAuthReminder',
                  },
                },
              },
              updating: {
                // Temporary state when connections change - pause data, update, then resume
                on: {
                  AUTHENTICATION_REQUIRED: {
                    actions: 'delegateAuthenticationStart',
                  },
                  AUTHENTICATION_SUCCESS: {
                    actions: 'recordAuthenticationSuccess',
                  },
                  AUTHENTICATION_FAILED: {
                    actions: 'recordAuthenticationFailure',
                  },
                  AUTH_REMINDER_SET: {
                    actions: 'recordAuthReminder',
                  },
                  AUTH_REMINDER_CLEARED: {
                    actions: 'clearAuthReminder',
                  },
                  AUTH_REMINDER_DISMISSED: {
                    actions: 'dismissAuthReminder',
                  },
                  CONNECTION_ESTABLISHED: {
                    target: 'ready',
                    actions: 'updateConnectionState',
                  },
                  UPDATE_WEBVIEW_PANEL: {
                    actions: [
                      'updateWebviewPanelInContext',
                      'syncPendingDataIfAvailable',
                      'clearPendingData',
                    ],
                  },
                },
              },
            },
            on: {
              // Global events that can happen in any active state
              DEACTIVATE: 'deactivating',
              ERROR: {
                target: 'error_recovery',
                actions: 'recordError',
              },
            },
          },
          activation_failed: {
            on: {
              RETRY: 'activating',
              ACTIVATE: 'activating',
            },
          },
          error_recovery: {
            invoke: {
              src: 'recoverFromError',
              onDone: 'active',
              onError: {
                target: 'error_recovery',
                actions: 'incrementRecoveryAttempts',
              },
            },
            after: {
              5e3: {
                target: 'active',
                guard: 'canRecover',
              },
            },
          },
          deactivating: {
            invoke: {
              src: 'performDeactivation',
              input: ({ context }) => context,
              onDone: 'inactive',
              onError: 'inactive',
              // Force to inactive even on error
            },
            entry: 'markDeactivating',
          },
        },
      },
      {
        guards: {
          canRecover: ({ context }) => context.errorRecoveryAttempts < 3,
          hasActiveConnection: ({ context }) => {
            console.log('[ApplicationFSM] Checking hasActiveConnection guard:', {
              activeConnectionId: context.activeConnectionId,
              connectionStatesSize: context.connectionStates.size,
            });
            if (!context.activeConnectionId) {
              return false;
            }
            const connectionState = context.connectionStates.get(context.activeConnectionId);
            const hasClient = !!connectionState?.client;
            const hasProvider = !!connectionState?.provider;
            console.log('[ApplicationFSM] Connection state check:', {
              connectionId: context.activeConnectionId,
              hasState: !!connectionState,
              hasClient,
              hasProvider,
              shouldTriggerLoading: hasClient && hasProvider,
            });
            return hasClient && hasProvider;
          },
          hasWebviewPanel: ({ context }) => {
            const hasPanel = !!context.webviewPanel;
            console.log('[ApplicationFSM] Checking hasWebviewPanel guard:', {
              hasPanel,
              webviewPanelType: typeof context.webviewPanel,
              webviewPanelValue: context.webviewPanel,
              contextKeys: Object.keys(context),
              fullContext: JSON.stringify(context, null, 2),
            });
            return hasPanel;
          },
          canLoadData: ({ context }) => {
            const hasConnection = !!(
              context.activeConnectionId && context.connectionStates.size > 0
            );
            console.log('[ApplicationFSM] Checking canLoadData guard:', {
              hasConnection,
              activeConnectionId: context.activeConnectionId,
              connectionStatesSize: context.connectionStates.size,
              canLoad: hasConnection,
            });
            return hasConnection;
          },
        },
        actions: {
          // Universal event logger - catches ALL events sent to FSM
          logAllEvents: ({ context, event: event2 }) => {
            if (event2.type === 'WORK_ITEMS_LOADED') {
              console.log(
                '[ApplicationFSM] \u{1F525} UNIVERSAL EVENT LOGGER: WORK_ITEMS_LOADED received!',
                {
                  eventType: event2.type,
                  workItemCount: event2?.workItems?.length || 0,
                  connectionId: event2?.connectionId,
                  timestamp: Date.now(),
                }
              );
            } else {
              console.log('[ApplicationFSM] \u{1F50D} UNIVERSAL EVENT LOGGER: Event received:', {
                eventType: event2.type,
                timestamp: Date.now(),
              });
            }
          },
          // Pure assignment actions (no side effects)
          storeExtensionContext: assign({
            extensionContext: ({ event: event2 }) =>
              event2.type === 'ACTIVATE' ? event2.context : void 0,
          }),
          markActivated: assign({
            isActivated: true,
          }),
          recordActivationError: assign({
            lastError: ({ event: event2 }) => (event2.type === 'ERROR' ? event2.error : void 0),
          }),
          registerConnections: assign({
            connections: ({ event: event2 }) =>
              event2.type === 'CONNECTIONS_LOADED' ? event2.connections : [],
          }),
          loadConnectionsFromUISetup: () => {},
          showWebview: () => {
            try {
              import('vscode')
                .then((vscode9) => {
                  vscode9.commands.executeCommand(
                    'workbench.view.extension.azureDevOpsIntegration'
                  );
                  setTimeout(() => {
                    vscode9.commands.executeCommand('azureDevOpsWorkItems.focus');
                  }, 100);
                })
                .catch((error) => {
                  console.warn('[ApplicationFSM] Failed to show webview:', error);
                });
            } catch (error) {
              console.warn('[ApplicationFSM] Failed to import vscode module:', error);
            }
          },
          recordAuthenticationSuccess: assign(({ context, event: event2 }) => {
            const newPendingAuthReminders = (() => {
              if (event2.type === 'AUTHENTICATION_SUCCESS') {
                const newReminders = new Map(context.pendingAuthReminders);
                newReminders.delete(event2.connectionId);
                return newReminders;
              }
              return context.pendingAuthReminders;
            })();
            return {
              ...context,
              // Preserve ALL existing context properties
              pendingAuthReminders: newPendingAuthReminders,
              // Only change what we need
            };
          }),
          recordAuthenticationFailure: assign(({ context, event: event2 }) => {
            const newPendingAuthReminders = (() => {
              if (event2.type === 'AUTHENTICATION_FAILED') {
                const newReminders = new Map(context.pendingAuthReminders);
                newReminders.set(event2.connectionId, {
                  connectionId: event2.connectionId,
                  status: 'pending',
                  reason: 'authFailed',
                  detail: event2.error,
                });
                return newReminders;
              }
              return context.pendingAuthReminders;
            })();
            return {
              ...context,
              // Preserve ALL existing context properties
              pendingAuthReminders: newPendingAuthReminders,
              // Only change what we need
            };
          }),
          recordAuthReminder: assign(({ context, event: event2 }) => {
            if (event2.type !== 'AUTH_REMINDER_SET') {
              return context;
            }
            const newPendingAuthReminders = new Map(context.pendingAuthReminders);
            newPendingAuthReminders.set(event2.connectionId, {
              ...event2.reminder,
              connectionId: event2.connectionId,
              status: event2.reminder.status ?? 'pending',
            });
            return {
              ...context,
              pendingAuthReminders: newPendingAuthReminders,
            };
          }),
          clearAuthReminder: assign(({ context, event: event2 }) => {
            if (event2.type !== 'AUTH_REMINDER_CLEARED') {
              return context;
            }
            const newPendingAuthReminders = new Map(context.pendingAuthReminders);
            newPendingAuthReminders.delete(event2.connectionId);
            return {
              ...context,
              pendingAuthReminders: newPendingAuthReminders,
            };
          }),
          dismissAuthReminder: assign(({ context, event: event2 }) => {
            if (event2.type !== 'AUTH_REMINDER_DISMISSED') {
              return context;
            }
            const newPendingAuthReminders = new Map(context.pendingAuthReminders);
            const existing = newPendingAuthReminders.get(event2.connectionId);
            if (!existing) {
              return context;
            }
            newPendingAuthReminders.set(event2.connectionId, {
              ...existing,
              status: 'dismissed',
              snoozeUntil: event2.snoozeUntil,
            });
            return {
              ...context,
              pendingAuthReminders: newPendingAuthReminders,
            };
          }),
          recordError: assign(({ context, event: event2 }) => ({
            ...context,
            // Preserve ALL existing context properties
            lastError: event2.type === 'ERROR' ? event2.error : void 0,
            // Only change what we need
          })),
          updateWebviewPanelInContext: assign(({ context, event: event2 }) => {
            if (event2.type === 'UPDATE_WEBVIEW_PANEL') {
              console.log('[ApplicationFSM] WEBVIEW_PANEL_TRACE - Setting panel:', {
                eventType: event2.type,
                hasIncomingPanel: !!event2.webviewPanel,
                currentContextPanel: !!context.webviewPanel,
                incomingPanelType: typeof event2.webviewPanel,
                contextPanelType: typeof context.webviewPanel,
                timestamp: Date.now(),
              });
              const updatedContext = {
                ...context,
                // Preserve ALL existing context properties
                webviewPanel: event2.webviewPanel,
                // Only update what we need
              };
              console.log('[ApplicationFSM] WEBVIEW_PANEL_TRACE - Panel set result:', {
                hasUpdatedPanel: !!updatedContext.webviewPanel,
                updatedPanelType: typeof updatedContext.webviewPanel,
                allContextKeys: Object.keys(updatedContext).length,
              });
              return updatedContext;
            }
            console.log(
              '[ApplicationFSM] WEBVIEW_PANEL_TRACE - Non-UPDATE event, preserving context:',
              {
                eventType: event2.type,
                hasCurrentPanel: !!context.webviewPanel,
                currentPanelType: typeof context.webviewPanel,
                timestamp: Date.now(),
              }
            );
            return context;
          }),
          updateConnectionState: assign(({ context, event: event2 }) => {
            console.log('[ApplicationFSM] WEBVIEW_PANEL_TRACE - updateConnectionState ENTRY:', {
              eventType: event2.type,
              connectionId:
                event2.type === 'CONNECTION_ESTABLISHED' ? event2.connectionId : 'not applicable',
              currentWebviewPanel: !!context.webviewPanel,
              webviewPanelType: typeof context.webviewPanel,
              allContextKeys: Object.keys(context).sort(),
              timestamp: Date.now(),
            });
            const activeConnectionId3 = (() => {
              if (event2.type === 'CONNECTION_ESTABLISHED') {
                return event2.connectionId;
              }
              return context.activeConnectionId;
            })();
            const connectionStates3 = (() => {
              if (event2.type === 'CONNECTION_ESTABLISHED' && event2.connectionState) {
                const newStates = new Map(context.connectionStates);
                newStates.set(event2.connectionId, event2.connectionState);
                console.log(
                  '[ApplicationFSM] updateConnectionState - AFTER storing connection state:',
                  {
                    connectionId: event2.connectionId,
                    hasClient: !!event2.connectionState.client,
                    hasProvider: !!event2.connectionState.provider,
                    authMethod: event2.connectionState.authMethod,
                    totalConnections: newStates.size,
                    webviewPanelPreserved: !!context.webviewPanel,
                    webviewPanelType: typeof context.webviewPanel,
                  }
                );
                return newStates;
              }
              return context.connectionStates;
            })();
            const updatedContext = {
              ...context,
              // Preserve ALL existing context properties including webviewPanel
              activeConnectionId: activeConnectionId3,
              // Only change what we need
              connectionStates: connectionStates3,
            };
            console.log('[ApplicationFSM] WEBVIEW_PANEL_TRACE - updateConnectionState EXIT:', {
              hasWebviewPanel: !!updatedContext.webviewPanel,
              webviewPanelType: typeof updatedContext.webviewPanel,
              preservedFromInput: !!context.webviewPanel,
              allContextKeys: Object.keys(updatedContext).sort(),
              timestamp: Date.now(),
            });
            return updatedContext;
          }),
          syncPendingDataIfAvailable: ({ context }) => {
            console.log(
              '[ApplicationFSM] syncPendingDataIfAvailable called - DETAILED context check:',
              {
                hasWebviewPanel: !!context.webviewPanel,
                hasPendingWorkItems: !!context.pendingWorkItems,
                webviewPanelType: typeof context.webviewPanel,
                webviewPanelValue: context.webviewPanel,
                contextKeys: Object.keys(context),
                fullContextSubset: {
                  isActivated: context.isActivated,
                  activeConnectionId: context.activeConnectionId,
                  connectionStatesSize: context.connectionStates.size,
                  webviewPanel: context.webviewPanel,
                },
              }
            );
            if (context.webviewPanel && context.pendingWorkItems) {
              console.log(
                '[ApplicationFSM] Webview panel now available - syncing pending work items:',
                {
                  workItemCount: context.pendingWorkItems.workItems.length,
                  connectionId: context.pendingWorkItems.connectionId,
                }
              );
              const pendingData = context.pendingWorkItems;
              const workItems = pendingData.workItems;
              if (context.webviewPanel?.webview?.postMessage) {
                try {
                  context.webviewPanel.webview.postMessage({
                    type: 'work-items-update',
                    workItems,
                    source: 'fsm-pending-sync',
                    metadata: {
                      workItemsCount: workItems.length,
                      connectionId: pendingData.connectionId,
                      query: pendingData.query,
                      firstWorkItem: workItems[0]
                        ? {
                            id: workItems[0].id,
                            title: workItems[0].title || workItems[0].fields?.['System.Title'],
                            state: workItems[0].state || workItems[0].fields?.['System.State'],
                          }
                        : null,
                    },
                  });
                } catch (error) {
                  console.error(
                    '[ApplicationFSM] Failed to sync pending work items to webview:',
                    error
                  );
                }
              }
            }
          },
          clearPendingData: assign(({ context }) => {
            console.log('[ApplicationFSM] WEBVIEW_PANEL_TRACE - clearPendingData BEFORE:', {
              hasWebviewPanel: !!context.webviewPanel,
              webviewPanelType: typeof context.webviewPanel,
              contextKeys: Object.keys(context).length,
              timestamp: Date.now(),
            });
            const updatedContext = {
              ...context,
              // Preserve ALL existing context properties
              pendingWorkItems: void 0,
              // Only change what we need to change
            };
            console.log('[ApplicationFSM] WEBVIEW_PANEL_TRACE - clearPendingData AFTER:', {
              hasWebviewPanel: !!updatedContext.webviewPanel,
              webviewPanelType: typeof updatedContext.webviewPanel,
              contextKeys: Object.keys(updatedContext).length,
              timestamp: Date.now(),
            });
            return updatedContext;
          }),
          incrementRecoveryAttempts: assign(({ context }) => ({
            ...context,
            // Preserve ALL existing context properties
            errorRecoveryAttempts: context.errorRecoveryAttempts + 1,
            // Only change what we need
          })),
          markDeactivating: assign(({ context }) => ({
            ...context,
            // Preserve ALL existing context properties
            isDeactivating: true,
            // Only change what we need
          })),
          // Delegation actions (invoke single-purpose functions)
          initializeChildActors: ({ context }) => {
            initializeTimerActor(context);
          },
          delegateConnectionActivation: ({ context, event: event2 }) => {
            if (event2.type === 'CONNECTION_SELECTED') {
              activateConnection(context, event2.connectionId);
            }
          },
          delegateAuthenticationStart: ({ context, event: event2 }) => {
            if (event2.type === 'AUTHENTICATION_REQUIRED') {
              startAuthentication(context, event2.connectionId);
            }
          },
          notifyWebviewReady: ({ context }) => {
            notifyWebviewReady(context);
          },
          routeWebviewMessage: ({ context, event: event2 }) => {
            if (event2.type === 'WEBVIEW_MESSAGE') {
              routeWebviewMessage(context, event2.message);
            }
          },
          // Data loading debugging action
          checkForDataLoading: ({ context }) => {
            const hasActiveConnection = !!(
              context.activeConnectionId && context.connectionStates.size > 0
            );
            console.log('[ApplicationFSM] Data state idle - checking prerequisites for loading:', {
              activeConnectionId: context.activeConnectionId,
              connectionStatesSize: context.connectionStates.size,
              hasActiveConnection,
              stateBasedApproach: 'Panel existence guaranteed by state transitions',
            });
          },
          // Data synchronization actions
          syncDataToWebview: ({ context, event: event2 }) => {
            console.log('[ApplicationFSM] \u{1F525} syncDataToWebview ACTION CALLED!', {
              eventType: event2.type,
              hasWorkItems: 'workItems' in event2,
              hasData: 'data' in event2,
            });
            let workItems = [];
            let connectionId;
            let query;
            let source2 = 'unknown';
            if (event2.type === 'WORK_ITEMS_LOADED' && 'workItems' in event2) {
              workItems = event2.workItems || [];
              connectionId = event2.connectionId;
              query = event2.query;
              source2 = 'provider';
            } else if ('data' in event2 && event2.data) {
              const data = event2.data;
              workItems = data.workItems || [];
              connectionId = data.connectionId;
              query = data.query;
              source2 = 'loadData';
            }
            console.log('[ApplicationFSM] Syncing data to webview store:', {
              source: source2,
              workItemCount: workItems.length,
              eventType: event2.type,
              connectionId,
              stateBasedSyncGuarantee: 'Panel guaranteed by ready state',
            });
            try {
              context.webviewPanel.webview.postMessage({
                type: 'work-items-update',
                workItems,
                source: 'fsm-store-update',
                metadata: {
                  workItemsCount: workItems.length,
                  connectionId,
                  query,
                  source: source2,
                  firstWorkItem: workItems[0]
                    ? {
                        id: workItems[0].id,
                        title: workItems[0].title || workItems[0].fields?.['System.Title'],
                        state: workItems[0].state || workItems[0].fields?.['System.State'],
                      }
                    : null,
                },
              });
            } catch (error) {
              console.error('[ApplicationFSM] Failed to sync work items to webview:', error);
            }
          },
        },
        actors: {
          performActivation: fromPromise(performActivation),
          performDeactivation: fromPromise(performDeactivation),
          setupUI: fromPromise(setupUI),
          loadData: fromPromise(loadData),
          recoverFromError: fromPromise(recoverFromError),
        },
      }
    );
  },
});

// src/stores/applicationStore.ts
var applicationStore_exports = {};
__export(applicationStore_exports, {
  actions: () => actions,
  activeConnectionId: () => activeConnectionId,
  applicationState: () => applicationState,
  applicationStore: () => applicationStore,
  connectionStates: () => connectionStates,
  connections: () => connections,
  dataError: () => dataError,
  debug: () => storeDebug,
  default: () => applicationStore_default,
  isActivated: () => isActivated,
  isDataLoading: () => isDataLoading,
  isDataSynced: () => isDataSynced,
  isDeactivating: () => isDeactivating,
  isInErrorRecovery: () => isInErrorRecovery,
  isInitializing: () => isInitializing,
  lastError: () => lastError,
  pendingAuthReminders: () => pendingAuthReminders,
  selectors: () => selectors,
  storeDebug: () => storeDebug,
  uiError: () => uiError,
  webviewReady: () => webviewReady,
});
function createApplicationStore() {
  let applicationActor = createActor(applicationMachine);
  applicationActor.start();
  const applicationState2 = readable(null, (set2) => {
    const subscription = applicationActor.subscribe((state2) => {
      set2({
        value: state2.value,
        context: state2.context,
        matches: (stateValue) => state2.matches(stateValue),
        can: (event2) => state2.can(event2),
      });
    });
    return () => {
      subscription.unsubscribe();
      applicationActor?.stop();
    };
  });
  function send(event2) {
    applicationActor.send(event2);
  }
  return {
    applicationState: applicationState2,
    send,
    // Expose actor for debugging
    get actor() {
      return applicationActor;
    },
  };
}
var applicationStore,
  isActivated,
  isInitializing,
  isDeactivating,
  connections,
  activeConnectionId,
  connectionStates,
  pendingAuthReminders,
  webviewReady,
  uiError,
  isDataLoading,
  isDataSynced,
  dataError,
  lastError,
  isInErrorRecovery,
  actions,
  selectors,
  storeDebug,
  applicationState,
  applicationStore_default;
var init_applicationStore = __esm({
  'src/stores/applicationStore.ts'() {
    'use strict';
    init_index_server();
    init_xstate_esm();
    init_applicationMachine();
    init_extensionHostBridge();
    applicationStore = createApplicationStore();
    setApplicationStoreBridge({
      getActor: () => applicationStore.actor,
      send: (event2) => applicationStore.send(event2),
    });
    isActivated = derived2(
      applicationStore.applicationState,
      ($state) => $state?.context.isActivated ?? false
    );
    isInitializing = derived2(
      applicationStore.applicationState,
      ($state) => $state?.matches('activating') ?? false
    );
    isDeactivating = derived2(
      applicationStore.applicationState,
      ($state) => $state?.context.isDeactivating ?? false
    );
    connections = derived2(
      applicationStore.applicationState,
      ($state) => $state?.context.connections ?? []
    );
    activeConnectionId = derived2(
      applicationStore.applicationState,
      ($state) => $state?.context.activeConnectionId
    );
    connectionStates = derived2(
      applicationStore.applicationState,
      ($state) => $state?.context.connectionStates ?? /* @__PURE__ */ new Map()
    );
    pendingAuthReminders = derived2(
      applicationStore.applicationState,
      ($state) => $state?.context.pendingAuthReminders ?? /* @__PURE__ */ new Map()
    );
    webviewReady = derived2(
      applicationStore.applicationState,
      ($state) => $state?.matches('active.ui.ready') ?? false
    );
    uiError = derived2(
      applicationStore.applicationState,
      ($state) => $state?.matches('active.ui.ui_error') ?? false
    );
    isDataLoading = derived2(
      applicationStore.applicationState,
      ($state) => $state?.matches('active.data.loading') ?? false
    );
    isDataSynced = derived2(
      applicationStore.applicationState,
      ($state) => $state?.matches('active.data.synced') ?? false
    );
    dataError = derived2(
      applicationStore.applicationState,
      ($state) => $state?.matches('active.data.sync_error') ?? false
    );
    lastError = derived2(applicationStore.applicationState, ($state) => $state?.context.lastError);
    isInErrorRecovery = derived2(
      applicationStore.applicationState,
      ($state) => $state?.matches('error_recovery') ?? false
    );
    actions = {
      // Extension Lifecycle
      activate: (context) => applicationStore.send({ type: 'ACTIVATE', context }),
      deactivate: () => applicationStore.send({ type: 'DEACTIVATE' }),
      // Connection Management
      loadConnections: (connections3) =>
        applicationStore.send({ type: 'CONNECTIONS_LOADED', connections: connections3 }),
      selectConnection: (connectionId) =>
        applicationStore.send({ type: 'CONNECTION_SELECTED', connectionId }),
      // Authentication
      requireAuthentication: (connectionId) =>
        applicationStore.send({ type: 'AUTHENTICATION_REQUIRED', connectionId }),
      authenticationSuccess: (connectionId) =>
        applicationStore.send({ type: 'AUTHENTICATION_SUCCESS', connectionId }),
      authenticationFailed: (connectionId, error) =>
        applicationStore.send({ type: 'AUTHENTICATION_FAILED', connectionId, error }),
      // UI Events
      webviewReady: () => applicationStore.send({ type: 'WEBVIEW_READY' }),
      webviewMessage: (message) => applicationStore.send({ type: 'WEBVIEW_MESSAGE', message }),
      // Error Handling
      reportError: (error) => applicationStore.send({ type: 'ERROR', error }),
      retry: () => applicationStore.send({ type: 'RETRY' }),
      reset: () => applicationStore.send({ type: 'RESET' }),
    };
    selectors = {
      // Get initialization status with detailed sub-state
      getInitializationStatus: derived2(applicationStore.applicationState, ($state) => {
        if (!$state) return { phase: 'inactive', progress: 0 };
        if ($state.matches('inactive')) {
          return { phase: 'inactive', progress: 0 };
        }
        if ($state.matches('activating')) {
          return { phase: 'activating', progress: 25 };
        }
        if ($state.matches('active.ui.initializing')) {
          return { phase: 'ui-setup', progress: 50 };
        }
        if ($state.matches('active.ui.ready') && !$state.matches('active.data.synced')) {
          return { phase: 'loading-data', progress: 75 };
        }
        if ($state.matches('active.data.synced')) {
          return { phase: 'ready', progress: 100 };
        }
        return { phase: 'unknown', progress: 0 };
      }),
      // Get connection by ID
      getConnectionById: (connectionId) =>
        derived2([connections, connectionStates], ([$connections, $connectionStates]) => {
          const config = $connections.find((c) => c.id === connectionId);
          const state2 = $connectionStates.get(connectionId);
          return config ? { ...config, state: state2 } : null;
        }),
      // Get auth reminders as array
      getAuthRemindersArray: derived2(pendingAuthReminders, ($reminders) =>
        Array.from($reminders.values())
      ),
      // Check if can perform actions
      canActivate: derived2(
        applicationStore.applicationState,
        ($state) => $state?.can({ type: 'ACTIVATE', context: null }) ?? false
      ),
      canDeactivate: derived2(
        applicationStore.applicationState,
        ($state) => $state?.can({ type: 'DEACTIVATE' }) ?? false
      ),
      canRetry: derived2(
        applicationStore.applicationState,
        ($state) => $state?.can({ type: 'RETRY' }) ?? false
      ),
    };
    storeDebug = {
      // Get current state snapshot
      getSnapshot: () => {
        const actor = applicationStore.actor;
        return actor ? actor.getSnapshot() : null;
      },
      // Get state as string for logging
      getStateString: () => {
        const snapshot2 = storeDebug.getSnapshot();
        return snapshot2 ? JSON.stringify(snapshot2.value) : 'not-started';
      },
      // Send arbitrary event (for testing)
      send: (event2) => applicationStore.send(event2),
      // Get full context (for debugging)
      getContext: () => {
        const snapshot2 = storeDebug.getSnapshot();
        return snapshot2 ? snapshot2.context : null;
      },
    };
    applicationState = applicationStore.applicationState;
    applicationStore_default = applicationStore;
  },
});

// src/fsm/commands/quickDebugCommands.ts
var quickDebugCommands_exports = {};
__export(quickDebugCommands_exports, {
  registerQuickDebugCommands: () => registerQuickDebugCommands,
});
import * as vscode6 from 'vscode';
function registerQuickDebugCommands(context) {
  context.subscriptions.push(
    vscode6.commands.registerCommand('azureDevOpsInt.quickDebug', async () => {
      await showInstantDebugPanel();
    })
  );
  context.subscriptions.push(
    vscode6.commands.registerCommand('azureDevOpsInt.showFSMLogs', async () => {
      showFSMLogsNow();
    })
  );
  context.subscriptions.push(
    vscode6.commands.registerCommand('azureDevOpsInt.triageBrokenFeature', async () => {
      await triageBrokenFeature();
    })
  );
  fsmLogger.info('MACHINE' /* MACHINE */, 'Quick debug commands registered');
}
async function showInstantDebugPanel() {
  try {
    showFSMLogsNow();
    const stats = fsmTracer.getStats();
    const currentSession = fsmTracer.getCurrentSession();
    const analysis = analyzeCurrentTrace();
    const panel2 = vscode6.window.createWebviewPanel(
      'instantDebug',
      '\u{1F6A8} Instant Debug Panel',
      vscode6.ViewColumn.Beside,
      // Open beside current editor
      { enableScripts: false }
    );
    const recentErrors = fsmLogger
      .getLogBuffer()
      .filter((entry) => entry.level >= 2)
      .slice(-10)
      .reverse();
    panel2.webview.html = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <style>
          body { 
            font-family: var(--vscode-font-family); 
            color: var(--vscode-foreground);
            background: var(--vscode-editor-background);
            padding: 20px;
            line-height: 1.6;
          }
          .status-ok { color: var(--vscode-charts-green); }
          .status-warn { color: var(--vscode-charts-orange); }
          .status-error { color: var(--vscode-charts-red); }
          .metric {
            background: var(--vscode-textCodeBlock-background);
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 3px solid var(--vscode-charts-blue);
          }
          .error-item {
            background: var(--vscode-inputValidation-errorBackground);
            padding: 8px;
            margin: 5px 0;
            border-radius: 3px;
            border-left: 3px solid var(--vscode-charts-red);
          }
          .command-button {
            background: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            padding: 8px 16px;
            border: none;
            border-radius: 3px;
            margin: 5px;
            cursor: pointer;
          }
          .section {
            margin: 20px 0;
            padding: 15px;
            background: var(--vscode-editor-lineHighlightBackground);
            border-radius: 5px;
          }
        </style>
      </head>
      <body>
        <h1>\u{1F6A8} Instant Debug Panel</h1>
        <p><strong>Generated:</strong> ${/* @__PURE__ */ new Date().toLocaleString()}</p>
        
        <div class="section">
          <h2>\u{1F4CA} Current Status</h2>
          <div class="metric">
            <strong>FSM Tracing:</strong> 
            <span class="${currentSession ? 'status-ok' : 'status-error'}">
              ${currentSession ? `Active (${currentSession.entries.length} events)` : 'Inactive'}
            </span>
          </div>
          <div class="metric">
            <strong>Instrumented Actors:</strong> 
            <span class="${stats.instrumentedActors > 0 ? 'status-ok' : 'status-warn'}">
              ${stats.instrumentedActors}
            </span>
          </div>
          <div class="metric">
            <strong>Recent Errors:</strong> 
            <span class="${recentErrors.length === 0 ? 'status-ok' : 'status-error'}">
              ${recentErrors.length}
            </span>
          </div>
          ${
            analysis
              ? `
          <div class="metric">
            <strong>FSM Performance:</strong> 
            <span class="${analysis.performance.avgTransitionTime < 100 ? 'status-ok' : 'status-warn'}">
              ${Math.round(analysis.performance.avgTransitionTime)}ms avg
            </span>
          </div>
          `
              : ''
          }
        </div>

        ${
          recentErrors.length > 0
            ? `
        <div class="section">
          <h2>\u{1F534} Recent Errors</h2>
          ${recentErrors
            .map(
              (error) => `
            <div class="error-item">
              <strong>${new Date(error.timestamp).toLocaleTimeString()}</strong> 
              [${error.component}] ${error.message}
              ${error.data ? `<br><small>${JSON.stringify(error.data, null, 2)}</small>` : ''}
            </div>
          `
            )
            .join('')}
        </div>
        `
            : ''
        }

        <div class="section">
          <h2>\u{1F527} Quick Actions</h2>
          <p>Use Command Palette (Ctrl+Shift+P) to run:</p>
          <ul>
            <li><code>Azure DevOps Int (Debug): Show FSM Logs</code> - View detailed logs</li>
            <li><code>Azure DevOps Int (Debug): Export FSM Trace</code> - Save current trace</li>
            <li><code>Azure DevOps Int (Debug): Analyze FSM Trace</code> - Performance analysis</li>
            <li><code>Azure DevOps Int (Debug): Show FSM Trace Timeline</code> - Event timeline</li>
          </ul>
        </div>

        <div class="section">
          <h2>\u{1F4CB} System Info</h2>
          <div class="metric">
            <strong>Total FSM Sessions:</strong> ${stats.sessionsCount}<br>
            <strong>Total FSM Events:</strong> ${stats.totalEntries}<br>
            <strong>Current Session Events:</strong> ${stats.currentSessionEntries}
          </div>
        </div>

        <div class="section">
          <h2>\u{1F4A1} Debugging Tips</h2>
          <ul>
            <li>Check the <strong>FSM Output Channel</strong> for real-time logs</li>
            <li>Look for <code>\u{1F534}</code> error symbols in the console output</li>
            <li>Export traces when issues occur for later analysis</li>
            <li>Use timeline view to see event sequences</li>
          </ul>
        </div>
      </body>
      </html>
    `;
    vscode6.window.showInformationMessage(
      '\u{1F6A8} Debug panel opened! Check the FSM Output Channel for live logs.',
      'OK'
    );
  } catch (error) {
    vscode6.window.showErrorMessage(`Failed to show debug panel: ${error}`);
  }
}
function showFSMLogsNow() {
  try {
    fsmLogger.showOutputChannel();
    vscode6.window
      .showInformationMessage(
        '\u{1F4FA} FSM Output Channel opened. Also check Developer Console (Help > Toggle Developer Tools) for console.log output.',
        'Open Developer Tools'
      )
      .then((selection) => {
        if (selection === 'Open Developer Tools') {
          vscode6.commands.executeCommand('workbench.action.toggleDevTools');
        }
      });
    fsmLogger.info(
      'MACHINE' /* MACHINE */,
      '\u{1F50D} MANUAL DEBUG SESSION STARTED',
      {
        component: 'MACHINE' /* MACHINE */,
        event: 'DEBUG_SESSION_START',
      },
      {
        timestamp: /* @__PURE__ */ new Date().toISOString(),
        reason: 'User requested debug logs',
      }
    );
    fsmLogger.info(
      'APPLICATION' /* APPLICATION */,
      'FSM Output Channel opened - logs are now visible'
    );
  } catch (error) {
    console.error('\u274C Failed to show FSM logs:', error);
    vscode6.window.showErrorMessage(`Failed to show FSM logs: ${error}`);
  }
}
async function triageBrokenFeature() {
  try {
    const featureName = await vscode6.window.showInputBox({
      prompt: 'What feature is broken? (e.g., "sign-in button", "query sync", "timer")',
      placeHolder: 'Enter feature name...',
    });
    if (!featureName) return;
    const sessionId = fsmTracer.startNewSession(`Triage: ${featureName}`);
    showFSMLogsNow();
    fsmLogger.info(
      'MACHINE' /* MACHINE */,
      `\u{1F50D} FEATURE TRIAGE STARTED: ${featureName}`,
      {
        component: 'MACHINE' /* MACHINE */,
        event: 'TRIAGE_START',
      },
      {
        feature: featureName,
        sessionId,
        timestamp: /* @__PURE__ */ new Date().toISOString(),
      }
    );
    const panel2 = vscode6.window.createWebviewPanel(
      'featureTriage',
      `\u{1F50D} Triaging: ${featureName}`,
      vscode6.ViewColumn.Beside,
      { enableScripts: false }
    );
    panel2.webview.html = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <style>
          body { 
            font-family: var(--vscode-font-family); 
            color: var(--vscode-foreground);
            background: var(--vscode-editor-background);
            padding: 20px;
            line-height: 1.6;
          }
          .step {
            background: var(--vscode-textCodeBlock-background);
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 3px solid var(--vscode-charts-blue);
          }
          .highlight {
            background: var(--vscode-editor-selectionBackground);
            padding: 2px 4px;
            border-radius: 3px;
          }
        </style>
      </head>
      <body>
        <h1>\u{1F50D} Feature Triage: ${featureName}</h1>
        <p><strong>Debug session started:</strong> ${sessionId}</p>
        
        <h2>\u{1F4CB} Triage Steps</h2>
        
        <div class="step">
          <h3>1. Reproduce the Issue</h3>
          <p>Try to use the <span class="highlight">${featureName}</span> feature now.</p>
          <p>The FSM Output Channel is open and logging all activity.</p>
        </div>
        
        <div class="step">
          <h3>2. Watch for Errors</h3>
          <p>Look for <code>\u{1F534}</code> error messages in the FSM Output Channel.</p>
          <p>Also check the Developer Console (Help > Toggle Developer Tools).</p>
        </div>
        
        <div class="step">
          <h3>3. Capture the Trace</h3>
          <p>After reproducing the issue, run:</p>
          <p><code>Azure DevOps Int (Debug): Export FSM Trace</code></p>
        </div>
        
        <div class="step">
          <h3>4. Analyze Results</h3>
          <p>Run <code>Azure DevOps Int (Debug): Analyze FSM Trace</code> to see patterns.</p>
          <p>Check the timeline with <code>Show FSM Trace Timeline</code>.</p>
        </div>
        
        <h2>\u{1F3AF} What to Look For</h2>
        <ul>
          <li><strong>Missing Events:</strong> Expected FSM events that don't appear</li>
          <li><strong>Error Messages:</strong> Red error logs with stack traces</li>
          <li><strong>State Transitions:</strong> FSM getting stuck in wrong states</li>
          <li><strong>Message Flow:</strong> Webview \u2194 Extension communication issues</li>
        </ul>
        
        <p><strong>Pro tip:</strong> This triage session is being traced. Export it when done!</p>
      </body>
      </html>
    `;
    vscode6.window.showInformationMessage(
      `\u{1F50D} Triage started for "${featureName}". Try to reproduce the issue now - everything is being logged!`,
      'OK'
    );
  } catch (error) {
    vscode6.window.showErrorMessage(`Failed to start feature triage: ${error}`);
  }
}
var init_quickDebugCommands = __esm({
  'src/fsm/commands/quickDebugCommands.ts'() {
    'use strict';
    init_FSMLogger();
    init_FSMTracer();
  },
});

// src/fsm/commands/outputChannelReader.ts
var outputChannelReader_exports = {};
__export(outputChannelReader_exports, {
  OutputChannelReader: () => OutputChannelReader,
  getFSMLogsForDebugging: () => getFSMLogsForDebugging,
  registerOutputChannelReader: () => registerOutputChannelReader,
});
import * as vscode7 from 'vscode';
async function getFSMLogsForDebugging(context) {
  const reader = OutputChannelReader.getInstance();
  const recentLogs = reader.getRecentLogs(100);
  const stats = reader.getLogStats();
  const report = `
=== FSM Debug Log Report ===
Generated: ${/* @__PURE__ */ new Date().toISOString()}

=== Statistics ===
Total Logs: ${stats.totalLogs}
Active Components: ${stats.componentsActive.join(', ')}
Last Log: ${stats.lastLogTime || 'None'}
Errors: ${stats.errorCount}
Warnings: ${stats.warningCount}

=== Recent Logs (Last 100) ===
${recentLogs.join('\n')}

=== End Report ===
`;
  return report;
}
function registerOutputChannelReader(context) {
  const reader = OutputChannelReader.getInstance();
  const disposable = vscode7.commands.registerCommand(
    'azureDevOpsInt.getFSMLogs',
    async (options) => {
      try {
        if (options?.format === 'json') {
          return {
            logs: reader.getAllLogs(),
            stats: reader.getLogStats(),
            timestamp: /* @__PURE__ */ new Date().toISOString(),
          };
        } else {
          return await getFSMLogsForDebugging(context);
        }
      } catch (error) {
        console.error('[OutputChannelReader] Error getting FSM logs:', error);
        return `Error retrieving FSM logs: ${error}`;
      }
    }
  );
  context.subscriptions.push(disposable);
  const debugCommand = vscode7.commands.registerCommand(
    'azureDevOpsInt.exportFSMLogs',
    async () => {
      try {
        const logs = await getFSMLogsForDebugging(context);
        const doc = await vscode7.workspace.openTextDocument({
          content: logs,
          language: 'log',
        });
        await vscode7.window.showTextDocument(doc);
        vscode7.window.showInformationMessage('FSM logs exported to new document');
      } catch (error) {
        vscode7.window.showErrorMessage(`Failed to export FSM logs: ${error}`);
      }
    }
  );
  context.subscriptions.push(debugCommand);
}
var OutputChannelReader;
var init_outputChannelReader = __esm({
  'src/fsm/commands/outputChannelReader.ts'() {
    'use strict';
    init_FSMLogger();
    OutputChannelReader = class _OutputChannelReader {
      static instance;
      logBuffer = [];
      maxBufferSize = 1e3;
      // Keep last 1000 log entries
      constructor() {
        this.setupLogCapture();
      }
      static getInstance() {
        if (!_OutputChannelReader.instance) {
          _OutputChannelReader.instance = new _OutputChannelReader();
        }
        return _OutputChannelReader.instance;
      }
      /**
       * Setup log capture by intercepting FSM logger output
       */
      setupLogCapture() {
        const originalAppendLine = fsmLogger.outputChannel?.appendLine?.bind(
          fsmLogger.outputChannel
        );
        if (fsmLogger.outputChannel && originalAppendLine) {
          fsmLogger.outputChannel.appendLine = (value) => {
            this.logBuffer.push(`${/* @__PURE__ */ new Date().toISOString()} ${value}`);
            if (this.logBuffer.length > this.maxBufferSize) {
              this.logBuffer = this.logBuffer.slice(-this.maxBufferSize);
            }
            return originalAppendLine(value);
          };
        }
      }
      /**
       * Get recent FSM logs
       */
      getRecentLogs(count = 50) {
        return this.logBuffer.slice(-count);
      }
      /**
       * Get all captured logs
       */
      getAllLogs() {
        return [...this.logBuffer];
      }
      /**
       * Get logs matching a pattern
       */
      getLogsMatching(pattern) {
        const regex = typeof pattern === 'string' ? new RegExp(pattern, 'i') : pattern;
        return this.logBuffer.filter((log2) => regex.test(log2));
      }
      /**
       * Get logs from the last N minutes
       */
      getLogsFromLastMinutes(minutes) {
        const cutoffTime = new Date(Date.now() - minutes * 60 * 1e3);
        return this.logBuffer.filter((log2) => {
          const timestamp = log2.substring(0, 24);
          try {
            const logTime = new Date(timestamp);
            return logTime >= cutoffTime;
          } catch {
            return false;
          }
        });
      }
      /**
       * Export logs as formatted text
       */
      exportLogsAsText(filter2) {
        let logs = this.logBuffer;
        if (filter2) {
          if (filter2.lastMinutes) {
            logs = this.getLogsFromLastMinutes(filter2.lastMinutes);
          }
          if (filter2.component) {
            logs = logs.filter((log2) => log2.includes(`[${filter2.component}]`));
          }
          if (filter2.level) {
            logs = logs.filter((log2) => log2.includes(filter2.level));
          }
          if (filter2.pattern) {
            const regex =
              typeof filter2.pattern === 'string'
                ? new RegExp(filter2.pattern, 'i')
                : filter2.pattern;
            logs = logs.filter((log2) => regex.test(log2));
          }
        }
        return logs.join('\n');
      }
      /**
       * Clear the log buffer
       */
      clearBuffer() {
        this.logBuffer = [];
      }
      /**
       * Get summary statistics about captured logs
       */
      getLogStats() {
        const components = /* @__PURE__ */ new Set();
        let errorCount = 0;
        let warningCount = 0;
        let lastLogTime;
        this.logBuffer.forEach((log2) => {
          const componentMatch = log2.match(/\[FSM\]\[([^\]]+)\]/);
          if (componentMatch) {
            components.add(componentMatch[1]);
          }
          if (log2.includes('ERROR')) errorCount++;
          if (log2.includes('WARN')) warningCount++;
          const timestamp = log2.substring(0, 24);
          if (timestamp.includes('T')) {
            lastLogTime = timestamp;
          }
        });
        return {
          totalLogs: this.logBuffer.length,
          componentsActive: Array.from(components),
          lastLogTime,
          errorCount,
          warningCount,
        };
      }
    };
  },
});

// src/fsm/functions/authFunctions.ts
function isTokenValid(tokenInfo, bufferMs = 5 * 60 * 1e3) {
  if (!tokenInfo || !tokenInfo.expiresAt) {
    return false;
  }
  let expiryMs;
  if (tokenInfo.expiresAt instanceof Date) {
    expiryMs = tokenInfo.expiresAt.getTime();
  } else if (typeof tokenInfo.expiresAt === 'number') {
    expiryMs = tokenInfo.expiresAt;
  } else if (typeof tokenInfo.expiresAt === 'string') {
    const parsed = Date.parse(tokenInfo.expiresAt);
    expiryMs = Number.isNaN(parsed) ? void 0 : parsed;
  }
  if (typeof expiryMs !== 'number' || !Number.isFinite(expiryMs)) {
    return false;
  }
  return expiryMs - bufferMs > Date.now();
}
var init_authFunctions = __esm({
  'src/fsm/functions/authFunctions.ts'() {
    'use strict';
    init_FSMLogger();
  },
});

// node_modules/@azure/msal-node/dist/cache/serializer/Serializer.mjs
var Serializer;
var init_Serializer = __esm({
  'node_modules/@azure/msal-node/dist/cache/serializer/Serializer.mjs'() {
    'use strict';
    Serializer = class {
      /**
       * serialize the JSON blob
       * @param data - JSON blob cache
       */
      static serializeJSONBlob(data) {
        return JSON.stringify(data);
      }
      /**
       * Serialize Accounts
       * @param accCache - cache of accounts
       */
      static serializeAccounts(accCache) {
        const accounts = {};
        Object.keys(accCache).map(function (key2) {
          const accountEntity = accCache[key2];
          accounts[key2] = {
            home_account_id: accountEntity.homeAccountId,
            environment: accountEntity.environment,
            realm: accountEntity.realm,
            local_account_id: accountEntity.localAccountId,
            username: accountEntity.username,
            authority_type: accountEntity.authorityType,
            name: accountEntity.name,
            client_info: accountEntity.clientInfo,
            last_modification_time: accountEntity.lastModificationTime,
            last_modification_app: accountEntity.lastModificationApp,
            tenantProfiles: accountEntity.tenantProfiles?.map((tenantProfile) => {
              return JSON.stringify(tenantProfile);
            }),
          };
        });
        return accounts;
      }
      /**
       * Serialize IdTokens
       * @param idTCache - cache of ID tokens
       */
      static serializeIdTokens(idTCache) {
        const idTokens = {};
        Object.keys(idTCache).map(function (key2) {
          const idTEntity = idTCache[key2];
          idTokens[key2] = {
            home_account_id: idTEntity.homeAccountId,
            environment: idTEntity.environment,
            credential_type: idTEntity.credentialType,
            client_id: idTEntity.clientId,
            secret: idTEntity.secret,
            realm: idTEntity.realm,
          };
        });
        return idTokens;
      }
      /**
       * Serializes AccessTokens
       * @param atCache - cache of access tokens
       */
      static serializeAccessTokens(atCache) {
        const accessTokens = {};
        Object.keys(atCache).map(function (key2) {
          const atEntity = atCache[key2];
          accessTokens[key2] = {
            home_account_id: atEntity.homeAccountId,
            environment: atEntity.environment,
            credential_type: atEntity.credentialType,
            client_id: atEntity.clientId,
            secret: atEntity.secret,
            realm: atEntity.realm,
            target: atEntity.target,
            cached_at: atEntity.cachedAt,
            expires_on: atEntity.expiresOn,
            extended_expires_on: atEntity.extendedExpiresOn,
            refresh_on: atEntity.refreshOn,
            key_id: atEntity.keyId,
            token_type: atEntity.tokenType,
            requestedClaims: atEntity.requestedClaims,
            requestedClaimsHash: atEntity.requestedClaimsHash,
            userAssertionHash: atEntity.userAssertionHash,
          };
        });
        return accessTokens;
      }
      /**
       * Serialize refreshTokens
       * @param rtCache - cache of refresh tokens
       */
      static serializeRefreshTokens(rtCache) {
        const refreshTokens = {};
        Object.keys(rtCache).map(function (key2) {
          const rtEntity = rtCache[key2];
          refreshTokens[key2] = {
            home_account_id: rtEntity.homeAccountId,
            environment: rtEntity.environment,
            credential_type: rtEntity.credentialType,
            client_id: rtEntity.clientId,
            secret: rtEntity.secret,
            family_id: rtEntity.familyId,
            target: rtEntity.target,
            realm: rtEntity.realm,
          };
        });
        return refreshTokens;
      }
      /**
       * Serialize amdtCache
       * @param amdtCache - cache of app metadata
       */
      static serializeAppMetadata(amdtCache) {
        const appMetadata = {};
        Object.keys(amdtCache).map(function (key2) {
          const amdtEntity = amdtCache[key2];
          appMetadata[key2] = {
            client_id: amdtEntity.clientId,
            environment: amdtEntity.environment,
            family_id: amdtEntity.familyId,
          };
        });
        return appMetadata;
      }
      /**
       * Serialize the cache
       * @param inMemCache - itemised cache read from the JSON
       */
      static serializeAllCache(inMemCache) {
        return {
          Account: this.serializeAccounts(inMemCache.accounts),
          IdToken: this.serializeIdTokens(inMemCache.idTokens),
          AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),
          RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),
          AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata),
        };
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/utils/Constants.mjs
var Constants,
  HttpStatus,
  OIDC_DEFAULT_SCOPES,
  OIDC_SCOPES,
  HeaderNames,
  AADAuthorityConstants,
  ClaimsRequestKeys,
  PromptValue,
  CodeChallengeMethodValues,
  OAuthResponseType,
  ResponseMode,
  GrantType,
  CacheAccountType,
  Separators,
  CredentialType,
  APP_METADATA,
  CLIENT_INFO,
  THE_FAMILY_ID,
  AUTHORITY_METADATA_CONSTANTS,
  AuthorityMetadataSource,
  SERVER_TELEM_CONSTANTS,
  AuthenticationScheme,
  ThrottlingConstants,
  Errors,
  PasswordGrantConstants,
  RegionDiscoverySources,
  RegionDiscoveryOutcomes,
  CacheOutcome,
  DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
  EncodingTypes;
var init_Constants = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/utils/Constants.mjs'() {
    'use strict';
    Constants = {
      LIBRARY_NAME: 'MSAL.JS',
      SKU: 'msal.js.common',
      // default authority
      DEFAULT_AUTHORITY: 'https://login.microsoftonline.com/common/',
      DEFAULT_AUTHORITY_HOST: 'login.microsoftonline.com',
      DEFAULT_COMMON_TENANT: 'common',
      // ADFS String
      ADFS: 'adfs',
      DSTS: 'dstsv2',
      // Default AAD Instance Discovery Endpoint
      AAD_INSTANCE_DISCOVERY_ENDPT:
        'https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=',
      // CIAM URL
      CIAM_AUTH_URL: '.ciamlogin.com',
      AAD_TENANT_DOMAIN_SUFFIX: '.onmicrosoft.com',
      // Resource delimiter - used for certain cache entries
      RESOURCE_DELIM: '|',
      // Placeholder for non-existent account ids/objects
      NO_ACCOUNT: 'NO_ACCOUNT',
      // Claims
      CLAIMS: 'claims',
      // Consumer UTID
      CONSUMER_UTID: '9188040d-6c67-4c5b-b112-36a304b66dad',
      // Default scopes
      OPENID_SCOPE: 'openid',
      PROFILE_SCOPE: 'profile',
      OFFLINE_ACCESS_SCOPE: 'offline_access',
      EMAIL_SCOPE: 'email',
      CODE_GRANT_TYPE: 'authorization_code',
      RT_GRANT_TYPE: 'refresh_token',
      S256_CODE_CHALLENGE_METHOD: 'S256',
      URL_FORM_CONTENT_TYPE: 'application/x-www-form-urlencoded;charset=utf-8',
      AUTHORIZATION_PENDING: 'authorization_pending',
      NOT_DEFINED: 'not_defined',
      EMPTY_STRING: '',
      NOT_APPLICABLE: 'N/A',
      NOT_AVAILABLE: 'Not Available',
      FORWARD_SLASH: '/',
      IMDS_ENDPOINT: 'http://169.254.169.254/metadata/instance/compute/location',
      IMDS_VERSION: '2020-06-01',
      IMDS_TIMEOUT: 2e3,
      AZURE_REGION_AUTO_DISCOVER_FLAG: 'TryAutoDetect',
      REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: 'login.microsoft.com',
      KNOWN_PUBLIC_CLOUDS: [
        'login.microsoftonline.com',
        'login.windows.net',
        'login.microsoft.com',
        'sts.windows.net',
      ],
      SHR_NONCE_VALIDITY: 240,
      INVALID_INSTANCE: 'invalid_instance',
    };
    HttpStatus = {
      SUCCESS: 200,
      SUCCESS_RANGE_START: 200,
      SUCCESS_RANGE_END: 299,
      REDIRECT: 302,
      CLIENT_ERROR: 400,
      CLIENT_ERROR_RANGE_START: 400,
      BAD_REQUEST: 400,
      UNAUTHORIZED: 401,
      NOT_FOUND: 404,
      REQUEST_TIMEOUT: 408,
      GONE: 410,
      TOO_MANY_REQUESTS: 429,
      CLIENT_ERROR_RANGE_END: 499,
      SERVER_ERROR: 500,
      SERVER_ERROR_RANGE_START: 500,
      SERVICE_UNAVAILABLE: 503,
      GATEWAY_TIMEOUT: 504,
      SERVER_ERROR_RANGE_END: 599,
      MULTI_SIDED_ERROR: 600,
    };
    OIDC_DEFAULT_SCOPES = [
      Constants.OPENID_SCOPE,
      Constants.PROFILE_SCOPE,
      Constants.OFFLINE_ACCESS_SCOPE,
    ];
    OIDC_SCOPES = [...OIDC_DEFAULT_SCOPES, Constants.EMAIL_SCOPE];
    HeaderNames = {
      CONTENT_TYPE: 'Content-Type',
      CONTENT_LENGTH: 'Content-Length',
      RETRY_AFTER: 'Retry-After',
      CCS_HEADER: 'X-AnchorMailbox',
      WWWAuthenticate: 'WWW-Authenticate',
      AuthenticationInfo: 'Authentication-Info',
      X_MS_REQUEST_ID: 'x-ms-request-id',
      X_MS_HTTP_VERSION: 'x-ms-httpver',
    };
    AADAuthorityConstants = {
      COMMON: 'common',
      ORGANIZATIONS: 'organizations',
      CONSUMERS: 'consumers',
    };
    ClaimsRequestKeys = {
      ACCESS_TOKEN: 'access_token',
      XMS_CC: 'xms_cc',
    };
    PromptValue = {
      LOGIN: 'login',
      SELECT_ACCOUNT: 'select_account',
      CONSENT: 'consent',
      NONE: 'none',
      CREATE: 'create',
      NO_SESSION: 'no_session',
    };
    CodeChallengeMethodValues = {
      PLAIN: 'plain',
      S256: 'S256',
    };
    OAuthResponseType = {
      CODE: 'code',
      IDTOKEN_TOKEN: 'id_token token',
      IDTOKEN_TOKEN_REFRESHTOKEN: 'id_token token refresh_token',
    };
    ResponseMode = {
      QUERY: 'query',
      FRAGMENT: 'fragment',
      FORM_POST: 'form_post',
    };
    GrantType = {
      IMPLICIT_GRANT: 'implicit',
      AUTHORIZATION_CODE_GRANT: 'authorization_code',
      CLIENT_CREDENTIALS_GRANT: 'client_credentials',
      RESOURCE_OWNER_PASSWORD_GRANT: 'password',
      REFRESH_TOKEN_GRANT: 'refresh_token',
      DEVICE_CODE_GRANT: 'device_code',
      JWT_BEARER: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
    };
    CacheAccountType = {
      MSSTS_ACCOUNT_TYPE: 'MSSTS',
      ADFS_ACCOUNT_TYPE: 'ADFS',
      MSAV1_ACCOUNT_TYPE: 'MSA',
      GENERIC_ACCOUNT_TYPE: 'Generic',
      // NTLM, Kerberos, FBA, Basic etc
    };
    Separators = {
      CACHE_KEY_SEPARATOR: '-',
      CLIENT_INFO_SEPARATOR: '.',
    };
    CredentialType = {
      ID_TOKEN: 'IdToken',
      ACCESS_TOKEN: 'AccessToken',
      ACCESS_TOKEN_WITH_AUTH_SCHEME: 'AccessToken_With_AuthScheme',
      REFRESH_TOKEN: 'RefreshToken',
    };
    APP_METADATA = 'appmetadata';
    CLIENT_INFO = 'client_info';
    THE_FAMILY_ID = '1';
    AUTHORITY_METADATA_CONSTANTS = {
      CACHE_KEY: 'authority-metadata',
      REFRESH_TIME_SECONDS: 3600 * 24,
      // 24 Hours
    };
    AuthorityMetadataSource = {
      CONFIG: 'config',
      CACHE: 'cache',
      NETWORK: 'network',
      HARDCODED_VALUES: 'hardcoded_values',
    };
    SERVER_TELEM_CONSTANTS = {
      SCHEMA_VERSION: 5,
      MAX_LAST_HEADER_BYTES: 330,
      MAX_CACHED_ERRORS: 50,
      CACHE_KEY: 'server-telemetry',
      CATEGORY_SEPARATOR: '|',
      VALUE_SEPARATOR: ',',
      OVERFLOW_TRUE: '1',
      OVERFLOW_FALSE: '0',
      UNKNOWN_ERROR: 'unknown_error',
    };
    AuthenticationScheme = {
      BEARER: 'Bearer',
      POP: 'pop',
      SSH: 'ssh-cert',
    };
    ThrottlingConstants = {
      // Default time to throttle RequestThumbprint in seconds
      DEFAULT_THROTTLE_TIME_SECONDS: 60,
      // Default maximum time to throttle in seconds, overrides what the server sends back
      DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
      // Prefix for storing throttling entries
      THROTTLING_PREFIX: 'throttling',
      // Value assigned to the x-ms-lib-capability header to indicate to the server the library supports throttling
      X_MS_LIB_CAPABILITY_VALUE: 'retry-after, h429',
    };
    Errors = {
      INVALID_GRANT_ERROR: 'invalid_grant',
      CLIENT_MISMATCH_ERROR: 'client_mismatch',
    };
    PasswordGrantConstants = {
      username: 'username',
      password: 'password',
    };
    RegionDiscoverySources = {
      FAILED_AUTO_DETECTION: '1',
      INTERNAL_CACHE: '2',
      ENVIRONMENT_VARIABLE: '3',
      IMDS: '4',
    };
    RegionDiscoveryOutcomes = {
      CONFIGURED_NO_AUTO_DETECTION: '2',
      AUTO_DETECTION_REQUESTED_SUCCESSFUL: '4',
      AUTO_DETECTION_REQUESTED_FAILED: '5',
    };
    CacheOutcome = {
      // When a token is found in the cache or the cache is not supposed to be hit when making the request
      NOT_APPLICABLE: '0',
      // When the token request goes to the identity provider because force_refresh was set to true. Also occurs if claims were requested
      FORCE_REFRESH_OR_CLAIMS: '1',
      // When the token request goes to the identity provider because no cached access token exists
      NO_CACHED_ACCESS_TOKEN: '2',
      // When the token request goes to the identity provider because cached access token expired
      CACHED_ACCESS_TOKEN_EXPIRED: '3',
      // When the token request goes to the identity provider because refresh_in was used and the existing token needs to be refreshed
      PROACTIVELY_REFRESHED: '4',
    };
    DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;
    EncodingTypes = {
      BASE64: 'base64',
      HEX: 'hex',
      UTF8: 'utf-8',
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/AuthErrorCodes.mjs
var AuthErrorCodes_exports = {};
__export(AuthErrorCodes_exports, {
  postRequestFailed: () => postRequestFailed,
  unexpectedError: () => unexpectedError,
});
var unexpectedError, postRequestFailed;
var init_AuthErrorCodes = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/AuthErrorCodes.mjs'() {
    'use strict';
    unexpectedError = 'unexpected_error';
    postRequestFailed = 'post_request_failed';
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/AuthError.mjs
function createAuthError(code, additionalMessage) {
  return new AuthError(
    code,
    additionalMessage ? `${AuthErrorMessages[code]} ${additionalMessage}` : AuthErrorMessages[code]
  );
}
var AuthErrorMessages, AuthErrorMessage, AuthError;
var init_AuthError = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/AuthError.mjs'() {
    'use strict';
    init_Constants();
    init_AuthErrorCodes();
    AuthErrorMessages = {
      [unexpectedError]: 'Unexpected error in authentication.',
      [postRequestFailed]:
        'Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details.',
    };
    AuthErrorMessage = {
      unexpectedError: {
        code: unexpectedError,
        desc: AuthErrorMessages[unexpectedError],
      },
      postRequestFailed: {
        code: postRequestFailed,
        desc: AuthErrorMessages[postRequestFailed],
      },
    };
    AuthError = class _AuthError extends Error {
      constructor(errorCode, errorMessage, suberror) {
        const errorString = errorMessage ? `${errorCode}: ${errorMessage}` : errorCode;
        super(errorString);
        Object.setPrototypeOf(this, _AuthError.prototype);
        this.errorCode = errorCode || Constants.EMPTY_STRING;
        this.errorMessage = errorMessage || Constants.EMPTY_STRING;
        this.subError = suberror || Constants.EMPTY_STRING;
        this.name = 'AuthError';
      }
      setCorrelationId(correlationId) {
        this.correlationId = correlationId;
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs
var ClientAuthErrorCodes_exports = {};
__export(ClientAuthErrorCodes_exports, {
  authTimeNotFound: () => authTimeNotFound,
  authorizationCodeMissingFromServerResponse: () => authorizationCodeMissingFromServerResponse,
  bindingKeyNotRemoved: () => bindingKeyNotRemoved,
  cannotAppendScopeSet: () => cannotAppendScopeSet,
  cannotRemoveEmptyScope: () => cannotRemoveEmptyScope,
  clientInfoDecodingError: () => clientInfoDecodingError,
  clientInfoEmptyError: () => clientInfoEmptyError,
  deviceCodeExpired: () => deviceCodeExpired,
  deviceCodePollingCancelled: () => deviceCodePollingCancelled,
  deviceCodeUnknownError: () => deviceCodeUnknownError,
  emptyInputScopeSet: () => emptyInputScopeSet,
  endSessionEndpointNotSupported: () => endSessionEndpointNotSupported,
  endpointResolutionError: () => endpointResolutionError,
  hashNotDeserialized: () => hashNotDeserialized,
  invalidAssertion: () => invalidAssertion,
  invalidCacheEnvironment: () => invalidCacheEnvironment,
  invalidCacheRecord: () => invalidCacheRecord,
  invalidClientCredential: () => invalidClientCredential,
  invalidState: () => invalidState,
  keyIdMissing: () => keyIdMissing,
  maxAgeTranspired: () => maxAgeTranspired,
  methodNotImplemented: () => methodNotImplemented,
  missingTenantIdError: () => missingTenantIdError,
  multipleMatchingAccounts: () => multipleMatchingAccounts,
  multipleMatchingAppMetadata: () => multipleMatchingAppMetadata,
  multipleMatchingTokens: () => multipleMatchingTokens,
  nestedAppAuthBridgeDisabled: () => nestedAppAuthBridgeDisabled,
  networkError: () => networkError,
  noAccountFound: () => noAccountFound,
  noAccountInSilentRequest: () => noAccountInSilentRequest,
  noCryptoObject: () => noCryptoObject,
  noNetworkConnectivity: () => noNetworkConnectivity,
  nonceMismatch: () => nonceMismatch,
  nullOrEmptyToken: () => nullOrEmptyToken,
  openIdConfigError: () => openIdConfigError,
  requestCannotBeMade: () => requestCannotBeMade,
  stateMismatch: () => stateMismatch,
  stateNotFound: () => stateNotFound,
  tokenClaimsCnfRequiredForSignedJwt: () => tokenClaimsCnfRequiredForSignedJwt,
  tokenParsingError: () => tokenParsingError,
  tokenRefreshRequired: () => tokenRefreshRequired,
  unexpectedCredentialType: () => unexpectedCredentialType,
  userCanceled: () => userCanceled,
  userTimeoutReached: () => userTimeoutReached,
});
var clientInfoDecodingError,
  clientInfoEmptyError,
  tokenParsingError,
  nullOrEmptyToken,
  endpointResolutionError,
  networkError,
  openIdConfigError,
  hashNotDeserialized,
  invalidState,
  stateMismatch,
  stateNotFound,
  nonceMismatch,
  authTimeNotFound,
  maxAgeTranspired,
  multipleMatchingTokens,
  multipleMatchingAccounts,
  multipleMatchingAppMetadata,
  requestCannotBeMade,
  cannotRemoveEmptyScope,
  cannotAppendScopeSet,
  emptyInputScopeSet,
  deviceCodePollingCancelled,
  deviceCodeExpired,
  deviceCodeUnknownError,
  noAccountInSilentRequest,
  invalidCacheRecord,
  invalidCacheEnvironment,
  noAccountFound,
  noCryptoObject,
  unexpectedCredentialType,
  invalidAssertion,
  invalidClientCredential,
  tokenRefreshRequired,
  userTimeoutReached,
  tokenClaimsCnfRequiredForSignedJwt,
  authorizationCodeMissingFromServerResponse,
  bindingKeyNotRemoved,
  endSessionEndpointNotSupported,
  keyIdMissing,
  noNetworkConnectivity,
  userCanceled,
  missingTenantIdError,
  methodNotImplemented,
  nestedAppAuthBridgeDisabled;
var init_ClientAuthErrorCodes = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs'() {
    'use strict';
    clientInfoDecodingError = 'client_info_decoding_error';
    clientInfoEmptyError = 'client_info_empty_error';
    tokenParsingError = 'token_parsing_error';
    nullOrEmptyToken = 'null_or_empty_token';
    endpointResolutionError = 'endpoints_resolution_error';
    networkError = 'network_error';
    openIdConfigError = 'openid_config_error';
    hashNotDeserialized = 'hash_not_deserialized';
    invalidState = 'invalid_state';
    stateMismatch = 'state_mismatch';
    stateNotFound = 'state_not_found';
    nonceMismatch = 'nonce_mismatch';
    authTimeNotFound = 'auth_time_not_found';
    maxAgeTranspired = 'max_age_transpired';
    multipleMatchingTokens = 'multiple_matching_tokens';
    multipleMatchingAccounts = 'multiple_matching_accounts';
    multipleMatchingAppMetadata = 'multiple_matching_appMetadata';
    requestCannotBeMade = 'request_cannot_be_made';
    cannotRemoveEmptyScope = 'cannot_remove_empty_scope';
    cannotAppendScopeSet = 'cannot_append_scopeset';
    emptyInputScopeSet = 'empty_input_scopeset';
    deviceCodePollingCancelled = 'device_code_polling_cancelled';
    deviceCodeExpired = 'device_code_expired';
    deviceCodeUnknownError = 'device_code_unknown_error';
    noAccountInSilentRequest = 'no_account_in_silent_request';
    invalidCacheRecord = 'invalid_cache_record';
    invalidCacheEnvironment = 'invalid_cache_environment';
    noAccountFound = 'no_account_found';
    noCryptoObject = 'no_crypto_object';
    unexpectedCredentialType = 'unexpected_credential_type';
    invalidAssertion = 'invalid_assertion';
    invalidClientCredential = 'invalid_client_credential';
    tokenRefreshRequired = 'token_refresh_required';
    userTimeoutReached = 'user_timeout_reached';
    tokenClaimsCnfRequiredForSignedJwt = 'token_claims_cnf_required_for_signedjwt';
    authorizationCodeMissingFromServerResponse = 'authorization_code_missing_from_server_response';
    bindingKeyNotRemoved = 'binding_key_not_removed';
    endSessionEndpointNotSupported = 'end_session_endpoint_not_supported';
    keyIdMissing = 'key_id_missing';
    noNetworkConnectivity = 'no_network_connectivity';
    userCanceled = 'user_canceled';
    missingTenantIdError = 'missing_tenant_id_error';
    methodNotImplemented = 'method_not_implemented';
    nestedAppAuthBridgeDisabled = 'nested_app_auth_bridge_disabled';
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/ClientAuthError.mjs
function createClientAuthError(errorCode, additionalMessage) {
  return new ClientAuthError(errorCode, additionalMessage);
}
var ClientAuthErrorMessages, ClientAuthErrorMessage, ClientAuthError;
var init_ClientAuthError = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/ClientAuthError.mjs'() {
    'use strict';
    init_AuthError();
    init_ClientAuthErrorCodes();
    ClientAuthErrorMessages = {
      [clientInfoDecodingError]: 'The client info could not be parsed/decoded correctly',
      [clientInfoEmptyError]: 'The client info was empty',
      [tokenParsingError]: 'Token cannot be parsed',
      [nullOrEmptyToken]: 'The token is null or empty',
      [endpointResolutionError]: 'Endpoints cannot be resolved',
      [networkError]: 'Network request failed',
      [openIdConfigError]:
        'Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints.',
      [hashNotDeserialized]: 'The hash parameters could not be deserialized',
      [invalidState]: 'State was not the expected format',
      [stateMismatch]: 'State mismatch error',
      [stateNotFound]: 'State not found',
      [nonceMismatch]: 'Nonce mismatch error',
      [authTimeNotFound]:
        'Max Age was requested and the ID token is missing the auth_time variable. auth_time is an optional claim and is not enabled by default - it must be enabled. See https://aka.ms/msaljs/optional-claims for more information.',
      [maxAgeTranspired]:
        'Max Age is set to 0, or too much time has elapsed since the last end-user authentication.',
      [multipleMatchingTokens]:
        'The cache contains multiple tokens satisfying the requirements. Call AcquireToken again providing more requirements such as authority or account.',
      [multipleMatchingAccounts]:
        'The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account',
      [multipleMatchingAppMetadata]:
        'The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata',
      [requestCannotBeMade]:
        'Token request cannot be made without authorization code or refresh token.',
      [cannotRemoveEmptyScope]: 'Cannot remove null or empty scope from ScopeSet',
      [cannotAppendScopeSet]: 'Cannot append ScopeSet',
      [emptyInputScopeSet]: 'Empty input ScopeSet cannot be processed',
      [deviceCodePollingCancelled]:
        'Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true.',
      [deviceCodeExpired]: 'Device code is expired.',
      [deviceCodeUnknownError]: 'Device code stopped polling for unknown reasons.',
      [noAccountInSilentRequest]:
        'Please pass an account object, silent flow is not supported without account information',
      [invalidCacheRecord]: 'Cache record object was null or undefined.',
      [invalidCacheEnvironment]: 'Invalid environment when attempting to create cache entry',
      [noAccountFound]: 'No account found in cache for given key.',
      [noCryptoObject]: 'No crypto object detected.',
      [unexpectedCredentialType]: 'Unexpected credential type.',
      [invalidAssertion]:
        'Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515',
      [invalidClientCredential]:
        'Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential',
      [tokenRefreshRequired]:
        'Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired.',
      [userTimeoutReached]: 'User defined timeout for device code polling reached',
      [tokenClaimsCnfRequiredForSignedJwt]:
        'Cannot generate a POP jwt if the token_claims are not populated',
      [authorizationCodeMissingFromServerResponse]:
        'Server response does not contain an authorization code to proceed',
      [bindingKeyNotRemoved]: "Could not remove the credential's binding key from storage.",
      [endSessionEndpointNotSupported]: 'The provided authority does not support logout',
      [keyIdMissing]:
        "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key.",
      [noNetworkConnectivity]: 'No network connectivity. Check your internet connection.',
      [userCanceled]: 'User cancelled the flow.',
      [missingTenantIdError]:
        'A tenant id - not common, organizations, or consumers - must be specified when using the client_credentials flow.',
      [methodNotImplemented]: 'This method has not been implemented',
      [nestedAppAuthBridgeDisabled]: 'The nested app auth bridge is disabled',
    };
    ClientAuthErrorMessage = {
      clientInfoDecodingError: {
        code: clientInfoDecodingError,
        desc: ClientAuthErrorMessages[clientInfoDecodingError],
      },
      clientInfoEmptyError: {
        code: clientInfoEmptyError,
        desc: ClientAuthErrorMessages[clientInfoEmptyError],
      },
      tokenParsingError: {
        code: tokenParsingError,
        desc: ClientAuthErrorMessages[tokenParsingError],
      },
      nullOrEmptyToken: {
        code: nullOrEmptyToken,
        desc: ClientAuthErrorMessages[nullOrEmptyToken],
      },
      endpointResolutionError: {
        code: endpointResolutionError,
        desc: ClientAuthErrorMessages[endpointResolutionError],
      },
      networkError: {
        code: networkError,
        desc: ClientAuthErrorMessages[networkError],
      },
      unableToGetOpenidConfigError: {
        code: openIdConfigError,
        desc: ClientAuthErrorMessages[openIdConfigError],
      },
      hashNotDeserialized: {
        code: hashNotDeserialized,
        desc: ClientAuthErrorMessages[hashNotDeserialized],
      },
      invalidStateError: {
        code: invalidState,
        desc: ClientAuthErrorMessages[invalidState],
      },
      stateMismatchError: {
        code: stateMismatch,
        desc: ClientAuthErrorMessages[stateMismatch],
      },
      stateNotFoundError: {
        code: stateNotFound,
        desc: ClientAuthErrorMessages[stateNotFound],
      },
      nonceMismatchError: {
        code: nonceMismatch,
        desc: ClientAuthErrorMessages[nonceMismatch],
      },
      authTimeNotFoundError: {
        code: authTimeNotFound,
        desc: ClientAuthErrorMessages[authTimeNotFound],
      },
      maxAgeTranspired: {
        code: maxAgeTranspired,
        desc: ClientAuthErrorMessages[maxAgeTranspired],
      },
      multipleMatchingTokens: {
        code: multipleMatchingTokens,
        desc: ClientAuthErrorMessages[multipleMatchingTokens],
      },
      multipleMatchingAccounts: {
        code: multipleMatchingAccounts,
        desc: ClientAuthErrorMessages[multipleMatchingAccounts],
      },
      multipleMatchingAppMetadata: {
        code: multipleMatchingAppMetadata,
        desc: ClientAuthErrorMessages[multipleMatchingAppMetadata],
      },
      tokenRequestCannotBeMade: {
        code: requestCannotBeMade,
        desc: ClientAuthErrorMessages[requestCannotBeMade],
      },
      removeEmptyScopeError: {
        code: cannotRemoveEmptyScope,
        desc: ClientAuthErrorMessages[cannotRemoveEmptyScope],
      },
      appendScopeSetError: {
        code: cannotAppendScopeSet,
        desc: ClientAuthErrorMessages[cannotAppendScopeSet],
      },
      emptyInputScopeSetError: {
        code: emptyInputScopeSet,
        desc: ClientAuthErrorMessages[emptyInputScopeSet],
      },
      DeviceCodePollingCancelled: {
        code: deviceCodePollingCancelled,
        desc: ClientAuthErrorMessages[deviceCodePollingCancelled],
      },
      DeviceCodeExpired: {
        code: deviceCodeExpired,
        desc: ClientAuthErrorMessages[deviceCodeExpired],
      },
      DeviceCodeUnknownError: {
        code: deviceCodeUnknownError,
        desc: ClientAuthErrorMessages[deviceCodeUnknownError],
      },
      NoAccountInSilentRequest: {
        code: noAccountInSilentRequest,
        desc: ClientAuthErrorMessages[noAccountInSilentRequest],
      },
      invalidCacheRecord: {
        code: invalidCacheRecord,
        desc: ClientAuthErrorMessages[invalidCacheRecord],
      },
      invalidCacheEnvironment: {
        code: invalidCacheEnvironment,
        desc: ClientAuthErrorMessages[invalidCacheEnvironment],
      },
      noAccountFound: {
        code: noAccountFound,
        desc: ClientAuthErrorMessages[noAccountFound],
      },
      noCryptoObj: {
        code: noCryptoObject,
        desc: ClientAuthErrorMessages[noCryptoObject],
      },
      unexpectedCredentialType: {
        code: unexpectedCredentialType,
        desc: ClientAuthErrorMessages[unexpectedCredentialType],
      },
      invalidAssertion: {
        code: invalidAssertion,
        desc: ClientAuthErrorMessages[invalidAssertion],
      },
      invalidClientCredential: {
        code: invalidClientCredential,
        desc: ClientAuthErrorMessages[invalidClientCredential],
      },
      tokenRefreshRequired: {
        code: tokenRefreshRequired,
        desc: ClientAuthErrorMessages[tokenRefreshRequired],
      },
      userTimeoutReached: {
        code: userTimeoutReached,
        desc: ClientAuthErrorMessages[userTimeoutReached],
      },
      tokenClaimsRequired: {
        code: tokenClaimsCnfRequiredForSignedJwt,
        desc: ClientAuthErrorMessages[tokenClaimsCnfRequiredForSignedJwt],
      },
      noAuthorizationCodeFromServer: {
        code: authorizationCodeMissingFromServerResponse,
        desc: ClientAuthErrorMessages[authorizationCodeMissingFromServerResponse],
      },
      bindingKeyNotRemovedError: {
        code: bindingKeyNotRemoved,
        desc: ClientAuthErrorMessages[bindingKeyNotRemoved],
      },
      logoutNotSupported: {
        code: endSessionEndpointNotSupported,
        desc: ClientAuthErrorMessages[endSessionEndpointNotSupported],
      },
      keyIdMissing: {
        code: keyIdMissing,
        desc: ClientAuthErrorMessages[keyIdMissing],
      },
      noNetworkConnectivity: {
        code: noNetworkConnectivity,
        desc: ClientAuthErrorMessages[noNetworkConnectivity],
      },
      userCanceledError: {
        code: userCanceled,
        desc: ClientAuthErrorMessages[userCanceled],
      },
      missingTenantIdError: {
        code: missingTenantIdError,
        desc: ClientAuthErrorMessages[missingTenantIdError],
      },
      nestedAppAuthBridgeDisabled: {
        code: nestedAppAuthBridgeDisabled,
        desc: ClientAuthErrorMessages[nestedAppAuthBridgeDisabled],
      },
    };
    ClientAuthError = class _ClientAuthError extends AuthError {
      constructor(errorCode, additionalMessage) {
        super(
          errorCode,
          additionalMessage
            ? `${ClientAuthErrorMessages[errorCode]}: ${additionalMessage}`
            : ClientAuthErrorMessages[errorCode]
        );
        this.name = 'ClientAuthError';
        Object.setPrototypeOf(this, _ClientAuthError.prototype);
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/crypto/ICrypto.mjs
var DEFAULT_CRYPTO_IMPLEMENTATION;
var init_ICrypto = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/crypto/ICrypto.mjs'() {
    'use strict';
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
    DEFAULT_CRYPTO_IMPLEMENTATION = {
      createNewGuid: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64Decode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64Encode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64UrlEncode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      encodeKid: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      async getPublicKeyThumbprint() {
        throw createClientAuthError(methodNotImplemented);
      },
      async removeTokenBindingKey() {
        throw createClientAuthError(methodNotImplemented);
      },
      async clearKeystore() {
        throw createClientAuthError(methodNotImplemented);
      },
      async signJwt() {
        throw createClientAuthError(methodNotImplemented);
      },
      async hashString() {
        throw createClientAuthError(methodNotImplemented);
      },
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/logger/Logger.mjs
var LogLevel3, Logger;
var init_Logger = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/logger/Logger.mjs'() {
    'use strict';
    init_Constants();
    (function (LogLevel4) {
      LogLevel4[(LogLevel4['Error'] = 0)] = 'Error';
      LogLevel4[(LogLevel4['Warning'] = 1)] = 'Warning';
      LogLevel4[(LogLevel4['Info'] = 2)] = 'Info';
      LogLevel4[(LogLevel4['Verbose'] = 3)] = 'Verbose';
      LogLevel4[(LogLevel4['Trace'] = 4)] = 'Trace';
    })(LogLevel3 || (LogLevel3 = {}));
    Logger = class _Logger {
      constructor(loggerOptions, packageName, packageVersion) {
        this.level = LogLevel3.Info;
        const defaultLoggerCallback = () => {
          return;
        };
        const setLoggerOptions = loggerOptions || _Logger.createDefaultLoggerOptions();
        this.localCallback = setLoggerOptions.loggerCallback || defaultLoggerCallback;
        this.piiLoggingEnabled = setLoggerOptions.piiLoggingEnabled || false;
        this.level =
          typeof setLoggerOptions.logLevel === 'number'
            ? setLoggerOptions.logLevel
            : LogLevel3.Info;
        this.correlationId = setLoggerOptions.correlationId || Constants.EMPTY_STRING;
        this.packageName = packageName || Constants.EMPTY_STRING;
        this.packageVersion = packageVersion || Constants.EMPTY_STRING;
      }
      static createDefaultLoggerOptions() {
        return {
          loggerCallback: () => {},
          piiLoggingEnabled: false,
          logLevel: LogLevel3.Info,
        };
      }
      /**
       * Create new Logger with existing configurations.
       */
      clone(packageName, packageVersion, correlationId) {
        return new _Logger(
          {
            loggerCallback: this.localCallback,
            piiLoggingEnabled: this.piiLoggingEnabled,
            logLevel: this.level,
            correlationId: correlationId || this.correlationId,
          },
          packageName,
          packageVersion
        );
      }
      /**
       * Log message with required options.
       */
      logMessage(logMessage, options) {
        if (options.logLevel > this.level || (!this.piiLoggingEnabled && options.containsPii)) {
          return;
        }
        const timestamp = /* @__PURE__ */ new Date().toUTCString();
        const logHeader = `[${timestamp}] : [${options.correlationId || this.correlationId || ''}]`;
        const log2 = `${logHeader} : ${this.packageName}@${this.packageVersion} : ${LogLevel3[options.logLevel]} - ${logMessage}`;
        this.executeCallback(options.logLevel, log2, options.containsPii || false);
      }
      /**
       * Execute callback with message.
       */
      executeCallback(level, message, containsPii) {
        if (this.localCallback) {
          this.localCallback(level, message, containsPii);
        }
      }
      /**
       * Logs error messages.
       */
      error(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel3.Error,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING,
        });
      }
      /**
       * Logs error messages with PII.
       */
      errorPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel3.Error,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING,
        });
      }
      /**
       * Logs warning messages.
       */
      warning(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel3.Warning,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING,
        });
      }
      /**
       * Logs warning messages with PII.
       */
      warningPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel3.Warning,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING,
        });
      }
      /**
       * Logs info messages.
       */
      info(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel3.Info,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING,
        });
      }
      /**
       * Logs info messages with PII.
       */
      infoPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel3.Info,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING,
        });
      }
      /**
       * Logs verbose messages.
       */
      verbose(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel3.Verbose,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING,
        });
      }
      /**
       * Logs verbose messages with PII.
       */
      verbosePii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel3.Verbose,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING,
        });
      }
      /**
       * Logs trace messages.
       */
      trace(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel3.Trace,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING,
        });
      }
      /**
       * Logs trace messages with PII.
       */
      tracePii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel3.Trace,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING,
        });
      }
      /**
       * Returns whether PII Logging is enabled or not.
       */
      isPiiLoggingEnabled() {
        return this.piiLoggingEnabled || false;
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/packageMetadata.mjs
var name, version2;
var init_packageMetadata = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/packageMetadata.mjs'() {
    'use strict';
    name = '@azure/msal-common';
    version2 = '15.13.0';
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/AuthorityOptions.mjs
var AzureCloudInstance;
var init_AuthorityOptions = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/AuthorityOptions.mjs'() {
    'use strict';
    AzureCloudInstance = {
      // AzureCloudInstance is not specified.
      None: 'none',
      // Microsoft Azure public cloud
      AzurePublic: 'https://login.microsoftonline.com',
      // Microsoft PPE
      AzurePpe: 'https://login.windows-ppe.net',
      // Microsoft Chinese national/regional cloud
      AzureChina: 'https://login.chinacloudapi.cn',
      // Microsoft German national/regional cloud ("Black Forest")
      AzureGermany: 'https://login.microsoftonline.de',
      // US Government cloud
      AzureUsGovernment: 'https://login.microsoftonline.us',
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs
var redirectUriEmpty,
  claimsRequestParsingError,
  authorityUriInsecure,
  urlParseError,
  urlEmptyError,
  emptyInputScopesError,
  invalidClaims,
  tokenRequestEmpty,
  logoutRequestEmpty,
  invalidCodeChallengeMethod,
  pkceParamsMissing,
  invalidCloudDiscoveryMetadata,
  invalidAuthorityMetadata,
  untrustedAuthority,
  missingSshJwk,
  missingSshKid,
  missingNonceAuthenticationHeader,
  invalidAuthenticationHeader,
  cannotSetOIDCOptions,
  cannotAllowPlatformBroker,
  authorityMismatch,
  invalidRequestMethodForEAR,
  invalidAuthorizePostBodyParameters;
var init_ClientConfigurationErrorCodes = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs'() {
    'use strict';
    redirectUriEmpty = 'redirect_uri_empty';
    claimsRequestParsingError = 'claims_request_parsing_error';
    authorityUriInsecure = 'authority_uri_insecure';
    urlParseError = 'url_parse_error';
    urlEmptyError = 'empty_url_error';
    emptyInputScopesError = 'empty_input_scopes_error';
    invalidClaims = 'invalid_claims';
    tokenRequestEmpty = 'token_request_empty';
    logoutRequestEmpty = 'logout_request_empty';
    invalidCodeChallengeMethod = 'invalid_code_challenge_method';
    pkceParamsMissing = 'pkce_params_missing';
    invalidCloudDiscoveryMetadata = 'invalid_cloud_discovery_metadata';
    invalidAuthorityMetadata = 'invalid_authority_metadata';
    untrustedAuthority = 'untrusted_authority';
    missingSshJwk = 'missing_ssh_jwk';
    missingSshKid = 'missing_ssh_kid';
    missingNonceAuthenticationHeader = 'missing_nonce_authentication_header';
    invalidAuthenticationHeader = 'invalid_authentication_header';
    cannotSetOIDCOptions = 'cannot_set_OIDCOptions';
    cannotAllowPlatformBroker = 'cannot_allow_platform_broker';
    authorityMismatch = 'authority_mismatch';
    invalidRequestMethodForEAR = 'invalid_request_method_for_EAR';
    invalidAuthorizePostBodyParameters = 'invalid_authorize_post_body_parameters';
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/ClientConfigurationError.mjs
function createClientConfigurationError(errorCode) {
  return new ClientConfigurationError(errorCode);
}
var ClientConfigurationErrorMessages, ClientConfigurationErrorMessage, ClientConfigurationError;
var init_ClientConfigurationError = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/ClientConfigurationError.mjs'() {
    'use strict';
    init_AuthError();
    init_ClientConfigurationErrorCodes();
    ClientConfigurationErrorMessages = {
      [redirectUriEmpty]: 'A redirect URI is required for all calls, and none has been set.',
      [claimsRequestParsingError]: 'Could not parse the given claims request object.',
      [authorityUriInsecure]:
        'Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options',
      [urlParseError]: 'URL could not be parsed into appropriate segments.',
      [urlEmptyError]: 'URL was empty or null.',
      [emptyInputScopesError]:
        'Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token.',
      [invalidClaims]: 'Given claims parameter must be a stringified JSON object.',
      [tokenRequestEmpty]: 'Token request was empty and not found in cache.',
      [logoutRequestEmpty]: 'The logout request was null or undefined.',
      [invalidCodeChallengeMethod]:
        'code_challenge_method passed is invalid. Valid values are "plain" and "S256".',
      [pkceParamsMissing]:
        'Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request',
      [invalidCloudDiscoveryMetadata]:
        'Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields',
      [invalidAuthorityMetadata]:
        'Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields.',
      [untrustedAuthority]:
        'The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter.',
      [missingSshJwk]:
        'Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme.',
      [missingSshKid]:
        'Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme.',
      [missingNonceAuthenticationHeader]:
        'Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce.',
      [invalidAuthenticationHeader]: 'Invalid authentication header provided',
      [cannotSetOIDCOptions]:
        'Cannot set OIDCOptions parameter. Please change the protocol mode to OIDC or use a non-Microsoft authority.',
      [cannotAllowPlatformBroker]:
        'Cannot set allowPlatformBroker parameter to true when not in AAD protocol mode.',
      [authorityMismatch]:
        'Authority mismatch error. Authority provided in login request or PublicClientApplication config does not match the environment of the provided account. Please use a matching account or make an interactive request to login to this authority.',
      [invalidAuthorizePostBodyParameters]:
        'Invalid authorize post body parameters provided. If you are using authorizePostBodyParameters, the request method must be POST. Please check the request method and parameters.',
      [invalidRequestMethodForEAR]:
        'Invalid request method for EAR protocol mode. The request method cannot be GET when using EAR protocol mode. Please change the request method to POST.',
    };
    ClientConfigurationErrorMessage = {
      redirectUriNotSet: {
        code: redirectUriEmpty,
        desc: ClientConfigurationErrorMessages[redirectUriEmpty],
      },
      claimsRequestParsingError: {
        code: claimsRequestParsingError,
        desc: ClientConfigurationErrorMessages[claimsRequestParsingError],
      },
      authorityUriInsecure: {
        code: authorityUriInsecure,
        desc: ClientConfigurationErrorMessages[authorityUriInsecure],
      },
      urlParseError: {
        code: urlParseError,
        desc: ClientConfigurationErrorMessages[urlParseError],
      },
      urlEmptyError: {
        code: urlEmptyError,
        desc: ClientConfigurationErrorMessages[urlEmptyError],
      },
      emptyScopesError: {
        code: emptyInputScopesError,
        desc: ClientConfigurationErrorMessages[emptyInputScopesError],
      },
      invalidClaimsRequest: {
        code: invalidClaims,
        desc: ClientConfigurationErrorMessages[invalidClaims],
      },
      tokenRequestEmptyError: {
        code: tokenRequestEmpty,
        desc: ClientConfigurationErrorMessages[tokenRequestEmpty],
      },
      logoutRequestEmptyError: {
        code: logoutRequestEmpty,
        desc: ClientConfigurationErrorMessages[logoutRequestEmpty],
      },
      invalidCodeChallengeMethod: {
        code: invalidCodeChallengeMethod,
        desc: ClientConfigurationErrorMessages[invalidCodeChallengeMethod],
      },
      invalidCodeChallengeParams: {
        code: pkceParamsMissing,
        desc: ClientConfigurationErrorMessages[pkceParamsMissing],
      },
      invalidCloudDiscoveryMetadata: {
        code: invalidCloudDiscoveryMetadata,
        desc: ClientConfigurationErrorMessages[invalidCloudDiscoveryMetadata],
      },
      invalidAuthorityMetadata: {
        code: invalidAuthorityMetadata,
        desc: ClientConfigurationErrorMessages[invalidAuthorityMetadata],
      },
      untrustedAuthority: {
        code: untrustedAuthority,
        desc: ClientConfigurationErrorMessages[untrustedAuthority],
      },
      missingSshJwk: {
        code: missingSshJwk,
        desc: ClientConfigurationErrorMessages[missingSshJwk],
      },
      missingSshKid: {
        code: missingSshKid,
        desc: ClientConfigurationErrorMessages[missingSshKid],
      },
      missingNonceAuthenticationHeader: {
        code: missingNonceAuthenticationHeader,
        desc: ClientConfigurationErrorMessages[missingNonceAuthenticationHeader],
      },
      invalidAuthenticationHeader: {
        code: invalidAuthenticationHeader,
        desc: ClientConfigurationErrorMessages[invalidAuthenticationHeader],
      },
      cannotSetOIDCOptions: {
        code: cannotSetOIDCOptions,
        desc: ClientConfigurationErrorMessages[cannotSetOIDCOptions],
      },
      cannotAllowPlatformBroker: {
        code: cannotAllowPlatformBroker,
        desc: ClientConfigurationErrorMessages[cannotAllowPlatformBroker],
      },
      authorityMismatch: {
        code: authorityMismatch,
        desc: ClientConfigurationErrorMessages[authorityMismatch],
      },
      invalidAuthorizePostBodyParameters: {
        code: invalidAuthorizePostBodyParameters,
        desc: ClientConfigurationErrorMessages[invalidAuthorizePostBodyParameters],
      },
      invalidRequestMethodForEAR: {
        code: invalidRequestMethodForEAR,
        desc: ClientConfigurationErrorMessages[invalidRequestMethodForEAR],
      },
    };
    ClientConfigurationError = class _ClientConfigurationError extends AuthError {
      constructor(errorCode) {
        super(errorCode, ClientConfigurationErrorMessages[errorCode]);
        this.name = 'ClientConfigurationError';
        Object.setPrototypeOf(this, _ClientConfigurationError.prototype);
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/utils/StringUtils.mjs
var StringUtils;
var init_StringUtils = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/utils/StringUtils.mjs'() {
    'use strict';
    StringUtils = class {
      /**
       * Check if stringified object is empty
       * @param strObj
       */
      static isEmptyObj(strObj) {
        if (strObj) {
          try {
            const obj = JSON.parse(strObj);
            return Object.keys(obj).length === 0;
          } catch (e) {}
        }
        return true;
      }
      static startsWith(str2, search) {
        return str2.indexOf(search) === 0;
      }
      static endsWith(str2, search) {
        return (
          str2.length >= search.length && str2.lastIndexOf(search) === str2.length - search.length
        );
      }
      /**
       * Parses string into an object.
       *
       * @param query
       */
      static queryStringToObject(query) {
        const obj = {};
        const params = query.split('&');
        const decode = (s) => decodeURIComponent(s.replace(/\+/g, ' '));
        params.forEach((pair) => {
          if (pair.trim()) {
            const [key2, value] = pair.split(/=(.+)/g, 2);
            if (key2 && value) {
              obj[decode(key2)] = decode(value);
            }
          }
        });
        return obj;
      }
      /**
       * Trims entries in an array.
       *
       * @param arr
       */
      static trimArrayEntries(arr) {
        return arr.map((entry) => entry.trim());
      }
      /**
       * Removes empty strings from array
       * @param arr
       */
      static removeEmptyStringsFromArray(arr) {
        return arr.filter((entry) => {
          return !!entry;
        });
      }
      /**
       * Attempts to parse a string into JSON
       * @param str
       */
      static jsonParseHelper(str2) {
        try {
          return JSON.parse(str2);
        } catch (e) {
          return null;
        }
      }
      /**
       * Tests if a given string matches a given pattern, with support for wildcards and queries.
       * @param pattern Wildcard pattern to string match. Supports "*" for wildcards and "?" for queries
       * @param input String to match against
       */
      static matchPattern(pattern, input) {
        const regex = new RegExp(
          pattern.replace(/\\/g, '\\\\').replace(/\*/g, '[^ ]*').replace(/\?/g, '\\?')
        );
        return regex.test(input);
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/request/ScopeSet.mjs
var ScopeSet;
var init_ScopeSet = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/request/ScopeSet.mjs'() {
    'use strict';
    init_ClientConfigurationError();
    init_StringUtils();
    init_ClientAuthError();
    init_Constants();
    init_ClientConfigurationErrorCodes();
    init_ClientAuthErrorCodes();
    ScopeSet = class _ScopeSet {
      constructor(inputScopes) {
        const scopeArr = inputScopes ? StringUtils.trimArrayEntries([...inputScopes]) : [];
        const filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];
        if (!filteredInput || !filteredInput.length) {
          throw createClientConfigurationError(emptyInputScopesError);
        }
        this.scopes = /* @__PURE__ */ new Set();
        filteredInput.forEach((scope) => this.scopes.add(scope));
      }
      /**
       * Factory method to create ScopeSet from space-delimited string
       * @param inputScopeString
       * @param appClientId
       * @param scopesRequired
       */
      static fromString(inputScopeString) {
        const scopeString = inputScopeString || Constants.EMPTY_STRING;
        const inputScopes = scopeString.split(' ');
        return new _ScopeSet(inputScopes);
      }
      /**
       * Creates the set of scopes to search for in cache lookups
       * @param inputScopeString
       * @returns
       */
      static createSearchScopes(inputScopeString) {
        const scopesToUse =
          inputScopeString && inputScopeString.length > 0
            ? inputScopeString
            : [...OIDC_DEFAULT_SCOPES];
        const scopeSet = new _ScopeSet(scopesToUse);
        if (!scopeSet.containsOnlyOIDCScopes()) {
          scopeSet.removeOIDCScopes();
        } else {
          scopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);
        }
        return scopeSet;
      }
      /**
       * Check if a given scope is present in this set of scopes.
       * @param scope
       */
      containsScope(scope) {
        const lowerCaseScopes = this.printScopesLowerCase().split(' ');
        const lowerCaseScopesSet = new _ScopeSet(lowerCaseScopes);
        return scope ? lowerCaseScopesSet.scopes.has(scope.toLowerCase()) : false;
      }
      /**
       * Check if a set of scopes is present in this set of scopes.
       * @param scopeSet
       */
      containsScopeSet(scopeSet) {
        if (!scopeSet || scopeSet.scopes.size <= 0) {
          return false;
        }
        return (
          this.scopes.size >= scopeSet.scopes.size &&
          scopeSet.asArray().every((scope) => this.containsScope(scope))
        );
      }
      /**
       * Check if set of scopes contains only the defaults
       */
      containsOnlyOIDCScopes() {
        let defaultScopeCount = 0;
        OIDC_SCOPES.forEach((defaultScope) => {
          if (this.containsScope(defaultScope)) {
            defaultScopeCount += 1;
          }
        });
        return this.scopes.size === defaultScopeCount;
      }
      /**
       * Appends single scope if passed
       * @param newScope
       */
      appendScope(newScope) {
        if (newScope) {
          this.scopes.add(newScope.trim());
        }
      }
      /**
       * Appends multiple scopes if passed
       * @param newScopes
       */
      appendScopes(newScopes) {
        try {
          newScopes.forEach((newScope) => this.appendScope(newScope));
        } catch (e) {
          throw createClientAuthError(cannotAppendScopeSet);
        }
      }
      /**
       * Removes element from set of scopes.
       * @param scope
       */
      removeScope(scope) {
        if (!scope) {
          throw createClientAuthError(cannotRemoveEmptyScope);
        }
        this.scopes.delete(scope.trim());
      }
      /**
       * Removes default scopes from set of scopes
       * Primarily used to prevent cache misses if the default scopes are not returned from the server
       */
      removeOIDCScopes() {
        OIDC_SCOPES.forEach((defaultScope) => {
          this.scopes.delete(defaultScope);
        });
      }
      /**
       * Combines an array of scopes with the current set of scopes.
       * @param otherScopes
       */
      unionScopeSets(otherScopes) {
        if (!otherScopes) {
          throw createClientAuthError(emptyInputScopeSet);
        }
        const unionScopes = /* @__PURE__ */ new Set();
        otherScopes.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
        this.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
        return unionScopes;
      }
      /**
       * Check if scopes intersect between this set and another.
       * @param otherScopes
       */
      intersectingScopeSets(otherScopes) {
        if (!otherScopes) {
          throw createClientAuthError(emptyInputScopeSet);
        }
        if (!otherScopes.containsOnlyOIDCScopes()) {
          otherScopes.removeOIDCScopes();
        }
        const unionScopes = this.unionScopeSets(otherScopes);
        const sizeOtherScopes = otherScopes.getScopeCount();
        const sizeThisScopes = this.getScopeCount();
        const sizeUnionScopes = unionScopes.size;
        return sizeUnionScopes < sizeThisScopes + sizeOtherScopes;
      }
      /**
       * Returns size of set of scopes.
       */
      getScopeCount() {
        return this.scopes.size;
      }
      /**
       * Returns the scopes as an array of string values
       */
      asArray() {
        const array = [];
        this.scopes.forEach((val) => array.push(val));
        return array;
      }
      /**
       * Prints scopes into a space-delimited string
       */
      printScopes() {
        if (this.scopes) {
          const scopeArr = this.asArray();
          return scopeArr.join(' ');
        }
        return Constants.EMPTY_STRING;
      }
      /**
       * Prints scopes into a space-delimited lower-case string (used for caching)
       */
      printScopesLowerCase() {
        return this.printScopes().toLowerCase();
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/account/AccountInfo.mjs
function tenantIdMatchesHomeTenant(tenantId, homeAccountId) {
  return !!tenantId && !!homeAccountId && tenantId === homeAccountId.split('.')[1];
}
function buildTenantProfile(homeAccountId, localAccountId, tenantId, idTokenClaims) {
  if (idTokenClaims) {
    const {
      oid,
      sub,
      tid,
      name: name3,
      tfp,
      acr,
      preferred_username,
      upn,
      login_hint,
    } = idTokenClaims;
    const tenantId2 = tid || tfp || acr || '';
    return {
      tenantId: tenantId2,
      localAccountId: oid || sub || '',
      name: name3,
      username: preferred_username || upn || '',
      loginHint: login_hint,
      isHomeTenant: tenantIdMatchesHomeTenant(tenantId2, homeAccountId),
    };
  } else {
    return {
      tenantId,
      localAccountId,
      username: '',
      isHomeTenant: tenantIdMatchesHomeTenant(tenantId, homeAccountId),
    };
  }
}
function updateAccountTenantProfileData(
  baseAccountInfo,
  tenantProfile,
  idTokenClaims,
  idTokenSecret
) {
  let updatedAccountInfo = baseAccountInfo;
  if (tenantProfile) {
    const { isHomeTenant, ...tenantProfileOverride } = tenantProfile;
    updatedAccountInfo = { ...baseAccountInfo, ...tenantProfileOverride };
  }
  if (idTokenClaims) {
    const { isHomeTenant, ...claimsSourcedTenantProfile } = buildTenantProfile(
      baseAccountInfo.homeAccountId,
      baseAccountInfo.localAccountId,
      baseAccountInfo.tenantId,
      idTokenClaims
    );
    updatedAccountInfo = {
      ...updatedAccountInfo,
      ...claimsSourcedTenantProfile,
      idTokenClaims,
      idToken: idTokenSecret,
    };
    return updatedAccountInfo;
  }
  return updatedAccountInfo;
}
var init_AccountInfo = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/account/AccountInfo.mjs'() {
    'use strict';
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/account/AuthToken.mjs
function extractTokenClaims(encodedToken, base64Decode) {
  const jswPayload = getJWSPayload(encodedToken);
  try {
    const base64Decoded = base64Decode(jswPayload);
    return JSON.parse(base64Decoded);
  } catch (err) {
    throw createClientAuthError(tokenParsingError);
  }
}
function getJWSPayload(authToken) {
  if (!authToken) {
    throw createClientAuthError(nullOrEmptyToken);
  }
  const tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
  const matches2 = tokenPartsRegex.exec(authToken);
  if (!matches2 || matches2.length < 4) {
    throw createClientAuthError(tokenParsingError);
  }
  return matches2[2];
}
function checkMaxAge(authTime, maxAge) {
  const fiveMinuteSkew = 3e5;
  if (maxAge === 0 || Date.now() - fiveMinuteSkew > authTime + maxAge) {
    throw createClientAuthError(maxAgeTranspired);
  }
}
var init_AuthToken = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/account/AuthToken.mjs'() {
    'use strict';
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/utils/UrlUtils.mjs
var UrlUtils_exports = {};
__export(UrlUtils_exports, {
  getDeserializedResponse: () => getDeserializedResponse,
  mapToQueryString: () => mapToQueryString,
  normalizeUrlForComparison: () => normalizeUrlForComparison,
  stripLeadingHashOrQuery: () => stripLeadingHashOrQuery,
});
function canonicalizeUrl(url2) {
  if (!url2) {
    return url2;
  }
  let lowerCaseUrl = url2.toLowerCase();
  if (StringUtils.endsWith(lowerCaseUrl, '?')) {
    lowerCaseUrl = lowerCaseUrl.slice(0, -1);
  } else if (StringUtils.endsWith(lowerCaseUrl, '?/')) {
    lowerCaseUrl = lowerCaseUrl.slice(0, -2);
  }
  if (!StringUtils.endsWith(lowerCaseUrl, '/')) {
    lowerCaseUrl += '/';
  }
  return lowerCaseUrl;
}
function stripLeadingHashOrQuery(responseString) {
  if (responseString.startsWith('#/')) {
    return responseString.substring(2);
  } else if (responseString.startsWith('#') || responseString.startsWith('?')) {
    return responseString.substring(1);
  }
  return responseString;
}
function getDeserializedResponse(responseString) {
  if (!responseString || responseString.indexOf('=') < 0) {
    return null;
  }
  try {
    const normalizedResponse = stripLeadingHashOrQuery(responseString);
    const deserializedHash = Object.fromEntries(new URLSearchParams(normalizedResponse));
    if (
      deserializedHash.code ||
      deserializedHash.ear_jwe ||
      deserializedHash.error ||
      deserializedHash.error_description ||
      deserializedHash.state
    ) {
      return deserializedHash;
    }
  } catch (e) {
    throw createClientAuthError(hashNotDeserialized);
  }
  return null;
}
function mapToQueryString(parameters, encodeExtraParams = true, extraQueryParameters) {
  const queryParameterArray = new Array();
  parameters.forEach((value, key2) => {
    if (!encodeExtraParams && extraQueryParameters && key2 in extraQueryParameters) {
      queryParameterArray.push(`${key2}=${value}`);
    } else {
      queryParameterArray.push(`${key2}=${encodeURIComponent(value)}`);
    }
  });
  return queryParameterArray.join('&');
}
function normalizeUrlForComparison(url2) {
  if (!url2) {
    return url2;
  }
  const urlWithoutHash = url2.split('#')[0];
  try {
    const urlObj = new URL(urlWithoutHash);
    const normalizedUrl = urlObj.origin + urlObj.pathname + urlObj.search;
    return canonicalizeUrl(normalizedUrl);
  } catch (e) {
    return canonicalizeUrl(urlWithoutHash);
  }
}
var init_UrlUtils = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/utils/UrlUtils.mjs'() {
    'use strict';
    init_ClientAuthError();
    init_StringUtils();
    init_ClientAuthErrorCodes();
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/url/UrlString.mjs
var UrlString;
var init_UrlString = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/url/UrlString.mjs'() {
    'use strict';
    init_ClientConfigurationError();
    init_StringUtils();
    init_Constants();
    init_UrlUtils();
    init_ClientConfigurationErrorCodes();
    UrlString = class _UrlString {
      get urlString() {
        return this._urlString;
      }
      constructor(url2) {
        this._urlString = url2;
        if (!this._urlString) {
          throw createClientConfigurationError(urlEmptyError);
        }
        if (!url2.includes('#')) {
          this._urlString = _UrlString.canonicalizeUri(url2);
        }
      }
      /**
       * Ensure urls are lower case and end with a / character.
       * @param url
       */
      static canonicalizeUri(url2) {
        if (url2) {
          let lowerCaseUrl = url2.toLowerCase();
          if (StringUtils.endsWith(lowerCaseUrl, '?')) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -1);
          } else if (StringUtils.endsWith(lowerCaseUrl, '?/')) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -2);
          }
          if (!StringUtils.endsWith(lowerCaseUrl, '/')) {
            lowerCaseUrl += '/';
          }
          return lowerCaseUrl;
        }
        return url2;
      }
      /**
       * Throws if urlString passed is not a valid authority URI string.
       */
      validateAsUri() {
        let components;
        try {
          components = this.getUrlComponents();
        } catch (e) {
          throw createClientConfigurationError(urlParseError);
        }
        if (!components.HostNameAndPort || !components.PathSegments) {
          throw createClientConfigurationError(urlParseError);
        }
        if (!components.Protocol || components.Protocol.toLowerCase() !== 'https:') {
          throw createClientConfigurationError(authorityUriInsecure);
        }
      }
      /**
       * Given a url and a query string return the url with provided query string appended
       * @param url
       * @param queryString
       */
      static appendQueryString(url2, queryString) {
        if (!queryString) {
          return url2;
        }
        return url2.indexOf('?') < 0 ? `${url2}?${queryString}` : `${url2}&${queryString}`;
      }
      /**
       * Returns a url with the hash removed
       * @param url
       */
      static removeHashFromUrl(url2) {
        return _UrlString.canonicalizeUri(url2.split('#')[0]);
      }
      /**
       * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d
       * @param href The url
       * @param tenantId The tenant id to replace
       */
      replaceTenantPath(tenantId) {
        const urlObject = this.getUrlComponents();
        const pathArray = urlObject.PathSegments;
        if (
          tenantId &&
          pathArray.length !== 0 &&
          (pathArray[0] === AADAuthorityConstants.COMMON ||
            pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)
        ) {
          pathArray[0] = tenantId;
        }
        return _UrlString.constructAuthorityUriFromObject(urlObject);
      }
      /**
       * Parses out the components from a url string.
       * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.
       */
      getUrlComponents() {
        const regEx = RegExp('^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?');
        const match = this.urlString.match(regEx);
        if (!match) {
          throw createClientConfigurationError(urlParseError);
        }
        const urlComponents = {
          Protocol: match[1],
          HostNameAndPort: match[4],
          AbsolutePath: match[5],
          QueryString: match[7],
        };
        let pathSegments = urlComponents.AbsolutePath.split('/');
        pathSegments = pathSegments.filter((val) => val && val.length > 0);
        urlComponents.PathSegments = pathSegments;
        if (urlComponents.QueryString && urlComponents.QueryString.endsWith('/')) {
          urlComponents.QueryString = urlComponents.QueryString.substring(
            0,
            urlComponents.QueryString.length - 1
          );
        }
        return urlComponents;
      }
      static getDomainFromUrl(url2) {
        const regEx = RegExp('^([^:/?#]+://)?([^/?#]*)');
        const match = url2.match(regEx);
        if (!match) {
          throw createClientConfigurationError(urlParseError);
        }
        return match[2];
      }
      static getAbsoluteUrl(relativeUrl, baseUrl) {
        if (relativeUrl[0] === Constants.FORWARD_SLASH) {
          const url2 = new _UrlString(baseUrl);
          const baseComponents = url2.getUrlComponents();
          return baseComponents.Protocol + '//' + baseComponents.HostNameAndPort + relativeUrl;
        }
        return relativeUrl;
      }
      static constructAuthorityUriFromObject(urlObject) {
        return new _UrlString(
          urlObject.Protocol +
            '//' +
            urlObject.HostNameAndPort +
            '/' +
            urlObject.PathSegments.join('/')
        );
      }
      /**
       * Check if the hash of the URL string contains known properties
       * @deprecated This API will be removed in a future version
       */
      static hashContainsKnownProperties(response) {
        return !!getDeserializedResponse(response);
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/AuthorityMetadata.mjs
function getAliasesFromStaticSources(staticAuthorityOptions, logger4) {
  let staticAliases;
  const canonicalAuthority = staticAuthorityOptions.canonicalAuthority;
  if (canonicalAuthority) {
    const authorityHost = new UrlString(canonicalAuthority).getUrlComponents().HostNameAndPort;
    staticAliases =
      getAliasesFromMetadata(
        authorityHost,
        staticAuthorityOptions.cloudDiscoveryMetadata?.metadata,
        AuthorityMetadataSource.CONFIG,
        logger4
      ) ||
      getAliasesFromMetadata(
        authorityHost,
        InstanceDiscoveryMetadata.metadata,
        AuthorityMetadataSource.HARDCODED_VALUES,
        logger4
      ) ||
      staticAuthorityOptions.knownAuthorities;
  }
  return staticAliases || [];
}
function getAliasesFromMetadata(authorityHost, cloudDiscoveryMetadata, source2, logger4) {
  logger4?.trace(`getAliasesFromMetadata called with source: ${source2}`);
  if (authorityHost && cloudDiscoveryMetadata) {
    const metadata = getCloudDiscoveryMetadataFromNetworkResponse(
      cloudDiscoveryMetadata,
      authorityHost
    );
    if (metadata) {
      logger4?.trace(
        `getAliasesFromMetadata: found cloud discovery metadata in ${source2}, returning aliases`
      );
      return metadata.aliases;
    } else {
      logger4?.trace(`getAliasesFromMetadata: did not find cloud discovery metadata in ${source2}`);
    }
  }
  return null;
}
function getCloudDiscoveryMetadataFromHardcodedValues(authorityHost) {
  const metadata = getCloudDiscoveryMetadataFromNetworkResponse(
    InstanceDiscoveryMetadata.metadata,
    authorityHost
  );
  return metadata;
}
function getCloudDiscoveryMetadataFromNetworkResponse(response, authorityHost) {
  for (let i = 0; i < response.length; i++) {
    const metadata = response[i];
    if (metadata.aliases.includes(authorityHost)) {
      return metadata;
    }
  }
  return null;
}
var rawMetdataJSON, EndpointMetadata, InstanceDiscoveryMetadata, InstanceDiscoveryMetadataAliases;
var init_AuthorityMetadata = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/AuthorityMetadata.mjs'() {
    'use strict';
    init_UrlString();
    init_Constants();
    rawMetdataJSON = {
      endpointMetadata: {
        'login.microsoftonline.com': {
          token_endpoint: 'https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/token',
          jwks_uri: 'https://login.microsoftonline.com/{tenantid}/discovery/v2.0/keys',
          issuer: 'https://login.microsoftonline.com/{tenantid}/v2.0',
          authorization_endpoint:
            'https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/authorize',
          end_session_endpoint: 'https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/logout',
        },
        'login.chinacloudapi.cn': {
          token_endpoint: 'https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/token',
          jwks_uri: 'https://login.chinacloudapi.cn/{tenantid}/discovery/v2.0/keys',
          issuer: 'https://login.partner.microsoftonline.cn/{tenantid}/v2.0',
          authorization_endpoint: 'https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/authorize',
          end_session_endpoint: 'https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/logout',
        },
        'login.microsoftonline.us': {
          token_endpoint: 'https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/token',
          jwks_uri: 'https://login.microsoftonline.us/{tenantid}/discovery/v2.0/keys',
          issuer: 'https://login.microsoftonline.us/{tenantid}/v2.0',
          authorization_endpoint:
            'https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/authorize',
          end_session_endpoint: 'https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/logout',
        },
      },
      instanceDiscoveryMetadata: {
        metadata: [
          {
            preferred_network: 'login.microsoftonline.com',
            preferred_cache: 'login.windows.net',
            aliases: [
              'login.microsoftonline.com',
              'login.windows.net',
              'login.microsoft.com',
              'sts.windows.net',
            ],
          },
          {
            preferred_network: 'login.partner.microsoftonline.cn',
            preferred_cache: 'login.partner.microsoftonline.cn',
            aliases: ['login.partner.microsoftonline.cn', 'login.chinacloudapi.cn'],
          },
          {
            preferred_network: 'login.microsoftonline.de',
            preferred_cache: 'login.microsoftonline.de',
            aliases: ['login.microsoftonline.de'],
          },
          {
            preferred_network: 'login.microsoftonline.us',
            preferred_cache: 'login.microsoftonline.us',
            aliases: ['login.microsoftonline.us', 'login.usgovcloudapi.net'],
          },
          {
            preferred_network: 'login-us.microsoftonline.com',
            preferred_cache: 'login-us.microsoftonline.com',
            aliases: ['login-us.microsoftonline.com'],
          },
        ],
      },
    };
    EndpointMetadata = rawMetdataJSON.endpointMetadata;
    InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;
    InstanceDiscoveryMetadataAliases = /* @__PURE__ */ new Set();
    InstanceDiscoveryMetadata.metadata.forEach((metadataEntry) => {
      metadataEntry.aliases.forEach((alias) => {
        InstanceDiscoveryMetadataAliases.add(alias);
      });
    });
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/CacheErrorCodes.mjs
var cacheQuotaExceeded, cacheErrorUnknown;
var init_CacheErrorCodes = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/CacheErrorCodes.mjs'() {
    'use strict';
    cacheQuotaExceeded = 'cache_quota_exceeded';
    cacheErrorUnknown = 'cache_error_unknown';
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/CacheError.mjs
function createCacheError(e) {
  if (!(e instanceof Error)) {
    return new CacheError(cacheErrorUnknown);
  }
  if (
    e.name === 'QuotaExceededError' ||
    e.name === 'NS_ERROR_DOM_QUOTA_REACHED' ||
    e.message.includes('exceeded the quota')
  ) {
    return new CacheError(cacheQuotaExceeded);
  } else {
    return new CacheError(e.name, e.message);
  }
}
var CacheErrorMessages, CacheError;
var init_CacheError = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/CacheError.mjs'() {
    'use strict';
    init_AuthError();
    init_CacheErrorCodes();
    CacheErrorMessages = {
      [cacheQuotaExceeded]: 'Exceeded cache storage capacity.',
      [cacheErrorUnknown]: 'Unexpected error occurred when using cache storage.',
    };
    CacheError = class _CacheError extends AuthError {
      constructor(errorCode, errorMessage) {
        const message =
          errorMessage ||
          (CacheErrorMessages[errorCode]
            ? CacheErrorMessages[errorCode]
            : CacheErrorMessages[cacheErrorUnknown]);
        super(`${errorCode}: ${message}`);
        Object.setPrototypeOf(this, _CacheError.prototype);
        this.name = 'CacheError';
        this.errorCode = errorCode;
        this.errorMessage = message;
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/cache/CacheManager.mjs
var CacheManager, DefaultStorageClass;
var init_CacheManager = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/cache/CacheManager.mjs'() {
    'use strict';
    init_Constants();
    init_ScopeSet();
    init_ClientAuthError();
    init_AccountInfo();
    init_AuthToken();
    init_packageMetadata();
    init_AuthorityMetadata();
    init_CacheError();
    init_AuthError();
    init_ClientAuthErrorCodes();
    CacheManager = class {
      constructor(clientId, cryptoImpl, logger4, performanceClient, staticAuthorityOptions) {
        this.clientId = clientId;
        this.cryptoImpl = cryptoImpl;
        this.commonLogger = logger4.clone(name, version2);
        this.staticAuthorityOptions = staticAuthorityOptions;
        this.performanceClient = performanceClient;
      }
      /**
       * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
       * @param accountFilter - (Optional) filter to narrow down the accounts returned
       * @returns Array of AccountInfo objects in cache
       */
      getAllAccounts(accountFilter, correlationId) {
        return this.buildTenantProfiles(
          this.getAccountsFilteredBy(accountFilter, correlationId),
          correlationId,
          accountFilter
        );
      }
      /**
       * Gets first tenanted AccountInfo object found based on provided filters
       */
      getAccountInfoFilteredBy(accountFilter, correlationId) {
        if (
          Object.keys(accountFilter).length === 0 ||
          Object.values(accountFilter).every((value) => !value)
        ) {
          this.commonLogger.warning(
            'getAccountInfoFilteredBy: Account filter is empty or invalid, returning null'
          );
          return null;
        }
        const allAccounts = this.getAllAccounts(accountFilter, correlationId);
        if (allAccounts.length > 1) {
          const sortedAccounts = allAccounts.sort((account) => {
            return account.idTokenClaims ? -1 : 1;
          });
          return sortedAccounts[0];
        } else if (allAccounts.length === 1) {
          return allAccounts[0];
        } else {
          return null;
        }
      }
      /**
       * Returns a single matching
       * @param accountFilter
       * @returns
       */
      getBaseAccountInfo(accountFilter, correlationId) {
        const accountEntities = this.getAccountsFilteredBy(accountFilter, correlationId);
        if (accountEntities.length > 0) {
          return accountEntities[0].getAccountInfo();
        } else {
          return null;
        }
      }
      /**
       * Matches filtered account entities with cached ID tokens that match the tenant profile-specific account filters
       * and builds the account info objects from the matching ID token's claims
       * @param cachedAccounts
       * @param accountFilter
       * @returns Array of AccountInfo objects that match account and tenant profile filters
       */
      buildTenantProfiles(cachedAccounts, correlationId, accountFilter) {
        return cachedAccounts.flatMap((accountEntity) => {
          return this.getTenantProfilesFromAccountEntity(
            accountEntity,
            correlationId,
            accountFilter?.tenantId,
            accountFilter
          );
        });
      }
      getTenantedAccountInfoByFilter(
        accountInfo,
        tokenKeys,
        tenantProfile,
        correlationId,
        tenantProfileFilter
      ) {
        let tenantedAccountInfo = null;
        let idTokenClaims;
        if (tenantProfileFilter) {
          if (!this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter)) {
            return null;
          }
        }
        const idToken = this.getIdToken(
          accountInfo,
          correlationId,
          tokenKeys,
          tenantProfile.tenantId
        );
        if (idToken) {
          idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);
          if (!this.idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter)) {
            return null;
          }
        }
        tenantedAccountInfo = updateAccountTenantProfileData(
          accountInfo,
          tenantProfile,
          idTokenClaims,
          idToken?.secret
        );
        return tenantedAccountInfo;
      }
      getTenantProfilesFromAccountEntity(
        accountEntity,
        correlationId,
        targetTenantId,
        tenantProfileFilter
      ) {
        const accountInfo = accountEntity.getAccountInfo();
        let searchTenantProfiles = accountInfo.tenantProfiles || /* @__PURE__ */ new Map();
        const tokenKeys = this.getTokenKeys();
        if (targetTenantId) {
          const tenantProfile = searchTenantProfiles.get(targetTenantId);
          if (tenantProfile) {
            searchTenantProfiles = /* @__PURE__ */ new Map([[targetTenantId, tenantProfile]]);
          } else {
            return [];
          }
        }
        const matchingTenantProfiles = [];
        searchTenantProfiles.forEach((tenantProfile) => {
          const tenantedAccountInfo = this.getTenantedAccountInfoByFilter(
            accountInfo,
            tokenKeys,
            tenantProfile,
            correlationId,
            tenantProfileFilter
          );
          if (tenantedAccountInfo) {
            matchingTenantProfiles.push(tenantedAccountInfo);
          }
        });
        return matchingTenantProfiles;
      }
      tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter) {
        if (
          !!tenantProfileFilter.localAccountId &&
          !this.matchLocalAccountIdFromTenantProfile(
            tenantProfile,
            tenantProfileFilter.localAccountId
          )
        ) {
          return false;
        }
        if (!!tenantProfileFilter.name && !(tenantProfile.name === tenantProfileFilter.name)) {
          return false;
        }
        if (
          tenantProfileFilter.isHomeTenant !== void 0 &&
          !(tenantProfile.isHomeTenant === tenantProfileFilter.isHomeTenant)
        ) {
          return false;
        }
        return true;
      }
      idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter) {
        if (tenantProfileFilter) {
          if (
            !!tenantProfileFilter.localAccountId &&
            !this.matchLocalAccountIdFromTokenClaims(
              idTokenClaims,
              tenantProfileFilter.localAccountId
            )
          ) {
            return false;
          }
          if (
            !!tenantProfileFilter.loginHint &&
            !this.matchLoginHintFromTokenClaims(idTokenClaims, tenantProfileFilter.loginHint)
          ) {
            return false;
          }
          if (
            !!tenantProfileFilter.username &&
            !this.matchUsername(idTokenClaims.preferred_username, tenantProfileFilter.username)
          ) {
            return false;
          }
          if (
            !!tenantProfileFilter.name &&
            !this.matchName(idTokenClaims, tenantProfileFilter.name)
          ) {
            return false;
          }
          if (!!tenantProfileFilter.sid && !this.matchSid(idTokenClaims, tenantProfileFilter.sid)) {
            return false;
          }
        }
        return true;
      }
      /**
       * saves a cache record
       * @param cacheRecord {CacheRecord}
       * @param storeInCache {?StoreInCache}
       * @param correlationId {?string} correlation id
       */
      async saveCacheRecord(cacheRecord, correlationId, storeInCache) {
        if (!cacheRecord) {
          throw createClientAuthError(invalidCacheRecord);
        }
        try {
          if (!!cacheRecord.account) {
            await this.setAccount(cacheRecord.account, correlationId);
          }
          if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {
            await this.setIdTokenCredential(cacheRecord.idToken, correlationId);
          }
          if (!!cacheRecord.accessToken && storeInCache?.accessToken !== false) {
            await this.saveAccessToken(cacheRecord.accessToken, correlationId);
          }
          if (!!cacheRecord.refreshToken && storeInCache?.refreshToken !== false) {
            await this.setRefreshTokenCredential(cacheRecord.refreshToken, correlationId);
          }
          if (!!cacheRecord.appMetadata) {
            this.setAppMetadata(cacheRecord.appMetadata, correlationId);
          }
        } catch (e) {
          this.commonLogger?.error(`CacheManager.saveCacheRecord: failed`);
          if (e instanceof AuthError) {
            throw e;
          } else {
            throw createCacheError(e);
          }
        }
      }
      /**
       * saves access token credential
       * @param credential
       */
      async saveAccessToken(credential, correlationId) {
        const accessTokenFilter = {
          clientId: credential.clientId,
          credentialType: credential.credentialType,
          environment: credential.environment,
          homeAccountId: credential.homeAccountId,
          realm: credential.realm,
          tokenType: credential.tokenType,
          requestedClaimsHash: credential.requestedClaimsHash,
        };
        const tokenKeys = this.getTokenKeys();
        const currentScopes = ScopeSet.fromString(credential.target);
        tokenKeys.accessToken.forEach((key2) => {
          if (!this.accessTokenKeyMatchesFilter(key2, accessTokenFilter, false)) {
            return;
          }
          const tokenEntity = this.getAccessTokenCredential(key2, correlationId);
          if (tokenEntity && this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {
            const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
            if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
              this.removeAccessToken(key2, correlationId);
            }
          }
        });
        await this.setAccessTokenCredential(credential, correlationId);
      }
      /**
       * Retrieve account entities matching all provided tenant-agnostic filters; if no filter is set, get all account entities in the cache
       * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared
       * @param accountFilter - An object containing Account properties to filter by
       */
      getAccountsFilteredBy(accountFilter, correlationId) {
        const allAccountKeys = this.getAccountKeys();
        const matchingAccounts = [];
        allAccountKeys.forEach((cacheKey) => {
          const entity = this.getAccount(cacheKey, correlationId);
          if (!entity) {
            return;
          }
          if (
            !!accountFilter.homeAccountId &&
            !this.matchHomeAccountId(entity, accountFilter.homeAccountId)
          ) {
            return;
          }
          if (
            !!accountFilter.username &&
            !this.matchUsername(entity.username, accountFilter.username)
          ) {
            return;
          }
          if (
            !!accountFilter.environment &&
            !this.matchEnvironment(entity, accountFilter.environment)
          ) {
            return;
          }
          if (!!accountFilter.realm && !this.matchRealm(entity, accountFilter.realm)) {
            return;
          }
          if (
            !!accountFilter.nativeAccountId &&
            !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)
          ) {
            return;
          }
          if (
            !!accountFilter.authorityType &&
            !this.matchAuthorityType(entity, accountFilter.authorityType)
          ) {
            return;
          }
          const tenantProfileFilter = {
            localAccountId: accountFilter?.localAccountId,
            name: accountFilter?.name,
          };
          const matchingTenantProfiles = entity.tenantProfiles?.filter((tenantProfile) => {
            return this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter);
          });
          if (matchingTenantProfiles && matchingTenantProfiles.length === 0) {
            return;
          }
          matchingAccounts.push(entity);
        });
        return matchingAccounts;
      }
      /**
       * Returns whether or not the given credential entity matches the filter
       * @param entity
       * @param filter
       * @returns
       */
      credentialMatchesFilter(entity, filter2) {
        if (!!filter2.clientId && !this.matchClientId(entity, filter2.clientId)) {
          return false;
        }
        if (
          !!filter2.userAssertionHash &&
          !this.matchUserAssertionHash(entity, filter2.userAssertionHash)
        ) {
          return false;
        }
        if (
          typeof filter2.homeAccountId === 'string' &&
          !this.matchHomeAccountId(entity, filter2.homeAccountId)
        ) {
          return false;
        }
        if (!!filter2.environment && !this.matchEnvironment(entity, filter2.environment)) {
          return false;
        }
        if (!!filter2.realm && !this.matchRealm(entity, filter2.realm)) {
          return false;
        }
        if (!!filter2.credentialType && !this.matchCredentialType(entity, filter2.credentialType)) {
          return false;
        }
        if (!!filter2.familyId && !this.matchFamilyId(entity, filter2.familyId)) {
          return false;
        }
        if (!!filter2.target && !this.matchTarget(entity, filter2.target)) {
          return false;
        }
        if (filter2.requestedClaimsHash || entity.requestedClaimsHash) {
          if (entity.requestedClaimsHash !== filter2.requestedClaimsHash) {
            return false;
          }
        }
        if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
          if (!!filter2.tokenType && !this.matchTokenType(entity, filter2.tokenType)) {
            return false;
          }
          if (filter2.tokenType === AuthenticationScheme.SSH) {
            if (filter2.keyId && !this.matchKeyId(entity, filter2.keyId)) {
              return false;
            }
          }
        }
        return true;
      }
      /**
       * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata
       * @param filter
       */
      getAppMetadataFilteredBy(filter2) {
        const allCacheKeys = this.getKeys();
        const matchingAppMetadata = {};
        allCacheKeys.forEach((cacheKey) => {
          if (!this.isAppMetadata(cacheKey)) {
            return;
          }
          const entity = this.getAppMetadata(cacheKey);
          if (!entity) {
            return;
          }
          if (!!filter2.environment && !this.matchEnvironment(entity, filter2.environment)) {
            return;
          }
          if (!!filter2.clientId && !this.matchClientId(entity, filter2.clientId)) {
            return;
          }
          matchingAppMetadata[cacheKey] = entity;
        });
        return matchingAppMetadata;
      }
      /**
       * retrieve authorityMetadata that contains a matching alias
       * @param filter
       */
      getAuthorityMetadataByAlias(host) {
        const allCacheKeys = this.getAuthorityMetadataKeys();
        let matchedEntity = null;
        allCacheKeys.forEach((cacheKey) => {
          if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {
            return;
          }
          const entity = this.getAuthorityMetadata(cacheKey);
          if (!entity) {
            return;
          }
          if (entity.aliases.indexOf(host) === -1) {
            return;
          }
          matchedEntity = entity;
        });
        return matchedEntity;
      }
      /**
       * Removes all accounts and related tokens from cache.
       */
      removeAllAccounts(correlationId) {
        const accounts = this.getAllAccounts({}, correlationId);
        accounts.forEach((account) => {
          this.removeAccount(account, correlationId);
        });
      }
      /**
       * Removes the account and related tokens for a given account key
       * @param account
       */
      removeAccount(account, correlationId) {
        this.removeAccountContext(account, correlationId);
        const accountKeys = this.getAccountKeys();
        const keyFilter = (key2) => {
          return key2.includes(account.homeAccountId) && key2.includes(account.environment);
        };
        accountKeys.filter(keyFilter).forEach((key2) => {
          this.removeItem(key2, correlationId);
          this.performanceClient.incrementFields({ accountsRemoved: 1 }, correlationId);
        });
      }
      /**
       * Removes credentials associated with the provided account
       * @param account
       */
      removeAccountContext(account, correlationId) {
        const allTokenKeys = this.getTokenKeys();
        const keyFilter = (key2) => {
          return key2.includes(account.homeAccountId) && key2.includes(account.environment);
        };
        allTokenKeys.idToken.filter(keyFilter).forEach((key2) => {
          this.removeIdToken(key2, correlationId);
        });
        allTokenKeys.accessToken.filter(keyFilter).forEach((key2) => {
          this.removeAccessToken(key2, correlationId);
        });
        allTokenKeys.refreshToken.filter(keyFilter).forEach((key2) => {
          this.removeRefreshToken(key2, correlationId);
        });
      }
      /**
       * Removes accessToken from the cache
       * @param key
       * @param correlationId
       */
      removeAccessToken(key2, correlationId) {
        const credential = this.getAccessTokenCredential(key2, correlationId);
        this.removeItem(key2, correlationId);
        this.performanceClient.incrementFields({ accessTokensRemoved: 1 }, correlationId);
        if (
          !credential ||
          credential.credentialType.toLowerCase() !==
            CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase() ||
          credential.tokenType !== AuthenticationScheme.POP
        ) {
          return;
        }
        const kid = credential.keyId;
        if (kid) {
          void this.cryptoImpl.removeTokenBindingKey(kid).catch(() => {
            this.commonLogger.error(`Failed to remove token binding key ${kid}`, correlationId);
            this.performanceClient?.incrementFields(
              { removeTokenBindingKeyFailure: 1 },
              correlationId
            );
          });
        }
      }
      /**
       * Removes all app metadata objects from cache.
       */
      removeAppMetadata(correlationId) {
        const allCacheKeys = this.getKeys();
        allCacheKeys.forEach((cacheKey) => {
          if (this.isAppMetadata(cacheKey)) {
            this.removeItem(cacheKey, correlationId);
          }
        });
        return true;
      }
      /**
       * Retrieve IdTokenEntity from cache
       * @param account {AccountInfo}
       * @param tokenKeys {?TokenKeys}
       * @param targetRealm {?string}
       * @param performanceClient {?IPerformanceClient}
       * @param correlationId {?string}
       */
      getIdToken(account, correlationId, tokenKeys, targetRealm, performanceClient) {
        this.commonLogger.trace('CacheManager - getIdToken called');
        const idTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType: CredentialType.ID_TOKEN,
          clientId: this.clientId,
          realm: targetRealm,
        };
        const idTokenMap = this.getIdTokensByFilter(idTokenFilter, correlationId, tokenKeys);
        const numIdTokens = idTokenMap.size;
        if (numIdTokens < 1) {
          this.commonLogger.info('CacheManager:getIdToken - No token found');
          return null;
        } else if (numIdTokens > 1) {
          let tokensToBeRemoved = idTokenMap;
          if (!targetRealm) {
            const homeIdTokenMap = /* @__PURE__ */ new Map();
            idTokenMap.forEach((idToken, key2) => {
              if (idToken.realm === account.tenantId) {
                homeIdTokenMap.set(key2, idToken);
              }
            });
            const numHomeIdTokens = homeIdTokenMap.size;
            if (numHomeIdTokens < 1) {
              this.commonLogger.info(
                'CacheManager:getIdToken - Multiple ID tokens found for account but none match account entity tenant id, returning first result'
              );
              return idTokenMap.values().next().value;
            } else if (numHomeIdTokens === 1) {
              this.commonLogger.info(
                'CacheManager:getIdToken - Multiple ID tokens found for account, defaulting to home tenant profile'
              );
              return homeIdTokenMap.values().next().value;
            } else {
              tokensToBeRemoved = homeIdTokenMap;
            }
          }
          this.commonLogger.info(
            'CacheManager:getIdToken - Multiple matching ID tokens found, clearing them'
          );
          tokensToBeRemoved.forEach((idToken, key2) => {
            this.removeIdToken(key2, correlationId);
          });
          if (performanceClient && correlationId) {
            performanceClient.addFields({ multiMatchedID: idTokenMap.size }, correlationId);
          }
          return null;
        }
        this.commonLogger.info('CacheManager:getIdToken - Returning ID token');
        return idTokenMap.values().next().value;
      }
      /**
       * Gets all idTokens matching the given filter
       * @param filter
       * @returns
       */
      getIdTokensByFilter(filter2, correlationId, tokenKeys) {
        const idTokenKeys = (tokenKeys && tokenKeys.idToken) || this.getTokenKeys().idToken;
        const idTokens = /* @__PURE__ */ new Map();
        idTokenKeys.forEach((key2) => {
          if (
            !this.idTokenKeyMatchesFilter(key2, {
              clientId: this.clientId,
              ...filter2,
            })
          ) {
            return;
          }
          const idToken = this.getIdTokenCredential(key2, correlationId);
          if (idToken && this.credentialMatchesFilter(idToken, filter2)) {
            idTokens.set(key2, idToken);
          }
        });
        return idTokens;
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       * @returns
       */
      idTokenKeyMatchesFilter(inputKey, filter2) {
        const key2 = inputKey.toLowerCase();
        if (filter2.clientId && key2.indexOf(filter2.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter2.homeAccountId && key2.indexOf(filter2.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        return true;
      }
      /**
       * Removes idToken from the cache
       * @param key
       */
      removeIdToken(key2, correlationId) {
        this.removeItem(key2, correlationId);
      }
      /**
       * Removes refresh token from the cache
       * @param key
       */
      removeRefreshToken(key2, correlationId) {
        this.removeItem(key2, correlationId);
      }
      /**
       * Retrieve AccessTokenEntity from cache
       * @param account {AccountInfo}
       * @param request {BaseAuthRequest}
       * @param correlationId {?string}
       * @param tokenKeys {?TokenKeys}
       * @param performanceClient {?IPerformanceClient}
       */
      getAccessToken(account, request, tokenKeys, targetRealm) {
        const correlationId = request.correlationId;
        this.commonLogger.trace('CacheManager - getAccessToken called', correlationId);
        const scopes = ScopeSet.createSearchScopes(request.scopes);
        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;
        const credentialType =
          authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()
            ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME
            : CredentialType.ACCESS_TOKEN;
        const accessTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType,
          clientId: this.clientId,
          realm: targetRealm || account.tenantId,
          target: scopes,
          tokenType: authScheme,
          keyId: request.sshKid,
          requestedClaimsHash: request.requestedClaimsHash,
        };
        const accessTokenKeys =
          (tokenKeys && tokenKeys.accessToken) || this.getTokenKeys().accessToken;
        const accessTokens = [];
        accessTokenKeys.forEach((key2) => {
          if (this.accessTokenKeyMatchesFilter(key2, accessTokenFilter, true)) {
            const accessToken = this.getAccessTokenCredential(key2, correlationId);
            if (accessToken && this.credentialMatchesFilter(accessToken, accessTokenFilter)) {
              accessTokens.push(accessToken);
            }
          }
        });
        const numAccessTokens = accessTokens.length;
        if (numAccessTokens < 1) {
          this.commonLogger.info('CacheManager:getAccessToken - No token found', correlationId);
          return null;
        } else if (numAccessTokens > 1) {
          this.commonLogger.info(
            'CacheManager:getAccessToken - Multiple access tokens found, clearing them',
            correlationId
          );
          accessTokens.forEach((accessToken) => {
            this.removeAccessToken(this.generateCredentialKey(accessToken), correlationId);
          });
          this.performanceClient.addFields({ multiMatchedAT: accessTokens.length }, correlationId);
          return null;
        }
        this.commonLogger.info(
          'CacheManager:getAccessToken - Returning access token',
          correlationId
        );
        return accessTokens[0];
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       * @param keyMustContainAllScopes
       * @returns
       */
      accessTokenKeyMatchesFilter(inputKey, filter2, keyMustContainAllScopes) {
        const key2 = inputKey.toLowerCase();
        if (filter2.clientId && key2.indexOf(filter2.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter2.homeAccountId && key2.indexOf(filter2.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        if (filter2.realm && key2.indexOf(filter2.realm.toLowerCase()) === -1) {
          return false;
        }
        if (
          filter2.requestedClaimsHash &&
          key2.indexOf(filter2.requestedClaimsHash.toLowerCase()) === -1
        ) {
          return false;
        }
        if (filter2.target) {
          const scopes = filter2.target.asArray();
          for (let i = 0; i < scopes.length; i++) {
            if (keyMustContainAllScopes && !key2.includes(scopes[i].toLowerCase())) {
              return false;
            } else if (!keyMustContainAllScopes && key2.includes(scopes[i].toLowerCase())) {
              return true;
            }
          }
        }
        return true;
      }
      /**
       * Gets all access tokens matching the filter
       * @param filter
       * @returns
       */
      getAccessTokensByFilter(filter2, correlationId) {
        const tokenKeys = this.getTokenKeys();
        const accessTokens = [];
        tokenKeys.accessToken.forEach((key2) => {
          if (!this.accessTokenKeyMatchesFilter(key2, filter2, true)) {
            return;
          }
          const accessToken = this.getAccessTokenCredential(key2, correlationId);
          if (accessToken && this.credentialMatchesFilter(accessToken, filter2)) {
            accessTokens.push(accessToken);
          }
        });
        return accessTokens;
      }
      /**
       * Helper to retrieve the appropriate refresh token from cache
       * @param account {AccountInfo}
       * @param familyRT {boolean}
       * @param correlationId {?string}
       * @param tokenKeys {?TokenKeys}
       * @param performanceClient {?IPerformanceClient}
       */
      getRefreshToken(account, familyRT, correlationId, tokenKeys, performanceClient) {
        this.commonLogger.trace('CacheManager - getRefreshToken called');
        const id = familyRT ? THE_FAMILY_ID : void 0;
        const refreshTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType: CredentialType.REFRESH_TOKEN,
          clientId: this.clientId,
          familyId: id,
        };
        const refreshTokenKeys =
          (tokenKeys && tokenKeys.refreshToken) || this.getTokenKeys().refreshToken;
        const refreshTokens = [];
        refreshTokenKeys.forEach((key2) => {
          if (this.refreshTokenKeyMatchesFilter(key2, refreshTokenFilter)) {
            const refreshToken = this.getRefreshTokenCredential(key2, correlationId);
            if (refreshToken && this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {
              refreshTokens.push(refreshToken);
            }
          }
        });
        const numRefreshTokens = refreshTokens.length;
        if (numRefreshTokens < 1) {
          this.commonLogger.info('CacheManager:getRefreshToken - No refresh token found.');
          return null;
        }
        if (numRefreshTokens > 1 && performanceClient && correlationId) {
          performanceClient.addFields({ multiMatchedRT: numRefreshTokens }, correlationId);
        }
        this.commonLogger.info('CacheManager:getRefreshToken - returning refresh token');
        return refreshTokens[0];
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       */
      refreshTokenKeyMatchesFilter(inputKey, filter2) {
        const key2 = inputKey.toLowerCase();
        if (filter2.familyId && key2.indexOf(filter2.familyId.toLowerCase()) === -1) {
          return false;
        }
        if (
          !filter2.familyId &&
          filter2.clientId &&
          key2.indexOf(filter2.clientId.toLowerCase()) === -1
        ) {
          return false;
        }
        if (filter2.homeAccountId && key2.indexOf(filter2.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        return true;
      }
      /**
       * Retrieve AppMetadataEntity from cache
       */
      readAppMetadataFromCache(environment) {
        const appMetadataFilter = {
          environment,
          clientId: this.clientId,
        };
        const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
        const appMetadataEntries = Object.keys(appMetadata).map((key2) => appMetadata[key2]);
        const numAppMetadata = appMetadataEntries.length;
        if (numAppMetadata < 1) {
          return null;
        } else if (numAppMetadata > 1) {
          throw createClientAuthError(multipleMatchingAppMetadata);
        }
        return appMetadataEntries[0];
      }
      /**
       * Return the family_id value associated  with FOCI
       * @param environment
       * @param clientId
       */
      isAppMetadataFOCI(environment) {
        const appMetadata = this.readAppMetadataFromCache(environment);
        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);
      }
      /**
       * helper to match account ids
       * @param value
       * @param homeAccountId
       */
      matchHomeAccountId(entity, homeAccountId) {
        return !!(
          typeof entity.homeAccountId === 'string' && homeAccountId === entity.homeAccountId
        );
      }
      /**
       * helper to match account ids
       * @param entity
       * @param localAccountId
       * @returns
       */
      matchLocalAccountIdFromTokenClaims(tokenClaims, localAccountId) {
        const idTokenLocalAccountId = tokenClaims.oid || tokenClaims.sub;
        return localAccountId === idTokenLocalAccountId;
      }
      matchLocalAccountIdFromTenantProfile(tenantProfile, localAccountId) {
        return tenantProfile.localAccountId === localAccountId;
      }
      /**
       * helper to match names
       * @param entity
       * @param name
       * @returns true if the downcased name properties are present and match in the filter and the entity
       */
      matchName(claims, name3) {
        return !!(name3.toLowerCase() === claims.name?.toLowerCase());
      }
      /**
       * helper to match usernames
       * @param entity
       * @param username
       * @returns
       */
      matchUsername(cachedUsername, filterUsername) {
        return !!(
          cachedUsername &&
          typeof cachedUsername === 'string' &&
          filterUsername?.toLowerCase() === cachedUsername.toLowerCase()
        );
      }
      /**
       * helper to match assertion
       * @param value
       * @param oboAssertion
       */
      matchUserAssertionHash(entity, userAssertionHash) {
        return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);
      }
      /**
       * helper to match environment
       * @param value
       * @param environment
       */
      matchEnvironment(entity, environment) {
        if (this.staticAuthorityOptions) {
          const staticAliases = getAliasesFromStaticSources(
            this.staticAuthorityOptions,
            this.commonLogger
          );
          if (staticAliases.includes(environment) && staticAliases.includes(entity.environment)) {
            return true;
          }
        }
        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);
        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {
          return true;
        }
        return false;
      }
      /**
       * helper to match credential type
       * @param entity
       * @param credentialType
       */
      matchCredentialType(entity, credentialType) {
        return (
          entity.credentialType &&
          credentialType.toLowerCase() === entity.credentialType.toLowerCase()
        );
      }
      /**
       * helper to match client ids
       * @param entity
       * @param clientId
       */
      matchClientId(entity, clientId) {
        return !!(entity.clientId && clientId === entity.clientId);
      }
      /**
       * helper to match family ids
       * @param entity
       * @param familyId
       */
      matchFamilyId(entity, familyId) {
        return !!(entity.familyId && familyId === entity.familyId);
      }
      /**
       * helper to match realm
       * @param entity
       * @param realm
       */
      matchRealm(entity, realm) {
        return !!(entity.realm?.toLowerCase() === realm.toLowerCase());
      }
      /**
       * helper to match nativeAccountId
       * @param entity
       * @param nativeAccountId
       * @returns boolean indicating the match result
       */
      matchNativeAccountId(entity, nativeAccountId) {
        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);
      }
      /**
       * helper to match loginHint which can be either:
       * 1. login_hint ID token claim
       * 2. username in cached account object
       * 3. upn in ID token claims
       * @param entity
       * @param loginHint
       * @returns
       */
      matchLoginHintFromTokenClaims(tokenClaims, loginHint) {
        if (tokenClaims.login_hint === loginHint) {
          return true;
        }
        if (tokenClaims.preferred_username === loginHint) {
          return true;
        }
        if (tokenClaims.upn === loginHint) {
          return true;
        }
        return false;
      }
      /**
       * Helper to match sid
       * @param entity
       * @param sid
       * @returns true if the sid claim is present and matches the filter
       */
      matchSid(idTokenClaims, sid) {
        return idTokenClaims.sid === sid;
      }
      matchAuthorityType(entity, authorityType) {
        return !!(
          entity.authorityType && authorityType.toLowerCase() === entity.authorityType.toLowerCase()
        );
      }
      /**
       * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.
       * @param entity
       * @param target
       */
      matchTarget(entity, target) {
        const isNotAccessTokenCredential =
          entity.credentialType !== CredentialType.ACCESS_TOKEN &&
          entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
        if (isNotAccessTokenCredential || !entity.target) {
          return false;
        }
        const entityScopeSet = ScopeSet.fromString(entity.target);
        return entityScopeSet.containsScopeSet(target);
      }
      /**
       * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise
       * @param entity
       * @param tokenType
       */
      matchTokenType(entity, tokenType) {
        return !!(entity.tokenType && entity.tokenType === tokenType);
      }
      /**
       * Returns true if the credential's keyId matches the one in the request, false otherwise
       * @param entity
       * @param keyId
       */
      matchKeyId(entity, keyId) {
        return !!(entity.keyId && entity.keyId === keyId);
      }
      /**
       * returns if a given cache entity is of the type appmetadata
       * @param key
       */
      isAppMetadata(key2) {
        return key2.indexOf(APP_METADATA) !== -1;
      }
      /**
       * returns if a given cache entity is of the type authoritymetadata
       * @param key
       */
      isAuthorityMetadata(key2) {
        return key2.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;
      }
      /**
       * returns cache key used for cloud instance metadata
       */
      generateAuthorityMetadataCacheKey(authority) {
        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;
      }
      /**
       * Helper to convert serialized data to object
       * @param obj
       * @param json
       */
      static toObject(obj, json) {
        for (const propertyName in json) {
          obj[propertyName] = json[propertyName];
        }
        return obj;
      }
    };
    DefaultStorageClass = class extends CacheManager {
      async setAccount() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccount() {
        throw createClientAuthError(methodNotImplemented);
      }
      async setIdTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getIdTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      async setAccessTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccessTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      async setRefreshTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getRefreshTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      setAppMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAppMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      setServerTelemetry() {
        throw createClientAuthError(methodNotImplemented);
      }
      getServerTelemetry() {
        throw createClientAuthError(methodNotImplemented);
      }
      setAuthorityMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAuthorityMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAuthorityMetadataKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      setThrottlingCache() {
        throw createClientAuthError(methodNotImplemented);
      }
      getThrottlingCache() {
        throw createClientAuthError(methodNotImplemented);
      }
      removeItem() {
        throw createClientAuthError(methodNotImplemented);
      }
      getKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccountKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      getTokenKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      generateCredentialKey() {
        throw createClientAuthError(methodNotImplemented);
      }
      generateAccountKey() {
        throw createClientAuthError(methodNotImplemented);
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/ProtocolMode.mjs
var ProtocolMode;
var init_ProtocolMode = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/ProtocolMode.mjs'() {
    'use strict';
    ProtocolMode = {
      /**
       * Auth Code + PKCE with Entra ID (formerly AAD) specific optimizations and features
       */
      AAD: 'AAD',
      /**
       * Auth Code + PKCE without Entra ID specific optimizations and features. For use only with non-Microsoft owned authorities.
       * Support is limited for this mode.
       */
      OIDC: 'OIDC',
      /**
       * Encrypted Authorize Response (EAR) with Entra ID specific optimizations and features
       */
      EAR: 'EAR',
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs
var PerformanceEvents, PerformanceEventAbbreviations, PerformanceEventStatus;
var init_PerformanceEvent = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs'() {
    'use strict';
    PerformanceEvents = {
      /**
       * acquireTokenByCode API (msal-browser and msal-node).
       * Used to acquire tokens by trading an authorization code against the token endpoint.
       */
      AcquireTokenByCode: 'acquireTokenByCode',
      /**
       * acquireTokenByRefreshToken API (msal-browser and msal-node).
       * Used to renew an access token using a refresh token against the token endpoint.
       */
      AcquireTokenByRefreshToken: 'acquireTokenByRefreshToken',
      /**
       * acquireTokenSilent API (msal-browser and msal-node).
       * Used to silently acquire a new access token (from the cache or the network).
       */
      AcquireTokenSilent: 'acquireTokenSilent',
      /**
       * acquireTokenSilentAsync (msal-browser).
       * Internal API for acquireTokenSilent.
       */
      AcquireTokenSilentAsync: 'acquireTokenSilentAsync',
      /**
       * acquireTokenPopup (msal-browser).
       * Used to acquire a new access token interactively through pop ups
       */
      AcquireTokenPopup: 'acquireTokenPopup',
      /**
       * acquireTokenPreRedirect (msal-browser).
       * First part of the redirect flow.
       * Used to acquire a new access token interactively through redirects.
       */
      AcquireTokenPreRedirect: 'acquireTokenPreRedirect',
      /**
       * acquireTokenRedirect (msal-browser).
       * Second part of the redirect flow.
       * Used to acquire a new access token interactively through redirects.
       */
      AcquireTokenRedirect: 'acquireTokenRedirect',
      /**
       * getPublicKeyThumbprint API in CryptoOpts class (msal-browser).
       * Used to generate a public/private keypair and generate a public key thumbprint for pop requests.
       */
      CryptoOptsGetPublicKeyThumbprint: 'cryptoOptsGetPublicKeyThumbprint',
      /**
       * signJwt API in CryptoOpts class (msal-browser).
       * Used to signed a pop token.
       */
      CryptoOptsSignJwt: 'cryptoOptsSignJwt',
      /**
       * acquireToken API in the SilentCacheClient class (msal-browser).
       * Used to read access tokens from the cache.
       */
      SilentCacheClientAcquireToken: 'silentCacheClientAcquireToken',
      /**
       * acquireToken API in the SilentIframeClient class (msal-browser).
       * Used to acquire a new set of tokens from the authorize endpoint in a hidden iframe.
       */
      SilentIframeClientAcquireToken: 'silentIframeClientAcquireToken',
      AwaitConcurrentIframe: 'awaitConcurrentIframe',
      /**
       * acquireToken API in SilentRereshClient (msal-browser).
       * Used to acquire a new set of tokens from the token endpoint using a refresh token.
       */
      SilentRefreshClientAcquireToken: 'silentRefreshClientAcquireToken',
      /**
       * ssoSilent API (msal-browser).
       * Used to silently acquire an authorization code and set of tokens using a hidden iframe.
       */
      SsoSilent: 'ssoSilent',
      /**
       * getDiscoveredAuthority API in StandardInteractionClient class (msal-browser).
       * Used to load authority metadata for a request.
       */
      StandardInteractionClientGetDiscoveredAuthority:
        'standardInteractionClientGetDiscoveredAuthority',
      /**
       * acquireToken APIs in msal-browser.
       * Used to make an /authorize endpoint call with native brokering enabled.
       */
      FetchAccountIdWithNativeBroker: 'fetchAccountIdWithNativeBroker',
      /**
       * acquireToken API in NativeInteractionClient class (msal-browser).
       * Used to acquire a token from Native component when native brokering is enabled.
       */
      NativeInteractionClientAcquireToken: 'nativeInteractionClientAcquireToken',
      /**
       * Time spent creating default headers for requests to token endpoint
       */
      BaseClientCreateTokenRequestHeaders: 'baseClientCreateTokenRequestHeaders',
      /**
       * Time spent sending/waiting for the response of a request to the token endpoint
       */
      NetworkClientSendPostRequestAsync: 'networkClientSendPostRequestAsync',
      RefreshTokenClientExecutePostToTokenEndpoint: 'refreshTokenClientExecutePostToTokenEndpoint',
      AuthorizationCodeClientExecutePostToTokenEndpoint:
        'authorizationCodeClientExecutePostToTokenEndpoint',
      /**
       * Used to measure the time taken for completing embedded-broker handshake (PW-Broker).
       */
      BrokerHandhshake: 'brokerHandshake',
      /**
       * acquireTokenByRefreshToken API in BrokerClientApplication (PW-Broker) .
       */
      AcquireTokenByRefreshTokenInBroker: 'acquireTokenByRefreshTokenInBroker',
      /**
       * Time taken for token acquisition by broker
       */
      AcquireTokenByBroker: 'acquireTokenByBroker',
      /**
       * Time spent on the network for refresh token acquisition
       */
      RefreshTokenClientExecuteTokenRequest: 'refreshTokenClientExecuteTokenRequest',
      /**
       * Time taken for acquiring refresh token , records RT size
       */
      RefreshTokenClientAcquireToken: 'refreshTokenClientAcquireToken',
      /**
       * Time taken for acquiring cached refresh token
       */
      RefreshTokenClientAcquireTokenWithCachedRefreshToken:
        'refreshTokenClientAcquireTokenWithCachedRefreshToken',
      /**
       * acquireTokenByRefreshToken API in RefreshTokenClient (msal-common).
       */
      RefreshTokenClientAcquireTokenByRefreshToken: 'refreshTokenClientAcquireTokenByRefreshToken',
      /**
       * Helper function to create token request body in RefreshTokenClient (msal-common).
       */
      RefreshTokenClientCreateTokenRequestBody: 'refreshTokenClientCreateTokenRequestBody',
      /**
       * acquireTokenFromCache (msal-browser).
       * Internal API for acquiring token from cache
       */
      AcquireTokenFromCache: 'acquireTokenFromCache',
      SilentFlowClientAcquireCachedToken: 'silentFlowClientAcquireCachedToken',
      SilentFlowClientGenerateResultFromCacheRecord:
        'silentFlowClientGenerateResultFromCacheRecord',
      /**
       * acquireTokenBySilentIframe (msal-browser).
       * Internal API for acquiring token by silent Iframe
       */
      AcquireTokenBySilentIframe: 'acquireTokenBySilentIframe',
      /**
       * Internal API for initializing base request in BaseInteractionClient (msal-browser)
       */
      InitializeBaseRequest: 'initializeBaseRequest',
      /**
       * Internal API for initializing silent request in SilentCacheClient (msal-browser)
       */
      InitializeSilentRequest: 'initializeSilentRequest',
      InitializeClientApplication: 'initializeClientApplication',
      InitializeCache: 'initializeCache',
      /**
       * Helper function in SilentIframeClient class (msal-browser).
       */
      SilentIframeClientTokenHelper: 'silentIframeClientTokenHelper',
      /**
       * SilentHandler
       */
      SilentHandlerInitiateAuthRequest: 'silentHandlerInitiateAuthRequest',
      SilentHandlerMonitorIframeForHash: 'silentHandlerMonitorIframeForHash',
      SilentHandlerLoadFrame: 'silentHandlerLoadFrame',
      SilentHandlerLoadFrameSync: 'silentHandlerLoadFrameSync',
      /**
       * Helper functions in StandardInteractionClient class (msal-browser)
       */
      StandardInteractionClientCreateAuthCodeClient:
        'standardInteractionClientCreateAuthCodeClient',
      StandardInteractionClientGetClientConfiguration:
        'standardInteractionClientGetClientConfiguration',
      StandardInteractionClientInitializeAuthorizationRequest:
        'standardInteractionClientInitializeAuthorizationRequest',
      /**
       * getAuthCodeUrl API (msal-browser and msal-node).
       */
      GetAuthCodeUrl: 'getAuthCodeUrl',
      GetStandardParams: 'getStandardParams',
      /**
       * Functions from InteractionHandler (msal-browser)
       */
      HandleCodeResponseFromServer: 'handleCodeResponseFromServer',
      HandleCodeResponse: 'handleCodeResponse',
      HandleResponseEar: 'handleResponseEar',
      HandleResponsePlatformBroker: 'handleResponsePlatformBroker',
      HandleResponseCode: 'handleResponseCode',
      UpdateTokenEndpointAuthority: 'updateTokenEndpointAuthority',
      /**
       * APIs in Authorization Code Client (msal-common)
       */
      AuthClientAcquireToken: 'authClientAcquireToken',
      AuthClientExecuteTokenRequest: 'authClientExecuteTokenRequest',
      AuthClientCreateTokenRequestBody: 'authClientCreateTokenRequestBody',
      /**
       * Generate functions in PopTokenGenerator (msal-common)
       */
      PopTokenGenerateCnf: 'popTokenGenerateCnf',
      PopTokenGenerateKid: 'popTokenGenerateKid',
      /**
       * handleServerTokenResponse API in ResponseHandler (msal-common)
       */
      HandleServerTokenResponse: 'handleServerTokenResponse',
      DeserializeResponse: 'deserializeResponse',
      /**
       * Authority functions
       */
      AuthorityFactoryCreateDiscoveredInstance: 'authorityFactoryCreateDiscoveredInstance',
      AuthorityResolveEndpointsAsync: 'authorityResolveEndpointsAsync',
      AuthorityResolveEndpointsFromLocalSources: 'authorityResolveEndpointsFromLocalSources',
      AuthorityGetCloudDiscoveryMetadataFromNetwork:
        'authorityGetCloudDiscoveryMetadataFromNetwork',
      AuthorityUpdateCloudDiscoveryMetadata: 'authorityUpdateCloudDiscoveryMetadata',
      AuthorityGetEndpointMetadataFromNetwork: 'authorityGetEndpointMetadataFromNetwork',
      AuthorityUpdateEndpointMetadata: 'authorityUpdateEndpointMetadata',
      AuthorityUpdateMetadataWithRegionalInformation:
        'authorityUpdateMetadataWithRegionalInformation',
      /**
       * Region Discovery functions
       */
      RegionDiscoveryDetectRegion: 'regionDiscoveryDetectRegion',
      RegionDiscoveryGetRegionFromIMDS: 'regionDiscoveryGetRegionFromIMDS',
      RegionDiscoveryGetCurrentVersion: 'regionDiscoveryGetCurrentVersion',
      AcquireTokenByCodeAsync: 'acquireTokenByCodeAsync',
      GetEndpointMetadataFromNetwork: 'getEndpointMetadataFromNetwork',
      GetCloudDiscoveryMetadataFromNetworkMeasurement:
        'getCloudDiscoveryMetadataFromNetworkMeasurement',
      HandleRedirectPromiseMeasurement: 'handleRedirectPromise',
      HandleNativeRedirectPromiseMeasurement: 'handleNativeRedirectPromise',
      UpdateCloudDiscoveryMetadataMeasurement: 'updateCloudDiscoveryMetadataMeasurement',
      UsernamePasswordClientAcquireToken: 'usernamePasswordClientAcquireToken',
      NativeMessageHandlerHandshake: 'nativeMessageHandlerHandshake',
      NativeGenerateAuthResult: 'nativeGenerateAuthResult',
      RemoveHiddenIframe: 'removeHiddenIframe',
      /**
       * Cache operations
       */
      ClearTokensAndKeysWithClaims: 'clearTokensAndKeysWithClaims',
      CacheManagerGetRefreshToken: 'cacheManagerGetRefreshToken',
      ImportExistingCache: 'importExistingCache',
      SetUserData: 'setUserData',
      LocalStorageUpdated: 'localStorageUpdated',
      /**
       * Crypto Operations
       */
      GeneratePkceCodes: 'generatePkceCodes',
      GenerateCodeVerifier: 'generateCodeVerifier',
      GenerateCodeChallengeFromVerifier: 'generateCodeChallengeFromVerifier',
      Sha256Digest: 'sha256Digest',
      GetRandomValues: 'getRandomValues',
      GenerateHKDF: 'generateHKDF',
      GenerateBaseKey: 'generateBaseKey',
      Base64Decode: 'base64Decode',
      UrlEncodeArr: 'urlEncodeArr',
      Encrypt: 'encrypt',
      Decrypt: 'decrypt',
      GenerateEarKey: 'generateEarKey',
      DecryptEarResponse: 'decryptEarResponse',
    };
    PerformanceEventAbbreviations = /* @__PURE__ */ new Map([
      [PerformanceEvents.AcquireTokenByCode, 'ATByCode'],
      [PerformanceEvents.AcquireTokenByRefreshToken, 'ATByRT'],
      [PerformanceEvents.AcquireTokenSilent, 'ATS'],
      [PerformanceEvents.AcquireTokenSilentAsync, 'ATSAsync'],
      [PerformanceEvents.AcquireTokenPopup, 'ATPopup'],
      [PerformanceEvents.AcquireTokenRedirect, 'ATRedirect'],
      [PerformanceEvents.CryptoOptsGetPublicKeyThumbprint, 'CryptoGetPKThumb'],
      [PerformanceEvents.CryptoOptsSignJwt, 'CryptoSignJwt'],
      [PerformanceEvents.SilentCacheClientAcquireToken, 'SltCacheClientAT'],
      [PerformanceEvents.SilentIframeClientAcquireToken, 'SltIframeClientAT'],
      [PerformanceEvents.SilentRefreshClientAcquireToken, 'SltRClientAT'],
      [PerformanceEvents.SsoSilent, 'SsoSlt'],
      [
        PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority,
        'StdIntClientGetDiscAuth',
      ],
      [PerformanceEvents.FetchAccountIdWithNativeBroker, 'FetchAccIdWithNtvBroker'],
      [PerformanceEvents.NativeInteractionClientAcquireToken, 'NtvIntClientAT'],
      [PerformanceEvents.BaseClientCreateTokenRequestHeaders, 'BaseClientCreateTReqHead'],
      [PerformanceEvents.NetworkClientSendPostRequestAsync, 'NetClientSendPost'],
      [PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint, 'RTClientExecPost'],
      [
        PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint,
        'AuthCodeClientExecPost',
      ],
      [PerformanceEvents.BrokerHandhshake, 'BrokerHandshake'],
      [PerformanceEvents.AcquireTokenByRefreshTokenInBroker, 'ATByRTInBroker'],
      [PerformanceEvents.AcquireTokenByBroker, 'ATByBroker'],
      [PerformanceEvents.RefreshTokenClientExecuteTokenRequest, 'RTClientExecTReq'],
      [PerformanceEvents.RefreshTokenClientAcquireToken, 'RTClientAT'],
      [
        PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,
        'RTClientATWithCachedRT',
      ],
      [PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, 'RTClientATByRT'],
      [PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, 'RTClientCreateTReqBody'],
      [PerformanceEvents.AcquireTokenFromCache, 'ATFromCache'],
      [PerformanceEvents.SilentFlowClientAcquireCachedToken, 'SltFlowClientATCached'],
      [
        PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord,
        'SltFlowClientGenResFromCache',
      ],
      [PerformanceEvents.AcquireTokenBySilentIframe, 'ATBySltIframe'],
      [PerformanceEvents.InitializeBaseRequest, 'InitBaseReq'],
      [PerformanceEvents.InitializeSilentRequest, 'InitSltReq'],
      [PerformanceEvents.InitializeClientApplication, 'InitClientApplication'],
      [PerformanceEvents.InitializeCache, 'InitCache'],
      [PerformanceEvents.ImportExistingCache, 'importCache'],
      [PerformanceEvents.SetUserData, 'setUserData'],
      [PerformanceEvents.LocalStorageUpdated, 'localStorageUpdated'],
      [PerformanceEvents.SilentIframeClientTokenHelper, 'SIClientTHelper'],
      [PerformanceEvents.SilentHandlerInitiateAuthRequest, 'SHandlerInitAuthReq'],
      [PerformanceEvents.SilentHandlerMonitorIframeForHash, 'SltHandlerMonitorIframeForHash'],
      [PerformanceEvents.SilentHandlerLoadFrame, 'SHandlerLoadFrame'],
      [PerformanceEvents.SilentHandlerLoadFrameSync, 'SHandlerLoadFrameSync'],
      [
        PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,
        'StdIntClientCreateAuthCodeClient',
      ],
      [
        PerformanceEvents.StandardInteractionClientGetClientConfiguration,
        'StdIntClientGetClientConf',
      ],
      [
        PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest,
        'StdIntClientInitAuthReq',
      ],
      [PerformanceEvents.GetAuthCodeUrl, 'GetAuthCodeUrl'],
      [PerformanceEvents.HandleCodeResponseFromServer, 'HandleCodeResFromServer'],
      [PerformanceEvents.HandleCodeResponse, 'HandleCodeResp'],
      [PerformanceEvents.HandleResponseEar, 'HandleRespEar'],
      [PerformanceEvents.HandleResponseCode, 'HandleRespCode'],
      [PerformanceEvents.HandleResponsePlatformBroker, 'HandleRespPlatBroker'],
      [PerformanceEvents.UpdateTokenEndpointAuthority, 'UpdTEndpointAuth'],
      [PerformanceEvents.AuthClientAcquireToken, 'AuthClientAT'],
      [PerformanceEvents.AuthClientExecuteTokenRequest, 'AuthClientExecTReq'],
      [PerformanceEvents.AuthClientCreateTokenRequestBody, 'AuthClientCreateTReqBody'],
      [PerformanceEvents.PopTokenGenerateCnf, 'PopTGenCnf'],
      [PerformanceEvents.PopTokenGenerateKid, 'PopTGenKid'],
      [PerformanceEvents.HandleServerTokenResponse, 'HandleServerTRes'],
      [PerformanceEvents.DeserializeResponse, 'DeserializeRes'],
      [PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, 'AuthFactCreateDiscInst'],
      [PerformanceEvents.AuthorityResolveEndpointsAsync, 'AuthResolveEndpointsAsync'],
      [
        PerformanceEvents.AuthorityResolveEndpointsFromLocalSources,
        'AuthResolveEndpointsFromLocal',
      ],
      [PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, 'AuthGetCDMetaFromNet'],
      [PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, 'AuthUpdCDMeta'],
      [PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, 'AuthUpdCDMetaFromNet'],
      [PerformanceEvents.AuthorityUpdateEndpointMetadata, 'AuthUpdEndpointMeta'],
      [PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, 'AuthUpdMetaWithRegInfo'],
      [PerformanceEvents.RegionDiscoveryDetectRegion, 'RegDiscDetectReg'],
      [PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, 'RegDiscGetRegFromIMDS'],
      [PerformanceEvents.RegionDiscoveryGetCurrentVersion, 'RegDiscGetCurrentVer'],
      [PerformanceEvents.AcquireTokenByCodeAsync, 'ATByCodeAsync'],
      [PerformanceEvents.GetEndpointMetadataFromNetwork, 'GetEndpointMetaFromNet'],
      [PerformanceEvents.GetCloudDiscoveryMetadataFromNetworkMeasurement, 'GetCDMetaFromNet'],
      [PerformanceEvents.HandleRedirectPromiseMeasurement, 'HandleRedirectPromise'],
      [PerformanceEvents.HandleNativeRedirectPromiseMeasurement, 'HandleNtvRedirectPromise'],
      [PerformanceEvents.UpdateCloudDiscoveryMetadataMeasurement, 'UpdateCDMeta'],
      [PerformanceEvents.UsernamePasswordClientAcquireToken, 'UserPassClientAT'],
      [PerformanceEvents.NativeMessageHandlerHandshake, 'NtvMsgHandlerHandshake'],
      [PerformanceEvents.NativeGenerateAuthResult, 'NtvGenAuthRes'],
      [PerformanceEvents.RemoveHiddenIframe, 'RemoveHiddenIframe'],
      [PerformanceEvents.ClearTokensAndKeysWithClaims, 'ClearTAndKeysWithClaims'],
      [PerformanceEvents.CacheManagerGetRefreshToken, 'CacheManagerGetRT'],
      [PerformanceEvents.GeneratePkceCodes, 'GenPkceCodes'],
      [PerformanceEvents.GenerateCodeVerifier, 'GenCodeVerifier'],
      [PerformanceEvents.GenerateCodeChallengeFromVerifier, 'GenCodeChallengeFromVerifier'],
      [PerformanceEvents.Sha256Digest, 'Sha256Digest'],
      [PerformanceEvents.GetRandomValues, 'GetRandomValues'],
      [PerformanceEvents.GenerateHKDF, 'genHKDF'],
      [PerformanceEvents.GenerateBaseKey, 'genBaseKey'],
      [PerformanceEvents.Base64Decode, 'b64Decode'],
      [PerformanceEvents.UrlEncodeArr, 'urlEncArr'],
      [PerformanceEvents.Encrypt, 'encrypt'],
      [PerformanceEvents.Decrypt, 'decrypt'],
      [PerformanceEvents.GenerateEarKey, 'genEarKey'],
      [PerformanceEvents.DecryptEarResponse, 'decryptEarResp'],
    ]);
    PerformanceEventStatus = {
      NotStarted: 0,
      InProgress: 1,
      Completed: 2,
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/telemetry/performance/StubPerformanceClient.mjs
var StubPerformanceMeasurement, StubPerformanceClient;
var init_StubPerformanceClient = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/telemetry/performance/StubPerformanceClient.mjs'() {
    'use strict';
    init_PerformanceEvent();
    StubPerformanceMeasurement = class {
      startMeasurement() {
        return;
      }
      endMeasurement() {
        return;
      }
      flushMeasurement() {
        return null;
      }
    };
    StubPerformanceClient = class {
      generateId() {
        return 'callback-id';
      }
      startMeasurement(measureName, correlationId) {
        return {
          end: () => null,
          discard: () => {},
          add: () => {},
          increment: () => {},
          event: {
            eventId: this.generateId(),
            status: PerformanceEventStatus.InProgress,
            authority: '',
            libraryName: '',
            libraryVersion: '',
            clientId: '',
            name: measureName,
            startTimeMs: Date.now(),
            correlationId: correlationId || '',
          },
          measurement: new StubPerformanceMeasurement(),
        };
      }
      startPerformanceMeasurement() {
        return new StubPerformanceMeasurement();
      }
      calculateQueuedTime() {
        return 0;
      }
      addQueueMeasurement() {
        return;
      }
      setPreQueueTime() {
        return;
      }
      endMeasurement() {
        return null;
      }
      discardMeasurements() {
        return;
      }
      removePerformanceCallback() {
        return true;
      }
      addPerformanceCallback() {
        return '';
      }
      emitEvents() {
        return;
      }
      addFields() {
        return;
      }
      incrementFields() {
        return;
      }
      cacheEventByCorrelationId() {
        return;
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/config/ClientConfiguration.mjs
function buildClientConfiguration({
  authOptions: userAuthOptions,
  systemOptions: userSystemOptions,
  loggerOptions: userLoggerOption,
  cacheOptions: userCacheOptions,
  storageInterface: storageImplementation,
  networkInterface: networkImplementation,
  cryptoInterface: cryptoImplementation,
  clientCredentials,
  libraryInfo,
  telemetry,
  serverTelemetryManager,
  persistencePlugin,
  serializableCache,
}) {
  const loggerOptions = {
    ...DEFAULT_LOGGER_IMPLEMENTATION,
    ...userLoggerOption,
  };
  return {
    authOptions: buildAuthOptions(userAuthOptions),
    systemOptions: { ...DEFAULT_SYSTEM_OPTIONS, ...userSystemOptions },
    loggerOptions,
    cacheOptions: { ...DEFAULT_CACHE_OPTIONS, ...userCacheOptions },
    storageInterface:
      storageImplementation ||
      new DefaultStorageClass(
        userAuthOptions.clientId,
        DEFAULT_CRYPTO_IMPLEMENTATION,
        new Logger(loggerOptions),
        new StubPerformanceClient()
      ),
    networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
    cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,
    clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,
    libraryInfo: { ...DEFAULT_LIBRARY_INFO, ...libraryInfo },
    telemetry: { ...DEFAULT_TELEMETRY_OPTIONS, ...telemetry },
    serverTelemetryManager: serverTelemetryManager || null,
    persistencePlugin: persistencePlugin || null,
    serializableCache: serializableCache || null,
  };
}
function buildAuthOptions(authOptions) {
  return {
    clientCapabilities: [],
    azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS,
    skipAuthorityMetadataCache: false,
    instanceAware: false,
    encodeExtraQueryParams: false,
    ...authOptions,
  };
}
function isOidcProtocolMode(config) {
  return config.authOptions.authority.options.protocolMode === ProtocolMode.OIDC;
}
var DEFAULT_SYSTEM_OPTIONS,
  DEFAULT_LOGGER_IMPLEMENTATION,
  DEFAULT_CACHE_OPTIONS,
  DEFAULT_NETWORK_IMPLEMENTATION,
  DEFAULT_LIBRARY_INFO,
  DEFAULT_CLIENT_CREDENTIALS,
  DEFAULT_AZURE_CLOUD_OPTIONS,
  DEFAULT_TELEMETRY_OPTIONS;
var init_ClientConfiguration = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/config/ClientConfiguration.mjs'() {
    'use strict';
    init_ICrypto();
    init_Logger();
    init_Constants();
    init_packageMetadata();
    init_AuthorityOptions();
    init_CacheManager();
    init_ProtocolMode();
    init_ClientAuthError();
    init_StubPerformanceClient();
    init_ClientAuthErrorCodes();
    DEFAULT_SYSTEM_OPTIONS = {
      tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
      preventCorsPreflight: false,
    };
    DEFAULT_LOGGER_IMPLEMENTATION = {
      loggerCallback: () => {},
      piiLoggingEnabled: false,
      logLevel: LogLevel3.Info,
      correlationId: Constants.EMPTY_STRING,
    };
    DEFAULT_CACHE_OPTIONS = {
      claimsBasedCachingEnabled: false,
    };
    DEFAULT_NETWORK_IMPLEMENTATION = {
      async sendGetRequestAsync() {
        throw createClientAuthError(methodNotImplemented);
      },
      async sendPostRequestAsync() {
        throw createClientAuthError(methodNotImplemented);
      },
    };
    DEFAULT_LIBRARY_INFO = {
      sku: Constants.SKU,
      version: version2,
      cpu: Constants.EMPTY_STRING,
      os: Constants.EMPTY_STRING,
    };
    DEFAULT_CLIENT_CREDENTIALS = {
      clientSecret: Constants.EMPTY_STRING,
      clientAssertion: void 0,
    };
    DEFAULT_AZURE_CLOUD_OPTIONS = {
      azureCloudInstance: AzureCloudInstance.None,
      tenant: `${Constants.DEFAULT_COMMON_TENANT}`,
    };
    DEFAULT_TELEMETRY_OPTIONS = {
      application: {
        appName: '',
        appVersion: '',
      },
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/account/CcsCredential.mjs
var CcsCredentialType;
var init_CcsCredential = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/account/CcsCredential.mjs'() {
    'use strict';
    CcsCredentialType = {
      HOME_ACCOUNT_ID: 'home_account_id',
      UPN: 'UPN',
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/account/ClientInfo.mjs
function buildClientInfo(rawClientInfo, base64Decode) {
  if (!rawClientInfo) {
    throw createClientAuthError(clientInfoEmptyError);
  }
  try {
    const decodedClientInfo = base64Decode(rawClientInfo);
    return JSON.parse(decodedClientInfo);
  } catch (e) {
    throw createClientAuthError(clientInfoDecodingError);
  }
}
function buildClientInfoFromHomeAccountId(homeAccountId) {
  if (!homeAccountId) {
    throw createClientAuthError(clientInfoDecodingError);
  }
  const clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
  return {
    uid: clientInfoParts[0],
    utid: clientInfoParts.length < 2 ? Constants.EMPTY_STRING : clientInfoParts[1],
  };
}
var init_ClientInfo = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/account/ClientInfo.mjs'() {
    'use strict';
    init_ClientAuthError();
    init_Constants();
    init_ClientAuthErrorCodes();
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/constants/AADServerParamKeys.mjs
var AADServerParamKeys_exports = {};
__export(AADServerParamKeys_exports, {
  ACCESS_TOKEN: () => ACCESS_TOKEN,
  BROKER_CLIENT_ID: () => BROKER_CLIENT_ID,
  BROKER_REDIRECT_URI: () => BROKER_REDIRECT_URI,
  CCS_HEADER: () => CCS_HEADER,
  CLAIMS: () => CLAIMS,
  CLIENT_ASSERTION: () => CLIENT_ASSERTION,
  CLIENT_ASSERTION_TYPE: () => CLIENT_ASSERTION_TYPE,
  CLIENT_ID: () => CLIENT_ID,
  CLIENT_INFO: () => CLIENT_INFO2,
  CLIENT_REQUEST_ID: () => CLIENT_REQUEST_ID,
  CLIENT_SECRET: () => CLIENT_SECRET,
  CODE: () => CODE,
  CODE_CHALLENGE: () => CODE_CHALLENGE,
  CODE_CHALLENGE_METHOD: () => CODE_CHALLENGE_METHOD,
  CODE_VERIFIER: () => CODE_VERIFIER,
  DEVICE_CODE: () => DEVICE_CODE,
  DOMAIN_HINT: () => DOMAIN_HINT,
  EAR_JWE_CRYPTO: () => EAR_JWE_CRYPTO,
  EAR_JWK: () => EAR_JWK,
  ERROR: () => ERROR,
  ERROR_DESCRIPTION: () => ERROR_DESCRIPTION,
  EXPIRES_IN: () => EXPIRES_IN,
  FOCI: () => FOCI,
  GRANT_TYPE: () => GRANT_TYPE,
  ID_TOKEN: () => ID_TOKEN,
  ID_TOKEN_HINT: () => ID_TOKEN_HINT,
  INSTANCE_AWARE: () => INSTANCE_AWARE,
  LOGIN_HINT: () => LOGIN_HINT,
  LOGOUT_HINT: () => LOGOUT_HINT,
  NATIVE_BROKER: () => NATIVE_BROKER,
  NONCE: () => NONCE,
  OBO_ASSERTION: () => OBO_ASSERTION,
  ON_BEHALF_OF: () => ON_BEHALF_OF,
  POST_LOGOUT_URI: () => POST_LOGOUT_URI,
  PROMPT: () => PROMPT,
  REDIRECT_URI: () => REDIRECT_URI,
  REFRESH_TOKEN: () => REFRESH_TOKEN,
  REFRESH_TOKEN_EXPIRES_IN: () => REFRESH_TOKEN_EXPIRES_IN,
  REQUESTED_TOKEN_USE: () => REQUESTED_TOKEN_USE,
  REQ_CNF: () => REQ_CNF,
  RESPONSE_MODE: () => RESPONSE_MODE,
  RESPONSE_TYPE: () => RESPONSE_TYPE,
  RETURN_SPA_CODE: () => RETURN_SPA_CODE,
  SCOPE: () => SCOPE,
  SESSION_STATE: () => SESSION_STATE,
  SID: () => SID,
  STATE: () => STATE,
  TOKEN_TYPE: () => TOKEN_TYPE,
  X_APP_NAME: () => X_APP_NAME,
  X_APP_VER: () => X_APP_VER,
  X_CLIENT_CPU: () => X_CLIENT_CPU,
  X_CLIENT_CURR_TELEM: () => X_CLIENT_CURR_TELEM,
  X_CLIENT_EXTRA_SKU: () => X_CLIENT_EXTRA_SKU,
  X_CLIENT_LAST_TELEM: () => X_CLIENT_LAST_TELEM,
  X_CLIENT_OS: () => X_CLIENT_OS,
  X_CLIENT_SKU: () => X_CLIENT_SKU,
  X_CLIENT_VER: () => X_CLIENT_VER,
  X_MS_LIB_CAPABILITY: () => X_MS_LIB_CAPABILITY,
});
var CLIENT_ID,
  REDIRECT_URI,
  RESPONSE_TYPE,
  RESPONSE_MODE,
  GRANT_TYPE,
  CLAIMS,
  SCOPE,
  ERROR,
  ERROR_DESCRIPTION,
  ACCESS_TOKEN,
  ID_TOKEN,
  REFRESH_TOKEN,
  EXPIRES_IN,
  REFRESH_TOKEN_EXPIRES_IN,
  STATE,
  NONCE,
  PROMPT,
  SESSION_STATE,
  CLIENT_INFO2,
  CODE,
  CODE_CHALLENGE,
  CODE_CHALLENGE_METHOD,
  CODE_VERIFIER,
  CLIENT_REQUEST_ID,
  X_CLIENT_SKU,
  X_CLIENT_VER,
  X_CLIENT_OS,
  X_CLIENT_CPU,
  X_CLIENT_CURR_TELEM,
  X_CLIENT_LAST_TELEM,
  X_MS_LIB_CAPABILITY,
  X_APP_NAME,
  X_APP_VER,
  POST_LOGOUT_URI,
  ID_TOKEN_HINT,
  DEVICE_CODE,
  CLIENT_SECRET,
  CLIENT_ASSERTION,
  CLIENT_ASSERTION_TYPE,
  TOKEN_TYPE,
  REQ_CNF,
  OBO_ASSERTION,
  REQUESTED_TOKEN_USE,
  ON_BEHALF_OF,
  FOCI,
  CCS_HEADER,
  RETURN_SPA_CODE,
  NATIVE_BROKER,
  LOGOUT_HINT,
  SID,
  LOGIN_HINT,
  DOMAIN_HINT,
  X_CLIENT_EXTRA_SKU,
  BROKER_CLIENT_ID,
  BROKER_REDIRECT_URI,
  INSTANCE_AWARE,
  EAR_JWK,
  EAR_JWE_CRYPTO;
var init_AADServerParamKeys = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/constants/AADServerParamKeys.mjs'() {
    'use strict';
    CLIENT_ID = 'client_id';
    REDIRECT_URI = 'redirect_uri';
    RESPONSE_TYPE = 'response_type';
    RESPONSE_MODE = 'response_mode';
    GRANT_TYPE = 'grant_type';
    CLAIMS = 'claims';
    SCOPE = 'scope';
    ERROR = 'error';
    ERROR_DESCRIPTION = 'error_description';
    ACCESS_TOKEN = 'access_token';
    ID_TOKEN = 'id_token';
    REFRESH_TOKEN = 'refresh_token';
    EXPIRES_IN = 'expires_in';
    REFRESH_TOKEN_EXPIRES_IN = 'refresh_token_expires_in';
    STATE = 'state';
    NONCE = 'nonce';
    PROMPT = 'prompt';
    SESSION_STATE = 'session_state';
    CLIENT_INFO2 = 'client_info';
    CODE = 'code';
    CODE_CHALLENGE = 'code_challenge';
    CODE_CHALLENGE_METHOD = 'code_challenge_method';
    CODE_VERIFIER = 'code_verifier';
    CLIENT_REQUEST_ID = 'client-request-id';
    X_CLIENT_SKU = 'x-client-SKU';
    X_CLIENT_VER = 'x-client-VER';
    X_CLIENT_OS = 'x-client-OS';
    X_CLIENT_CPU = 'x-client-CPU';
    X_CLIENT_CURR_TELEM = 'x-client-current-telemetry';
    X_CLIENT_LAST_TELEM = 'x-client-last-telemetry';
    X_MS_LIB_CAPABILITY = 'x-ms-lib-capability';
    X_APP_NAME = 'x-app-name';
    X_APP_VER = 'x-app-ver';
    POST_LOGOUT_URI = 'post_logout_redirect_uri';
    ID_TOKEN_HINT = 'id_token_hint';
    DEVICE_CODE = 'device_code';
    CLIENT_SECRET = 'client_secret';
    CLIENT_ASSERTION = 'client_assertion';
    CLIENT_ASSERTION_TYPE = 'client_assertion_type';
    TOKEN_TYPE = 'token_type';
    REQ_CNF = 'req_cnf';
    OBO_ASSERTION = 'assertion';
    REQUESTED_TOKEN_USE = 'requested_token_use';
    ON_BEHALF_OF = 'on_behalf_of';
    FOCI = 'foci';
    CCS_HEADER = 'X-AnchorMailbox';
    RETURN_SPA_CODE = 'return_spa_code';
    NATIVE_BROKER = 'nativebroker';
    LOGOUT_HINT = 'logout_hint';
    SID = 'sid';
    LOGIN_HINT = 'login_hint';
    DOMAIN_HINT = 'domain_hint';
    X_CLIENT_EXTRA_SKU = 'x-client-xtra-sku';
    BROKER_CLIENT_ID = 'brk_client_id';
    BROKER_REDIRECT_URI = 'brk_redirect_uri';
    INSTANCE_AWARE = 'instance_aware';
    EAR_JWK = 'ear_jwk';
    EAR_JWE_CRYPTO = 'ear_jwe_crypto';
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/request/RequestParameterBuilder.mjs
var RequestParameterBuilder_exports = {};
__export(RequestParameterBuilder_exports, {
  addApplicationTelemetry: () => addApplicationTelemetry,
  addAuthorizationCode: () => addAuthorizationCode,
  addBrokerParameters: () => addBrokerParameters,
  addCcsOid: () => addCcsOid,
  addCcsUpn: () => addCcsUpn,
  addClaims: () => addClaims,
  addClientAssertion: () => addClientAssertion,
  addClientAssertionType: () => addClientAssertionType,
  addClientCapabilitiesToClaims: () => addClientCapabilitiesToClaims,
  addClientId: () => addClientId,
  addClientInfo: () => addClientInfo,
  addClientSecret: () => addClientSecret,
  addCodeChallengeParams: () => addCodeChallengeParams,
  addCodeVerifier: () => addCodeVerifier,
  addCorrelationId: () => addCorrelationId,
  addDeviceCode: () => addDeviceCode,
  addDomainHint: () => addDomainHint,
  addEARParameters: () => addEARParameters,
  addExtraQueryParameters: () => addExtraQueryParameters,
  addGrantType: () => addGrantType,
  addIdTokenHint: () => addIdTokenHint,
  addInstanceAware: () => addInstanceAware,
  addLibraryInfo: () => addLibraryInfo,
  addLoginHint: () => addLoginHint,
  addLogoutHint: () => addLogoutHint,
  addNativeBroker: () => addNativeBroker,
  addNonce: () => addNonce,
  addOboAssertion: () => addOboAssertion,
  addPassword: () => addPassword,
  addPopToken: () => addPopToken,
  addPostBodyParameters: () => addPostBodyParameters,
  addPostLogoutRedirectUri: () => addPostLogoutRedirectUri,
  addPrompt: () => addPrompt,
  addRedirectUri: () => addRedirectUri,
  addRefreshToken: () => addRefreshToken,
  addRequestTokenUse: () => addRequestTokenUse,
  addResponseMode: () => addResponseMode,
  addResponseType: () => addResponseType,
  addScopes: () => addScopes,
  addServerTelemetry: () => addServerTelemetry,
  addSid: () => addSid,
  addSshJwk: () => addSshJwk,
  addState: () => addState,
  addThrottling: () => addThrottling,
  addUsername: () => addUsername,
  instrumentBrokerParams: () => instrumentBrokerParams,
});
function instrumentBrokerParams(parameters, correlationId, performanceClient) {
  if (!correlationId) {
    return;
  }
  const clientId = parameters.get(CLIENT_ID);
  if (clientId && parameters.has(BROKER_CLIENT_ID)) {
    performanceClient?.addFields(
      {
        embeddedClientId: clientId,
        embeddedRedirectUri: parameters.get(REDIRECT_URI),
      },
      correlationId
    );
  }
}
function addResponseType(parameters, responseType) {
  parameters.set(RESPONSE_TYPE, responseType);
}
function addResponseMode(parameters, responseMode) {
  parameters.set(RESPONSE_MODE, responseMode ? responseMode : ResponseMode.QUERY);
}
function addNativeBroker(parameters) {
  parameters.set(NATIVE_BROKER, '1');
}
function addScopes(parameters, scopes, addOidcScopes = true, defaultScopes = OIDC_DEFAULT_SCOPES) {
  if (addOidcScopes && !defaultScopes.includes('openid') && !scopes.includes('openid')) {
    defaultScopes.push('openid');
  }
  const requestScopes = addOidcScopes ? [...(scopes || []), ...defaultScopes] : scopes || [];
  const scopeSet = new ScopeSet(requestScopes);
  parameters.set(SCOPE, scopeSet.printScopes());
}
function addClientId(parameters, clientId) {
  parameters.set(CLIENT_ID, clientId);
}
function addRedirectUri(parameters, redirectUri) {
  parameters.set(REDIRECT_URI, redirectUri);
}
function addPostLogoutRedirectUri(parameters, redirectUri) {
  parameters.set(POST_LOGOUT_URI, redirectUri);
}
function addIdTokenHint(parameters, idTokenHint) {
  parameters.set(ID_TOKEN_HINT, idTokenHint);
}
function addDomainHint(parameters, domainHint) {
  parameters.set(DOMAIN_HINT, domainHint);
}
function addLoginHint(parameters, loginHint) {
  parameters.set(LOGIN_HINT, loginHint);
}
function addCcsUpn(parameters, loginHint) {
  parameters.set(HeaderNames.CCS_HEADER, `UPN:${loginHint}`);
}
function addCcsOid(parameters, clientInfo) {
  parameters.set(HeaderNames.CCS_HEADER, `Oid:${clientInfo.uid}@${clientInfo.utid}`);
}
function addSid(parameters, sid) {
  parameters.set(SID, sid);
}
function addClaims(parameters, claims, clientCapabilities) {
  const mergedClaims = addClientCapabilitiesToClaims(claims, clientCapabilities);
  try {
    JSON.parse(mergedClaims);
  } catch (e) {
    throw createClientConfigurationError(invalidClaims);
  }
  parameters.set(CLAIMS, mergedClaims);
}
function addCorrelationId(parameters, correlationId) {
  parameters.set(CLIENT_REQUEST_ID, correlationId);
}
function addLibraryInfo(parameters, libraryInfo) {
  parameters.set(X_CLIENT_SKU, libraryInfo.sku);
  parameters.set(X_CLIENT_VER, libraryInfo.version);
  if (libraryInfo.os) {
    parameters.set(X_CLIENT_OS, libraryInfo.os);
  }
  if (libraryInfo.cpu) {
    parameters.set(X_CLIENT_CPU, libraryInfo.cpu);
  }
}
function addApplicationTelemetry(parameters, appTelemetry) {
  if (appTelemetry?.appName) {
    parameters.set(X_APP_NAME, appTelemetry.appName);
  }
  if (appTelemetry?.appVersion) {
    parameters.set(X_APP_VER, appTelemetry.appVersion);
  }
}
function addPrompt(parameters, prompt) {
  parameters.set(PROMPT, prompt);
}
function addState(parameters, state2) {
  if (state2) {
    parameters.set(STATE, state2);
  }
}
function addNonce(parameters, nonce) {
  parameters.set(NONCE, nonce);
}
function addCodeChallengeParams(parameters, codeChallenge, codeChallengeMethod) {
  if (codeChallenge && codeChallengeMethod) {
    parameters.set(CODE_CHALLENGE, codeChallenge);
    parameters.set(CODE_CHALLENGE_METHOD, codeChallengeMethod);
  } else {
    throw createClientConfigurationError(pkceParamsMissing);
  }
}
function addAuthorizationCode(parameters, code) {
  parameters.set(CODE, code);
}
function addDeviceCode(parameters, code) {
  parameters.set(DEVICE_CODE, code);
}
function addRefreshToken(parameters, refreshToken) {
  parameters.set(REFRESH_TOKEN, refreshToken);
}
function addCodeVerifier(parameters, codeVerifier) {
  parameters.set(CODE_VERIFIER, codeVerifier);
}
function addClientSecret(parameters, clientSecret) {
  parameters.set(CLIENT_SECRET, clientSecret);
}
function addClientAssertion(parameters, clientAssertion) {
  if (clientAssertion) {
    parameters.set(CLIENT_ASSERTION, clientAssertion);
  }
}
function addClientAssertionType(parameters, clientAssertionType) {
  if (clientAssertionType) {
    parameters.set(CLIENT_ASSERTION_TYPE, clientAssertionType);
  }
}
function addOboAssertion(parameters, oboAssertion) {
  parameters.set(OBO_ASSERTION, oboAssertion);
}
function addRequestTokenUse(parameters, tokenUse) {
  parameters.set(REQUESTED_TOKEN_USE, tokenUse);
}
function addGrantType(parameters, grantType) {
  parameters.set(GRANT_TYPE, grantType);
}
function addClientInfo(parameters) {
  parameters.set(CLIENT_INFO, '1');
}
function addInstanceAware(parameters) {
  if (!parameters.has(INSTANCE_AWARE)) {
    parameters.set(INSTANCE_AWARE, 'true');
  }
}
function addExtraQueryParameters(parameters, eQParams) {
  Object.entries(eQParams).forEach(([key2, value]) => {
    if (!parameters.has(key2) && value) {
      parameters.set(key2, value);
    }
  });
}
function addClientCapabilitiesToClaims(claims, clientCapabilities) {
  let mergedClaims;
  if (!claims) {
    mergedClaims = {};
  } else {
    try {
      mergedClaims = JSON.parse(claims);
    } catch (e) {
      throw createClientConfigurationError(invalidClaims);
    }
  }
  if (clientCapabilities && clientCapabilities.length > 0) {
    if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
      mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};
    }
    mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] = {
      values: clientCapabilities,
    };
  }
  return JSON.stringify(mergedClaims);
}
function addUsername(parameters, username) {
  parameters.set(PasswordGrantConstants.username, username);
}
function addPassword(parameters, password) {
  parameters.set(PasswordGrantConstants.password, password);
}
function addPopToken(parameters, cnfString) {
  if (cnfString) {
    parameters.set(TOKEN_TYPE, AuthenticationScheme.POP);
    parameters.set(REQ_CNF, cnfString);
  }
}
function addSshJwk(parameters, sshJwkString) {
  if (sshJwkString) {
    parameters.set(TOKEN_TYPE, AuthenticationScheme.SSH);
    parameters.set(REQ_CNF, sshJwkString);
  }
}
function addServerTelemetry(parameters, serverTelemetryManager) {
  parameters.set(X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
  parameters.set(X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());
}
function addThrottling(parameters) {
  parameters.set(X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
}
function addLogoutHint(parameters, logoutHint) {
  parameters.set(LOGOUT_HINT, logoutHint);
}
function addBrokerParameters(parameters, brokerClientId, brokerRedirectUri) {
  if (!parameters.has(BROKER_CLIENT_ID)) {
    parameters.set(BROKER_CLIENT_ID, brokerClientId);
  }
  if (!parameters.has(BROKER_REDIRECT_URI)) {
    parameters.set(BROKER_REDIRECT_URI, brokerRedirectUri);
  }
}
function addEARParameters(parameters, jwk) {
  parameters.set(EAR_JWK, encodeURIComponent(jwk));
  const jweCryptoB64Encoded = 'eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIn0';
  parameters.set(EAR_JWE_CRYPTO, jweCryptoB64Encoded);
}
function addPostBodyParameters(parameters, bodyParameters) {
  Object.entries(bodyParameters).forEach(([key2, value]) => {
    if (value) {
      parameters.set(key2, value);
    }
  });
}
var init_RequestParameterBuilder = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/request/RequestParameterBuilder.mjs'() {
    'use strict';
    init_Constants();
    init_AADServerParamKeys();
    init_ScopeSet();
    init_ClientConfigurationError();
    init_ClientConfigurationErrorCodes();
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/AuthorityType.mjs
var AuthorityType;
var init_AuthorityType = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/AuthorityType.mjs'() {
    'use strict';
    AuthorityType = {
      Default: 0,
      Adfs: 1,
      Dsts: 2,
      Ciam: 3,
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs
function isOpenIdConfigResponse(response) {
  return (
    response.hasOwnProperty('authorization_endpoint') &&
    response.hasOwnProperty('token_endpoint') &&
    response.hasOwnProperty('issuer') &&
    response.hasOwnProperty('jwks_uri')
  );
}
var init_OpenIdConfigResponse = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs'() {
    'use strict';
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs
function isCloudInstanceDiscoveryResponse(response) {
  return (
    response.hasOwnProperty('tenant_discovery_endpoint') && response.hasOwnProperty('metadata')
  );
}
var init_CloudInstanceDiscoveryResponse = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs'() {
    'use strict';
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs
function isCloudInstanceDiscoveryErrorResponse(response) {
  return response.hasOwnProperty('error') && response.hasOwnProperty('error_description');
}
var init_CloudInstanceDiscoveryErrorResponse = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs'() {
    'use strict';
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/utils/FunctionWrappers.mjs
var invoke, invokeAsync;
var init_FunctionWrappers = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/utils/FunctionWrappers.mjs'() {
    'use strict';
    invoke = (callback, eventName, logger4, telemetryClient, correlationId) => {
      return (...args) => {
        logger4.trace(`Executing function ${eventName}`);
        const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);
        if (correlationId) {
          const eventCount = eventName + 'CallCount';
          telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);
        }
        try {
          const result = callback(...args);
          inProgressEvent?.end({
            success: true,
          });
          logger4.trace(`Returning result from ${eventName}`);
          return result;
        } catch (e) {
          logger4.trace(`Error occurred in ${eventName}`);
          try {
            logger4.trace(JSON.stringify(e));
          } catch (e2) {
            logger4.trace('Unable to print error message.');
          }
          inProgressEvent?.end(
            {
              success: false,
            },
            e
          );
          throw e;
        }
      };
    };
    invokeAsync = (callback, eventName, logger4, telemetryClient, correlationId) => {
      return (...args) => {
        logger4.trace(`Executing function ${eventName}`);
        const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);
        if (correlationId) {
          const eventCount = eventName + 'CallCount';
          telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);
        }
        telemetryClient?.setPreQueueTime(eventName, correlationId);
        return callback(...args)
          .then((response) => {
            logger4.trace(`Returning result from ${eventName}`);
            inProgressEvent?.end({
              success: true,
            });
            return response;
          })
          .catch((e) => {
            logger4.trace(`Error occurred in ${eventName}`);
            try {
              logger4.trace(JSON.stringify(e));
            } catch (e2) {
              logger4.trace('Unable to print error message.');
            }
            inProgressEvent?.end(
              {
                success: false,
              },
              e
            );
            throw e;
          });
      };
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/RegionDiscovery.mjs
var RegionDiscovery;
var init_RegionDiscovery = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/RegionDiscovery.mjs'() {
    'use strict';
    init_Constants();
    init_PerformanceEvent();
    init_FunctionWrappers();
    RegionDiscovery = class _RegionDiscovery {
      constructor(networkInterface, logger4, performanceClient, correlationId) {
        this.networkInterface = networkInterface;
        this.logger = logger4;
        this.performanceClient = performanceClient;
        this.correlationId = correlationId;
      }
      /**
       * Detect the region from the application's environment.
       *
       * @returns Promise<string | null>
       */
      async detectRegion(environmentRegion, regionDiscoveryMetadata) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.RegionDiscoveryDetectRegion,
          this.correlationId
        );
        let autodetectedRegionName = environmentRegion;
        if (!autodetectedRegionName) {
          const options = _RegionDiscovery.IMDS_OPTIONS;
          try {
            const localIMDSVersionResponse = await invokeAsync(
              this.getRegionFromIMDS.bind(this),
              PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,
              this.logger,
              this.performanceClient,
              this.correlationId
            )(Constants.IMDS_VERSION, options);
            if (localIMDSVersionResponse.status === HttpStatus.SUCCESS) {
              autodetectedRegionName = localIMDSVersionResponse.body;
              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
            }
            if (localIMDSVersionResponse.status === HttpStatus.BAD_REQUEST) {
              const currentIMDSVersion = await invokeAsync(
                this.getCurrentVersion.bind(this),
                PerformanceEvents.RegionDiscoveryGetCurrentVersion,
                this.logger,
                this.performanceClient,
                this.correlationId
              )(options);
              if (!currentIMDSVersion) {
                regionDiscoveryMetadata.region_source =
                  RegionDiscoverySources.FAILED_AUTO_DETECTION;
                return null;
              }
              const currentIMDSVersionResponse = await invokeAsync(
                this.getRegionFromIMDS.bind(this),
                PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,
                this.logger,
                this.performanceClient,
                this.correlationId
              )(currentIMDSVersion, options);
              if (currentIMDSVersionResponse.status === HttpStatus.SUCCESS) {
                autodetectedRegionName = currentIMDSVersionResponse.body;
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
              }
            }
          } catch (e) {
            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
            return null;
          }
        } else {
          regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;
        }
        if (!autodetectedRegionName) {
          regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
        }
        return autodetectedRegionName || null;
      }
      /**
       * Make the call to the IMDS endpoint
       *
       * @param imdsEndpointUrl
       * @returns Promise<NetworkResponse<string>>
       */
      async getRegionFromIMDS(version4, options) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,
          this.correlationId
        );
        return this.networkInterface.sendGetRequestAsync(
          `${Constants.IMDS_ENDPOINT}?api-version=${version4}&format=text`,
          options,
          Constants.IMDS_TIMEOUT
        );
      }
      /**
       * Get the most recent version of the IMDS endpoint available
       *
       * @returns Promise<string | null>
       */
      async getCurrentVersion(options) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.RegionDiscoveryGetCurrentVersion,
          this.correlationId
        );
        try {
          const response = await this.networkInterface.sendGetRequestAsync(
            `${Constants.IMDS_ENDPOINT}?format=json`,
            options
          );
          if (
            response.status === HttpStatus.BAD_REQUEST &&
            response.body &&
            response.body['newest-versions'] &&
            response.body['newest-versions'].length > 0
          ) {
            return response.body['newest-versions'][0];
          }
          return null;
        } catch (e) {
          return null;
        }
      }
    };
    RegionDiscovery.IMDS_OPTIONS = {
      headers: {
        Metadata: 'true',
      },
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/utils/TimeUtils.mjs
var TimeUtils_exports = {};
__export(TimeUtils_exports, {
  delay: () => delay,
  isCacheExpired: () => isCacheExpired,
  isTokenExpired: () => isTokenExpired,
  nowSeconds: () => nowSeconds,
  toDateFromSeconds: () => toDateFromSeconds,
  toSecondsFromDate: () => toSecondsFromDate,
  wasClockTurnedBack: () => wasClockTurnedBack,
});
function nowSeconds() {
  return Math.round(/* @__PURE__ */ new Date().getTime() / 1e3);
}
function toSecondsFromDate(date) {
  return date.getTime() / 1e3;
}
function toDateFromSeconds(seconds) {
  if (seconds) {
    return new Date(Number(seconds) * 1e3);
  }
  return /* @__PURE__ */ new Date();
}
function isTokenExpired(expiresOn, offset) {
  const expirationSec = Number(expiresOn) || 0;
  const offsetCurrentTimeSec = nowSeconds() + offset;
  return offsetCurrentTimeSec > expirationSec;
}
function isCacheExpired(lastUpdatedAt, cacheRetentionDays) {
  const cacheExpirationTimestamp = Number(lastUpdatedAt) + cacheRetentionDays * 24 * 60 * 60 * 1e3;
  return Date.now() > cacheExpirationTimestamp;
}
function wasClockTurnedBack(cachedAt) {
  const cachedAtSec = Number(cachedAt);
  return cachedAtSec > nowSeconds();
}
function delay(t, value) {
  return new Promise((resolve) => setTimeout(() => resolve(value), t));
}
var init_TimeUtils = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/utils/TimeUtils.mjs'() {
    'use strict';
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/cache/utils/CacheHelpers.mjs
var CacheHelpers_exports = {};
__export(CacheHelpers_exports, {
  createAccessTokenEntity: () => createAccessTokenEntity,
  createIdTokenEntity: () => createIdTokenEntity,
  createRefreshTokenEntity: () => createRefreshTokenEntity,
  generateAppMetadataKey: () => generateAppMetadataKey,
  generateAuthorityMetadataExpiresAt: () => generateAuthorityMetadataExpiresAt,
  isAccessTokenEntity: () => isAccessTokenEntity,
  isAppMetadataEntity: () => isAppMetadataEntity,
  isAuthorityMetadataEntity: () => isAuthorityMetadataEntity,
  isAuthorityMetadataExpired: () => isAuthorityMetadataExpired,
  isCredentialEntity: () => isCredentialEntity,
  isIdTokenEntity: () => isIdTokenEntity,
  isRefreshTokenEntity: () => isRefreshTokenEntity,
  isServerTelemetryEntity: () => isServerTelemetryEntity,
  isThrottlingEntity: () => isThrottlingEntity,
  updateAuthorityEndpointMetadata: () => updateAuthorityEndpointMetadata,
  updateCloudDiscoveryMetadata: () => updateCloudDiscoveryMetadata,
});
function createIdTokenEntity(homeAccountId, environment, idToken, clientId, tenantId) {
  const idTokenEntity = {
    credentialType: CredentialType.ID_TOKEN,
    homeAccountId,
    environment,
    clientId,
    secret: idToken,
    realm: tenantId,
    lastUpdatedAt: Date.now().toString(),
    // Set the last updated time to now
  };
  return idTokenEntity;
}
function createAccessTokenEntity(
  homeAccountId,
  environment,
  accessToken,
  clientId,
  tenantId,
  scopes,
  expiresOn,
  extExpiresOn,
  base64Decode,
  refreshOn,
  tokenType,
  userAssertionHash,
  keyId,
  requestedClaims,
  requestedClaimsHash
) {
  const atEntity = {
    homeAccountId,
    credentialType: CredentialType.ACCESS_TOKEN,
    secret: accessToken,
    cachedAt: nowSeconds().toString(),
    expiresOn: expiresOn.toString(),
    extendedExpiresOn: extExpiresOn.toString(),
    environment,
    clientId,
    realm: tenantId,
    target: scopes,
    tokenType: tokenType || AuthenticationScheme.BEARER,
    lastUpdatedAt: Date.now().toString(),
    // Set the last updated time to now
  };
  if (userAssertionHash) {
    atEntity.userAssertionHash = userAssertionHash;
  }
  if (refreshOn) {
    atEntity.refreshOn = refreshOn.toString();
  }
  if (requestedClaims) {
    atEntity.requestedClaims = requestedClaims;
    atEntity.requestedClaimsHash = requestedClaimsHash;
  }
  if (atEntity.tokenType?.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) {
    atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
    switch (atEntity.tokenType) {
      case AuthenticationScheme.POP:
        const tokenClaims = extractTokenClaims(accessToken, base64Decode);
        if (!tokenClaims?.cnf?.kid) {
          throw createClientAuthError(tokenClaimsCnfRequiredForSignedJwt);
        }
        atEntity.keyId = tokenClaims.cnf.kid;
        break;
      case AuthenticationScheme.SSH:
        atEntity.keyId = keyId;
    }
  }
  return atEntity;
}
function createRefreshTokenEntity(
  homeAccountId,
  environment,
  refreshToken,
  clientId,
  familyId,
  userAssertionHash,
  expiresOn
) {
  const rtEntity = {
    credentialType: CredentialType.REFRESH_TOKEN,
    homeAccountId,
    environment,
    clientId,
    secret: refreshToken,
    lastUpdatedAt: Date.now().toString(),
  };
  if (userAssertionHash) {
    rtEntity.userAssertionHash = userAssertionHash;
  }
  if (familyId) {
    rtEntity.familyId = familyId;
  }
  if (expiresOn) {
    rtEntity.expiresOn = expiresOn.toString();
  }
  return rtEntity;
}
function isCredentialEntity(entity) {
  return (
    entity.hasOwnProperty('homeAccountId') &&
    entity.hasOwnProperty('environment') &&
    entity.hasOwnProperty('credentialType') &&
    entity.hasOwnProperty('clientId') &&
    entity.hasOwnProperty('secret')
  );
}
function isAccessTokenEntity(entity) {
  if (!entity) {
    return false;
  }
  return (
    isCredentialEntity(entity) &&
    entity.hasOwnProperty('realm') &&
    entity.hasOwnProperty('target') &&
    (entity['credentialType'] === CredentialType.ACCESS_TOKEN ||
      entity['credentialType'] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME)
  );
}
function isIdTokenEntity(entity) {
  if (!entity) {
    return false;
  }
  return (
    isCredentialEntity(entity) &&
    entity.hasOwnProperty('realm') &&
    entity['credentialType'] === CredentialType.ID_TOKEN
  );
}
function isRefreshTokenEntity(entity) {
  if (!entity) {
    return false;
  }
  return isCredentialEntity(entity) && entity['credentialType'] === CredentialType.REFRESH_TOKEN;
}
function isServerTelemetryEntity(key2, entity) {
  const validateKey = key2.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
  let validateEntity = true;
  if (entity) {
    validateEntity =
      entity.hasOwnProperty('failedRequests') &&
      entity.hasOwnProperty('errors') &&
      entity.hasOwnProperty('cacheHits');
  }
  return validateKey && validateEntity;
}
function isThrottlingEntity(key2, entity) {
  let validateKey = false;
  if (key2) {
    validateKey = key2.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;
  }
  let validateEntity = true;
  if (entity) {
    validateEntity = entity.hasOwnProperty('throttleTime');
  }
  return validateKey && validateEntity;
}
function generateAppMetadataKey({ environment, clientId }) {
  const appMetaDataKeyArray = [APP_METADATA, environment, clientId];
  return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
}
function isAppMetadataEntity(key2, entity) {
  if (!entity) {
    return false;
  }
  return (
    key2.indexOf(APP_METADATA) === 0 &&
    entity.hasOwnProperty('clientId') &&
    entity.hasOwnProperty('environment')
  );
}
function isAuthorityMetadataEntity(key2, entity) {
  if (!entity) {
    return false;
  }
  return (
    key2.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 &&
    entity.hasOwnProperty('aliases') &&
    entity.hasOwnProperty('preferred_cache') &&
    entity.hasOwnProperty('preferred_network') &&
    entity.hasOwnProperty('canonical_authority') &&
    entity.hasOwnProperty('authorization_endpoint') &&
    entity.hasOwnProperty('token_endpoint') &&
    entity.hasOwnProperty('issuer') &&
    entity.hasOwnProperty('aliasesFromNetwork') &&
    entity.hasOwnProperty('endpointsFromNetwork') &&
    entity.hasOwnProperty('expiresAt') &&
    entity.hasOwnProperty('jwks_uri')
  );
}
function generateAuthorityMetadataExpiresAt() {
  return nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
}
function updateAuthorityEndpointMetadata(authorityMetadata, updatedValues, fromNetwork) {
  authorityMetadata.authorization_endpoint = updatedValues.authorization_endpoint;
  authorityMetadata.token_endpoint = updatedValues.token_endpoint;
  authorityMetadata.end_session_endpoint = updatedValues.end_session_endpoint;
  authorityMetadata.issuer = updatedValues.issuer;
  authorityMetadata.endpointsFromNetwork = fromNetwork;
  authorityMetadata.jwks_uri = updatedValues.jwks_uri;
}
function updateCloudDiscoveryMetadata(authorityMetadata, updatedValues, fromNetwork) {
  authorityMetadata.aliases = updatedValues.aliases;
  authorityMetadata.preferred_cache = updatedValues.preferred_cache;
  authorityMetadata.preferred_network = updatedValues.preferred_network;
  authorityMetadata.aliasesFromNetwork = fromNetwork;
}
function isAuthorityMetadataExpired(metadata) {
  return metadata.expiresAt <= nowSeconds();
}
var init_CacheHelpers = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/cache/utils/CacheHelpers.mjs'() {
    'use strict';
    init_AuthToken();
    init_ClientAuthError();
    init_Constants();
    init_TimeUtils();
    init_ClientAuthErrorCodes();
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/Authority.mjs
function getTenantFromAuthorityString(authority) {
  const authorityUrl = new UrlString(authority);
  const authorityUrlComponents = authorityUrl.getUrlComponents();
  const tenantId = authorityUrlComponents.PathSegments.slice(-1)[0]?.toLowerCase();
  switch (tenantId) {
    case AADAuthorityConstants.COMMON:
    case AADAuthorityConstants.ORGANIZATIONS:
    case AADAuthorityConstants.CONSUMERS:
      return void 0;
    default:
      return tenantId;
  }
}
function formatAuthorityUri(authorityUri) {
  return authorityUri.endsWith(Constants.FORWARD_SLASH)
    ? authorityUri
    : `${authorityUri}${Constants.FORWARD_SLASH}`;
}
function buildStaticAuthorityOptions(authOptions) {
  const rawCloudDiscoveryMetadata = authOptions.cloudDiscoveryMetadata;
  let cloudDiscoveryMetadata = void 0;
  if (rawCloudDiscoveryMetadata) {
    try {
      cloudDiscoveryMetadata = JSON.parse(rawCloudDiscoveryMetadata);
    } catch (e) {
      throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
    }
  }
  return {
    canonicalAuthority: authOptions.authority ? formatAuthorityUri(authOptions.authority) : void 0,
    knownAuthorities: authOptions.knownAuthorities,
    cloudDiscoveryMetadata,
  };
}
var Authority;
var init_Authority = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/Authority.mjs'() {
    'use strict';
    init_AuthorityType();
    init_OpenIdConfigResponse();
    init_UrlString();
    init_ClientAuthError();
    init_Constants();
    init_AuthorityMetadata();
    init_ClientConfigurationError();
    init_ProtocolMode();
    init_AuthorityOptions();
    init_CloudInstanceDiscoveryResponse();
    init_CloudInstanceDiscoveryErrorResponse();
    init_RegionDiscovery();
    init_AuthError();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_CacheHelpers();
    init_ClientAuthErrorCodes();
    init_ClientConfigurationErrorCodes();
    Authority = class _Authority {
      constructor(
        authority,
        networkInterface,
        cacheManager,
        authorityOptions,
        logger4,
        correlationId,
        performanceClient,
        managedIdentity
      ) {
        this.canonicalAuthority = authority;
        this._canonicalAuthority.validateAsUri();
        this.networkInterface = networkInterface;
        this.cacheManager = cacheManager;
        this.authorityOptions = authorityOptions;
        this.regionDiscoveryMetadata = {
          region_used: void 0,
          region_source: void 0,
          region_outcome: void 0,
        };
        this.logger = logger4;
        this.performanceClient = performanceClient;
        this.correlationId = correlationId;
        this.managedIdentity = managedIdentity || false;
        this.regionDiscovery = new RegionDiscovery(
          networkInterface,
          this.logger,
          this.performanceClient,
          this.correlationId
        );
      }
      /**
       * Get {@link AuthorityType}
       * @param authorityUri {@link IUri}
       * @private
       */
      getAuthorityType(authorityUri) {
        if (authorityUri.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {
          return AuthorityType.Ciam;
        }
        const pathSegments = authorityUri.PathSegments;
        if (pathSegments.length) {
          switch (pathSegments[0].toLowerCase()) {
            case Constants.ADFS:
              return AuthorityType.Adfs;
            case Constants.DSTS:
              return AuthorityType.Dsts;
          }
        }
        return AuthorityType.Default;
      }
      // See above for AuthorityType
      get authorityType() {
        return this.getAuthorityType(this.canonicalAuthorityUrlComponents);
      }
      /**
       * ProtocolMode enum representing the way endpoints are constructed.
       */
      get protocolMode() {
        return this.authorityOptions.protocolMode;
      }
      /**
       * Returns authorityOptions which can be used to reinstantiate a new authority instance
       */
      get options() {
        return this.authorityOptions;
      }
      /**
       * A URL that is the authority set by the developer
       */
      get canonicalAuthority() {
        return this._canonicalAuthority.urlString;
      }
      /**
       * Sets canonical authority.
       */
      set canonicalAuthority(url2) {
        this._canonicalAuthority = new UrlString(url2);
        this._canonicalAuthority.validateAsUri();
        this._canonicalAuthorityUrlComponents = null;
      }
      /**
       * Get authority components.
       */
      get canonicalAuthorityUrlComponents() {
        if (!this._canonicalAuthorityUrlComponents) {
          this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();
        }
        return this._canonicalAuthorityUrlComponents;
      }
      /**
       * Get hostname and port i.e. login.microsoftonline.com
       */
      get hostnameAndPort() {
        return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
      }
      /**
       * Get tenant for authority.
       */
      get tenant() {
        return this.canonicalAuthorityUrlComponents.PathSegments[0];
      }
      /**
       * OAuth /authorize endpoint for requests
       */
      get authorizationEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.authorization_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth /token endpoint for requests
       */
      get tokenEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.token_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      get deviceCodeEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.token_endpoint.replace('/token', '/devicecode'));
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth logout endpoint for requests
       */
      get endSessionEndpoint() {
        if (this.discoveryComplete()) {
          if (!this.metadata.end_session_endpoint) {
            throw createClientAuthError(endSessionEndpointNotSupported);
          }
          return this.replacePath(this.metadata.end_session_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth issuer for requests
       */
      get selfSignedJwtAudience() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.issuer);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Jwks_uri for token signing keys
       */
      get jwksUri() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.jwks_uri);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Returns a flag indicating that tenant name can be replaced in authority {@link IUri}
       * @param authorityUri {@link IUri}
       * @private
       */
      canReplaceTenant(authorityUri) {
        return (
          authorityUri.PathSegments.length === 1 &&
          !_Authority.reservedTenantDomains.has(authorityUri.PathSegments[0]) &&
          this.getAuthorityType(authorityUri) === AuthorityType.Default &&
          this.protocolMode !== ProtocolMode.OIDC
        );
      }
      /**
       * Replaces tenant in url path with current tenant. Defaults to common.
       * @param urlString
       */
      replaceTenant(urlString) {
        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);
      }
      /**
       * Replaces path such as tenant or policy with the current tenant or policy.
       * @param urlString
       */
      replacePath(urlString) {
        let endpoint = urlString;
        const cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
        const cachedAuthorityUrlComponents = cachedAuthorityUrl.getUrlComponents();
        const cachedAuthorityParts = cachedAuthorityUrlComponents.PathSegments;
        const currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
        currentAuthorityParts.forEach((currentPart, index2) => {
          let cachedPart = cachedAuthorityParts[index2];
          if (index2 === 0 && this.canReplaceTenant(cachedAuthorityUrlComponents)) {
            const tenantId = new UrlString(this.metadata.authorization_endpoint).getUrlComponents()
              .PathSegments[0];
            if (cachedPart !== tenantId) {
              this.logger.verbose(`Replacing tenant domain name ${cachedPart} with id ${tenantId}`);
              cachedPart = tenantId;
            }
          }
          if (currentPart !== cachedPart) {
            endpoint = endpoint.replace(`/${cachedPart}/`, `/${currentPart}/`);
          }
        });
        return this.replaceTenant(endpoint);
      }
      /**
       * The default open id configuration endpoint for any canonical authority.
       */
      get defaultOpenIdConfigurationEndpoint() {
        const canonicalAuthorityHost = this.hostnameAndPort;
        if (
          this.canonicalAuthority.endsWith('v2.0/') ||
          this.authorityType === AuthorityType.Adfs ||
          (this.protocolMode === ProtocolMode.OIDC &&
            !this.isAliasOfKnownMicrosoftAuthority(canonicalAuthorityHost))
        ) {
          return `${this.canonicalAuthority}.well-known/openid-configuration`;
        }
        return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;
      }
      /**
       * Boolean that returns whether or not tenant discovery has been completed.
       */
      discoveryComplete() {
        return !!this.metadata;
      }
      /**
       * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network
       * and the /authorize, /token and logout endpoints.
       */
      async resolveEndpointsAsync() {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.AuthorityResolveEndpointsAsync,
          this.correlationId
        );
        const metadataEntity = this.getCurrentMetadataEntity();
        const cloudDiscoverySource = await invokeAsync(
          this.updateCloudDiscoveryMetadata.bind(this),
          PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata,
          this.logger,
          this.performanceClient,
          this.correlationId
        )(metadataEntity);
        this.canonicalAuthority = this.canonicalAuthority.replace(
          this.hostnameAndPort,
          metadataEntity.preferred_network
        );
        const endpointSource = await invokeAsync(
          this.updateEndpointMetadata.bind(this),
          PerformanceEvents.AuthorityUpdateEndpointMetadata,
          this.logger,
          this.performanceClient,
          this.correlationId
        )(metadataEntity);
        this.updateCachedMetadata(metadataEntity, cloudDiscoverySource, {
          source: endpointSource,
        });
        this.performanceClient?.addFields(
          {
            cloudDiscoverySource,
            authorityEndpointSource: endpointSource,
          },
          this.correlationId
        );
      }
      /**
       * Returns metadata entity from cache if it exists, otherwiser returns a new metadata entity built
       * from the configured canonical authority
       * @returns
       */
      getCurrentMetadataEntity() {
        let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
        if (!metadataEntity) {
          metadataEntity = {
            aliases: [],
            preferred_cache: this.hostnameAndPort,
            preferred_network: this.hostnameAndPort,
            canonical_authority: this.canonicalAuthority,
            authorization_endpoint: '',
            token_endpoint: '',
            end_session_endpoint: '',
            issuer: '',
            aliasesFromNetwork: false,
            endpointsFromNetwork: false,
            expiresAt: generateAuthorityMetadataExpiresAt(),
            jwks_uri: '',
          };
        }
        return metadataEntity;
      }
      /**
       * Updates cached metadata based on metadata source and sets the instance's metadata
       * property to the same value
       * @param metadataEntity
       * @param cloudDiscoverySource
       * @param endpointMetadataResult
       */
      updateCachedMetadata(metadataEntity, cloudDiscoverySource, endpointMetadataResult) {
        if (
          cloudDiscoverySource !== AuthorityMetadataSource.CACHE &&
          endpointMetadataResult?.source !== AuthorityMetadataSource.CACHE
        ) {
          metadataEntity.expiresAt = generateAuthorityMetadataExpiresAt();
          metadataEntity.canonical_authority = this.canonicalAuthority;
        }
        const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(
          metadataEntity.preferred_cache
        );
        this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
        this.metadata = metadataEntity;
      }
      /**
       * Update AuthorityMetadataEntity with new endpoints and return where the information came from
       * @param metadataEntity
       */
      async updateEndpointMetadata(metadataEntity) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.AuthorityUpdateEndpointMetadata,
          this.correlationId
        );
        const localMetadata = this.updateEndpointMetadataFromLocalSources(metadataEntity);
        if (localMetadata) {
          if (localMetadata.source === AuthorityMetadataSource.HARDCODED_VALUES) {
            if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {
              if (localMetadata.metadata) {
                const hardcodedMetadata = await invokeAsync(
                  this.updateMetadataWithRegionalInformation.bind(this),
                  PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation,
                  this.logger,
                  this.performanceClient,
                  this.correlationId
                )(localMetadata.metadata);
                updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
                metadataEntity.canonical_authority = this.canonicalAuthority;
              }
            }
          }
          return localMetadata.source;
        }
        let metadata = await invokeAsync(
          this.getEndpointMetadataFromNetwork.bind(this),
          PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork,
          this.logger,
          this.performanceClient,
          this.correlationId
        )();
        if (metadata) {
          if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {
            metadata = await invokeAsync(
              this.updateMetadataWithRegionalInformation.bind(this),
              PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation,
              this.logger,
              this.performanceClient,
              this.correlationId
            )(metadata);
          }
          updateAuthorityEndpointMetadata(metadataEntity, metadata, true);
          return AuthorityMetadataSource.NETWORK;
        } else {
          throw createClientAuthError(openIdConfigError, this.defaultOpenIdConfigurationEndpoint);
        }
      }
      /**
       * Updates endpoint metadata from local sources and returns where the information was retrieved from and the metadata config
       * response if the source is hardcoded metadata
       * @param metadataEntity
       * @returns
       */
      updateEndpointMetadataFromLocalSources(metadataEntity) {
        this.logger.verbose('Attempting to get endpoint metadata from authority configuration');
        const configMetadata = this.getEndpointMetadataFromConfig();
        if (configMetadata) {
          this.logger.verbose('Found endpoint metadata in authority configuration');
          updateAuthorityEndpointMetadata(metadataEntity, configMetadata, false);
          return {
            source: AuthorityMetadataSource.CONFIG,
          };
        }
        this.logger.verbose(
          'Did not find endpoint metadata in the config... Attempting to get endpoint metadata from the hardcoded values.'
        );
        if (this.authorityOptions.skipAuthorityMetadataCache) {
          this.logger.verbose(
            'Skipping hardcoded metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get endpoint metadata from the network metadata cache.'
          );
        } else {
          const hardcodedMetadata = this.getEndpointMetadataFromHardcodedValues();
          if (hardcodedMetadata) {
            updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
            return {
              source: AuthorityMetadataSource.HARDCODED_VALUES,
              metadata: hardcodedMetadata,
            };
          } else {
            this.logger.verbose(
              'Did not find endpoint metadata in hardcoded values... Attempting to get endpoint metadata from the network metadata cache.'
            );
          }
        }
        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
        if (
          this.isAuthoritySameType(metadataEntity) &&
          metadataEntity.endpointsFromNetwork &&
          !metadataEntityExpired
        ) {
          this.logger.verbose('Found endpoint metadata in the cache.');
          return { source: AuthorityMetadataSource.CACHE };
        } else if (metadataEntityExpired) {
          this.logger.verbose('The metadata entity is expired.');
        }
        return null;
      }
      /**
       * Compares the number of url components after the domain to determine if the cached
       * authority metadata can be used for the requested authority. Protects against same domain different
       * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy
       * @param metadataEntity
       */
      isAuthoritySameType(metadataEntity) {
        const cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
        const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
        return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;
      }
      /**
       * Parse authorityMetadata config option
       */
      getEndpointMetadataFromConfig() {
        if (this.authorityOptions.authorityMetadata) {
          try {
            return JSON.parse(this.authorityOptions.authorityMetadata);
          } catch (e) {
            throw createClientConfigurationError(invalidAuthorityMetadata);
          }
        }
        return null;
      }
      /**
       * Gets OAuth endpoints from the given OpenID configuration endpoint.
       *
       * @param hasHardcodedMetadata boolean
       */
      async getEndpointMetadataFromNetwork() {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork,
          this.correlationId
        );
        const options = {};
        const openIdConfigurationEndpoint = this.defaultOpenIdConfigurationEndpoint;
        this.logger.verbose(
          `Authority.getEndpointMetadataFromNetwork: attempting to retrieve OAuth endpoints from ${openIdConfigurationEndpoint}`
        );
        try {
          const response = await this.networkInterface.sendGetRequestAsync(
            openIdConfigurationEndpoint,
            options
          );
          const isValidResponse = isOpenIdConfigResponse(response.body);
          if (isValidResponse) {
            return response.body;
          } else {
            this.logger.verbose(
              `Authority.getEndpointMetadataFromNetwork: could not parse response as OpenID configuration`
            );
            return null;
          }
        } catch (e) {
          this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: ${e}`);
          return null;
        }
      }
      /**
       * Get OAuth endpoints for common authorities.
       */
      getEndpointMetadataFromHardcodedValues() {
        if (this.hostnameAndPort in EndpointMetadata) {
          return EndpointMetadata[this.hostnameAndPort];
        }
        return null;
      }
      /**
       * Update the retrieved metadata with regional information.
       * User selected Azure region will be used if configured.
       */
      async updateMetadataWithRegionalInformation(metadata) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation,
          this.correlationId
        );
        const userConfiguredAzureRegion =
          this.authorityOptions.azureRegionConfiguration?.azureRegion;
        if (userConfiguredAzureRegion) {
          if (userConfiguredAzureRegion !== Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {
            this.regionDiscoveryMetadata.region_outcome =
              RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;
            this.regionDiscoveryMetadata.region_used = userConfiguredAzureRegion;
            return _Authority.replaceWithRegionalInformation(metadata, userConfiguredAzureRegion);
          }
          const autodetectedRegionName = await invokeAsync(
            this.regionDiscovery.detectRegion.bind(this.regionDiscovery),
            PerformanceEvents.RegionDiscoveryDetectRegion,
            this.logger,
            this.performanceClient,
            this.correlationId
          )(
            this.authorityOptions.azureRegionConfiguration?.environmentRegion,
            this.regionDiscoveryMetadata
          );
          if (autodetectedRegionName) {
            this.regionDiscoveryMetadata.region_outcome =
              RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL;
            this.regionDiscoveryMetadata.region_used = autodetectedRegionName;
            return _Authority.replaceWithRegionalInformation(metadata, autodetectedRegionName);
          }
          this.regionDiscoveryMetadata.region_outcome =
            RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;
        }
        return metadata;
      }
      /**
       * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache
       * and returns where the information was retrieved from
       * @param metadataEntity
       * @returns AuthorityMetadataSource
       */
      async updateCloudDiscoveryMetadata(metadataEntity) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata,
          this.correlationId
        );
        const localMetadataSource =
          this.updateCloudDiscoveryMetadataFromLocalSources(metadataEntity);
        if (localMetadataSource) {
          return localMetadataSource;
        }
        const metadata = await invokeAsync(
          this.getCloudDiscoveryMetadataFromNetwork.bind(this),
          PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork,
          this.logger,
          this.performanceClient,
          this.correlationId
        )();
        if (metadata) {
          updateCloudDiscoveryMetadata(metadataEntity, metadata, true);
          return AuthorityMetadataSource.NETWORK;
        }
        throw createClientConfigurationError(untrustedAuthority);
      }
      updateCloudDiscoveryMetadataFromLocalSources(metadataEntity) {
        this.logger.verbose(
          'Attempting to get cloud discovery metadata  from authority configuration'
        );
        this.logger.verbosePii(
          `Known Authorities: ${this.authorityOptions.knownAuthorities || Constants.NOT_APPLICABLE}`
        );
        this.logger.verbosePii(
          `Authority Metadata: ${this.authorityOptions.authorityMetadata || Constants.NOT_APPLICABLE}`
        );
        this.logger.verbosePii(
          `Canonical Authority: ${metadataEntity.canonical_authority || Constants.NOT_APPLICABLE}`
        );
        const metadata = this.getCloudDiscoveryMetadataFromConfig();
        if (metadata) {
          this.logger.verbose('Found cloud discovery metadata in authority configuration');
          updateCloudDiscoveryMetadata(metadataEntity, metadata, false);
          return AuthorityMetadataSource.CONFIG;
        }
        this.logger.verbose(
          'Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the hardcoded values.'
        );
        if (this.options.skipAuthorityMetadataCache) {
          this.logger.verbose(
            'Skipping hardcoded cloud discovery metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get cloud discovery metadata from the network metadata cache.'
          );
        } else {
          const hardcodedMetadata = getCloudDiscoveryMetadataFromHardcodedValues(
            this.hostnameAndPort
          );
          if (hardcodedMetadata) {
            this.logger.verbose('Found cloud discovery metadata from hardcoded values.');
            updateCloudDiscoveryMetadata(metadataEntity, hardcodedMetadata, false);
            return AuthorityMetadataSource.HARDCODED_VALUES;
          }
          this.logger.verbose(
            'Did not find cloud discovery metadata in hardcoded values... Attempting to get cloud discovery metadata from the network metadata cache.'
          );
        }
        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
        if (
          this.isAuthoritySameType(metadataEntity) &&
          metadataEntity.aliasesFromNetwork &&
          !metadataEntityExpired
        ) {
          this.logger.verbose('Found cloud discovery metadata in the cache.');
          return AuthorityMetadataSource.CACHE;
        } else if (metadataEntityExpired) {
          this.logger.verbose('The metadata entity is expired.');
        }
        return null;
      }
      /**
       * Parse cloudDiscoveryMetadata config or check knownAuthorities
       */
      getCloudDiscoveryMetadataFromConfig() {
        if (this.authorityType === AuthorityType.Ciam) {
          this.logger.verbose(
            'CIAM authorities do not support cloud discovery metadata, generate the aliases from authority host.'
          );
          return _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        if (this.authorityOptions.cloudDiscoveryMetadata) {
          this.logger.verbose(
            'The cloud discovery metadata has been provided as a network response, in the config.'
          );
          try {
            this.logger.verbose('Attempting to parse the cloud discovery metadata.');
            const parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
            const metadata = getCloudDiscoveryMetadataFromNetworkResponse(
              parsedResponse.metadata,
              this.hostnameAndPort
            );
            this.logger.verbose('Parsed the cloud discovery metadata.');
            if (metadata) {
              this.logger.verbose(
                'There is returnable metadata attached to the parsed cloud discovery metadata.'
              );
              return metadata;
            } else {
              this.logger.verbose(
                'There is no metadata attached to the parsed cloud discovery metadata.'
              );
            }
          } catch (e) {
            this.logger.verbose(
              'Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.'
            );
            throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
          }
        }
        if (this.isInKnownAuthorities()) {
          this.logger.verbose(
            'The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.'
          );
          return _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        return null;
      }
      /**
       * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config
       *
       * @param hasHardcodedMetadata boolean
       */
      async getCloudDiscoveryMetadataFromNetwork() {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork,
          this.correlationId
        );
        const instanceDiscoveryEndpoint = `${Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;
        const options = {};
        let match = null;
        try {
          const response = await this.networkInterface.sendGetRequestAsync(
            instanceDiscoveryEndpoint,
            options
          );
          let typedResponseBody;
          let metadata;
          if (isCloudInstanceDiscoveryResponse(response.body)) {
            typedResponseBody = response.body;
            metadata = typedResponseBody.metadata;
            this.logger.verbosePii(
              `tenant_discovery_endpoint is: ${typedResponseBody.tenant_discovery_endpoint}`
            );
          } else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {
            this.logger.warning(
              `A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: ${response.status}`
            );
            typedResponseBody = response.body;
            if (typedResponseBody.error === Constants.INVALID_INSTANCE) {
              this.logger.error(
                'The CloudInstanceDiscoveryErrorResponse error is invalid_instance.'
              );
              return null;
            }
            this.logger.warning(
              `The CloudInstanceDiscoveryErrorResponse error is ${typedResponseBody.error}`
            );
            this.logger.warning(
              `The CloudInstanceDiscoveryErrorResponse error description is ${typedResponseBody.error_description}`
            );
            this.logger.warning(
              'Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []'
            );
            metadata = [];
          } else {
            this.logger.error(
              'AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse'
            );
            return null;
          }
          this.logger.verbose(
            "Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request."
          );
          match = getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
        } catch (error) {
          if (error instanceof AuthError) {
            this.logger
              .error(`There was a network error while attempting to get the cloud discovery instance metadata.
Error: ${error.errorCode}
Error Description: ${error.errorMessage}`);
          } else {
            const typedError = error;
            this.logger
              .error(`A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.
Error: ${typedError.name}
Error Description: ${typedError.message}`);
          }
          return null;
        }
        if (!match) {
          this.logger.warning(
            "The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request."
          );
          this.logger.verbose('Creating custom Authority for custom domain scenario.');
          match = _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        return match;
      }
      /**
       * Helper function to determine if this host is included in the knownAuthorities config option
       */
      isInKnownAuthorities() {
        const matches2 = this.authorityOptions.knownAuthorities.filter((authority) => {
          return (
            authority &&
            UrlString.getDomainFromUrl(authority).toLowerCase() === this.hostnameAndPort
          );
        });
        return matches2.length > 0;
      }
      /**
       * helper function to populate the authority based on azureCloudOptions
       * @param authorityString
       * @param azureCloudOptions
       */
      static generateAuthority(authorityString, azureCloudOptions) {
        let authorityAzureCloudInstance;
        if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {
          const tenant = azureCloudOptions.tenant
            ? azureCloudOptions.tenant
            : Constants.DEFAULT_COMMON_TENANT;
          authorityAzureCloudInstance = `${azureCloudOptions.azureCloudInstance}/${tenant}/`;
        }
        return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;
      }
      /**
       * Creates cloud discovery metadata object from a given host
       * @param host
       */
      static createCloudDiscoveryMetadataFromHost(host) {
        return {
          preferred_network: host,
          preferred_cache: host,
          aliases: [host],
        };
      }
      /**
       * helper function to generate environment from authority object
       */
      getPreferredCache() {
        if (this.managedIdentity) {
          return Constants.DEFAULT_AUTHORITY_HOST;
        } else if (this.discoveryComplete()) {
          return this.metadata.preferred_cache;
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Returns whether or not the provided host is an alias of this authority instance
       * @param host
       */
      isAlias(host) {
        return this.metadata.aliases.indexOf(host) > -1;
      }
      /**
       * Returns whether or not the provided host is an alias of a known Microsoft authority for purposes of endpoint discovery
       * @param host
       */
      isAliasOfKnownMicrosoftAuthority(host) {
        return InstanceDiscoveryMetadataAliases.has(host);
      }
      /**
       * Checks whether the provided host is that of a public cloud authority
       *
       * @param authority string
       * @returns bool
       */
      static isPublicCloudAuthority(host) {
        return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;
      }
      /**
       * Rebuild the authority string with the region
       *
       * @param host string
       * @param region string
       */
      static buildRegionalAuthorityString(host, region, queryString) {
        const authorityUrlInstance = new UrlString(host);
        authorityUrlInstance.validateAsUri();
        const authorityUrlParts = authorityUrlInstance.getUrlComponents();
        let hostNameAndPort = `${region}.${authorityUrlParts.HostNameAndPort}`;
        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
          hostNameAndPort = `${region}.${Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;
        }
        const url2 = UrlString.constructAuthorityUriFromObject({
          ...authorityUrlInstance.getUrlComponents(),
          HostNameAndPort: hostNameAndPort,
        }).urlString;
        if (queryString) return `${url2}?${queryString}`;
        return url2;
      }
      /**
       * Replace the endpoints in the metadata object with their regional equivalents.
       *
       * @param metadata OpenIdConfigResponse
       * @param azureRegion string
       */
      static replaceWithRegionalInformation(metadata, azureRegion) {
        const regionalMetadata = { ...metadata };
        regionalMetadata.authorization_endpoint = _Authority.buildRegionalAuthorityString(
          regionalMetadata.authorization_endpoint,
          azureRegion
        );
        regionalMetadata.token_endpoint = _Authority.buildRegionalAuthorityString(
          regionalMetadata.token_endpoint,
          azureRegion
        );
        if (regionalMetadata.end_session_endpoint) {
          regionalMetadata.end_session_endpoint = _Authority.buildRegionalAuthorityString(
            regionalMetadata.end_session_endpoint,
            azureRegion
          );
        }
        return regionalMetadata;
      }
      /**
       * Transform CIAM_AUTHORIY as per the below rules:
       * If no path segments found and it is a CIAM authority (hostname ends with .ciamlogin.com), then transform it
       *
       * NOTE: The transformation path should go away once STS supports CIAM with the format: `tenantIdorDomain.ciamlogin.com`
       * `ciamlogin.com` can also change in the future and we should accommodate the same
       *
       * @param authority
       */
      static transformCIAMAuthority(authority) {
        let ciamAuthority = authority;
        const authorityUrl = new UrlString(authority);
        const authorityUrlComponents = authorityUrl.getUrlComponents();
        if (
          authorityUrlComponents.PathSegments.length === 0 &&
          authorityUrlComponents.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)
        ) {
          const tenantIdOrDomain = authorityUrlComponents.HostNameAndPort.split('.')[0];
          ciamAuthority = `${ciamAuthority}${tenantIdOrDomain}${Constants.AAD_TENANT_DOMAIN_SUFFIX}`;
        }
        return ciamAuthority;
      }
    };
    Authority.reservedTenantDomains = /* @__PURE__ */ new Set([
      '{tenant}',
      '{tenantid}',
      AADAuthorityConstants.COMMON,
      AADAuthorityConstants.CONSUMERS,
      AADAuthorityConstants.ORGANIZATIONS,
    ]);
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/AuthorityFactory.mjs
var AuthorityFactory_exports = {};
__export(AuthorityFactory_exports, {
  createDiscoveredInstance: () => createDiscoveredInstance,
});
async function createDiscoveredInstance(
  authorityUri,
  networkClient,
  cacheManager,
  authorityOptions,
  logger4,
  correlationId,
  performanceClient
) {
  performanceClient?.addQueueMeasurement(
    PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance,
    correlationId
  );
  const authorityUriFinal = Authority.transformCIAMAuthority(formatAuthorityUri(authorityUri));
  const acquireTokenAuthority = new Authority(
    authorityUriFinal,
    networkClient,
    cacheManager,
    authorityOptions,
    logger4,
    correlationId,
    performanceClient
  );
  try {
    await invokeAsync(
      acquireTokenAuthority.resolveEndpointsAsync.bind(acquireTokenAuthority),
      PerformanceEvents.AuthorityResolveEndpointsAsync,
      logger4,
      performanceClient,
      correlationId
    )();
    return acquireTokenAuthority;
  } catch (e) {
    throw createClientAuthError(endpointResolutionError);
  }
}
var init_AuthorityFactory = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/authority/AuthorityFactory.mjs'() {
    'use strict';
    init_Authority();
    init_ClientAuthError();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_ClientAuthErrorCodes();
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/ServerError.mjs
var ServerError;
var init_ServerError = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/ServerError.mjs'() {
    'use strict';
    init_AuthError();
    ServerError = class _ServerError extends AuthError {
      constructor(errorCode, errorMessage, subError, errorNo, status) {
        super(errorCode, errorMessage, subError);
        this.name = 'ServerError';
        this.errorNo = errorNo;
        this.status = status;
        Object.setPrototypeOf(this, _ServerError.prototype);
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/network/RequestThumbprint.mjs
function getRequestThumbprint(clientId, request, homeAccountId) {
  return {
    clientId,
    authority: request.authority,
    scopes: request.scopes,
    homeAccountIdentifier: homeAccountId,
    claims: request.claims,
    authenticationScheme: request.authenticationScheme,
    resourceRequestMethod: request.resourceRequestMethod,
    resourceRequestUri: request.resourceRequestUri,
    shrClaims: request.shrClaims,
    sshKid: request.sshKid,
    embeddedClientId: request.embeddedClientId || request.tokenBodyParameters?.clientId,
  };
}
var init_RequestThumbprint = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/network/RequestThumbprint.mjs'() {
    'use strict';
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/network/ThrottlingUtils.mjs
var ThrottlingUtils;
var init_ThrottlingUtils = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/network/ThrottlingUtils.mjs'() {
    'use strict';
    init_Constants();
    init_ServerError();
    init_RequestThumbprint();
    ThrottlingUtils = class _ThrottlingUtils {
      /**
       * Prepares a RequestThumbprint to be stored as a key.
       * @param thumbprint
       */
      static generateThrottlingStorageKey(thumbprint) {
        return `${ThrottlingConstants.THROTTLING_PREFIX}.${JSON.stringify(thumbprint)}`;
      }
      /**
       * Performs necessary throttling checks before a network request.
       * @param cacheManager
       * @param thumbprint
       */
      static preProcess(cacheManager, thumbprint, correlationId) {
        const key2 = _ThrottlingUtils.generateThrottlingStorageKey(thumbprint);
        const value = cacheManager.getThrottlingCache(key2);
        if (value) {
          if (value.throttleTime < Date.now()) {
            cacheManager.removeItem(key2, correlationId);
            return;
          }
          throw new ServerError(
            value.errorCodes?.join(' ') || Constants.EMPTY_STRING,
            value.errorMessage,
            value.subError
          );
        }
      }
      /**
       * Performs necessary throttling checks after a network request.
       * @param cacheManager
       * @param thumbprint
       * @param response
       */
      static postProcess(cacheManager, thumbprint, response, correlationId) {
        if (
          _ThrottlingUtils.checkResponseStatus(response) ||
          _ThrottlingUtils.checkResponseForRetryAfter(response)
        ) {
          const thumbprintValue = {
            throttleTime: _ThrottlingUtils.calculateThrottleTime(
              parseInt(response.headers[HeaderNames.RETRY_AFTER])
            ),
            error: response.body.error,
            errorCodes: response.body.error_codes,
            errorMessage: response.body.error_description,
            subError: response.body.suberror,
          };
          cacheManager.setThrottlingCache(
            _ThrottlingUtils.generateThrottlingStorageKey(thumbprint),
            thumbprintValue,
            correlationId
          );
        }
      }
      /**
       * Checks a NetworkResponse object's status codes against 429 or 5xx
       * @param response
       */
      static checkResponseStatus(response) {
        return response.status === 429 || (response.status >= 500 && response.status < 600);
      }
      /**
       * Checks a NetworkResponse object's RetryAfter header
       * @param response
       */
      static checkResponseForRetryAfter(response) {
        if (response.headers) {
          return (
            response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) &&
            (response.status < 200 || response.status >= 300)
          );
        }
        return false;
      }
      /**
       * Calculates the Unix-time value for a throttle to expire given throttleTime in seconds.
       * @param throttleTime
       */
      static calculateThrottleTime(throttleTime) {
        const time = throttleTime <= 0 ? 0 : throttleTime;
        const currentSeconds = Date.now() / 1e3;
        return Math.floor(
          Math.min(
            currentSeconds + (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS),
            currentSeconds + ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS
          ) * 1e3
        );
      }
      static removeThrottle(cacheManager, clientId, request, homeAccountIdentifier) {
        const thumbprint = getRequestThumbprint(clientId, request, homeAccountIdentifier);
        const key2 = this.generateThrottlingStorageKey(thumbprint);
        cacheManager.removeItem(key2, request.correlationId);
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/NetworkError.mjs
var NetworkError;
var init_NetworkError = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/NetworkError.mjs'() {
    'use strict';
    init_AuthError();
    NetworkError = class _NetworkError extends AuthError {
      constructor(error, httpStatus, responseHeaders) {
        super(error.errorCode, error.errorMessage, error.subError);
        Object.setPrototypeOf(this, _NetworkError.prototype);
        this.name = 'NetworkError';
        this.error = error;
        this.httpStatus = httpStatus;
        this.responseHeaders = responseHeaders;
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/client/BaseClient.mjs
var BaseClient;
var init_BaseClient = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/client/BaseClient.mjs'() {
    'use strict';
    init_ClientConfiguration();
    init_Logger();
    init_Constants();
    init_packageMetadata();
    init_CcsCredential();
    init_ClientInfo();
    init_RequestParameterBuilder();
    init_UrlUtils();
    init_AuthorityFactory();
    init_PerformanceEvent();
    init_ThrottlingUtils();
    init_AuthError();
    init_ClientAuthError();
    init_NetworkError();
    init_FunctionWrappers();
    init_ClientAuthErrorCodes();
    BaseClient = class {
      constructor(configuration, performanceClient) {
        this.config = buildClientConfiguration(configuration);
        this.logger = new Logger(this.config.loggerOptions, name, version2);
        this.cryptoUtils = this.config.cryptoInterface;
        this.cacheManager = this.config.storageInterface;
        this.networkClient = this.config.networkInterface;
        this.serverTelemetryManager = this.config.serverTelemetryManager;
        this.authority = this.config.authOptions.authority;
        this.performanceClient = performanceClient;
      }
      /**
       * Creates default headers for requests to token endpoint
       */
      createTokenRequestHeaders(ccsCred) {
        const headers = {};
        headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
        if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
          switch (ccsCred.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                headers[HeaderNames.CCS_HEADER] = `Oid:${clientInfo.uid}@${clientInfo.utid}`;
              } catch (e) {
                this.logger.verbose('Could not parse home account ID for CCS Header: ' + e);
              }
              break;
            case CcsCredentialType.UPN:
              headers[HeaderNames.CCS_HEADER] = `UPN: ${ccsCred.credential}`;
              break;
          }
        }
        return headers;
      }
      /**
       * Http post to token endpoint
       * @param tokenEndpoint
       * @param queryString
       * @param headers
       * @param thumbprint
       */
      async executePostToTokenEndpoint(
        tokenEndpoint,
        queryString,
        headers,
        thumbprint,
        correlationId,
        queuedEvent
      ) {
        if (queuedEvent) {
          this.performanceClient?.addQueueMeasurement(queuedEvent, correlationId);
        }
        const response = await this.sendPostRequest(
          thumbprint,
          tokenEndpoint,
          { body: queryString, headers },
          correlationId
        );
        if (
          this.config.serverTelemetryManager &&
          response.status < 500 &&
          response.status !== 429
        ) {
          this.config.serverTelemetryManager.clearTelemetryCache();
        }
        return response;
      }
      /**
       * Wraps sendPostRequestAsync with necessary preflight and postflight logic
       * @param thumbprint - Request thumbprint for throttling
       * @param tokenEndpoint - Endpoint to make the POST to
       * @param options - Body and Headers to include on the POST request
       * @param correlationId - CorrelationId for telemetry
       */
      async sendPostRequest(thumbprint, tokenEndpoint, options, correlationId) {
        ThrottlingUtils.preProcess(this.cacheManager, thumbprint, correlationId);
        let response;
        try {
          response = await invokeAsync(
            this.networkClient.sendPostRequestAsync.bind(this.networkClient),
            PerformanceEvents.NetworkClientSendPostRequestAsync,
            this.logger,
            this.performanceClient,
            correlationId
          )(tokenEndpoint, options);
          const responseHeaders = response.headers || {};
          this.performanceClient?.addFields(
            {
              refreshTokenSize: response.body.refresh_token?.length || 0,
              httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || '',
              requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || '',
            },
            correlationId
          );
        } catch (e) {
          if (e instanceof NetworkError) {
            const responseHeaders = e.responseHeaders;
            if (responseHeaders) {
              this.performanceClient?.addFields(
                {
                  httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || '',
                  requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || '',
                  contentTypeHeader: responseHeaders[HeaderNames.CONTENT_TYPE] || void 0,
                  contentLengthHeader: responseHeaders[HeaderNames.CONTENT_LENGTH] || void 0,
                  httpStatus: e.httpStatus,
                },
                correlationId
              );
            }
            throw e.error;
          }
          if (e instanceof AuthError) {
            throw e;
          } else {
            throw createClientAuthError(networkError);
          }
        }
        ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response, correlationId);
        return response;
      }
      /**
       * Updates the authority object of the client. Endpoint discovery must be completed.
       * @param updatedAuthority
       */
      async updateAuthority(cloudInstanceHostname, correlationId) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.UpdateTokenEndpointAuthority,
          correlationId
        );
        const cloudInstanceAuthorityUri = `https://${cloudInstanceHostname}/${this.authority.tenant}/`;
        const cloudInstanceAuthority = await createDiscoveredInstance(
          cloudInstanceAuthorityUri,
          this.networkClient,
          this.cacheManager,
          this.authority.options,
          this.logger,
          correlationId,
          this.performanceClient
        );
        this.authority = cloudInstanceAuthority;
      }
      /**
       * Creates query string for the /token request
       * @param request
       */
      createTokenQueryParameters(request) {
        const parameters = /* @__PURE__ */ new Map();
        if (request.embeddedClientId) {
          addBrokerParameters(
            parameters,
            this.config.authOptions.clientId,
            this.config.authOptions.redirectUri
          );
        }
        if (request.tokenQueryParameters) {
          addExtraQueryParameters(parameters, request.tokenQueryParameters);
        }
        addCorrelationId(parameters, request.correlationId);
        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
        return mapToQueryString(parameters);
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/account/TokenClaims.mjs
function getTenantIdFromIdTokenClaims(idTokenClaims) {
  if (idTokenClaims) {
    const tenantId = idTokenClaims.tid || idTokenClaims.tfp || idTokenClaims.acr;
    return tenantId || null;
  }
  return null;
}
var init_TokenClaims = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/account/TokenClaims.mjs'() {
    'use strict';
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/cache/entities/AccountEntity.mjs
var AccountEntity;
var init_AccountEntity = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/cache/entities/AccountEntity.mjs'() {
    'use strict';
    init_Constants();
    init_ClientInfo();
    init_AccountInfo();
    init_ClientAuthError();
    init_AuthorityType();
    init_TokenClaims();
    init_ProtocolMode();
    init_ClientAuthErrorCodes();
    AccountEntity = class _AccountEntity {
      /**
       * Returns the AccountInfo interface for this account.
       */
      getAccountInfo() {
        return {
          homeAccountId: this.homeAccountId,
          environment: this.environment,
          tenantId: this.realm,
          username: this.username,
          localAccountId: this.localAccountId,
          loginHint: this.loginHint,
          name: this.name,
          nativeAccountId: this.nativeAccountId,
          authorityType: this.authorityType,
          // Deserialize tenant profiles array into a Map
          tenantProfiles: new Map(
            (this.tenantProfiles || []).map((tenantProfile) => {
              return [tenantProfile.tenantId, tenantProfile];
            })
          ),
          dataBoundary: this.dataBoundary,
        };
      }
      /**
       * Returns true if the account entity is in single tenant format (outdated), false otherwise
       */
      isSingleTenant() {
        return !this.tenantProfiles;
      }
      /**
       * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.
       * @param accountDetails
       */
      static createAccount(accountDetails, authority, base64Decode) {
        const account = new _AccountEntity();
        if (authority.authorityType === AuthorityType.Adfs) {
          account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;
        } else if (authority.protocolMode === ProtocolMode.OIDC) {
          account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;
        } else {
          account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;
        }
        let clientInfo;
        if (accountDetails.clientInfo && base64Decode) {
          clientInfo = buildClientInfo(accountDetails.clientInfo, base64Decode);
          if (clientInfo.xms_tdbr) {
            account.dataBoundary = clientInfo.xms_tdbr === 'EU' ? 'EU' : 'None';
          }
        }
        account.clientInfo = accountDetails.clientInfo;
        account.homeAccountId = accountDetails.homeAccountId;
        account.nativeAccountId = accountDetails.nativeAccountId;
        const env2 = accountDetails.environment || (authority && authority.getPreferredCache());
        if (!env2) {
          throw createClientAuthError(invalidCacheEnvironment);
        }
        account.environment = env2;
        account.realm =
          clientInfo?.utid || getTenantIdFromIdTokenClaims(accountDetails.idTokenClaims) || '';
        account.localAccountId =
          clientInfo?.uid ||
          accountDetails.idTokenClaims?.oid ||
          accountDetails.idTokenClaims?.sub ||
          '';
        const preferredUsername =
          accountDetails.idTokenClaims?.preferred_username || accountDetails.idTokenClaims?.upn;
        const email = accountDetails.idTokenClaims?.emails
          ? accountDetails.idTokenClaims.emails[0]
          : null;
        account.username = preferredUsername || email || '';
        account.loginHint = accountDetails.idTokenClaims?.login_hint;
        account.name = accountDetails.idTokenClaims?.name || '';
        account.cloudGraphHostName = accountDetails.cloudGraphHostName;
        account.msGraphHost = accountDetails.msGraphHost;
        if (accountDetails.tenantProfiles) {
          account.tenantProfiles = accountDetails.tenantProfiles;
        } else {
          const tenantProfile = buildTenantProfile(
            accountDetails.homeAccountId,
            account.localAccountId,
            account.realm,
            accountDetails.idTokenClaims
          );
          account.tenantProfiles = [tenantProfile];
        }
        return account;
      }
      /**
       * Creates an AccountEntity object from AccountInfo
       * @param accountInfo
       * @param cloudGraphHostName
       * @param msGraphHost
       * @returns
       */
      static createFromAccountInfo(accountInfo, cloudGraphHostName, msGraphHost) {
        const account = new _AccountEntity();
        account.authorityType = accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;
        account.homeAccountId = accountInfo.homeAccountId;
        account.localAccountId = accountInfo.localAccountId;
        account.nativeAccountId = accountInfo.nativeAccountId;
        account.realm = accountInfo.tenantId;
        account.environment = accountInfo.environment;
        account.username = accountInfo.username;
        account.name = accountInfo.name;
        account.loginHint = accountInfo.loginHint;
        account.cloudGraphHostName = cloudGraphHostName;
        account.msGraphHost = msGraphHost;
        account.tenantProfiles = Array.from(accountInfo.tenantProfiles?.values() || []);
        account.dataBoundary = accountInfo.dataBoundary;
        return account;
      }
      /**
       * Generate HomeAccountId from server response
       * @param serverClientInfo
       * @param authType
       */
      static generateHomeAccountId(serverClientInfo, authType, logger4, cryptoObj, idTokenClaims) {
        if (!(authType === AuthorityType.Adfs || authType === AuthorityType.Dsts)) {
          if (serverClientInfo) {
            try {
              const clientInfo = buildClientInfo(serverClientInfo, cryptoObj.base64Decode);
              if (clientInfo.uid && clientInfo.utid) {
                return `${clientInfo.uid}.${clientInfo.utid}`;
              }
            } catch (e) {}
          }
          logger4.warning('No client info in response');
        }
        return idTokenClaims?.sub || '';
      }
      /**
       * Validates an entity: checks for all expected params
       * @param entity
       */
      static isAccountEntity(entity) {
        if (!entity) {
          return false;
        }
        return (
          entity.hasOwnProperty('homeAccountId') &&
          entity.hasOwnProperty('environment') &&
          entity.hasOwnProperty('realm') &&
          entity.hasOwnProperty('localAccountId') &&
          entity.hasOwnProperty('username') &&
          entity.hasOwnProperty('authorityType')
        );
      }
      /**
       * Helper function to determine whether 2 accountInfo objects represent the same account
       * @param accountA
       * @param accountB
       * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality
       */
      static accountInfoIsEqual(accountA, accountB, compareClaims) {
        if (!accountA || !accountB) {
          return false;
        }
        let claimsMatch = true;
        if (compareClaims) {
          const accountAClaims = accountA.idTokenClaims || {};
          const accountBClaims = accountB.idTokenClaims || {};
          claimsMatch =
            accountAClaims.iat === accountBClaims.iat &&
            accountAClaims.nonce === accountBClaims.nonce;
        }
        return (
          accountA.homeAccountId === accountB.homeAccountId &&
          accountA.localAccountId === accountB.localAccountId &&
          accountA.username === accountB.username &&
          accountA.tenantId === accountB.tenantId &&
          accountA.loginHint === accountB.loginHint &&
          accountA.environment === accountB.environment &&
          accountA.nativeAccountId === accountB.nativeAccountId &&
          claimsMatch
        );
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs
var noTokensFound,
  nativeAccountUnavailable,
  refreshTokenExpired,
  uxNotAllowed,
  interactionRequired,
  consentRequired,
  loginRequired,
  badToken;
var init_InteractionRequiredAuthErrorCodes = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs'() {
    'use strict';
    noTokensFound = 'no_tokens_found';
    nativeAccountUnavailable = 'native_account_unavailable';
    refreshTokenExpired = 'refresh_token_expired';
    uxNotAllowed = 'ux_not_allowed';
    interactionRequired = 'interaction_required';
    consentRequired = 'consent_required';
    loginRequired = 'login_required';
    badToken = 'bad_token';
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs
function isInteractionRequiredError(errorCode, errorString, subError) {
  const isInteractionRequiredErrorCode =
    !!errorCode && InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
  const isInteractionRequiredSubError =
    !!subError && InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
  const isInteractionRequiredErrorDesc =
    !!errorString &&
    InteractionRequiredServerErrorMessage.some((irErrorCode) => {
      return errorString.indexOf(irErrorCode) > -1;
    });
  return (
    isInteractionRequiredErrorCode ||
    isInteractionRequiredErrorDesc ||
    isInteractionRequiredSubError
  );
}
function createInteractionRequiredAuthError(errorCode) {
  return new InteractionRequiredAuthError(
    errorCode,
    InteractionRequiredAuthErrorMessages[errorCode]
  );
}
var InteractionRequiredServerErrorMessage,
  InteractionRequiredAuthSubErrorMessage,
  InteractionRequiredAuthErrorMessages,
  InteractionRequiredAuthErrorMessage,
  InteractionRequiredAuthError;
var init_InteractionRequiredAuthError = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs'() {
    'use strict';
    init_Constants();
    init_AuthError();
    init_InteractionRequiredAuthErrorCodes();
    InteractionRequiredServerErrorMessage = [
      interactionRequired,
      consentRequired,
      loginRequired,
      badToken,
      uxNotAllowed,
    ];
    InteractionRequiredAuthSubErrorMessage = [
      'message_only',
      'additional_action',
      'basic_action',
      'user_password_expired',
      'consent_required',
      'bad_token',
    ];
    InteractionRequiredAuthErrorMessages = {
      [noTokensFound]: 'No refresh token found in the cache. Please sign-in.',
      [nativeAccountUnavailable]:
        'The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API.',
      [refreshTokenExpired]: 'Refresh token has expired.',
      [badToken]:
        'Identity provider returned bad_token due to an expired or invalid refresh token. Please invoke an interactive API to resolve.',
      [uxNotAllowed]:
        '`canShowUI` flag in Edge was set to false. User interaction required on web page. Please invoke an interactive API to resolve.',
    };
    InteractionRequiredAuthErrorMessage = {
      noTokensFoundError: {
        code: noTokensFound,
        desc: InteractionRequiredAuthErrorMessages[noTokensFound],
      },
      native_account_unavailable: {
        code: nativeAccountUnavailable,
        desc: InteractionRequiredAuthErrorMessages[nativeAccountUnavailable],
      },
      bad_token: {
        code: badToken,
        desc: InteractionRequiredAuthErrorMessages[badToken],
      },
    };
    InteractionRequiredAuthError = class _InteractionRequiredAuthError extends AuthError {
      constructor(
        errorCode,
        errorMessage,
        subError,
        timestamp,
        traceId,
        correlationId,
        claims,
        errorNo
      ) {
        super(errorCode, errorMessage, subError);
        Object.setPrototypeOf(this, _InteractionRequiredAuthError.prototype);
        this.timestamp = timestamp || Constants.EMPTY_STRING;
        this.traceId = traceId || Constants.EMPTY_STRING;
        this.correlationId = correlationId || Constants.EMPTY_STRING;
        this.claims = claims || Constants.EMPTY_STRING;
        this.name = 'InteractionRequiredAuthError';
        this.errorNo = errorNo;
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/utils/ProtocolUtils.mjs
var ProtocolUtils;
var init_ProtocolUtils = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/utils/ProtocolUtils.mjs'() {
    'use strict';
    init_Constants();
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
    ProtocolUtils = class _ProtocolUtils {
      /**
       * Appends user state with random guid, or returns random guid.
       * @param userState
       * @param randomGuid
       */
      static setRequestState(cryptoObj, userState, meta) {
        const libraryState = _ProtocolUtils.generateLibraryState(cryptoObj, meta);
        return userState ? `${libraryState}${Constants.RESOURCE_DELIM}${userState}` : libraryState;
      }
      /**
       * Generates the state value used by the common library.
       * @param randomGuid
       * @param cryptoObj
       */
      static generateLibraryState(cryptoObj, meta) {
        if (!cryptoObj) {
          throw createClientAuthError(noCryptoObject);
        }
        const stateObj = {
          id: cryptoObj.createNewGuid(),
        };
        if (meta) {
          stateObj.meta = meta;
        }
        const stateString = JSON.stringify(stateObj);
        return cryptoObj.base64Encode(stateString);
      }
      /**
       * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.
       * @param state
       * @param cryptoObj
       */
      static parseRequestState(cryptoObj, state2) {
        if (!cryptoObj) {
          throw createClientAuthError(noCryptoObject);
        }
        if (!state2) {
          throw createClientAuthError(invalidState);
        }
        try {
          const splitState = state2.split(Constants.RESOURCE_DELIM);
          const libraryState = splitState[0];
          const userState =
            splitState.length > 1
              ? splitState.slice(1).join(Constants.RESOURCE_DELIM)
              : Constants.EMPTY_STRING;
          const libraryStateString = cryptoObj.base64Decode(libraryState);
          const libraryStateObj = JSON.parse(libraryStateString);
          return {
            userRequestState: userState || Constants.EMPTY_STRING,
            libraryState: libraryStateObj,
          };
        } catch (e) {
          throw createClientAuthError(invalidState);
        }
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/crypto/PopTokenGenerator.mjs
var KeyLocation, PopTokenGenerator;
var init_PopTokenGenerator = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/crypto/PopTokenGenerator.mjs'() {
    'use strict';
    init_TimeUtils();
    init_UrlString();
    init_PerformanceEvent();
    init_FunctionWrappers();
    KeyLocation = {
      SW: 'sw',
    };
    PopTokenGenerator = class {
      constructor(cryptoUtils, performanceClient) {
        this.cryptoUtils = cryptoUtils;
        this.performanceClient = performanceClient;
      }
      /**
       * Generates the req_cnf validated at the RP in the POP protocol for SHR parameters
       * and returns an object containing the keyid, the full req_cnf string and the req_cnf string hash
       * @param request
       * @returns
       */
      async generateCnf(request, logger4) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.PopTokenGenerateCnf,
          request.correlationId
        );
        const reqCnf = await invokeAsync(
          this.generateKid.bind(this),
          PerformanceEvents.PopTokenGenerateCnf,
          logger4,
          this.performanceClient,
          request.correlationId
        )(request);
        const reqCnfString = this.cryptoUtils.base64UrlEncode(JSON.stringify(reqCnf));
        return {
          kid: reqCnf.kid,
          reqCnfString,
        };
      }
      /**
       * Generates key_id for a SHR token request
       * @param request
       * @returns
       */
      async generateKid(request) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.PopTokenGenerateKid,
          request.correlationId
        );
        const kidThumbprint = await this.cryptoUtils.getPublicKeyThumbprint(request);
        return {
          kid: kidThumbprint,
          xms_ksl: KeyLocation.SW,
        };
      }
      /**
       * Signs the POP access_token with the local generated key-pair
       * @param accessToken
       * @param request
       * @returns
       */
      async signPopToken(accessToken, keyId, request) {
        return this.signPayload(accessToken, keyId, request);
      }
      /**
       * Utility function to generate the signed JWT for an access_token
       * @param payload
       * @param kid
       * @param request
       * @param claims
       * @returns
       */
      async signPayload(payload, keyId, request, claims) {
        const { resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, shrOptions } =
          request;
        const resourceUrlString = resourceRequestUri ? new UrlString(resourceRequestUri) : void 0;
        const resourceUrlComponents = resourceUrlString?.getUrlComponents();
        return this.cryptoUtils.signJwt(
          {
            at: payload,
            ts: nowSeconds(),
            m: resourceRequestMethod?.toUpperCase(),
            u: resourceUrlComponents?.HostNameAndPort,
            nonce: shrNonce || this.cryptoUtils.createNewGuid(),
            p: resourceUrlComponents?.AbsolutePath,
            q: resourceUrlComponents?.QueryString
              ? [[], resourceUrlComponents.QueryString]
              : void 0,
            client_claims: shrClaims || void 0,
            ...claims,
          },
          keyId,
          shrOptions,
          request.correlationId
        );
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs
var TokenCacheContext;
var init_TokenCacheContext = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs'() {
    'use strict';
    TokenCacheContext = class {
      constructor(tokenCache, hasChanged) {
        this.cache = tokenCache;
        this.hasChanged = hasChanged;
      }
      /**
       * boolean which indicates the changes in cache
       */
      get cacheHasChanged() {
        return this.hasChanged;
      }
      /**
       * function to retrieve the token cache
       */
      get tokenCache() {
        return this.cache;
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/response/ResponseHandler.mjs
function buildAccountToCache(
  cacheStorage,
  authority,
  homeAccountId,
  base64Decode,
  correlationId,
  idTokenClaims,
  clientInfo,
  environment,
  claimsTenantId,
  authCodePayload,
  nativeAccountId,
  logger4
) {
  logger4?.verbose('setCachedAccount called');
  const accountKeys = cacheStorage.getAccountKeys();
  const baseAccountKey = accountKeys.find((accountKey) => {
    return accountKey.startsWith(homeAccountId);
  });
  let cachedAccount = null;
  if (baseAccountKey) {
    cachedAccount = cacheStorage.getAccount(baseAccountKey, correlationId);
  }
  const baseAccount =
    cachedAccount ||
    AccountEntity.createAccount(
      {
        homeAccountId,
        idTokenClaims,
        clientInfo,
        environment,
        cloudGraphHostName: authCodePayload?.cloud_graph_host_name,
        msGraphHost: authCodePayload?.msgraph_host,
        nativeAccountId,
      },
      authority,
      base64Decode
    );
  const tenantProfiles = baseAccount.tenantProfiles || [];
  const tenantId = claimsTenantId || baseAccount.realm;
  if (
    tenantId &&
    !tenantProfiles.find((tenantProfile) => {
      return tenantProfile.tenantId === tenantId;
    })
  ) {
    const newTenantProfile = buildTenantProfile(
      homeAccountId,
      baseAccount.localAccountId,
      tenantId,
      idTokenClaims
    );
    tenantProfiles.push(newTenantProfile);
  }
  baseAccount.tenantProfiles = tenantProfiles;
  return baseAccount;
}
var ResponseHandler;
var init_ResponseHandler = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/response/ResponseHandler.mjs'() {
    'use strict';
    init_ClientAuthError();
    init_ServerError();
    init_ScopeSet();
    init_AccountEntity();
    init_InteractionRequiredAuthError();
    init_ProtocolUtils();
    init_Constants();
    init_PopTokenGenerator();
    init_TokenCacheContext();
    init_PerformanceEvent();
    init_AuthToken();
    init_TokenClaims();
    init_AccountInfo();
    init_CacheHelpers();
    init_TimeUtils();
    init_ClientAuthErrorCodes();
    ResponseHandler = class _ResponseHandler {
      constructor(
        clientId,
        cacheStorage,
        cryptoObj,
        logger4,
        serializableCache,
        persistencePlugin,
        performanceClient
      ) {
        this.clientId = clientId;
        this.cacheStorage = cacheStorage;
        this.cryptoObj = cryptoObj;
        this.logger = logger4;
        this.serializableCache = serializableCache;
        this.persistencePlugin = persistencePlugin;
        this.performanceClient = performanceClient;
      }
      /**
       * Function which validates server authorization token response.
       * @param serverResponse
       * @param refreshAccessToken
       */
      validateTokenResponse(serverResponse, refreshAccessToken) {
        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
          const errString = `Error(s): ${serverResponse.error_codes || Constants.NOT_AVAILABLE} - Timestamp: ${serverResponse.timestamp || Constants.NOT_AVAILABLE} - Description: ${serverResponse.error_description || Constants.NOT_AVAILABLE} - Correlation ID: ${serverResponse.correlation_id || Constants.NOT_AVAILABLE} - Trace ID: ${serverResponse.trace_id || Constants.NOT_AVAILABLE}`;
          const serverErrorNo = serverResponse.error_codes?.length
            ? serverResponse.error_codes[0]
            : void 0;
          const serverError = new ServerError(
            serverResponse.error,
            errString,
            serverResponse.suberror,
            serverErrorNo,
            serverResponse.status
          );
          if (
            refreshAccessToken &&
            serverResponse.status &&
            serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START &&
            serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END
          ) {
            this.logger
              .warning(`executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.
${serverError}`);
            return;
          } else if (
            refreshAccessToken &&
            serverResponse.status &&
            serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START &&
            serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END
          ) {
            this.logger
              .warning(`executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.
${serverError}`);
            return;
          }
          if (
            isInteractionRequiredError(
              serverResponse.error,
              serverResponse.error_description,
              serverResponse.suberror
            )
          ) {
            throw new InteractionRequiredAuthError(
              serverResponse.error,
              serverResponse.error_description,
              serverResponse.suberror,
              serverResponse.timestamp || Constants.EMPTY_STRING,
              serverResponse.trace_id || Constants.EMPTY_STRING,
              serverResponse.correlation_id || Constants.EMPTY_STRING,
              serverResponse.claims || Constants.EMPTY_STRING,
              serverErrorNo
            );
          }
          throw serverError;
        }
      }
      /**
       * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.
       * @param serverTokenResponse
       * @param authority
       */
      async handleServerTokenResponse(
        serverTokenResponse,
        authority,
        reqTimestamp,
        request,
        authCodePayload,
        userAssertionHash,
        handlingRefreshTokenResponse,
        forceCacheRefreshTokenResponse,
        serverRequestId
      ) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.HandleServerTokenResponse,
          serverTokenResponse.correlation_id
        );
        let idTokenClaims;
        if (serverTokenResponse.id_token) {
          idTokenClaims = extractTokenClaims(
            serverTokenResponse.id_token || Constants.EMPTY_STRING,
            this.cryptoObj.base64Decode
          );
          if (authCodePayload && authCodePayload.nonce) {
            if (idTokenClaims.nonce !== authCodePayload.nonce) {
              throw createClientAuthError(nonceMismatch);
            }
          }
          if (request.maxAge || request.maxAge === 0) {
            const authTime = idTokenClaims.auth_time;
            if (!authTime) {
              throw createClientAuthError(authTimeNotFound);
            }
            checkMaxAge(authTime, request.maxAge);
          }
        }
        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(
          serverTokenResponse.client_info || Constants.EMPTY_STRING,
          authority.authorityType,
          this.logger,
          this.cryptoObj,
          idTokenClaims
        );
        let requestStateObj;
        if (!!authCodePayload && !!authCodePayload.state) {
          requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);
        }
        serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || void 0;
        const cacheRecord = this.generateCacheRecord(
          serverTokenResponse,
          authority,
          reqTimestamp,
          request,
          idTokenClaims,
          userAssertionHash,
          authCodePayload
        );
        let cacheContext;
        try {
          if (this.persistencePlugin && this.serializableCache) {
            this.logger.verbose('Persistence enabled, calling beforeCacheAccess');
            cacheContext = new TokenCacheContext(this.serializableCache, true);
            await this.persistencePlugin.beforeCacheAccess(cacheContext);
          }
          if (
            handlingRefreshTokenResponse &&
            !forceCacheRefreshTokenResponse &&
            cacheRecord.account
          ) {
            const key2 = this.cacheStorage.generateAccountKey(cacheRecord.account.getAccountInfo());
            const account = this.cacheStorage.getAccount(key2, request.correlationId);
            if (!account) {
              this.logger.warning(
                'Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache'
              );
              return await _ResponseHandler.generateAuthenticationResult(
                this.cryptoObj,
                authority,
                cacheRecord,
                false,
                request,
                idTokenClaims,
                requestStateObj,
                void 0,
                serverRequestId
              );
            }
          }
          await this.cacheStorage.saveCacheRecord(
            cacheRecord,
            request.correlationId,
            request.storeInCache
          );
        } finally {
          if (this.persistencePlugin && this.serializableCache && cacheContext) {
            this.logger.verbose('Persistence enabled, calling afterCacheAccess');
            await this.persistencePlugin.afterCacheAccess(cacheContext);
          }
        }
        return _ResponseHandler.generateAuthenticationResult(
          this.cryptoObj,
          authority,
          cacheRecord,
          false,
          request,
          idTokenClaims,
          requestStateObj,
          serverTokenResponse,
          serverRequestId
        );
      }
      /**
       * Generates CacheRecord
       * @param serverTokenResponse
       * @param idTokenObj
       * @param authority
       */
      generateCacheRecord(
        serverTokenResponse,
        authority,
        reqTimestamp,
        request,
        idTokenClaims,
        userAssertionHash,
        authCodePayload
      ) {
        const env2 = authority.getPreferredCache();
        if (!env2) {
          throw createClientAuthError(invalidCacheEnvironment);
        }
        const claimsTenantId = getTenantIdFromIdTokenClaims(idTokenClaims);
        let cachedIdToken;
        let cachedAccount;
        if (serverTokenResponse.id_token && !!idTokenClaims) {
          cachedIdToken = createIdTokenEntity(
            this.homeAccountIdentifier,
            env2,
            serverTokenResponse.id_token,
            this.clientId,
            claimsTenantId || ''
          );
          cachedAccount = buildAccountToCache(
            this.cacheStorage,
            authority,
            this.homeAccountIdentifier,
            this.cryptoObj.base64Decode,
            request.correlationId,
            idTokenClaims,
            serverTokenResponse.client_info,
            env2,
            claimsTenantId,
            authCodePayload,
            void 0,
            // nativeAccountId
            this.logger
          );
        }
        let cachedAccessToken = null;
        if (serverTokenResponse.access_token) {
          const responseScopes = serverTokenResponse.scope
            ? ScopeSet.fromString(serverTokenResponse.scope)
            : new ScopeSet(request.scopes || []);
          const expiresIn =
            (typeof serverTokenResponse.expires_in === 'string'
              ? parseInt(serverTokenResponse.expires_in, 10)
              : serverTokenResponse.expires_in) || 0;
          const extExpiresIn =
            (typeof serverTokenResponse.ext_expires_in === 'string'
              ? parseInt(serverTokenResponse.ext_expires_in, 10)
              : serverTokenResponse.ext_expires_in) || 0;
          const refreshIn =
            (typeof serverTokenResponse.refresh_in === 'string'
              ? parseInt(serverTokenResponse.refresh_in, 10)
              : serverTokenResponse.refresh_in) || void 0;
          const tokenExpirationSeconds = reqTimestamp + expiresIn;
          const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
          const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : void 0;
          cachedAccessToken = createAccessTokenEntity(
            this.homeAccountIdentifier,
            env2,
            serverTokenResponse.access_token,
            this.clientId,
            claimsTenantId || authority.tenant || '',
            responseScopes.printScopes(),
            tokenExpirationSeconds,
            extendedTokenExpirationSeconds,
            this.cryptoObj.base64Decode,
            refreshOnSeconds,
            serverTokenResponse.token_type,
            userAssertionHash,
            serverTokenResponse.key_id,
            request.claims,
            request.requestedClaimsHash
          );
        }
        let cachedRefreshToken = null;
        if (serverTokenResponse.refresh_token) {
          let rtExpiresOn;
          if (serverTokenResponse.refresh_token_expires_in) {
            const rtExpiresIn =
              typeof serverTokenResponse.refresh_token_expires_in === 'string'
                ? parseInt(serverTokenResponse.refresh_token_expires_in, 10)
                : serverTokenResponse.refresh_token_expires_in;
            rtExpiresOn = reqTimestamp + rtExpiresIn;
          }
          cachedRefreshToken = createRefreshTokenEntity(
            this.homeAccountIdentifier,
            env2,
            serverTokenResponse.refresh_token,
            this.clientId,
            serverTokenResponse.foci,
            userAssertionHash,
            rtExpiresOn
          );
        }
        let cachedAppMetadata = null;
        if (serverTokenResponse.foci) {
          cachedAppMetadata = {
            clientId: this.clientId,
            environment: env2,
            familyId: serverTokenResponse.foci,
          };
        }
        return {
          account: cachedAccount,
          idToken: cachedIdToken,
          accessToken: cachedAccessToken,
          refreshToken: cachedRefreshToken,
          appMetadata: cachedAppMetadata,
        };
      }
      /**
       * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.
       *
       * Optionally takes a state string that is set as-is in the response.
       *
       * @param cacheRecord
       * @param idTokenObj
       * @param fromTokenCache
       * @param stateString
       */
      static async generateAuthenticationResult(
        cryptoObj,
        authority,
        cacheRecord,
        fromTokenCache,
        request,
        idTokenClaims,
        requestState,
        serverTokenResponse,
        requestId
      ) {
        let accessToken = Constants.EMPTY_STRING;
        let responseScopes = [];
        let expiresOn = null;
        let extExpiresOn;
        let refreshOn;
        let familyId = Constants.EMPTY_STRING;
        if (cacheRecord.accessToken) {
          if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP && !request.popKid) {
            const popTokenGenerator = new PopTokenGenerator(cryptoObj);
            const { secret, keyId } = cacheRecord.accessToken;
            if (!keyId) {
              throw createClientAuthError(keyIdMissing);
            }
            accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);
          } else {
            accessToken = cacheRecord.accessToken.secret;
          }
          responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
          expiresOn = toDateFromSeconds(cacheRecord.accessToken.expiresOn);
          extExpiresOn = toDateFromSeconds(cacheRecord.accessToken.extendedExpiresOn);
          if (cacheRecord.accessToken.refreshOn) {
            refreshOn = toDateFromSeconds(cacheRecord.accessToken.refreshOn);
          }
        }
        if (cacheRecord.appMetadata) {
          familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : '';
        }
        const uid = idTokenClaims?.oid || idTokenClaims?.sub || '';
        const tid = idTokenClaims?.tid || '';
        if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {
          cacheRecord.account.nativeAccountId = serverTokenResponse?.spa_accountid;
        }
        const accountInfo = cacheRecord.account
          ? updateAccountTenantProfileData(
              cacheRecord.account.getAccountInfo(),
              void 0,
              // tenantProfile optional
              idTokenClaims,
              cacheRecord.idToken?.secret
            )
          : null;
        return {
          authority: authority.canonicalAuthority,
          uniqueId: uid,
          tenantId: tid,
          scopes: responseScopes,
          account: accountInfo,
          idToken: cacheRecord?.idToken?.secret || '',
          idTokenClaims: idTokenClaims || {},
          accessToken,
          fromCache: fromTokenCache,
          expiresOn,
          extExpiresOn,
          refreshOn,
          correlationId: request.correlationId,
          requestId: requestId || Constants.EMPTY_STRING,
          familyId,
          tokenType: cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,
          state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,
          cloudGraphHostName: cacheRecord.account?.cloudGraphHostName || Constants.EMPTY_STRING,
          msGraphHost: cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,
          code: serverTokenResponse?.spa_code,
          fromNativeBroker: false,
        };
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/utils/ClientAssertionUtils.mjs
async function getClientAssertion(clientAssertion, clientId, tokenEndpoint) {
  if (typeof clientAssertion === 'string') {
    return clientAssertion;
  } else {
    const config = {
      clientId,
      tokenEndpoint,
    };
    return clientAssertion(config);
  }
}
var init_ClientAssertionUtils = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/utils/ClientAssertionUtils.mjs'() {
    'use strict';
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/client/AuthorizationCodeClient.mjs
var AuthorizationCodeClient;
var init_AuthorizationCodeClient = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/client/AuthorizationCodeClient.mjs'() {
    'use strict';
    init_BaseClient();
    init_RequestParameterBuilder();
    init_UrlUtils();
    init_Constants();
    init_AADServerParamKeys();
    init_ClientConfiguration();
    init_ResponseHandler();
    init_StringUtils();
    init_ClientAuthError();
    init_UrlString();
    init_PopTokenGenerator();
    init_TimeUtils();
    init_ClientInfo();
    init_CcsCredential();
    init_ClientConfigurationError();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_ClientAssertionUtils();
    init_RequestThumbprint();
    init_ClientAuthErrorCodes();
    init_ClientConfigurationErrorCodes();
    AuthorizationCodeClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
        this.includeRedirectUri = true;
        this.oidcDefaultScopes =
          this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;
      }
      /**
       * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the
       * authorization_code_grant
       * @param request
       */
      async acquireToken(request, authCodePayload) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.AuthClientAcquireToken,
          request.correlationId
        );
        if (!request.code) {
          throw createClientAuthError(requestCannotBeMade);
        }
        const reqTimestamp = nowSeconds();
        const response = await invokeAsync(
          this.executeTokenRequest.bind(this),
          PerformanceEvents.AuthClientExecuteTokenRequest,
          this.logger,
          this.performanceClient,
          request.correlationId
        )(this.authority, request);
        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];
        const responseHandler = new ResponseHandler(
          this.config.authOptions.clientId,
          this.cacheManager,
          this.cryptoUtils,
          this.logger,
          this.config.serializableCache,
          this.config.persistencePlugin,
          this.performanceClient
        );
        responseHandler.validateTokenResponse(response.body);
        return invokeAsync(
          responseHandler.handleServerTokenResponse.bind(responseHandler),
          PerformanceEvents.HandleServerTokenResponse,
          this.logger,
          this.performanceClient,
          request.correlationId
        )(
          response.body,
          this.authority,
          reqTimestamp,
          request,
          authCodePayload,
          void 0,
          void 0,
          void 0,
          requestId
        );
      }
      /**
       * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.
       * Default behaviour is to redirect the user to `window.location.href`.
       * @param authorityUri
       */
      getLogoutUri(logoutRequest) {
        if (!logoutRequest) {
          throw createClientConfigurationError(logoutRequestEmpty);
        }
        const queryString = this.createLogoutUrlQueryString(logoutRequest);
        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);
      }
      /**
       * Executes POST request to token endpoint
       * @param authority
       * @param request
       */
      async executeTokenRequest(authority, request) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.AuthClientExecuteTokenRequest,
          request.correlationId
        );
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(
          authority.tokenEndpoint,
          queryParametersString
        );
        const requestBody = await invokeAsync(
          this.createTokenRequestBody.bind(this),
          PerformanceEvents.AuthClientCreateTokenRequestBody,
          this.logger,
          this.performanceClient,
          request.correlationId
        )(request);
        let ccsCredential = void 0;
        if (request.clientInfo) {
          try {
            const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
            ccsCredential = {
              credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
              type: CcsCredentialType.HOME_ACCOUNT_ID,
            };
          } catch (e) {
            this.logger.verbose('Could not parse client info for CCS Header: ' + e);
          }
        }
        const headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);
        const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
        return invokeAsync(
          this.executePostToTokenEndpoint.bind(this),
          PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint,
          this.logger,
          this.performanceClient,
          request.correlationId
        )(
          endpoint,
          requestBody,
          headers,
          thumbprint,
          request.correlationId,
          PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint
        );
      }
      /**
       * Generates a map for all the params to be sent to the service
       * @param request
       */
      async createTokenRequestBody(request) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.AuthClientCreateTokenRequestBody,
          request.correlationId
        );
        const parameters = /* @__PURE__ */ new Map();
        addClientId(
          parameters,
          request.embeddedClientId ||
            request.tokenBodyParameters?.[CLIENT_ID] ||
            this.config.authOptions.clientId
        );
        if (!this.includeRedirectUri) {
          if (!request.redirectUri) {
            throw createClientConfigurationError(redirectUriEmpty);
          }
        } else {
          addRedirectUri(parameters, request.redirectUri);
        }
        addScopes(parameters, request.scopes, true, this.oidcDefaultScopes);
        addAuthorizationCode(parameters, request.code);
        addLibraryInfo(parameters, this.config.libraryInfo);
        addApplicationTelemetry(parameters, this.config.telemetry.application);
        addThrottling(parameters);
        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
          addServerTelemetry(parameters, this.serverTelemetryManager);
        }
        if (request.codeVerifier) {
          addCodeVerifier(parameters, request.codeVerifier);
        }
        if (this.config.clientCredentials.clientSecret) {
          addClientSecret(parameters, this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
          const clientAssertion = this.config.clientCredentials.clientAssertion;
          addClientAssertion(
            parameters,
            await getClientAssertion(
              clientAssertion.assertion,
              this.config.authOptions.clientId,
              request.resourceRequestUri
            )
          );
          addClientAssertionType(parameters, clientAssertion.assertionType);
        }
        addGrantType(parameters, GrantType.AUTHORIZATION_CODE_GRANT);
        addClientInfo(parameters);
        if (request.authenticationScheme === AuthenticationScheme.POP) {
          const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
          let reqCnfData;
          if (!request.popKid) {
            const generatedReqCnfData = await invokeAsync(
              popTokenGenerator.generateCnf.bind(popTokenGenerator),
              PerformanceEvents.PopTokenGenerateCnf,
              this.logger,
              this.performanceClient,
              request.correlationId
            )(request, this.logger);
            reqCnfData = generatedReqCnfData.reqCnfString;
          } else {
            reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
          }
          addPopToken(parameters, reqCnfData);
        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {
          if (request.sshJwk) {
            addSshJwk(parameters, request.sshJwk);
          } else {
            throw createClientConfigurationError(missingSshJwk);
          }
        }
        if (
          !StringUtils.isEmptyObj(request.claims) ||
          (this.config.authOptions.clientCapabilities &&
            this.config.authOptions.clientCapabilities.length > 0)
        ) {
          addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        let ccsCred = void 0;
        if (request.clientInfo) {
          try {
            const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
            ccsCred = {
              credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
              type: CcsCredentialType.HOME_ACCOUNT_ID,
            };
          } catch (e) {
            this.logger.verbose('Could not parse client info for CCS Header: ' + e);
          }
        } else {
          ccsCred = request.ccsCredential;
        }
        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
          switch (ccsCred.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                addCcsOid(parameters, clientInfo);
              } catch (e) {
                this.logger.verbose('Could not parse home account ID for CCS Header: ' + e);
              }
              break;
            case CcsCredentialType.UPN:
              addCcsUpn(parameters, ccsCred.credential);
              break;
          }
        }
        if (request.embeddedClientId) {
          addBrokerParameters(
            parameters,
            this.config.authOptions.clientId,
            this.config.authOptions.redirectUri
          );
        }
        if (request.tokenBodyParameters) {
          addExtraQueryParameters(parameters, request.tokenBodyParameters);
        }
        if (
          request.enableSpaAuthorizationCode &&
          (!request.tokenBodyParameters || !request.tokenBodyParameters[RETURN_SPA_CODE])
        ) {
          addExtraQueryParameters(parameters, {
            [RETURN_SPA_CODE]: '1',
          });
        }
        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
        return mapToQueryString(parameters);
      }
      /**
       * This API validates the `EndSessionRequest` and creates a URL
       * @param request
       */
      createLogoutUrlQueryString(request) {
        const parameters = /* @__PURE__ */ new Map();
        if (request.postLogoutRedirectUri) {
          addPostLogoutRedirectUri(parameters, request.postLogoutRedirectUri);
        }
        if (request.correlationId) {
          addCorrelationId(parameters, request.correlationId);
        }
        if (request.idTokenHint) {
          addIdTokenHint(parameters, request.idTokenHint);
        }
        if (request.state) {
          addState(parameters, request.state);
        }
        if (request.logoutHint) {
          addLogoutHint(parameters, request.logoutHint);
        }
        if (request.extraQueryParameters) {
          addExtraQueryParameters(parameters, request.extraQueryParameters);
        }
        if (this.config.authOptions.instanceAware) {
          addInstanceAware(parameters);
        }
        return mapToQueryString(
          parameters,
          this.config.authOptions.encodeExtraQueryParams,
          request.extraQueryParameters
        );
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/client/RefreshTokenClient.mjs
var DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS, RefreshTokenClient;
var init_RefreshTokenClient = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/client/RefreshTokenClient.mjs'() {
    'use strict';
    init_ClientConfiguration();
    init_BaseClient();
    init_RequestParameterBuilder();
    init_UrlUtils();
    init_Constants();
    init_AADServerParamKeys();
    init_ResponseHandler();
    init_PopTokenGenerator();
    init_StringUtils();
    init_ClientConfigurationError();
    init_ClientAuthError();
    init_ServerError();
    init_TimeUtils();
    init_UrlString();
    init_CcsCredential();
    init_ClientInfo();
    init_InteractionRequiredAuthError();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_ClientAssertionUtils();
    init_RequestThumbprint();
    init_InteractionRequiredAuthErrorCodes();
    init_ClientConfigurationErrorCodes();
    init_ClientAuthErrorCodes();
    DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS = 300;
    RefreshTokenClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
      }
      async acquireToken(request) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.RefreshTokenClientAcquireToken,
          request.correlationId
        );
        const reqTimestamp = nowSeconds();
        const response = await invokeAsync(
          this.executeTokenRequest.bind(this),
          PerformanceEvents.RefreshTokenClientExecuteTokenRequest,
          this.logger,
          this.performanceClient,
          request.correlationId
        )(request, this.authority);
        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];
        const responseHandler = new ResponseHandler(
          this.config.authOptions.clientId,
          this.cacheManager,
          this.cryptoUtils,
          this.logger,
          this.config.serializableCache,
          this.config.persistencePlugin
        );
        responseHandler.validateTokenResponse(response.body);
        return invokeAsync(
          responseHandler.handleServerTokenResponse.bind(responseHandler),
          PerformanceEvents.HandleServerTokenResponse,
          this.logger,
          this.performanceClient,
          request.correlationId
        )(
          response.body,
          this.authority,
          reqTimestamp,
          request,
          void 0,
          void 0,
          true,
          request.forceCache,
          requestId
        );
      }
      /**
       * Gets cached refresh token and attaches to request, then calls acquireToken API
       * @param request
       */
      async acquireTokenByRefreshToken(request) {
        if (!request) {
          throw createClientConfigurationError(tokenRequestEmpty);
        }
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken,
          request.correlationId
        );
        if (!request.account) {
          throw createClientAuthError(noAccountInSilentRequest);
        }
        const isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment);
        if (isFOCI) {
          try {
            return await invokeAsync(
              this.acquireTokenWithCachedRefreshToken.bind(this),
              PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,
              this.logger,
              this.performanceClient,
              request.correlationId
            )(request, true);
          } catch (e) {
            const noFamilyRTInCache =
              e instanceof InteractionRequiredAuthError && e.errorCode === noTokensFound;
            const clientMismatchErrorWithFamilyRT =
              e instanceof ServerError &&
              e.errorCode === Errors.INVALID_GRANT_ERROR &&
              e.subError === Errors.CLIENT_MISMATCH_ERROR;
            if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
              return invokeAsync(
                this.acquireTokenWithCachedRefreshToken.bind(this),
                PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,
                this.logger,
                this.performanceClient,
                request.correlationId
              )(request, false);
            } else {
              throw e;
            }
          }
        }
        return invokeAsync(
          this.acquireTokenWithCachedRefreshToken.bind(this),
          PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,
          this.logger,
          this.performanceClient,
          request.correlationId
        )(request, false);
      }
      /**
       * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached
       * @param request
       */
      async acquireTokenWithCachedRefreshToken(request, foci) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,
          request.correlationId
        );
        const refreshToken = invoke(
          this.cacheManager.getRefreshToken.bind(this.cacheManager),
          PerformanceEvents.CacheManagerGetRefreshToken,
          this.logger,
          this.performanceClient,
          request.correlationId
        )(request.account, foci, request.correlationId, void 0, this.performanceClient);
        if (!refreshToken) {
          throw createInteractionRequiredAuthError(noTokensFound);
        }
        if (
          refreshToken.expiresOn &&
          isTokenExpired(
            refreshToken.expiresOn,
            request.refreshTokenExpirationOffsetSeconds ||
              DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS
          )
        ) {
          this.performanceClient?.addFields(
            { rtExpiresOnMs: Number(refreshToken.expiresOn) },
            request.correlationId
          );
          throw createInteractionRequiredAuthError(refreshTokenExpired);
        }
        const refreshTokenRequest = {
          ...request,
          refreshToken: refreshToken.secret,
          authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,
          ccsCredential: {
            credential: request.account.homeAccountId,
            type: CcsCredentialType.HOME_ACCOUNT_ID,
          },
        };
        try {
          return await invokeAsync(
            this.acquireToken.bind(this),
            PerformanceEvents.RefreshTokenClientAcquireToken,
            this.logger,
            this.performanceClient,
            request.correlationId
          )(refreshTokenRequest);
        } catch (e) {
          if (e instanceof InteractionRequiredAuthError) {
            this.performanceClient?.addFields(
              { rtExpiresOnMs: Number(refreshToken.expiresOn) },
              request.correlationId
            );
            if (e.subError === badToken) {
              this.logger.verbose(
                'acquireTokenWithRefreshToken: bad refresh token, removing from cache'
              );
              const badRefreshTokenKey = this.cacheManager.generateCredentialKey(refreshToken);
              this.cacheManager.removeRefreshToken(badRefreshTokenKey, request.correlationId);
            }
          }
          throw e;
        }
      }
      /**
       * Constructs the network message and makes a NW call to the underlying secure token service
       * @param request
       * @param authority
       */
      async executeTokenRequest(request, authority) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.RefreshTokenClientExecuteTokenRequest,
          request.correlationId
        );
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(
          authority.tokenEndpoint,
          queryParametersString
        );
        const requestBody = await invokeAsync(
          this.createTokenRequestBody.bind(this),
          PerformanceEvents.RefreshTokenClientCreateTokenRequestBody,
          this.logger,
          this.performanceClient,
          request.correlationId
        )(request);
        const headers = this.createTokenRequestHeaders(request.ccsCredential);
        const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
        return invokeAsync(
          this.executePostToTokenEndpoint.bind(this),
          PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint,
          this.logger,
          this.performanceClient,
          request.correlationId
        )(
          endpoint,
          requestBody,
          headers,
          thumbprint,
          request.correlationId,
          PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint
        );
      }
      /**
       * Helper function to create the token request body
       * @param request
       */
      async createTokenRequestBody(request) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.RefreshTokenClientCreateTokenRequestBody,
          request.correlationId
        );
        const parameters = /* @__PURE__ */ new Map();
        addClientId(
          parameters,
          request.embeddedClientId ||
            request.tokenBodyParameters?.[CLIENT_ID] ||
            this.config.authOptions.clientId
        );
        if (request.redirectUri) {
          addRedirectUri(parameters, request.redirectUri);
        }
        addScopes(
          parameters,
          request.scopes,
          true,
          this.config.authOptions.authority.options.OIDCOptions?.defaultScopes
        );
        addGrantType(parameters, GrantType.REFRESH_TOKEN_GRANT);
        addClientInfo(parameters);
        addLibraryInfo(parameters, this.config.libraryInfo);
        addApplicationTelemetry(parameters, this.config.telemetry.application);
        addThrottling(parameters);
        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
          addServerTelemetry(parameters, this.serverTelemetryManager);
        }
        addRefreshToken(parameters, request.refreshToken);
        if (this.config.clientCredentials.clientSecret) {
          addClientSecret(parameters, this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
          const clientAssertion = this.config.clientCredentials.clientAssertion;
          addClientAssertion(
            parameters,
            await getClientAssertion(
              clientAssertion.assertion,
              this.config.authOptions.clientId,
              request.resourceRequestUri
            )
          );
          addClientAssertionType(parameters, clientAssertion.assertionType);
        }
        if (request.authenticationScheme === AuthenticationScheme.POP) {
          const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
          let reqCnfData;
          if (!request.popKid) {
            const generatedReqCnfData = await invokeAsync(
              popTokenGenerator.generateCnf.bind(popTokenGenerator),
              PerformanceEvents.PopTokenGenerateCnf,
              this.logger,
              this.performanceClient,
              request.correlationId
            )(request, this.logger);
            reqCnfData = generatedReqCnfData.reqCnfString;
          } else {
            reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
          }
          addPopToken(parameters, reqCnfData);
        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {
          if (request.sshJwk) {
            addSshJwk(parameters, request.sshJwk);
          } else {
            throw createClientConfigurationError(missingSshJwk);
          }
        }
        if (
          !StringUtils.isEmptyObj(request.claims) ||
          (this.config.authOptions.clientCapabilities &&
            this.config.authOptions.clientCapabilities.length > 0)
        ) {
          addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        if (this.config.systemOptions.preventCorsPreflight && request.ccsCredential) {
          switch (request.ccsCredential.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(
                  request.ccsCredential.credential
                );
                addCcsOid(parameters, clientInfo);
              } catch (e) {
                this.logger.verbose('Could not parse home account ID for CCS Header: ' + e);
              }
              break;
            case CcsCredentialType.UPN:
              addCcsUpn(parameters, request.ccsCredential.credential);
              break;
          }
        }
        if (request.embeddedClientId) {
          addBrokerParameters(
            parameters,
            this.config.authOptions.clientId,
            this.config.authOptions.redirectUri
          );
        }
        if (request.tokenBodyParameters) {
          addExtraQueryParameters(parameters, request.tokenBodyParameters);
        }
        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
        return mapToQueryString(parameters);
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/client/SilentFlowClient.mjs
var SilentFlowClient;
var init_SilentFlowClient = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/client/SilentFlowClient.mjs'() {
    'use strict';
    init_BaseClient();
    init_TimeUtils();
    init_ClientAuthError();
    init_ResponseHandler();
    init_Constants();
    init_StringUtils();
    init_AuthToken();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_Authority();
    init_ClientAuthErrorCodes();
    SilentFlowClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
      }
      /**
       * Retrieves token from cache or throws an error if it must be refreshed.
       * @param request
       */
      async acquireCachedToken(request) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.SilentFlowClientAcquireCachedToken,
          request.correlationId
        );
        let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;
        if (
          request.forceRefresh ||
          (!this.config.cacheOptions.claimsBasedCachingEnabled &&
            !StringUtils.isEmptyObj(request.claims))
        ) {
          this.setCacheOutcome(CacheOutcome.FORCE_REFRESH_OR_CLAIMS, request.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        }
        if (!request.account) {
          throw createClientAuthError(noAccountInSilentRequest);
        }
        const requestTenantId =
          request.account.tenantId || getTenantFromAuthorityString(request.authority);
        const tokenKeys = this.cacheManager.getTokenKeys();
        const cachedAccessToken = this.cacheManager.getAccessToken(
          request.account,
          request,
          tokenKeys,
          requestTenantId
        );
        if (!cachedAccessToken) {
          this.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN, request.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        } else if (
          wasClockTurnedBack(cachedAccessToken.cachedAt) ||
          isTokenExpired(
            cachedAccessToken.expiresOn,
            this.config.systemOptions.tokenRenewalOffsetSeconds
          )
        ) {
          this.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED, request.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        } else if (cachedAccessToken.refreshOn && isTokenExpired(cachedAccessToken.refreshOn, 0)) {
          lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;
        }
        const environment = request.authority || this.authority.getPreferredCache();
        const cacheRecord = {
          account: this.cacheManager.getAccount(
            this.cacheManager.generateAccountKey(request.account),
            request.correlationId
          ),
          accessToken: cachedAccessToken,
          idToken: this.cacheManager.getIdToken(
            request.account,
            request.correlationId,
            tokenKeys,
            requestTenantId,
            this.performanceClient
          ),
          refreshToken: null,
          appMetadata: this.cacheManager.readAppMetadataFromCache(environment),
        };
        this.setCacheOutcome(lastCacheOutcome, request.correlationId);
        if (this.config.serverTelemetryManager) {
          this.config.serverTelemetryManager.incrementCacheHits();
        }
        return [
          await invokeAsync(
            this.generateResultFromCacheRecord.bind(this),
            PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord,
            this.logger,
            this.performanceClient,
            request.correlationId
          )(cacheRecord, request),
          lastCacheOutcome,
        ];
      }
      setCacheOutcome(cacheOutcome, correlationId) {
        this.serverTelemetryManager?.setCacheOutcome(cacheOutcome);
        this.performanceClient?.addFields(
          {
            cacheOutcome,
          },
          correlationId
        );
        if (cacheOutcome !== CacheOutcome.NOT_APPLICABLE) {
          this.logger.info(`Token refresh is required due to cache outcome: ${cacheOutcome}`);
        }
      }
      /**
       * Helper function to build response object from the CacheRecord
       * @param cacheRecord
       */
      async generateResultFromCacheRecord(cacheRecord, request) {
        this.performanceClient?.addQueueMeasurement(
          PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord,
          request.correlationId
        );
        let idTokenClaims;
        if (cacheRecord.idToken) {
          idTokenClaims = extractTokenClaims(
            cacheRecord.idToken.secret,
            this.config.cryptoInterface.base64Decode
          );
        }
        if (request.maxAge || request.maxAge === 0) {
          const authTime = idTokenClaims?.auth_time;
          if (!authTime) {
            throw createClientAuthError(authTimeNotFound);
          }
          checkMaxAge(authTime, request.maxAge);
        }
        return ResponseHandler.generateAuthenticationResult(
          this.cryptoUtils,
          this.authority,
          cacheRecord,
          true,
          request,
          idTokenClaims
        );
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/protocol/Authorize.mjs
var Authorize_exports = {};
__export(Authorize_exports, {
  getAuthorizationCodePayload: () => getAuthorizationCodePayload,
  getAuthorizeUrl: () => getAuthorizeUrl,
  getStandardAuthorizeRequestParameters: () => getStandardAuthorizeRequestParameters,
  validateAuthorizationResponse: () => validateAuthorizationResponse,
});
function getStandardAuthorizeRequestParameters(authOptions, request, logger4, performanceClient) {
  const correlationId = request.correlationId;
  const parameters = /* @__PURE__ */ new Map();
  addClientId(
    parameters,
    request.embeddedClientId || request.extraQueryParameters?.[CLIENT_ID] || authOptions.clientId
  );
  const requestScopes = [...(request.scopes || []), ...(request.extraScopesToConsent || [])];
  addScopes(
    parameters,
    requestScopes,
    true,
    authOptions.authority.options.OIDCOptions?.defaultScopes
  );
  addRedirectUri(parameters, request.redirectUri);
  addCorrelationId(parameters, correlationId);
  addResponseMode(parameters, request.responseMode);
  addClientInfo(parameters);
  if (request.prompt) {
    addPrompt(parameters, request.prompt);
    performanceClient?.addFields({ prompt: request.prompt }, correlationId);
  }
  if (request.domainHint) {
    addDomainHint(parameters, request.domainHint);
    performanceClient?.addFields({ domainHintFromRequest: true }, correlationId);
  }
  if (request.prompt !== PromptValue.SELECT_ACCOUNT) {
    if (request.sid && request.prompt === PromptValue.NONE) {
      logger4.verbose('createAuthCodeUrlQueryString: Prompt is none, adding sid from request');
      addSid(parameters, request.sid);
      performanceClient?.addFields({ sidFromRequest: true }, correlationId);
    } else if (request.account) {
      const accountSid = extractAccountSid(request.account);
      let accountLoginHintClaim = extractLoginHint(request.account);
      if (accountLoginHintClaim && request.domainHint) {
        logger4.warning(
          `AuthorizationCodeClient.createAuthCodeUrlQueryString: "domainHint" param is set, skipping opaque "login_hint" claim. Please consider not passing domainHint`
        );
        accountLoginHintClaim = null;
      }
      if (accountLoginHintClaim) {
        logger4.verbose('createAuthCodeUrlQueryString: login_hint claim present on account');
        addLoginHint(parameters, accountLoginHintClaim);
        performanceClient?.addFields({ loginHintFromClaim: true }, correlationId);
        try {
          const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
          addCcsOid(parameters, clientInfo);
        } catch (e) {
          logger4.verbose(
            'createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header'
          );
        }
      } else if (accountSid && request.prompt === PromptValue.NONE) {
        logger4.verbose('createAuthCodeUrlQueryString: Prompt is none, adding sid from account');
        addSid(parameters, accountSid);
        performanceClient?.addFields({ sidFromClaim: true }, correlationId);
        try {
          const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
          addCcsOid(parameters, clientInfo);
        } catch (e) {
          logger4.verbose(
            'createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header'
          );
        }
      } else if (request.loginHint) {
        logger4.verbose('createAuthCodeUrlQueryString: Adding login_hint from request');
        addLoginHint(parameters, request.loginHint);
        addCcsUpn(parameters, request.loginHint);
        performanceClient?.addFields({ loginHintFromRequest: true }, correlationId);
      } else if (request.account.username) {
        logger4.verbose('createAuthCodeUrlQueryString: Adding login_hint from account');
        addLoginHint(parameters, request.account.username);
        performanceClient?.addFields({ loginHintFromUpn: true }, correlationId);
        try {
          const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
          addCcsOid(parameters, clientInfo);
        } catch (e) {
          logger4.verbose(
            'createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header'
          );
        }
      }
    } else if (request.loginHint) {
      logger4.verbose('createAuthCodeUrlQueryString: No account, adding login_hint from request');
      addLoginHint(parameters, request.loginHint);
      addCcsUpn(parameters, request.loginHint);
      performanceClient?.addFields({ loginHintFromRequest: true }, correlationId);
    }
  } else {
    logger4.verbose(
      'createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints'
    );
  }
  if (request.nonce) {
    addNonce(parameters, request.nonce);
  }
  if (request.state) {
    addState(parameters, request.state);
  }
  if (
    request.claims ||
    (authOptions.clientCapabilities && authOptions.clientCapabilities.length > 0)
  ) {
    addClaims(parameters, request.claims, authOptions.clientCapabilities);
  }
  if (request.embeddedClientId) {
    addBrokerParameters(parameters, authOptions.clientId, authOptions.redirectUri);
  }
  if (
    authOptions.instanceAware &&
    (!request.extraQueryParameters ||
      !Object.keys(request.extraQueryParameters).includes(INSTANCE_AWARE))
  ) {
    addInstanceAware(parameters);
  }
  return parameters;
}
function getAuthorizeUrl(authority, requestParameters, encodeParams, extraQueryParameters) {
  const queryString = mapToQueryString(requestParameters, encodeParams, extraQueryParameters);
  return UrlString.appendQueryString(authority.authorizationEndpoint, queryString);
}
function getAuthorizationCodePayload(serverParams, cachedState) {
  validateAuthorizationResponse(serverParams, cachedState);
  if (!serverParams.code) {
    throw createClientAuthError(authorizationCodeMissingFromServerResponse);
  }
  return serverParams;
}
function validateAuthorizationResponse(serverResponse, requestState) {
  if (!serverResponse.state || !requestState) {
    throw serverResponse.state
      ? createClientAuthError(stateNotFound, 'Cached State')
      : createClientAuthError(stateNotFound, 'Server State');
  }
  let decodedServerResponseState;
  let decodedRequestState;
  try {
    decodedServerResponseState = decodeURIComponent(serverResponse.state);
  } catch (e) {
    throw createClientAuthError(invalidState, serverResponse.state);
  }
  try {
    decodedRequestState = decodeURIComponent(requestState);
  } catch (e) {
    throw createClientAuthError(invalidState, serverResponse.state);
  }
  if (decodedServerResponseState !== decodedRequestState) {
    throw createClientAuthError(stateMismatch);
  }
  if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
    const serverErrorNo = parseServerErrorNo(serverResponse);
    if (
      isInteractionRequiredError(
        serverResponse.error,
        serverResponse.error_description,
        serverResponse.suberror
      )
    ) {
      throw new InteractionRequiredAuthError(
        serverResponse.error || '',
        serverResponse.error_description,
        serverResponse.suberror,
        serverResponse.timestamp || '',
        serverResponse.trace_id || '',
        serverResponse.correlation_id || '',
        serverResponse.claims || '',
        serverErrorNo
      );
    }
    throw new ServerError(
      serverResponse.error || '',
      serverResponse.error_description,
      serverResponse.suberror,
      serverErrorNo
    );
  }
}
function parseServerErrorNo(serverResponse) {
  const errorCodePrefix = 'code=';
  const errorCodePrefixIndex = serverResponse.error_uri?.lastIndexOf(errorCodePrefix);
  return errorCodePrefixIndex && errorCodePrefixIndex >= 0
    ? serverResponse.error_uri?.substring(errorCodePrefixIndex + errorCodePrefix.length)
    : void 0;
}
function extractAccountSid(account) {
  return account.idTokenClaims?.sid || null;
}
function extractLoginHint(account) {
  return account.loginHint || account.idTokenClaims?.login_hint || null;
}
var init_Authorize = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/protocol/Authorize.mjs'() {
    'use strict';
    init_RequestParameterBuilder();
    init_AADServerParamKeys();
    init_Constants();
    init_ClientInfo();
    init_UrlUtils();
    init_UrlString();
    init_ClientAuthError();
    init_InteractionRequiredAuthError();
    init_ServerError();
    init_ClientAuthErrorCodes();
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs
function makeExtraSkuString(params) {
  const { skus, libraryName, libraryVersion, extensionName, extensionVersion } = params;
  const skuMap = /* @__PURE__ */ new Map([
    [0, [libraryName, libraryVersion]],
    [2, [extensionName, extensionVersion]],
  ]);
  let skuArr = [];
  if (skus?.length) {
    skuArr = skus.split(skuGroupSeparator);
    if (skuArr.length < 4) {
      return skus;
    }
  } else {
    skuArr = Array.from({ length: 4 }, () => skuValueSeparator);
  }
  skuMap.forEach((value, key2) => {
    if (value.length === 2 && value[0]?.length && value[1]?.length) {
      setSku({
        skuArr,
        index: key2,
        skuName: value[0],
        skuVersion: value[1],
      });
    }
  });
  return skuArr.join(skuGroupSeparator);
}
function setSku(params) {
  const { skuArr, index: index2, skuName, skuVersion } = params;
  if (index2 >= skuArr.length) {
    return;
  }
  skuArr[index2] = [skuName, skuVersion].join(skuValueSeparator);
}
var skuGroupSeparator, skuValueSeparator, ServerTelemetryManager;
var init_ServerTelemetryManager = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs'() {
    'use strict';
    init_Constants();
    init_AuthError();
    skuGroupSeparator = ',';
    skuValueSeparator = '|';
    ServerTelemetryManager = class _ServerTelemetryManager {
      constructor(telemetryRequest, cacheManager) {
        this.cacheOutcome = CacheOutcome.NOT_APPLICABLE;
        this.cacheManager = cacheManager;
        this.apiId = telemetryRequest.apiId;
        this.correlationId = telemetryRequest.correlationId;
        this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;
        this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;
        this.telemetryCacheKey =
          SERVER_TELEM_CONSTANTS.CACHE_KEY +
          Separators.CACHE_KEY_SEPARATOR +
          telemetryRequest.clientId;
      }
      /**
       * API to add MSER Telemetry to request
       */
      generateCurrentRequestHeaderValue() {
        const request = `${this.apiId}${SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR}${this.cacheOutcome}`;
        const platformFieldsArr = [this.wrapperSKU, this.wrapperVer];
        const nativeBrokerErrorCode = this.getNativeBrokerErrorCode();
        if (nativeBrokerErrorCode?.length) {
          platformFieldsArr.push(`broker_error=${nativeBrokerErrorCode}`);
        }
        const platformFields = platformFieldsArr.join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const regionDiscoveryFields = this.getRegionDiscoveryFields();
        const requestWithRegionDiscoveryFields = [request, regionDiscoveryFields].join(
          SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR
        );
        return [
          SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
          requestWithRegionDiscoveryFields,
          platformFields,
        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
      }
      /**
       * API to add MSER Telemetry for the last failed request
       */
      generateLastRequestHeaderValue() {
        const lastRequests = this.getLastRequests();
        const maxErrors = _ServerTelemetryManager.maxErrorsToSend(lastRequests);
        const failedRequests = lastRequests.failedRequests
          .slice(0, 2 * maxErrors)
          .join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const errors = lastRequests.errors
          .slice(0, maxErrors)
          .join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const errorCount = lastRequests.errors.length;
        const overflow =
          maxErrors < errorCount
            ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE
            : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
        const platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [
          SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
          lastRequests.cacheHits,
          failedRequests,
          errors,
          platformFields,
        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
      }
      /**
       * API to cache token failures for MSER data capture
       * @param error
       */
      cacheFailedRequest(error) {
        const lastRequests = this.getLastRequests();
        if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
          lastRequests.failedRequests.shift();
          lastRequests.failedRequests.shift();
          lastRequests.errors.shift();
        }
        lastRequests.failedRequests.push(this.apiId, this.correlationId);
        if (error instanceof Error && !!error && error.toString()) {
          if (error instanceof AuthError) {
            if (error.subError) {
              lastRequests.errors.push(error.subError);
            } else if (error.errorCode) {
              lastRequests.errors.push(error.errorCode);
            } else {
              lastRequests.errors.push(error.toString());
            }
          } else {
            lastRequests.errors.push(error.toString());
          }
        } else {
          lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);
        }
        this.cacheManager.setServerTelemetry(
          this.telemetryCacheKey,
          lastRequests,
          this.correlationId
        );
        return;
      }
      /**
       * Update server telemetry cache entry by incrementing cache hit counter
       */
      incrementCacheHits() {
        const lastRequests = this.getLastRequests();
        lastRequests.cacheHits += 1;
        this.cacheManager.setServerTelemetry(
          this.telemetryCacheKey,
          lastRequests,
          this.correlationId
        );
        return lastRequests.cacheHits;
      }
      /**
       * Get the server telemetry entity from cache or initialize a new one
       */
      getLastRequests() {
        const initialValue = {
          failedRequests: [],
          errors: [],
          cacheHits: 0,
        };
        const lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
        return lastRequests || initialValue;
      }
      /**
       * Remove server telemetry cache entry
       */
      clearTelemetryCache() {
        const lastRequests = this.getLastRequests();
        const numErrorsFlushed = _ServerTelemetryManager.maxErrorsToSend(lastRequests);
        const errorCount = lastRequests.errors.length;
        if (numErrorsFlushed === errorCount) {
          this.cacheManager.removeItem(this.telemetryCacheKey, this.correlationId);
        } else {
          const serverTelemEntity = {
            failedRequests: lastRequests.failedRequests.slice(numErrorsFlushed * 2),
            errors: lastRequests.errors.slice(numErrorsFlushed),
            cacheHits: 0,
          };
          this.cacheManager.setServerTelemetry(
            this.telemetryCacheKey,
            serverTelemEntity,
            this.correlationId
          );
        }
      }
      /**
       * Returns the maximum number of errors that can be flushed to the server in the next network request
       * @param serverTelemetryEntity
       */
      static maxErrorsToSend(serverTelemetryEntity) {
        let i;
        let maxErrors = 0;
        let dataSize = 0;
        const errorCount = serverTelemetryEntity.errors.length;
        for (i = 0; i < errorCount; i++) {
          const apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants.EMPTY_STRING;
          const correlationId =
            serverTelemetryEntity.failedRequests[2 * i + 1] || Constants.EMPTY_STRING;
          const errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;
          dataSize +=
            apiId.toString().length + correlationId.toString().length + errorCode.length + 3;
          if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
            maxErrors += 1;
          } else {
            break;
          }
        }
        return maxErrors;
      }
      /**
       * Get the region discovery fields
       *
       * @returns string
       */
      getRegionDiscoveryFields() {
        const regionDiscoveryFields = [];
        regionDiscoveryFields.push(this.regionUsed || Constants.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionSource || Constants.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionOutcome || Constants.EMPTY_STRING);
        return regionDiscoveryFields.join(',');
      }
      /**
       * Update the region discovery metadata
       *
       * @param regionDiscoveryMetadata
       * @returns void
       */
      updateRegionDiscoveryMetadata(regionDiscoveryMetadata) {
        this.regionUsed = regionDiscoveryMetadata.region_used;
        this.regionSource = regionDiscoveryMetadata.region_source;
        this.regionOutcome = regionDiscoveryMetadata.region_outcome;
      }
      /**
       * Set cache outcome
       */
      setCacheOutcome(cacheOutcome) {
        this.cacheOutcome = cacheOutcome;
      }
      setNativeBrokerErrorCode(errorCode) {
        const lastRequests = this.getLastRequests();
        lastRequests.nativeBrokerErrorCode = errorCode;
        this.cacheManager.setServerTelemetry(
          this.telemetryCacheKey,
          lastRequests,
          this.correlationId
        );
      }
      getNativeBrokerErrorCode() {
        return this.getLastRequests().nativeBrokerErrorCode;
      }
      clearNativeBrokerErrorCode() {
        const lastRequests = this.getLastRequests();
        delete lastRequests.nativeBrokerErrorCode;
        this.cacheManager.setServerTelemetry(
          this.telemetryCacheKey,
          lastRequests,
          this.correlationId
        );
      }
      static makeExtraSkuString(params) {
        return makeExtraSkuString(params);
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/index-node.mjs
var init_index_node = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/index-node.mjs'() {
    'use strict';
    init_AuthorizationCodeClient();
    init_RefreshTokenClient();
    init_SilentFlowClient();
    init_BaseClient();
    init_CcsCredential();
    init_Authority();
    init_AuthorityOptions();
    init_ProtocolMode();
    init_CacheManager();
    init_AccountEntity();
    init_UrlString();
    init_Authorize();
    init_RequestParameterBuilder();
    init_ResponseHandler();
    init_Logger();
    init_AuthError();
    init_AuthErrorCodes();
    init_ServerError();
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
    init_Constants();
    init_StringUtils();
    init_ServerTelemetryManager();
    init_AuthorityFactory();
    init_CacheHelpers();
    init_TimeUtils();
    init_UrlUtils();
    init_AADServerParamKeys();
    init_TokenCacheContext();
    init_ClientAssertionUtils();
  },
});

// node_modules/@azure/msal-node/dist/cache/serializer/Deserializer.mjs
var Deserializer;
var init_Deserializer = __esm({
  'node_modules/@azure/msal-node/dist/cache/serializer/Deserializer.mjs'() {
    'use strict';
    init_index_node();
    Deserializer = class {
      /**
       * Parse the JSON blob in memory and deserialize the content
       * @param cachedJson - JSON blob cache
       */
      static deserializeJSONBlob(jsonFile) {
        const deserializedCache = !jsonFile ? {} : JSON.parse(jsonFile);
        return deserializedCache;
      }
      /**
       * Deserializes accounts to AccountEntity objects
       * @param accounts - accounts of type SerializedAccountEntity
       */
      static deserializeAccounts(accounts) {
        const accountObjects = {};
        if (accounts) {
          Object.keys(accounts).map(function (key2) {
            const serializedAcc = accounts[key2];
            const mappedAcc = {
              homeAccountId: serializedAcc.home_account_id,
              environment: serializedAcc.environment,
              realm: serializedAcc.realm,
              localAccountId: serializedAcc.local_account_id,
              username: serializedAcc.username,
              authorityType: serializedAcc.authority_type,
              name: serializedAcc.name,
              clientInfo: serializedAcc.client_info,
              lastModificationTime: serializedAcc.last_modification_time,
              lastModificationApp: serializedAcc.last_modification_app,
              tenantProfiles: serializedAcc.tenantProfiles?.map((serializedTenantProfile) => {
                return JSON.parse(serializedTenantProfile);
              }),
              lastUpdatedAt: Date.now().toString(),
            };
            const account = new AccountEntity();
            CacheManager.toObject(account, mappedAcc);
            accountObjects[key2] = account;
          });
        }
        return accountObjects;
      }
      /**
       * Deserializes id tokens to IdTokenEntity objects
       * @param idTokens - credentials of type SerializedIdTokenEntity
       */
      static deserializeIdTokens(idTokens) {
        const idObjects = {};
        if (idTokens) {
          Object.keys(idTokens).map(function (key2) {
            const serializedIdT = idTokens[key2];
            const idToken = {
              homeAccountId: serializedIdT.home_account_id,
              environment: serializedIdT.environment,
              credentialType: serializedIdT.credential_type,
              clientId: serializedIdT.client_id,
              secret: serializedIdT.secret,
              realm: serializedIdT.realm,
              lastUpdatedAt: Date.now().toString(),
            };
            idObjects[key2] = idToken;
          });
        }
        return idObjects;
      }
      /**
       * Deserializes access tokens to AccessTokenEntity objects
       * @param accessTokens - access tokens of type SerializedAccessTokenEntity
       */
      static deserializeAccessTokens(accessTokens) {
        const atObjects = {};
        if (accessTokens) {
          Object.keys(accessTokens).map(function (key2) {
            const serializedAT = accessTokens[key2];
            const accessToken = {
              homeAccountId: serializedAT.home_account_id,
              environment: serializedAT.environment,
              credentialType: serializedAT.credential_type,
              clientId: serializedAT.client_id,
              secret: serializedAT.secret,
              realm: serializedAT.realm,
              target: serializedAT.target,
              cachedAt: serializedAT.cached_at,
              expiresOn: serializedAT.expires_on,
              extendedExpiresOn: serializedAT.extended_expires_on,
              refreshOn: serializedAT.refresh_on,
              keyId: serializedAT.key_id,
              tokenType: serializedAT.token_type,
              requestedClaims: serializedAT.requestedClaims,
              requestedClaimsHash: serializedAT.requestedClaimsHash,
              userAssertionHash: serializedAT.userAssertionHash,
              lastUpdatedAt: Date.now().toString(),
            };
            atObjects[key2] = accessToken;
          });
        }
        return atObjects;
      }
      /**
       * Deserializes refresh tokens to RefreshTokenEntity objects
       * @param refreshTokens - refresh tokens of type SerializedRefreshTokenEntity
       */
      static deserializeRefreshTokens(refreshTokens) {
        const rtObjects = {};
        if (refreshTokens) {
          Object.keys(refreshTokens).map(function (key2) {
            const serializedRT = refreshTokens[key2];
            const refreshToken = {
              homeAccountId: serializedRT.home_account_id,
              environment: serializedRT.environment,
              credentialType: serializedRT.credential_type,
              clientId: serializedRT.client_id,
              secret: serializedRT.secret,
              familyId: serializedRT.family_id,
              target: serializedRT.target,
              realm: serializedRT.realm,
              lastUpdatedAt: Date.now().toString(),
            };
            rtObjects[key2] = refreshToken;
          });
        }
        return rtObjects;
      }
      /**
       * Deserializes appMetadata to AppMetaData objects
       * @param appMetadata - app metadata of type SerializedAppMetadataEntity
       */
      static deserializeAppMetadata(appMetadata) {
        const appMetadataObjects = {};
        if (appMetadata) {
          Object.keys(appMetadata).map(function (key2) {
            const serializedAmdt = appMetadata[key2];
            appMetadataObjects[key2] = {
              clientId: serializedAmdt.client_id,
              environment: serializedAmdt.environment,
              familyId: serializedAmdt.family_id,
            };
          });
        }
        return appMetadataObjects;
      }
      /**
       * Deserialize an inMemory Cache
       * @param jsonCache - JSON blob cache
       */
      static deserializeAllCache(jsonCache) {
        return {
          accounts: jsonCache.Account ? this.deserializeAccounts(jsonCache.Account) : {},
          idTokens: jsonCache.IdToken ? this.deserializeIdTokens(jsonCache.IdToken) : {},
          accessTokens: jsonCache.AccessToken
            ? this.deserializeAccessTokens(jsonCache.AccessToken)
            : {},
          refreshTokens: jsonCache.RefreshToken
            ? this.deserializeRefreshTokens(jsonCache.RefreshToken)
            : {},
          appMetadata: jsonCache.AppMetadata
            ? this.deserializeAppMetadata(jsonCache.AppMetadata)
            : {},
        };
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/internals.mjs
var init_internals = __esm({
  'node_modules/@azure/msal-node/dist/internals.mjs'() {
    'use strict';
    init_Serializer();
    init_Deserializer();
  },
});

// node_modules/@azure/msal-node/dist/utils/Constants.mjs
var MANAGED_IDENTITY_DEFAULT_TENANT,
  DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY,
  ManagedIdentityQueryParameters,
  ManagedIdentityEnvironmentVariableNames,
  ManagedIdentitySourceNames,
  ManagedIdentityIdType,
  HttpMethod2,
  ProxyStatus,
  RANDOM_OCTET_SIZE,
  Hash,
  CharSet,
  CACHE,
  Constants2,
  ApiId,
  JwtConstants,
  LOOPBACK_SERVER_CONSTANTS;
var init_Constants2 = __esm({
  'node_modules/@azure/msal-node/dist/utils/Constants.mjs'() {
    'use strict';
    init_index_node();
    MANAGED_IDENTITY_DEFAULT_TENANT = 'managed_identity';
    DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY = `https://login.microsoftonline.com/${MANAGED_IDENTITY_DEFAULT_TENANT}/`;
    ManagedIdentityQueryParameters = {
      API_VERSION: 'api-version',
      RESOURCE: 'resource',
      SHA256_TOKEN_TO_REFRESH: 'token_sha256_to_refresh',
      XMS_CC: 'xms_cc',
    };
    ManagedIdentityEnvironmentVariableNames = {
      AZURE_POD_IDENTITY_AUTHORITY_HOST: 'AZURE_POD_IDENTITY_AUTHORITY_HOST',
      DEFAULT_IDENTITY_CLIENT_ID: 'DEFAULT_IDENTITY_CLIENT_ID',
      IDENTITY_ENDPOINT: 'IDENTITY_ENDPOINT',
      IDENTITY_HEADER: 'IDENTITY_HEADER',
      IDENTITY_SERVER_THUMBPRINT: 'IDENTITY_SERVER_THUMBPRINT',
      IMDS_ENDPOINT: 'IMDS_ENDPOINT',
      MSI_ENDPOINT: 'MSI_ENDPOINT',
      MSI_SECRET: 'MSI_SECRET',
    };
    ManagedIdentitySourceNames = {
      APP_SERVICE: 'AppService',
      AZURE_ARC: 'AzureArc',
      CLOUD_SHELL: 'CloudShell',
      DEFAULT_TO_IMDS: 'DefaultToImds',
      IMDS: 'Imds',
      MACHINE_LEARNING: 'MachineLearning',
      SERVICE_FABRIC: 'ServiceFabric',
    };
    ManagedIdentityIdType = {
      SYSTEM_ASSIGNED: 'system-assigned',
      USER_ASSIGNED_CLIENT_ID: 'user-assigned-client-id',
      USER_ASSIGNED_RESOURCE_ID: 'user-assigned-resource-id',
      USER_ASSIGNED_OBJECT_ID: 'user-assigned-object-id',
    };
    HttpMethod2 = {
      GET: 'get',
      POST: 'post',
    };
    ProxyStatus = {
      SUCCESS_RANGE_START: HttpStatus.SUCCESS_RANGE_START,
      SUCCESS_RANGE_END: HttpStatus.SUCCESS_RANGE_END,
      SERVER_ERROR: HttpStatus.SERVER_ERROR,
    };
    RANDOM_OCTET_SIZE = 32;
    Hash = {
      SHA256: 'sha256',
    };
    CharSet = {
      CV_CHARSET: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~',
    };
    CACHE = {
      KEY_SEPARATOR: '-',
    };
    Constants2 = {
      MSAL_SKU: 'msal.js.node',
      JWT_BEARER_ASSERTION_TYPE: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',
      AUTHORIZATION_PENDING: 'authorization_pending',
      HTTP_PROTOCOL: 'http://',
      LOCALHOST: 'localhost',
    };
    ApiId = {
      acquireTokenSilent: 62,
      acquireTokenByUsernamePassword: 371,
      acquireTokenByDeviceCode: 671,
      acquireTokenByClientCredential: 771,
      acquireTokenByCode: 871,
      acquireTokenByRefreshToken: 872,
    };
    JwtConstants = {
      RSA_256: 'RS256',
      PSS_256: 'PS256',
      X5T_256: 'x5t#S256',
      X5T: 'x5t',
      X5C: 'x5c',
      AUDIENCE: 'aud',
      EXPIRATION_TIME: 'exp',
      ISSUER: 'iss',
      SUBJECT: 'sub',
      NOT_BEFORE: 'nbf',
      JWT_ID: 'jti',
    };
    LOOPBACK_SERVER_CONSTANTS = {
      INTERVAL_MS: 100,
      TIMEOUT_MS: 5e3,
    };
  },
});

// node_modules/@azure/msal-node/dist/utils/NetworkUtils.mjs
var NetworkUtils;
var init_NetworkUtils = __esm({
  'node_modules/@azure/msal-node/dist/utils/NetworkUtils.mjs'() {
    'use strict';
    NetworkUtils = class {
      static getNetworkResponse(headers, body, statusCode) {
        return {
          headers,
          body,
          status: statusCode,
        };
      }
      /*
       * Utility function that converts a URL object into an ordinary options object as expected by the
       * http.request and https.request APIs.
       * https://github.com/nodejs/node/blob/main/lib/internal/url.js#L1090
       */
      static urlToHttpOptions(url2) {
        const options = {
          protocol: url2.protocol,
          hostname:
            url2.hostname && url2.hostname.startsWith('[')
              ? url2.hostname.slice(1, -1)
              : url2.hostname,
          hash: url2.hash,
          search: url2.search,
          pathname: url2.pathname,
          path: `${url2.pathname || ''}${url2.search || ''}`,
          href: url2.href,
        };
        if (url2.port !== '') {
          options.port = Number(url2.port);
        }
        if (url2.username || url2.password) {
          options.auth = `${decodeURIComponent(url2.username)}:${decodeURIComponent(url2.password)}`;
        }
        return options;
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/network/HttpClient.mjs
import http2 from 'http';
import https2 from 'https';
var HttpClient, networkRequestViaProxy, networkRequestViaHttps, parseBody;
var init_HttpClient = __esm({
  'node_modules/@azure/msal-node/dist/network/HttpClient.mjs'() {
    'use strict';
    init_index_node();
    init_Constants2();
    init_NetworkUtils();
    HttpClient = class {
      constructor(proxyUrl, customAgentOptions) {
        this.proxyUrl = proxyUrl || '';
        this.customAgentOptions = customAgentOptions || {};
      }
      /**
       * Http Get request
       * @param url
       * @param options
       */
      async sendGetRequestAsync(url2, options, timeout) {
        if (this.proxyUrl) {
          return networkRequestViaProxy(
            url2,
            this.proxyUrl,
            HttpMethod2.GET,
            options,
            this.customAgentOptions,
            timeout
          );
        } else {
          return networkRequestViaHttps(
            url2,
            HttpMethod2.GET,
            options,
            this.customAgentOptions,
            timeout
          );
        }
      }
      /**
       * Http Post request
       * @param url
       * @param options
       */
      async sendPostRequestAsync(url2, options) {
        if (this.proxyUrl) {
          return networkRequestViaProxy(
            url2,
            this.proxyUrl,
            HttpMethod2.POST,
            options,
            this.customAgentOptions
          );
        } else {
          return networkRequestViaHttps(url2, HttpMethod2.POST, options, this.customAgentOptions);
        }
      }
    };
    networkRequestViaProxy = (
      destinationUrlString,
      proxyUrlString,
      httpMethod,
      options,
      agentOptions,
      timeout
    ) => {
      const destinationUrl = new URL(destinationUrlString);
      const proxyUrl = new URL(proxyUrlString);
      const headers = options?.headers || {};
      const tunnelRequestOptions = {
        host: proxyUrl.hostname,
        port: proxyUrl.port,
        method: 'CONNECT',
        path: destinationUrl.hostname,
        headers,
      };
      if (agentOptions && Object.keys(agentOptions).length) {
        tunnelRequestOptions.agent = new http2.Agent(agentOptions);
      }
      let postRequestStringContent = '';
      if (httpMethod === HttpMethod2.POST) {
        const body = options?.body || '';
        postRequestStringContent = `Content-Type: application/x-www-form-urlencoded\r
Content-Length: ${body.length}\r
\r
${body}`;
      } else {
        if (timeout) {
          tunnelRequestOptions.timeout = timeout;
        }
      }
      const outgoingRequestString =
        `${httpMethod.toUpperCase()} ${destinationUrl.href} HTTP/1.1\r
Host: ${destinationUrl.host}\r
Connection: close\r
` +
        postRequestStringContent +
        '\r\n';
      return new Promise((resolve, reject) => {
        const request = http2.request(tunnelRequestOptions);
        if (timeout) {
          request.on('timeout', () => {
            request.destroy();
            reject(new Error('Request time out'));
          });
        }
        request.end();
        request.on('connect', (response, socket) => {
          const proxyStatusCode = response?.statusCode || ProxyStatus.SERVER_ERROR;
          if (
            proxyStatusCode < ProxyStatus.SUCCESS_RANGE_START ||
            proxyStatusCode > ProxyStatus.SUCCESS_RANGE_END
          ) {
            request.destroy();
            socket.destroy();
            reject(
              new Error(
                `Error connecting to proxy. Http status code: ${response.statusCode}. Http status message: ${response?.statusMessage || 'Unknown'}`
              )
            );
          }
          socket.write(outgoingRequestString);
          const data = [];
          socket.on('data', (chunk) => {
            data.push(chunk);
          });
          socket.on('end', () => {
            const dataString = Buffer.concat([...data]).toString();
            const dataStringArray = dataString.split('\r\n');
            const httpStatusCode = parseInt(dataStringArray[0].split(' ')[1]);
            const statusMessage = dataStringArray[0].split(' ').slice(2).join(' ');
            const body = dataStringArray[dataStringArray.length - 1];
            const headersArray = dataStringArray.slice(1, dataStringArray.length - 2);
            const entries = /* @__PURE__ */ new Map();
            headersArray.forEach((header) => {
              const headerKeyValue = header.split(new RegExp(/:\s(.*)/s));
              const headerKey = headerKeyValue[0];
              let headerValue = headerKeyValue[1];
              try {
                const object = JSON.parse(headerValue);
                if (object && typeof object === 'object') {
                  headerValue = object;
                }
              } catch (e) {}
              entries.set(headerKey, headerValue);
            });
            const headers2 = Object.fromEntries(entries);
            const parsedHeaders = headers2;
            const networkResponse = NetworkUtils.getNetworkResponse(
              parsedHeaders,
              parseBody(httpStatusCode, statusMessage, parsedHeaders, body),
              httpStatusCode
            );
            if (
              (httpStatusCode < HttpStatus.SUCCESS_RANGE_START ||
                httpStatusCode > HttpStatus.SUCCESS_RANGE_END) && // do not destroy the request for the device code flow
              networkResponse.body['error'] !== Constants2.AUTHORIZATION_PENDING
            ) {
              request.destroy();
            }
            resolve(networkResponse);
          });
          socket.on('error', (chunk) => {
            request.destroy();
            socket.destroy();
            reject(new Error(chunk.toString()));
          });
        });
        request.on('error', (chunk) => {
          request.destroy();
          reject(new Error(chunk.toString()));
        });
      });
    };
    networkRequestViaHttps = (urlString, httpMethod, options, agentOptions, timeout) => {
      const isPostRequest = httpMethod === HttpMethod2.POST;
      const body = options?.body || '';
      const url2 = new URL(urlString);
      const headers = options?.headers || {};
      const customOptions = {
        method: httpMethod,
        headers,
        ...NetworkUtils.urlToHttpOptions(url2),
      };
      if (agentOptions && Object.keys(agentOptions).length) {
        customOptions.agent = new https2.Agent(agentOptions);
      }
      if (isPostRequest) {
        customOptions.headers = {
          ...customOptions.headers,
          'Content-Length': body.length,
        };
      } else {
        if (timeout) {
          customOptions.timeout = timeout;
        }
      }
      return new Promise((resolve, reject) => {
        let request;
        if (customOptions.protocol === 'http:') {
          request = http2.request(customOptions);
        } else {
          request = https2.request(customOptions);
        }
        if (isPostRequest) {
          request.write(body);
        }
        if (timeout) {
          request.on('timeout', () => {
            request.destroy();
            reject(new Error('Request time out'));
          });
        }
        request.end();
        request.on('response', (response) => {
          const headers2 = response.headers;
          const statusCode = response.statusCode;
          const statusMessage = response.statusMessage;
          const data = [];
          response.on('data', (chunk) => {
            data.push(chunk);
          });
          response.on('end', () => {
            const body2 = Buffer.concat([...data]).toString();
            const parsedHeaders = headers2;
            const networkResponse = NetworkUtils.getNetworkResponse(
              parsedHeaders,
              parseBody(statusCode, statusMessage, parsedHeaders, body2),
              statusCode
            );
            if (
              (statusCode < HttpStatus.SUCCESS_RANGE_START ||
                statusCode > HttpStatus.SUCCESS_RANGE_END) && // do not destroy the request for the device code flow
              networkResponse.body['error'] !== Constants2.AUTHORIZATION_PENDING
            ) {
              request.destroy();
            }
            resolve(networkResponse);
          });
        });
        request.on('error', (chunk) => {
          request.destroy();
          reject(new Error(chunk.toString()));
        });
      });
    };
    parseBody = (statusCode, statusMessage, headers, body) => {
      let parsedBody;
      try {
        parsedBody = JSON.parse(body);
      } catch (error) {
        let errorType;
        let errorDescriptionHelper;
        if (
          statusCode >= HttpStatus.CLIENT_ERROR_RANGE_START &&
          statusCode <= HttpStatus.CLIENT_ERROR_RANGE_END
        ) {
          errorType = 'client_error';
          errorDescriptionHelper = 'A client';
        } else if (
          statusCode >= HttpStatus.SERVER_ERROR_RANGE_START &&
          statusCode <= HttpStatus.SERVER_ERROR_RANGE_END
        ) {
          errorType = 'server_error';
          errorDescriptionHelper = 'A server';
        } else {
          errorType = 'unknown_error';
          errorDescriptionHelper = 'An unknown';
        }
        parsedBody = {
          error: errorType,
          error_description: `${errorDescriptionHelper} error occured.
Http status code: ${statusCode}
Http status message: ${statusMessage || 'Unknown'}
Headers: ${JSON.stringify(headers)}`,
        };
      }
      return parsedBody;
    };
  },
});

// node_modules/@azure/msal-node/dist/error/ManagedIdentityErrorCodes.mjs
var invalidFileExtension,
  invalidFilePath,
  invalidManagedIdentityIdType,
  invalidSecret,
  missingId,
  networkUnavailable,
  platformNotSupported,
  unableToCreateAzureArc,
  unableToCreateCloudShell,
  unableToCreateSource,
  unableToReadSecretFile,
  userAssignedNotAvailableAtRuntime,
  wwwAuthenticateHeaderMissing,
  wwwAuthenticateHeaderUnsupportedFormat,
  MsiEnvironmentVariableUrlMalformedErrorCodes;
var init_ManagedIdentityErrorCodes = __esm({
  'node_modules/@azure/msal-node/dist/error/ManagedIdentityErrorCodes.mjs'() {
    'use strict';
    init_Constants2();
    invalidFileExtension = 'invalid_file_extension';
    invalidFilePath = 'invalid_file_path';
    invalidManagedIdentityIdType = 'invalid_managed_identity_id_type';
    invalidSecret = 'invalid_secret';
    missingId = 'missing_client_id';
    networkUnavailable = 'network_unavailable';
    platformNotSupported = 'platform_not_supported';
    unableToCreateAzureArc = 'unable_to_create_azure_arc';
    unableToCreateCloudShell = 'unable_to_create_cloud_shell';
    unableToCreateSource = 'unable_to_create_source';
    unableToReadSecretFile = 'unable_to_read_secret_file';
    userAssignedNotAvailableAtRuntime = 'user_assigned_not_available_at_runtime';
    wwwAuthenticateHeaderMissing = 'www_authenticate_header_missing';
    wwwAuthenticateHeaderUnsupportedFormat = 'www_authenticate_header_unsupported_format';
    MsiEnvironmentVariableUrlMalformedErrorCodes = {
      [ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST]:
        'azure_pod_identity_authority_host_url_malformed',
      [ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT]:
        'identity_endpoint_url_malformed',
      [ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT]: 'imds_endpoint_url_malformed',
      [ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT]: 'msi_endpoint_url_malformed',
    };
  },
});

// node_modules/@azure/msal-node/dist/error/ManagedIdentityError.mjs
function createManagedIdentityError(errorCode) {
  return new ManagedIdentityError(errorCode);
}
var ManagedIdentityErrorMessages, ManagedIdentityError;
var init_ManagedIdentityError = __esm({
  'node_modules/@azure/msal-node/dist/error/ManagedIdentityError.mjs'() {
    'use strict';
    init_index_node();
    init_ManagedIdentityErrorCodes();
    init_Constants2();
    ManagedIdentityErrorMessages = {
      [invalidFileExtension]:
        'The file path in the WWW-Authenticate header does not contain a .key file.',
      [invalidFilePath]:
        'The file path in the WWW-Authenticate header is not in a valid Windows or Linux Format.',
      [invalidManagedIdentityIdType]: 'More than one ManagedIdentityIdType was provided.',
      [invalidSecret]:
        'The secret in the file on the file path in the WWW-Authenticate header is greater than 4096 bytes.',
      [platformNotSupported]:
        'The platform is not supported by Azure Arc. Azure Arc only supports Windows and Linux.',
      [missingId]: 'A ManagedIdentityId id was not provided.',
      [MsiEnvironmentVariableUrlMalformedErrorCodes.AZURE_POD_IDENTITY_AUTHORITY_HOST]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST}' environment variable is malformed.`,
      [MsiEnvironmentVariableUrlMalformedErrorCodes.IDENTITY_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' environment variable is malformed.`,
      [MsiEnvironmentVariableUrlMalformedErrorCodes.IMDS_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT}' environment variable is malformed.`,
      [MsiEnvironmentVariableUrlMalformedErrorCodes.MSI_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT}' environment variable is malformed.`,
      [networkUnavailable]:
        'Authentication unavailable. The request to the managed identity endpoint timed out.',
      [unableToCreateAzureArc]: 'Azure Arc Managed Identities can only be system assigned.',
      [unableToCreateCloudShell]: 'Cloud Shell Managed Identities can only be system assigned.',
      [unableToCreateSource]:
        'Unable to create a Managed Identity source based on environment variables.',
      [unableToReadSecretFile]: 'Unable to read the secret file.',
      [userAssignedNotAvailableAtRuntime]:
        'Service Fabric user assigned managed identity ClientId or ResourceId is not configurable at runtime.',
      [wwwAuthenticateHeaderMissing]:
        'A 401 response was received form the Azure Arc Managed Identity, but the www-authenticate header is missing.',
      [wwwAuthenticateHeaderUnsupportedFormat]:
        'A 401 response was received form the Azure Arc Managed Identity, but the www-authenticate header is in an unsupported format.',
    };
    ManagedIdentityError = class _ManagedIdentityError extends AuthError {
      constructor(errorCode) {
        super(errorCode, ManagedIdentityErrorMessages[errorCode]);
        this.name = 'ManagedIdentityError';
        Object.setPrototypeOf(this, _ManagedIdentityError.prototype);
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/config/ManagedIdentityId.mjs
var init_ManagedIdentityId = __esm({
  'node_modules/@azure/msal-node/dist/config/ManagedIdentityId.mjs'() {
    'use strict';
    init_ManagedIdentityError();
    init_Constants2();
    init_ManagedIdentityErrorCodes();
  },
});

// node_modules/@azure/msal-node/dist/error/NodeAuthError.mjs
var NodeAuthErrorMessage, NodeAuthError;
var init_NodeAuthError = __esm({
  'node_modules/@azure/msal-node/dist/error/NodeAuthError.mjs'() {
    'use strict';
    init_index_node();
    NodeAuthErrorMessage = {
      invalidLoopbackAddressType: {
        code: 'invalid_loopback_server_address_type',
        desc: 'Loopback server address is not type string. This is unexpected.',
      },
      unableToLoadRedirectUri: {
        code: 'unable_to_load_redirectUrl',
        desc: 'Loopback server callback was invoked without a url. This is unexpected.',
      },
      noAuthCodeInResponse: {
        code: 'no_auth_code_in_response',
        desc: 'No auth code found in the server response. Please check your network trace to determine what happened.',
      },
      noLoopbackServerExists: {
        code: 'no_loopback_server_exists',
        desc: 'No loopback server exists yet.',
      },
      loopbackServerAlreadyExists: {
        code: 'loopback_server_already_exists',
        desc: 'Loopback server already exists. Cannot create another.',
      },
      loopbackServerTimeout: {
        code: 'loopback_server_timeout',
        desc: 'Timed out waiting for auth code listener to be registered.',
      },
      stateNotFoundError: {
        code: 'state_not_found',
        desc: 'State not found. Please verify that the request originated from msal.',
      },
      thumbprintMissing: {
        code: 'thumbprint_missing_from_client_certificate',
        desc: 'Client certificate does not contain a SHA-1 or SHA-256 thumbprint.',
      },
      redirectUriNotSupported: {
        code: 'redirect_uri_not_supported',
        desc: 'RedirectUri is not supported in this scenario. Please remove redirectUri from the request.',
      },
    };
    NodeAuthError = class _NodeAuthError extends AuthError {
      constructor(errorCode, errorMessage) {
        super(errorCode, errorMessage);
        this.name = 'NodeAuthError';
      }
      /**
       * Creates an error thrown if loopback server address is of type string.
       */
      static createInvalidLoopbackAddressTypeError() {
        return new _NodeAuthError(
          NodeAuthErrorMessage.invalidLoopbackAddressType.code,
          `${NodeAuthErrorMessage.invalidLoopbackAddressType.desc}`
        );
      }
      /**
       * Creates an error thrown if the loopback server is unable to get a url.
       */
      static createUnableToLoadRedirectUrlError() {
        return new _NodeAuthError(
          NodeAuthErrorMessage.unableToLoadRedirectUri.code,
          `${NodeAuthErrorMessage.unableToLoadRedirectUri.desc}`
        );
      }
      /**
       * Creates an error thrown if the server response does not contain an auth code.
       */
      static createNoAuthCodeInResponseError() {
        return new _NodeAuthError(
          NodeAuthErrorMessage.noAuthCodeInResponse.code,
          `${NodeAuthErrorMessage.noAuthCodeInResponse.desc}`
        );
      }
      /**
       * Creates an error thrown if the loopback server has not been spun up yet.
       */
      static createNoLoopbackServerExistsError() {
        return new _NodeAuthError(
          NodeAuthErrorMessage.noLoopbackServerExists.code,
          `${NodeAuthErrorMessage.noLoopbackServerExists.desc}`
        );
      }
      /**
       * Creates an error thrown if a loopback server already exists when attempting to create another one.
       */
      static createLoopbackServerAlreadyExistsError() {
        return new _NodeAuthError(
          NodeAuthErrorMessage.loopbackServerAlreadyExists.code,
          `${NodeAuthErrorMessage.loopbackServerAlreadyExists.desc}`
        );
      }
      /**
       * Creates an error thrown if the loopback server times out registering the auth code listener.
       */
      static createLoopbackServerTimeoutError() {
        return new _NodeAuthError(
          NodeAuthErrorMessage.loopbackServerTimeout.code,
          `${NodeAuthErrorMessage.loopbackServerTimeout.desc}`
        );
      }
      /**
       * Creates an error thrown when the state is not present.
       */
      static createStateNotFoundError() {
        return new _NodeAuthError(
          NodeAuthErrorMessage.stateNotFoundError.code,
          NodeAuthErrorMessage.stateNotFoundError.desc
        );
      }
      /**
       * Creates an error thrown when client certificate was provided, but neither the SHA-1 or SHA-256 thumbprints were provided
       */
      static createThumbprintMissingError() {
        return new _NodeAuthError(
          NodeAuthErrorMessage.thumbprintMissing.code,
          NodeAuthErrorMessage.thumbprintMissing.desc
        );
      }
      /**
       * Creates an error thrown when redirectUri is provided in an unsupported scenario
       */
      static createRedirectUriNotSupportedError() {
        return new _NodeAuthError(
          NodeAuthErrorMessage.redirectUriNotSupported.code,
          NodeAuthErrorMessage.redirectUriNotSupported.desc
        );
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/config/Configuration.mjs
function buildAppConfiguration({ auth, broker, cache: cache2, system, telemetry }) {
  const systemOptions = {
    ...DEFAULT_SYSTEM_OPTIONS2,
    networkClient: new HttpClient(system?.proxyUrl, system?.customAgentOptions),
    loggerOptions: system?.loggerOptions || DEFAULT_LOGGER_OPTIONS,
    disableInternalRetries: system?.disableInternalRetries || false,
  };
  if (
    !!auth.clientCertificate &&
    !!!auth.clientCertificate.thumbprint &&
    !!!auth.clientCertificate.thumbprintSha256
  ) {
    throw NodeAuthError.createStateNotFoundError();
  }
  return {
    auth: { ...DEFAULT_AUTH_OPTIONS, ...auth },
    broker: { ...broker },
    cache: { ...DEFAULT_CACHE_OPTIONS2, ...cache2 },
    system: { ...systemOptions, ...system },
    telemetry: { ...DEFAULT_TELEMETRY_OPTIONS2, ...telemetry },
  };
}
var DEFAULT_AUTH_OPTIONS,
  DEFAULT_CACHE_OPTIONS2,
  DEFAULT_LOGGER_OPTIONS,
  DEFAULT_SYSTEM_OPTIONS2,
  DEFAULT_TELEMETRY_OPTIONS2;
var init_Configuration = __esm({
  'node_modules/@azure/msal-node/dist/config/Configuration.mjs'() {
    'use strict';
    init_index_node();
    init_HttpClient();
    init_ManagedIdentityId();
    init_NodeAuthError();
    DEFAULT_AUTH_OPTIONS = {
      clientId: Constants.EMPTY_STRING,
      authority: Constants.DEFAULT_AUTHORITY,
      clientSecret: Constants.EMPTY_STRING,
      clientAssertion: Constants.EMPTY_STRING,
      clientCertificate: {
        thumbprint: Constants.EMPTY_STRING,
        thumbprintSha256: Constants.EMPTY_STRING,
        privateKey: Constants.EMPTY_STRING,
        x5c: Constants.EMPTY_STRING,
      },
      knownAuthorities: [],
      cloudDiscoveryMetadata: Constants.EMPTY_STRING,
      authorityMetadata: Constants.EMPTY_STRING,
      clientCapabilities: [],
      protocolMode: ProtocolMode.AAD,
      azureCloudOptions: {
        azureCloudInstance: AzureCloudInstance.None,
        tenant: Constants.EMPTY_STRING,
      },
      skipAuthorityMetadataCache: false,
      encodeExtraQueryParams: false,
    };
    DEFAULT_CACHE_OPTIONS2 = {
      claimsBasedCachingEnabled: false,
    };
    DEFAULT_LOGGER_OPTIONS = {
      loggerCallback: () => {},
      piiLoggingEnabled: false,
      logLevel: LogLevel3.Info,
    };
    DEFAULT_SYSTEM_OPTIONS2 = {
      loggerOptions: DEFAULT_LOGGER_OPTIONS,
      networkClient: new HttpClient(),
      proxyUrl: Constants.EMPTY_STRING,
      customAgentOptions: {},
      disableInternalRetries: false,
    };
    DEFAULT_TELEMETRY_OPTIONS2 = {
      application: {
        appName: Constants.EMPTY_STRING,
        appVersion: Constants.EMPTY_STRING,
      },
    };
  },
});

// node_modules/uuid/dist/esm-node/rng.js
import crypto7 from 'crypto';
function rng2() {
  if (poolPtr2 > rnds8Pool2.length - 16) {
    crypto7.randomFillSync(rnds8Pool2);
    poolPtr2 = 0;
  }
  return rnds8Pool2.slice(poolPtr2, (poolPtr2 += 16));
}
var rnds8Pool2, poolPtr2;
var init_rng2 = __esm({
  'node_modules/uuid/dist/esm-node/rng.js'() {
    rnds8Pool2 = new Uint8Array(256);
    poolPtr2 = rnds8Pool2.length;
  },
});

// node_modules/uuid/dist/esm-node/regex.js
var regex_default2;
var init_regex2 = __esm({
  'node_modules/uuid/dist/esm-node/regex.js'() {
    regex_default2 =
      /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  },
});

// node_modules/uuid/dist/esm-node/validate.js
function validate2(uuid) {
  return typeof uuid === 'string' && regex_default2.test(uuid);
}
var validate_default2;
var init_validate4 = __esm({
  'node_modules/uuid/dist/esm-node/validate.js'() {
    init_regex2();
    validate_default2 = validate2;
  },
});

// node_modules/uuid/dist/esm-node/stringify.js
function stringify2(arr, offset = 0) {
  const uuid = (
    byteToHex2[arr[offset + 0]] +
    byteToHex2[arr[offset + 1]] +
    byteToHex2[arr[offset + 2]] +
    byteToHex2[arr[offset + 3]] +
    '-' +
    byteToHex2[arr[offset + 4]] +
    byteToHex2[arr[offset + 5]] +
    '-' +
    byteToHex2[arr[offset + 6]] +
    byteToHex2[arr[offset + 7]] +
    '-' +
    byteToHex2[arr[offset + 8]] +
    byteToHex2[arr[offset + 9]] +
    '-' +
    byteToHex2[arr[offset + 10]] +
    byteToHex2[arr[offset + 11]] +
    byteToHex2[arr[offset + 12]] +
    byteToHex2[arr[offset + 13]] +
    byteToHex2[arr[offset + 14]] +
    byteToHex2[arr[offset + 15]]
  ).toLowerCase();
  if (!validate_default2(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }
  return uuid;
}
var byteToHex2, stringify_default2;
var init_stringify2 = __esm({
  'node_modules/uuid/dist/esm-node/stringify.js'() {
    init_validate4();
    byteToHex2 = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex2.push((i + 256).toString(16).substr(1));
    }
    stringify_default2 = stringify2;
  },
});

// node_modules/uuid/dist/esm-node/v4.js
function v42(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng2)();
  rnds[6] = (rnds[6] & 15) | 64;
  rnds[8] = (rnds[8] & 63) | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default2(rnds);
}
var v4_default2;
var init_v42 = __esm({
  'node_modules/uuid/dist/esm-node/v4.js'() {
    init_rng2();
    init_stringify2();
    v4_default2 = v42;
  },
});

// node_modules/uuid/dist/esm-node/index.js
var init_esm_node2 = __esm({
  'node_modules/uuid/dist/esm-node/index.js'() {
    init_v42();
  },
});

// node_modules/@azure/msal-node/dist/crypto/GuidGenerator.mjs
var GuidGenerator;
var init_GuidGenerator = __esm({
  'node_modules/@azure/msal-node/dist/crypto/GuidGenerator.mjs'() {
    'use strict';
    init_esm_node2();
    GuidGenerator = class {
      /**
       *
       * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.
       * uuidv4 generates guids from cryprtographically-string random
       */
      generateGuid() {
        return v4_default2();
      }
      /**
       * verifies if a string is  GUID
       * @param guid
       */
      isGuid(guid) {
        const regexGuid =
          /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return regexGuid.test(guid);
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/utils/EncodingUtils.mjs
var EncodingUtils;
var init_EncodingUtils = __esm({
  'node_modules/@azure/msal-node/dist/utils/EncodingUtils.mjs'() {
    'use strict';
    init_index_node();
    EncodingUtils = class _EncodingUtils {
      /**
       * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
       * 'base64': Base64 encoding.
       *
       * @param str text
       */
      static base64Encode(str2, encoding) {
        return Buffer.from(str2, encoding).toString(EncodingTypes.BASE64);
      }
      /**
       * encode a URL
       * @param str
       */
      static base64EncodeUrl(str2, encoding) {
        return _EncodingUtils
          .base64Encode(str2, encoding)
          .replace(/=/g, Constants.EMPTY_STRING)
          .replace(/\+/g, '-')
          .replace(/\//g, '_');
      }
      /**
       * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
       * 'base64': Base64 encoding.
       *
       * @param base64Str Base64 encoded text
       */
      static base64Decode(base64Str) {
        return Buffer.from(base64Str, EncodingTypes.BASE64).toString('utf8');
      }
      /**
       * @param base64Str Base64 encoded Url
       */
      static base64DecodeUrl(base64Str) {
        let str2 = base64Str.replace(/-/g, '+').replace(/_/g, '/');
        while (str2.length % 4) {
          str2 += '=';
        }
        return _EncodingUtils.base64Decode(str2);
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/crypto/HashUtils.mjs
import crypto8 from 'crypto';
var HashUtils;
var init_HashUtils = __esm({
  'node_modules/@azure/msal-node/dist/crypto/HashUtils.mjs'() {
    'use strict';
    init_Constants2();
    HashUtils = class {
      /**
       * generate 'SHA256' hash
       * @param buffer
       */
      sha256(buffer) {
        return crypto8.createHash(Hash.SHA256).update(buffer).digest();
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/crypto/PkceGenerator.mjs
import crypto9 from 'crypto';
var PkceGenerator;
var init_PkceGenerator = __esm({
  'node_modules/@azure/msal-node/dist/crypto/PkceGenerator.mjs'() {
    'use strict';
    init_index_node();
    init_Constants2();
    init_EncodingUtils();
    init_HashUtils();
    PkceGenerator = class {
      constructor() {
        this.hashUtils = new HashUtils();
      }
      /**
       * generates the codeVerfier and the challenge from the codeVerfier
       * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2
       */
      async generatePkceCodes() {
        const verifier = this.generateCodeVerifier();
        const challenge = this.generateCodeChallengeFromVerifier(verifier);
        return { verifier, challenge };
      }
      /**
       * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1
       */
      generateCodeVerifier() {
        const charArr = [];
        const maxNumber = 256 - (256 % CharSet.CV_CHARSET.length);
        while (charArr.length <= RANDOM_OCTET_SIZE) {
          const byte = crypto9.randomBytes(1)[0];
          if (byte >= maxNumber) {
            continue;
          }
          const index2 = byte % CharSet.CV_CHARSET.length;
          charArr.push(CharSet.CV_CHARSET[index2]);
        }
        const verifier = charArr.join(Constants.EMPTY_STRING);
        return EncodingUtils.base64EncodeUrl(verifier);
      }
      /**
       * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2
       * @param codeVerifier
       */
      generateCodeChallengeFromVerifier(codeVerifier) {
        return EncodingUtils.base64EncodeUrl(
          this.hashUtils.sha256(codeVerifier).toString(EncodingTypes.BASE64),
          EncodingTypes.BASE64
        );
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/crypto/CryptoProvider.mjs
var CryptoProvider;
var init_CryptoProvider = __esm({
  'node_modules/@azure/msal-node/dist/crypto/CryptoProvider.mjs'() {
    'use strict';
    init_index_node();
    init_GuidGenerator();
    init_EncodingUtils();
    init_PkceGenerator();
    init_HashUtils();
    CryptoProvider = class {
      constructor() {
        this.pkceGenerator = new PkceGenerator();
        this.guidGenerator = new GuidGenerator();
        this.hashUtils = new HashUtils();
      }
      /**
       * base64 URL safe encoded string
       */
      base64UrlEncode() {
        throw new Error('Method not implemented.');
      }
      /**
       * Stringifies and base64Url encodes input public key
       * @param inputKid - public key id
       * @returns Base64Url encoded public key
       */
      encodeKid() {
        throw new Error('Method not implemented.');
      }
      /**
       * Creates a new random GUID - used to populate state and nonce.
       * @returns string (GUID)
       */
      createNewGuid() {
        return this.guidGenerator.generateGuid();
      }
      /**
       * Encodes input string to base64.
       * @param input - string to be encoded
       */
      base64Encode(input) {
        return EncodingUtils.base64Encode(input);
      }
      /**
       * Decodes input string from base64.
       * @param input - string to be decoded
       */
      base64Decode(input) {
        return EncodingUtils.base64Decode(input);
      }
      /**
       * Generates PKCE codes used in Authorization Code Flow.
       */
      generatePkceCodes() {
        return this.pkceGenerator.generatePkceCodes();
      }
      /**
       * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node
       */
      getPublicKeyThumbprint() {
        throw new Error('Method not implemented.');
      }
      /**
       * Removes cryptographic keypair from key store matching the keyId passed in
       * @param kid - public key id
       */
      removeTokenBindingKey() {
        throw new Error('Method not implemented.');
      }
      /**
       * Removes all cryptographic keys from Keystore
       */
      clearKeystore() {
        throw new Error('Method not implemented.');
      }
      /**
       * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node
       */
      signJwt() {
        throw new Error('Method not implemented.');
      }
      /**
       * Returns the SHA-256 hash of an input string
       */
      async hashString(plainText) {
        return EncodingUtils.base64EncodeUrl(
          this.hashUtils.sha256(plainText).toString(EncodingTypes.BASE64),
          EncodingTypes.BASE64
        );
      }
    };
  },
});

// node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/index.mjs
var init_dist = __esm({
  'node_modules/@azure/msal-node/node_modules/@azure/msal-common/dist/index.mjs'() {
    'use strict';
    init_Constants();
    init_StubPerformanceClient();
  },
});

// node_modules/@azure/msal-node/dist/cache/CacheHelpers.mjs
function generateCredentialKey(credential) {
  const familyId =
    (credential.credentialType === CredentialType.REFRESH_TOKEN && credential.familyId) ||
    credential.clientId;
  const scheme =
    credential.tokenType &&
    credential.tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()
      ? credential.tokenType.toLowerCase()
      : '';
  const credentialKey = [
    credential.homeAccountId,
    credential.environment,
    credential.credentialType,
    familyId,
    credential.realm || '',
    credential.target || '',
    credential.requestedClaimsHash || '',
    scheme,
  ];
  return credentialKey.join(CACHE.KEY_SEPARATOR).toLowerCase();
}
function generateAccountKey(account) {
  const homeTenantId = account.homeAccountId.split('.')[1];
  const accountKey = [
    account.homeAccountId,
    account.environment,
    homeTenantId || account.tenantId || '',
  ];
  return accountKey.join(CACHE.KEY_SEPARATOR).toLowerCase();
}
var init_CacheHelpers2 = __esm({
  'node_modules/@azure/msal-node/dist/cache/CacheHelpers.mjs'() {
    'use strict';
    init_index_node();
    init_Constants2();
  },
});

// node_modules/@azure/msal-node/dist/cache/NodeStorage.mjs
var NodeStorage;
var init_NodeStorage = __esm({
  'node_modules/@azure/msal-node/dist/cache/NodeStorage.mjs'() {
    'use strict';
    init_index_node();
    init_Deserializer();
    init_Serializer();
    init_dist();
    init_CacheHelpers2();
    NodeStorage = class extends CacheManager {
      constructor(logger4, clientId, cryptoImpl, staticAuthorityOptions) {
        super(clientId, cryptoImpl, logger4, new StubPerformanceClient(), staticAuthorityOptions);
        this.cache = {};
        this.changeEmitters = [];
        this.logger = logger4;
      }
      /**
       * Queue up callbacks
       * @param func - a callback function for cache change indication
       */
      registerChangeEmitter(func) {
        this.changeEmitters.push(func);
      }
      /**
       * Invoke the callback when cache changes
       */
      emitChange() {
        this.changeEmitters.forEach((func) => func.call(null));
      }
      /**
       * Converts cacheKVStore to InMemoryCache
       * @param cache - key value store
       */
      cacheToInMemoryCache(cache2) {
        const inMemoryCache = {
          accounts: {},
          idTokens: {},
          accessTokens: {},
          refreshTokens: {},
          appMetadata: {},
        };
        for (const key2 in cache2) {
          const value = cache2[key2];
          if (typeof value !== 'object') {
            continue;
          }
          if (value instanceof AccountEntity) {
            inMemoryCache.accounts[key2] = value;
          } else if (CacheHelpers_exports.isIdTokenEntity(value)) {
            inMemoryCache.idTokens[key2] = value;
          } else if (CacheHelpers_exports.isAccessTokenEntity(value)) {
            inMemoryCache.accessTokens[key2] = value;
          } else if (CacheHelpers_exports.isRefreshTokenEntity(value)) {
            inMemoryCache.refreshTokens[key2] = value;
          } else if (CacheHelpers_exports.isAppMetadataEntity(key2, value)) {
            inMemoryCache.appMetadata[key2] = value;
          } else {
            continue;
          }
        }
        return inMemoryCache;
      }
      /**
       * converts inMemoryCache to CacheKVStore
       * @param inMemoryCache - kvstore map for inmemory
       */
      inMemoryCacheToCache(inMemoryCache) {
        let cache2 = this.getCache();
        cache2 = {
          ...cache2,
          ...inMemoryCache.accounts,
          ...inMemoryCache.idTokens,
          ...inMemoryCache.accessTokens,
          ...inMemoryCache.refreshTokens,
          ...inMemoryCache.appMetadata,
        };
        return cache2;
      }
      /**
       * gets the current in memory cache for the client
       */
      getInMemoryCache() {
        this.logger.trace('Getting in-memory cache');
        const inMemoryCache = this.cacheToInMemoryCache(this.getCache());
        return inMemoryCache;
      }
      /**
       * sets the current in memory cache for the client
       * @param inMemoryCache - key value map in memory
       */
      setInMemoryCache(inMemoryCache) {
        this.logger.trace('Setting in-memory cache');
        const cache2 = this.inMemoryCacheToCache(inMemoryCache);
        this.setCache(cache2);
        this.emitChange();
      }
      /**
       * get the current cache key-value store
       */
      getCache() {
        this.logger.trace('Getting cache key-value store');
        return this.cache;
      }
      /**
       * sets the current cache (key value store)
       * @param cacheMap - key value map
       */
      setCache(cache2) {
        this.logger.trace('Setting cache key value store');
        this.cache = cache2;
        this.emitChange();
      }
      /**
       * Gets cache item with given key.
       * @param key - lookup key for the cache entry
       */
      getItem(key2) {
        this.logger.tracePii(`Item key: ${key2}`);
        const cache2 = this.getCache();
        return cache2[key2];
      }
      /**
       * Gets cache item with given key-value
       * @param key - lookup key for the cache entry
       * @param value - value of the cache entry
       */
      setItem(key2, value) {
        this.logger.tracePii(`Item key: ${key2}`);
        const cache2 = this.getCache();
        cache2[key2] = value;
        this.setCache(cache2);
      }
      generateCredentialKey(credential) {
        return generateCredentialKey(credential);
      }
      generateAccountKey(account) {
        return generateAccountKey(account);
      }
      getAccountKeys() {
        const inMemoryCache = this.getInMemoryCache();
        const accountKeys = Object.keys(inMemoryCache.accounts);
        return accountKeys;
      }
      getTokenKeys() {
        const inMemoryCache = this.getInMemoryCache();
        const tokenKeys = {
          idToken: Object.keys(inMemoryCache.idTokens),
          accessToken: Object.keys(inMemoryCache.accessTokens),
          refreshToken: Object.keys(inMemoryCache.refreshTokens),
        };
        return tokenKeys;
      }
      /**
       * Reads account from cache, builds it into an account entity and returns it.
       * @param accountKey - lookup key to fetch cache type AccountEntity
       * @returns
       */
      getAccount(accountKey) {
        const cachedAccount = this.getItem(accountKey);
        return cachedAccount ? Object.assign(new AccountEntity(), this.getItem(accountKey)) : null;
      }
      /**
       * set account entity
       * @param account - cache value to be set of type AccountEntity
       */
      async setAccount(account) {
        const accountKey = this.generateAccountKey(account.getAccountInfo());
        this.setItem(accountKey, account);
      }
      /**
       * fetch the idToken credential
       * @param idTokenKey - lookup key to fetch cache type IdTokenEntity
       */
      getIdTokenCredential(idTokenKey) {
        const idToken = this.getItem(idTokenKey);
        if (CacheHelpers_exports.isIdTokenEntity(idToken)) {
          return idToken;
        }
        return null;
      }
      /**
       * set idToken credential
       * @param idToken - cache value to be set of type IdTokenEntity
       */
      async setIdTokenCredential(idToken) {
        const idTokenKey = this.generateCredentialKey(idToken);
        this.setItem(idTokenKey, idToken);
      }
      /**
       * fetch the accessToken credential
       * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity
       */
      getAccessTokenCredential(accessTokenKey) {
        const accessToken = this.getItem(accessTokenKey);
        if (CacheHelpers_exports.isAccessTokenEntity(accessToken)) {
          return accessToken;
        }
        return null;
      }
      /**
       * set accessToken credential
       * @param accessToken -  cache value to be set of type AccessTokenEntity
       */
      async setAccessTokenCredential(accessToken) {
        const accessTokenKey = this.generateCredentialKey(accessToken);
        this.setItem(accessTokenKey, accessToken);
      }
      /**
       * fetch the refreshToken credential
       * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity
       */
      getRefreshTokenCredential(refreshTokenKey) {
        const refreshToken = this.getItem(refreshTokenKey);
        if (CacheHelpers_exports.isRefreshTokenEntity(refreshToken)) {
          return refreshToken;
        }
        return null;
      }
      /**
       * set refreshToken credential
       * @param refreshToken - cache value to be set of type RefreshTokenEntity
       */
      async setRefreshTokenCredential(refreshToken) {
        const refreshTokenKey = this.generateCredentialKey(refreshToken);
        this.setItem(refreshTokenKey, refreshToken);
      }
      /**
       * fetch appMetadata entity from the platform cache
       * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity
       */
      getAppMetadata(appMetadataKey) {
        const appMetadata = this.getItem(appMetadataKey);
        if (CacheHelpers_exports.isAppMetadataEntity(appMetadataKey, appMetadata)) {
          return appMetadata;
        }
        return null;
      }
      /**
       * set appMetadata entity to the platform cache
       * @param appMetadata - cache value to be set of type AppMetadataEntity
       */
      setAppMetadata(appMetadata) {
        const appMetadataKey = CacheHelpers_exports.generateAppMetadataKey(appMetadata);
        this.setItem(appMetadataKey, appMetadata);
      }
      /**
       * fetch server telemetry entity from the platform cache
       * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity
       */
      getServerTelemetry(serverTelemetrykey) {
        const serverTelemetryEntity = this.getItem(serverTelemetrykey);
        if (
          serverTelemetryEntity &&
          CacheHelpers_exports.isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)
        ) {
          return serverTelemetryEntity;
        }
        return null;
      }
      /**
       * set server telemetry entity to the platform cache
       * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity
       * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity
       */
      setServerTelemetry(serverTelemetryKey, serverTelemetry) {
        this.setItem(serverTelemetryKey, serverTelemetry);
      }
      /**
       * fetch authority metadata entity from the platform cache
       * @param key - lookup key to fetch cache type AuthorityMetadataEntity
       */
      getAuthorityMetadata(key2) {
        const authorityMetadataEntity = this.getItem(key2);
        if (
          authorityMetadataEntity &&
          CacheHelpers_exports.isAuthorityMetadataEntity(key2, authorityMetadataEntity)
        ) {
          return authorityMetadataEntity;
        }
        return null;
      }
      /**
       * Get all authority metadata keys
       */
      getAuthorityMetadataKeys() {
        return this.getKeys().filter((key2) => {
          return this.isAuthorityMetadata(key2);
        });
      }
      /**
       * set authority metadata entity to the platform cache
       * @param key - lookup key to fetch cache type AuthorityMetadataEntity
       * @param metadata - cache value to be set of type AuthorityMetadataEntity
       */
      setAuthorityMetadata(key2, metadata) {
        this.setItem(key2, metadata);
      }
      /**
       * fetch throttling entity from the platform cache
       * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
       */
      getThrottlingCache(throttlingCacheKey) {
        const throttlingCache = this.getItem(throttlingCacheKey);
        if (
          throttlingCache &&
          CacheHelpers_exports.isThrottlingEntity(throttlingCacheKey, throttlingCache)
        ) {
          return throttlingCache;
        }
        return null;
      }
      /**
       * set throttling entity to the platform cache
       * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
       * @param throttlingCache - cache value to be set of type ThrottlingEntity
       */
      setThrottlingCache(throttlingCacheKey, throttlingCache) {
        this.setItem(throttlingCacheKey, throttlingCache);
      }
      /**
       * Removes the cache item from memory with the given key.
       * @param key - lookup key to remove a cache entity
       * @param inMemory - key value map of the cache
       */
      removeItem(key2) {
        this.logger.tracePii(`Item key: ${key2}`);
        let result = false;
        const cache2 = this.getCache();
        if (!!cache2[key2]) {
          delete cache2[key2];
          result = true;
        }
        if (result) {
          this.setCache(cache2);
          this.emitChange();
        }
        return result;
      }
      /**
       * Remove account entity from the platform cache if it's outdated
       * @param accountKey - lookup key to fetch cache type AccountEntity
       */
      removeOutdatedAccount(accountKey) {
        this.removeItem(accountKey);
      }
      /**
       * Checks whether key is in cache.
       * @param key - look up key for a cache entity
       */
      containsKey(key2) {
        return this.getKeys().includes(key2);
      }
      /**
       * Gets all keys in window.
       */
      getKeys() {
        this.logger.trace('Retrieving all cache keys');
        const cache2 = this.getCache();
        return [...Object.keys(cache2)];
      }
      /**
       * Clears all cache entries created by MSAL (except tokens).
       */
      clear() {
        this.logger.trace('Clearing cache entries created by MSAL');
        const cacheKeys = this.getKeys();
        cacheKeys.forEach((key2) => {
          this.removeItem(key2);
        });
        this.emitChange();
      }
      /**
       * Initialize in memory cache from an exisiting cache vault
       * @param cache - blob formatted cache (JSON)
       */
      static generateInMemoryCache(cache2) {
        return Deserializer.deserializeAllCache(Deserializer.deserializeJSONBlob(cache2));
      }
      /**
       * retrieves the final JSON
       * @param inMemoryCache - itemised cache read from the JSON
       */
      static generateJsonCache(inMemoryCache) {
        return Serializer.serializeAllCache(inMemoryCache);
      }
      /**
       * Updates a credential's cache key if the current cache key is outdated
       */
      updateCredentialCacheKey(currentCacheKey, credential) {
        const updatedCacheKey = this.generateCredentialKey(credential);
        if (currentCacheKey !== updatedCacheKey) {
          const cacheItem = this.getItem(currentCacheKey);
          if (cacheItem) {
            this.removeItem(currentCacheKey);
            this.setItem(updatedCacheKey, cacheItem);
            this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);
            return updatedCacheKey;
          } else {
            this.logger.error(
              `Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`
            );
          }
        }
        return currentCacheKey;
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/cache/TokenCache.mjs
var defaultSerializedCache, TokenCache;
var init_TokenCache = __esm({
  'node_modules/@azure/msal-node/dist/cache/TokenCache.mjs'() {
    'use strict';
    init_NodeStorage();
    init_index_node();
    init_Deserializer();
    init_Serializer();
    init_CryptoProvider();
    init_GuidGenerator();
    defaultSerializedCache = {
      Account: {},
      IdToken: {},
      AccessToken: {},
      RefreshToken: {},
      AppMetadata: {},
    };
    TokenCache = class {
      constructor(storage, logger4, cachePlugin) {
        this.cacheHasChanged = false;
        this.storage = storage;
        this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));
        if (cachePlugin) {
          this.persistence = cachePlugin;
        }
        this.logger = logger4;
      }
      /**
       * Set to true if cache state has changed since last time serialize or writeToPersistence was called
       */
      hasChanged() {
        return this.cacheHasChanged;
      }
      /**
       * Serializes in memory cache to JSON
       */
      serialize() {
        this.logger.trace('Serializing in-memory cache');
        let finalState = Serializer.serializeAllCache(this.storage.getInMemoryCache());
        if (this.cacheSnapshot) {
          this.logger.trace('Reading cache snapshot from disk');
          finalState = this.mergeState(JSON.parse(this.cacheSnapshot), finalState);
        } else {
          this.logger.trace('No cache snapshot to merge');
        }
        this.cacheHasChanged = false;
        return JSON.stringify(finalState);
      }
      /**
       * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format
       * @param cache - blob formatted cache
       */
      deserialize(cache2) {
        this.logger.trace('Deserializing JSON to in-memory cache');
        this.cacheSnapshot = cache2;
        if (this.cacheSnapshot) {
          this.logger.trace('Reading cache snapshot from disk');
          const deserializedCache = Deserializer.deserializeAllCache(
            this.overlayDefaults(JSON.parse(this.cacheSnapshot))
          );
          this.storage.setInMemoryCache(deserializedCache);
        } else {
          this.logger.trace('No cache snapshot to deserialize');
        }
      }
      /**
       * Fetches the cache key-value map
       */
      getKVStore() {
        return this.storage.getCache();
      }
      /**
       * Gets cache snapshot in CacheKVStore format
       */
      getCacheSnapshot() {
        const deserializedPersistentStorage = NodeStorage.generateInMemoryCache(this.cacheSnapshot);
        return this.storage.inMemoryCacheToCache(deserializedPersistentStorage);
      }
      /**
       * API that retrieves all accounts currently in cache to the user
       */
      async getAllAccounts(correlationId = new CryptoProvider().createNewGuid()) {
        this.logger.trace('getAllAccounts called');
        let cacheContext;
        try {
          if (this.persistence) {
            cacheContext = new TokenCacheContext(this, false);
            await this.persistence.beforeCacheAccess(cacheContext);
          }
          return this.storage.getAllAccounts({}, correlationId);
        } finally {
          if (this.persistence && cacheContext) {
            await this.persistence.afterCacheAccess(cacheContext);
          }
        }
      }
      /**
       * Returns the signed in account matching homeAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param homeAccountId - unique identifier for an account (uid.utid)
       */
      async getAccountByHomeId(homeAccountId) {
        const allAccounts = await this.getAllAccounts();
        if (homeAccountId && allAccounts && allAccounts.length) {
          return (
            allAccounts.filter((accountObj) => accountObj.homeAccountId === homeAccountId)[0] ||
            null
          );
        } else {
          return null;
        }
      }
      /**
       * Returns the signed in account matching localAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)
       */
      async getAccountByLocalId(localAccountId) {
        const allAccounts = await this.getAllAccounts();
        if (localAccountId && allAccounts && allAccounts.length) {
          return (
            allAccounts.filter((accountObj) => accountObj.localAccountId === localAccountId)[0] ||
            null
          );
        } else {
          return null;
        }
      }
      /**
       * API to remove a specific account and the relevant data from cache
       * @param account - AccountInfo passed by the user
       */
      async removeAccount(account, correlationId) {
        this.logger.trace('removeAccount called');
        let cacheContext;
        try {
          if (this.persistence) {
            cacheContext = new TokenCacheContext(this, true);
            await this.persistence.beforeCacheAccess(cacheContext);
          }
          this.storage.removeAccount(account, correlationId || new GuidGenerator().generateGuid());
        } finally {
          if (this.persistence && cacheContext) {
            await this.persistence.afterCacheAccess(cacheContext);
          }
        }
      }
      /**
       * Overwrites in-memory cache with persistent cache
       */
      async overwriteCache() {
        if (!this.persistence) {
          this.logger.info('No persistence layer specified, cache cannot be overwritten');
          return;
        }
        this.logger.info('Overwriting in-memory cache with persistent cache');
        this.storage.clear();
        const cacheContext = new TokenCacheContext(this, false);
        await this.persistence.beforeCacheAccess(cacheContext);
        const cacheSnapshot = this.getCacheSnapshot();
        this.storage.setCache(cacheSnapshot);
        await this.persistence.afterCacheAccess(cacheContext);
      }
      /**
       * Called when the cache has changed state.
       */
      handleChangeEvent() {
        this.cacheHasChanged = true;
      }
      /**
       * Merge in memory cache with the cache snapshot.
       * @param oldState - cache before changes
       * @param currentState - current cache state in the library
       */
      mergeState(oldState, currentState) {
        this.logger.trace('Merging in-memory cache with cache snapshot');
        const stateAfterRemoval = this.mergeRemovals(oldState, currentState);
        return this.mergeUpdates(stateAfterRemoval, currentState);
      }
      /**
       * Deep update of oldState based on newState values
       * @param oldState - cache before changes
       * @param newState - updated cache
       */
      mergeUpdates(oldState, newState) {
        Object.keys(newState).forEach((newKey) => {
          const newValue = newState[newKey];
          if (!oldState.hasOwnProperty(newKey)) {
            if (newValue !== null) {
              oldState[newKey] = newValue;
            }
          } else {
            const newValueNotNull = newValue !== null;
            const newValueIsObject = typeof newValue === 'object';
            const newValueIsNotArray = !Array.isArray(newValue);
            const oldStateNotUndefinedOrNull =
              typeof oldState[newKey] !== 'undefined' && oldState[newKey] !== null;
            if (
              newValueNotNull &&
              newValueIsObject &&
              newValueIsNotArray &&
              oldStateNotUndefinedOrNull
            ) {
              this.mergeUpdates(oldState[newKey], newValue);
            } else {
              oldState[newKey] = newValue;
            }
          }
        });
        return oldState;
      }
      /**
       * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of
       * oldState that are not recognized, they are left untouched.
       * @param oldState - cache before changes
       * @param newState - updated cache
       */
      mergeRemovals(oldState, newState) {
        this.logger.trace('Remove updated entries in cache');
        const accounts = oldState.Account
          ? this.mergeRemovalsDict(oldState.Account, newState.Account)
          : oldState.Account;
        const accessTokens = oldState.AccessToken
          ? this.mergeRemovalsDict(oldState.AccessToken, newState.AccessToken)
          : oldState.AccessToken;
        const refreshTokens = oldState.RefreshToken
          ? this.mergeRemovalsDict(oldState.RefreshToken, newState.RefreshToken)
          : oldState.RefreshToken;
        const idTokens = oldState.IdToken
          ? this.mergeRemovalsDict(oldState.IdToken, newState.IdToken)
          : oldState.IdToken;
        const appMetadata = oldState.AppMetadata
          ? this.mergeRemovalsDict(oldState.AppMetadata, newState.AppMetadata)
          : oldState.AppMetadata;
        return {
          ...oldState,
          Account: accounts,
          AccessToken: accessTokens,
          RefreshToken: refreshTokens,
          IdToken: idTokens,
          AppMetadata: appMetadata,
        };
      }
      /**
       * Helper to merge new cache with the old one
       * @param oldState - cache before changes
       * @param newState - updated cache
       */
      mergeRemovalsDict(oldState, newState) {
        const finalState = { ...oldState };
        Object.keys(oldState).forEach((oldKey) => {
          if (!newState || !newState.hasOwnProperty(oldKey)) {
            delete finalState[oldKey];
          }
        });
        return finalState;
      }
      /**
       * Helper to overlay as a part of cache merge
       * @param passedInCache - cache read from the blob
       */
      overlayDefaults(passedInCache) {
        this.logger.trace('Overlaying input cache with the default cache');
        return {
          Account: {
            ...defaultSerializedCache.Account,
            ...passedInCache.Account,
          },
          IdToken: {
            ...defaultSerializedCache.IdToken,
            ...passedInCache.IdToken,
          },
          AccessToken: {
            ...defaultSerializedCache.AccessToken,
            ...passedInCache.AccessToken,
          },
          RefreshToken: {
            ...defaultSerializedCache.RefreshToken,
            ...passedInCache.RefreshToken,
          },
          AppMetadata: {
            ...defaultSerializedCache.AppMetadata,
            ...passedInCache.AppMetadata,
          },
        };
      }
    };
  },
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  'node_modules/safe-buffer/index.js'(exports, module) {
    var buffer = __require('buffer');
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key2 in src) {
        dst[key2] = src[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function (arg, encodingOrOffset, length) {
      if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function (size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === 'string') {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }
      return buffer.SlowBuffer(size);
    };
  },
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  'node_modules/jws/lib/data-stream.js'(exports, module) {
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream2 = __require('stream');
    var util3 = __require('util');
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === 'function') {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === 'object') {
        this.buffer = data;
        this.writable = false;
        process.nextTick(
          function () {
            this.emit('end', data);
            this.readable = false;
            this.emit('close');
          }.bind(this)
        );
        return this;
      }
      throw new TypeError('Unexpected data type (' + typeof data + ')');
    }
    util3.inherits(DataStream, Stream2);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit('data', data);
    };
    DataStream.prototype.end = function end(data) {
      if (data) this.write(data);
      this.emit('end', data);
      this.emit('close');
      this.writable = false;
      this.readable = false;
    };
    module.exports = DataStream;
  },
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  'node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js'(exports, module) {
    'use strict';
    function getParamSize(keySize) {
      var result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521),
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module.exports = getParamBytesForAlg;
  },
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  'node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js'(exports, module) {
    'use strict';
    var Buffer2 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | (CLASS_UNIVERSAL << 6);
    var ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);
    function base64Url(base64) {
      return base64.replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
    }
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if ('string' === typeof signature) {
        return Buffer2.from(signature, 'base64');
      }
      throw new TypeError('ECDSA signature must be a Base64 string or a Buffer');
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error(
          '"seq" specified length of "' +
            seqLength +
            '", only "' +
            (inputLength - offset) +
            '" remaining'
        );
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error(
          '"r" specified length of "' +
            rLength +
            '", only "' +
            (inputLength - offset - 2) +
            '" available'
        );
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error(
          '"r" specified length of "' +
            rLength +
            '", max of "' +
            maxEncodedParamLength +
            '" is acceptable'
        );
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error(
          '"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"'
        );
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error(
          '"s" specified length of "' +
            sLength +
            '", max of "' +
            maxEncodedParamLength +
            '" is acceptable'
        );
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error(
          'Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain'
        );
      }
      var rPadding = paramBytes - rLength,
        sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString('base64');
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop2) {
      var padding = 0;
      while (start + padding < stop2 && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError(
          '"' +
            alg +
            '" signatures must be "' +
            paramBytes * 2 +
            '" bytes, saw "' +
            signatureBytes +
            '"'
        );
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module.exports = {
      derToJose,
      joseToDer,
    };
  },
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  'node_modules/buffer-equal-constant-time/index.js'(exports, module) {
    'use strict';
    var Buffer2 = __require('buffer').Buffer;
    var SlowBuffer = __require('buffer').SlowBuffer;
    module.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    bufferEq.install = function () {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function () {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  },
});

// node_modules/jwa/index.js
var require_jwa = __commonJS({
  'node_modules/jwa/index.js'(exports, module) {
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto10 = __require('crypto');
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util3 = __require('util');
    var MSG_INVALID_ALGORITHM =
      '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = 'secret must be a string or buffer';
    var MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';
    var MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';
    var supportsKeyObjects = typeof crypto10.createPublicKey === 'function';
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += ' or a KeyObject';
      MSG_INVALID_SECRET += 'or a KeyObject';
    }
    function checkIsPublicKey(key2) {
      if (Buffer2.isBuffer(key2)) {
        return;
      }
      if (typeof key2 === 'string') {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key2 !== 'object') {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key2.type !== 'string') {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key2.asymmetricKeyType !== 'string') {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key2.export !== 'function') {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key2) {
      if (Buffer2.isBuffer(key2)) {
        return;
      }
      if (typeof key2 === 'string') {
        return;
      }
      if (typeof key2 === 'object') {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key2) {
      if (Buffer2.isBuffer(key2)) {
        return;
      }
      if (typeof key2 === 'string') {
        return key2;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key2 !== 'object') {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key2.type !== 'secret') {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key2.export !== 'function') {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - (base64url.length % 4);
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += '=';
        }
      }
      return base64url.replace(/\-/g, '+').replace(/_/g, '/');
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util3.format.bind(util3, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === 'string';
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing)) thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto10.createHmac('sha' + bits, secret);
        var sig = (hmac.update(thing), hmac.digest('base64'));
        return fromBase64(sig);
      };
    }
    var bufferEqual;
    var timingSafeEqual =
      'timingSafeEqual' in crypto10
        ? function timingSafeEqual2(a, b) {
            if (a.byteLength !== b.byteLength) {
              return false;
            }
            return crypto10.timingSafeEqual(a, b);
          }
        : function timingSafeEqual2(a, b) {
            if (!bufferEqual) {
              bufferEqual = require_buffer_equal_constant_time();
            }
            return bufferEqual(a, b);
          };
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return timingSafeEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto10.createSign('RSA-SHA' + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto10.createVerify('RSA-SHA' + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, 'base64');
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto10.createSign('RSA-SHA' + bits);
        var sig =
          (signer.update(thing),
          signer.sign(
            {
              key: privateKey,
              padding: crypto10.constants.RSA_PKCS1_PSS_PADDING,
              saltLength: crypto10.constants.RSA_PSS_SALTLEN_DIGEST,
            },
            'base64'
          ));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto10.createVerify('RSA-SHA' + bits);
        verifier.update(thing);
        return verifier.verify(
          {
            key: publicKey,
            padding: crypto10.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: crypto10.constants.RSA_PSS_SALTLEN_DIGEST,
          },
          signature,
          'base64'
        );
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, 'ES' + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return '';
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === '';
      };
    }
    module.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner,
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier,
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match) throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits),
      };
    };
  },
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  'node_modules/jws/lib/tostring.js'(exports, module) {
    var Buffer2 = __require('buffer').Buffer;
    module.exports = function toString3(obj) {
      if (typeof obj === 'string') return obj;
      if (typeof obj === 'number' || Buffer2.isBuffer(obj)) return obj.toString();
      return JSON.stringify(obj);
    };
  },
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  'node_modules/jws/lib/sign-stream.js'(exports, module) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream2 = __require('stream');
    var toString3 = require_tostring();
    var util3 = __require('util');
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding)
        .toString('base64')
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || 'utf8';
      var encodedHeader = base64url(toString3(header), 'binary');
      var encodedPayload = base64url(toString3(payload), encoding);
      return util3.format('%s.%s', encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util3.format('%s.%s', securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once(
        'close',
        function () {
          if (!this.payload.writable && this.readable) this.sign();
        }.bind(this)
      );
      this.payload.once(
        'close',
        function () {
          if (!this.secret.writable && this.readable) this.sign();
        }.bind(this)
      );
    }
    util3.inherits(SignStream, Stream2);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding,
        });
        this.emit('done', signature);
        this.emit('data', signature);
        this.emit('end');
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit('error', e);
        this.emit('close');
      }
    };
    SignStream.sign = jwsSign;
    module.exports = SignStream;
  },
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  'node_modules/jws/lib/verify-stream.js'(exports, module) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream2 = __require('stream');
    var toString3 = require_tostring();
    var util3 = __require('util');
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject2(thing) {
      return Object.prototype.toString.call(thing) === '[object Object]';
    }
    function safeJsonParse(thing) {
      if (isObject2(thing)) return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split('.', 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, 'base64').toString('binary'));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split('.', 2).join('.');
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split('.')[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || 'utf8';
      var payload = jwsSig.split('.')[1];
      return Buffer2.from(payload, 'base64').toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error('Missing algorithm parameter for jws.verify');
        err.code = 'MISSING_ALGORITHM';
        throw err;
      }
      jwsSig = toString3(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString3(jwsSig);
      if (!isValidJws(jwsSig)) return null;
      var header = headerFromJWS(jwsSig);
      if (!header) return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === 'JWT' || opts.json) payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig),
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once(
        'close',
        function () {
          if (!this.signature.writable && this.readable) this.verify();
        }.bind(this)
      );
      this.signature.once(
        'close',
        function () {
          if (!this.secret.writable && this.readable) this.verify();
        }.bind(this)
      );
    }
    util3.inherits(VerifyStream, Stream2);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit('done', valid, obj);
        this.emit('data', valid);
        this.emit('end');
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit('error', e);
        this.emit('close');
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module.exports = VerifyStream;
  },
});

// node_modules/jws/index.js
var require_jws = __commonJS({
  'node_modules/jws/index.js'(exports) {
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      'HS256',
      'HS384',
      'HS512',
      'RS256',
      'RS384',
      'RS512',
      'PS256',
      'PS384',
      'PS512',
      'ES256',
      'ES384',
      'ES512',
    ];
    exports.ALGORITHMS = ALGORITHMS;
    exports.sign = SignStream.sign;
    exports.verify = VerifyStream.verify;
    exports.decode = VerifyStream.decode;
    exports.isValid = VerifyStream.isValid;
    exports.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  },
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  'node_modules/jsonwebtoken/decode.js'(exports, module) {
    var jws = require_jws();
    module.exports = function (jwt2, options) {
      options = options || {};
      var decoded = jws.decode(jwt2, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === 'string') {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === 'object') {
            payload = obj;
          }
        } catch (e) {}
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature,
        };
      }
      return payload;
    };
  },
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  'node_modules/jsonwebtoken/lib/JsonWebTokenError.js'(exports, module) {
    var JsonWebTokenError = function (message, error) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = 'JsonWebTokenError';
      this.message = message;
      if (error) this.inner = error;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module.exports = JsonWebTokenError;
  },
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  'node_modules/jsonwebtoken/lib/NotBeforeError.js'(exports, module) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function (message, date) {
      JsonWebTokenError.call(this, message);
      this.name = 'NotBeforeError';
      this.date = date;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module.exports = NotBeforeError;
  },
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  'node_modules/jsonwebtoken/lib/TokenExpiredError.js'(exports, module) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function (message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = 'TokenExpiredError';
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module.exports = TokenExpiredError;
  },
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  'node_modules/jsonwebtoken/lib/timespan.js'(exports, module) {
    var ms = require_ms();
    module.exports = function (time, iat) {
      var timestamp = iat || Math.floor(Date.now() / 1e3);
      if (typeof time === 'string') {
        var milliseconds = ms(time);
        if (typeof milliseconds === 'undefined') {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time === 'number') {
        return timestamp + time;
      } else {
        return;
      }
    };
  },
});

// node_modules/semver/internal/constants.js
var require_constants2 = __commonJS({
  'node_modules/semver/internal/constants.js'(exports, module) {
    'use strict';
    var SEMVER_SPEC_VERSION = '2.0.0';
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER /* istanbul ignore next */ || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      'major',
      'premajor',
      'minor',
      'preminor',
      'patch',
      'prepatch',
      'prerelease',
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2,
    };
  },
});

// node_modules/semver/internal/debug.js
var require_debug2 = __commonJS({
  'node_modules/semver/internal/debug.js'(exports, module) {
    'use strict';
    var debug =
      typeof process === 'object' &&
      process.env &&
      process.env.NODE_DEBUG &&
      /\bsemver\b/i.test(process.env.NODE_DEBUG)
        ? (...args) => console.error('SEMVER', ...args)
        : () => {};
    module.exports = debug;
  },
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  'node_modules/semver/internal/re.js'(exports, module) {
    'use strict';
    var { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } = require_constants2();
    var debug = require_debug2();
    exports = module.exports = {};
    var re = (exports.re = []);
    var safeRe = (exports.safeRe = []);
    var src = (exports.src = []);
    var safeSrc = (exports.safeSrc = []);
    var t = (exports.t = {});
    var R = 0;
    var LETTERDASHNUMBER = '[a-zA-Z0-9-]';
    var safeRegexReplacements = [
      ['\\s', 1],
      ['\\d', MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value
          .split(`${token}*`)
          .join(`${token}{0,${max}}`)
          .split(`${token}+`)
          .join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name3, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index2 = R++;
      debug(name3, index2, value);
      t[name3] = index2;
      src[index2] = value;
      safeSrc[index2] = safe;
      re[index2] = new RegExp(value, isGlobal ? 'g' : void 0);
      safeRe[index2] = new RegExp(safe, isGlobal ? 'g' : void 0);
    };
    createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
    createToken('NUMERICIDENTIFIERLOOSE', '\\d+');
    createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken(
      'MAINVERSION',
      `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`
    );
    createToken(
      'MAINVERSIONLOOSE',
      `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`
    );
    createToken(
      'PRERELEASEIDENTIFIER',
      `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`
    );
    createToken(
      'PRERELEASEIDENTIFIERLOOSE',
      `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`
    );
    createToken(
      'PRERELEASE',
      `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`
    );
    createToken(
      'PRERELEASELOOSE',
      `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`
    );
    createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);
    createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken('FULLPLAIN', `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken('FULL', `^${src[t.FULLPLAIN]}$`);
    createToken(
      'LOOSEPLAIN',
      `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`
    );
    createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);
    createToken('GTLT', '((?:<|>)?=?)');
    createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken(
      'XRANGEPLAIN',
      `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`
    );
    createToken(
      'XRANGEPLAINLOOSE',
      `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`
    );
    createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken(
      'COERCEPLAIN',
      `${'(^|[^\\d])(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`
    );
    createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken(
      'COERCEFULL',
      src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`
    );
    createToken('COERCERTL', src[t.COERCE], true);
    createToken('COERCERTLFULL', src[t.COERCEFULL], true);
    createToken('LONETILDE', '(?:~>?)');
    createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = '$1~';
    createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken('LONECARET', '(?:\\^)');
    createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = '$1^';
    createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken(
      'COMPARATORTRIM',
      `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`,
      true
    );
    exports.comparatorTrimReplace = '$1$2$3';
    createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken(
      'HYPHENRANGELOOSE',
      `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`
    );
    createToken('STAR', '(<|>)?=?\\s*\\*');
    createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
    createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
  },
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  'node_modules/semver/internal/parse-options.js'(exports, module) {
    'use strict';
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== 'object') {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  },
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  'node_modules/semver/internal/identifiers.js'(exports, module) {
    'use strict';
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers,
    };
  },
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  'node_modules/semver/classes/semver.js'(exports, module) {
    'use strict';
    var debug = require_debug2();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version4, options) {
        options = parseOptions(options);
        if (version4 instanceof _SemVer) {
          if (
            version4.loose === !!options.loose &&
            version4.includePrerelease === !!options.includePrerelease
          ) {
            return version4;
          } else {
            version4 = version4.version;
          }
        } else if (typeof version4 !== 'string') {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version4}".`);
        }
        if (version4.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug('SemVer', version4, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version4.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version4}`);
        }
        this.raw = version4;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError('Invalid major version');
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError('Invalid minor version');
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError('Invalid patch version');
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split('.').map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split('.') : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join('.')}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug('SemVer.compare', this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === 'string' && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return (
          compareIdentifiers(this.major, other.major) ||
          compareIdentifiers(this.minor, other.minor) ||
          compareIdentifiers(this.patch, other.patch)
        );
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug('prerelease compare', i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug('build compare', i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith('pre')) {
          if (!identifier && identifierBase === false) {
            throw new Error('invalid increment argument: identifier is empty');
          }
          if (identifier) {
            const match = `-${identifier}`.match(
              this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]
            );
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case 'premajor':
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc('pre', identifier, identifierBase);
            break;
          case 'preminor':
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc('pre', identifier, identifierBase);
            break;
          case 'prepatch':
            this.prerelease.length = 0;
            this.inc('patch', identifier, identifierBase);
            this.inc('pre', identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case 'prerelease':
            if (this.prerelease.length === 0) {
              this.inc('patch', identifier, identifierBase);
            }
            this.inc('pre', identifier, identifierBase);
            break;
          case 'release':
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case 'major':
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case 'minor':
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case 'patch':
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case 'pre': {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === 'number') {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join('.') && identifierBase === false) {
                  throw new Error('invalid increment argument: identifier already exists');
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join('.')}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  },
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  'node_modules/semver/functions/parse.js'(exports, module) {
    'use strict';
    var SemVer = require_semver();
    var parse2 = (version4, options, throwErrors = false) => {
      if (version4 instanceof SemVer) {
        return version4;
      }
      try {
        return new SemVer(version4, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse2;
  },
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  'node_modules/semver/functions/valid.js'(exports, module) {
    'use strict';
    var parse2 = require_parse();
    var valid = (version4, options) => {
      const v = parse2(version4, options);
      return v ? v.version : null;
    };
    module.exports = valid;
  },
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  'node_modules/semver/functions/clean.js'(exports, module) {
    'use strict';
    var parse2 = require_parse();
    var clean = (version4, options) => {
      const s = parse2(version4.trim().replace(/^[=v]+/, ''), options);
      return s ? s.version : null;
    };
    module.exports = clean;
  },
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  'node_modules/semver/functions/inc.js'(exports, module) {
    'use strict';
    var SemVer = require_semver();
    var inc = (version4, release, options, identifier, identifierBase) => {
      if (typeof options === 'string') {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(version4 instanceof SemVer ? version4.version : version4, options).inc(
          release,
          identifier,
          identifierBase
        ).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  },
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  'node_modules/semver/functions/diff.js'(exports, module) {
    'use strict';
    var parse2 = require_parse();
    var diff = (version1, version22) => {
      const v12 = parse2(version1, null, true);
      const v2 = parse2(version22, null, true);
      const comparison = v12.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v12 : v2;
      const lowVersion = v1Higher ? v2 : v12;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return 'major';
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return 'minor';
          }
          return 'patch';
        }
      }
      const prefix = highHasPre ? 'pre' : '';
      if (v12.major !== v2.major) {
        return prefix + 'major';
      }
      if (v12.minor !== v2.minor) {
        return prefix + 'minor';
      }
      if (v12.patch !== v2.patch) {
        return prefix + 'patch';
      }
      return 'prerelease';
    };
    module.exports = diff;
  },
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  'node_modules/semver/functions/major.js'(exports, module) {
    'use strict';
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module.exports = major;
  },
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  'node_modules/semver/functions/minor.js'(exports, module) {
    'use strict';
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module.exports = minor;
  },
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  'node_modules/semver/functions/patch.js'(exports, module) {
    'use strict';
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module.exports = patch;
  },
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  'node_modules/semver/functions/prerelease.js'(exports, module) {
    'use strict';
    var parse2 = require_parse();
    var prerelease = (version4, options) => {
      const parsed = parse2(version4, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  },
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  'node_modules/semver/functions/compare.js'(exports, module) {
    'use strict';
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module.exports = compare;
  },
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  'node_modules/semver/functions/rcompare.js'(exports, module) {
    'use strict';
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module.exports = rcompare;
  },
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  'node_modules/semver/functions/compare-loose.js'(exports, module) {
    'use strict';
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module.exports = compareLoose;
  },
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  'node_modules/semver/functions/compare-build.js'(exports, module) {
    'use strict';
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  },
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  'node_modules/semver/functions/sort.js'(exports, module) {
    'use strict';
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module.exports = sort;
  },
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  'node_modules/semver/functions/rsort.js'(exports, module) {
    'use strict';
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module.exports = rsort;
  },
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  'node_modules/semver/functions/gt.js'(exports, module) {
    'use strict';
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module.exports = gt;
  },
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  'node_modules/semver/functions/lt.js'(exports, module) {
    'use strict';
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module.exports = lt;
  },
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  'node_modules/semver/functions/eq.js'(exports, module) {
    'use strict';
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module.exports = eq;
  },
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  'node_modules/semver/functions/neq.js'(exports, module) {
    'use strict';
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module.exports = neq;
  },
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  'node_modules/semver/functions/gte.js'(exports, module) {
    'use strict';
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module.exports = gte;
  },
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  'node_modules/semver/functions/lte.js'(exports, module) {
    'use strict';
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module.exports = lte;
  },
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  'node_modules/semver/functions/cmp.js'(exports, module) {
    'use strict';
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case '===':
          if (typeof a === 'object') {
            a = a.version;
          }
          if (typeof b === 'object') {
            b = b.version;
          }
          return a === b;
        case '!==':
          if (typeof a === 'object') {
            a = a.version;
          }
          if (typeof b === 'object') {
            b = b.version;
          }
          return a !== b;
        case '':
        case '=':
        case '==':
          return eq(a, b, loose);
        case '!=':
          return neq(a, b, loose);
        case '>':
          return gt(a, b, loose);
        case '>=':
          return gte(a, b, loose);
        case '<':
          return lt(a, b, loose);
        case '<=':
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  },
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  'node_modules/semver/functions/coerce.js'(exports, module) {
    'use strict';
    var SemVer = require_semver();
    var parse2 = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version4, options) => {
      if (version4 instanceof SemVer) {
        return version4;
      }
      if (typeof version4 === 'number') {
        version4 = String(version4);
      }
      if (typeof version4 !== 'string') {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version4.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next2;
        while (
          (next2 = coerceRtlRegex.exec(version4)) &&
          (!match || match.index + match[0].length !== version4.length)
        ) {
          if (!match || next2.index + next2[0].length !== match.index + match[0].length) {
            match = next2;
          }
          coerceRtlRegex.lastIndex = next2.index + next2[1].length + next2[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || '0';
      const patch = match[4] || '0';
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';
      return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module.exports = coerce;
  },
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  'node_modules/semver/internal/lrucache.js'(exports, module) {
    'use strict';
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key2) {
        const value = this.map.get(key2);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key2);
          this.map.set(key2, value);
          return value;
        }
      }
      delete(key2) {
        return this.map.delete(key2);
      }
      set(key2, value) {
        const deleted = this.delete(key2);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key2, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  },
});

// node_modules/semver/classes/range.js
var require_range2 = __commonJS({
  'node_modules/semver/classes/range.js'(exports, module) {
    'use strict';
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (
            range.loose === !!options.loose &&
            range.includePrerelease === !!options.includePrerelease
          ) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');
        this.set = this.raw
          .split('||')
          .map((r) => this.parseRange(r.trim()))
          .filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = '';
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += '||';
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += ' ';
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts =
          (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
          (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ':' + range;
        const cached = cache2.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug('hyphen replace', range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug('comparator trim', range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug('tilde trim', range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug('caret trim', range);
        let rangeList = range
          .split(' ')
          .map((comp) => parseComparator(comp, this.options))
          .join(' ')
          .split(/\s+/)
          .map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug('loose invalid filter', comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug('range list', rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has('')) {
          rangeMap.delete('');
        }
        const result = [...rangeMap.values()];
        cache2.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError('a Range is required');
        }
        return this.set.some((thisComparators) => {
          return (
            isSatisfiable(thisComparators, options) &&
            range.set.some((rangeComparators) => {
              return (
                isSatisfiable(rangeComparators, options) &&
                thisComparators.every((thisComparator) => {
                  return rangeComparators.every((rangeComparator) => {
                    return thisComparator.intersects(rangeComparator, options);
                  });
                })
              );
            })
          );
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version4) {
        if (!version4) {
          return false;
        }
        if (typeof version4 === 'string') {
          try {
            version4 = new SemVer(version4, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version4, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache2 = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug2();
    var SemVer = require_semver();
    var { safeRe: re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants2();
    var isNullSet = (c) => c.value === '<0.0.0-0';
    var isAny = (c) => c.value === '';
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug('comp', comp, options);
      comp = replaceCarets(comp, options);
      debug('caret', comp);
      comp = replaceTildes(comp, options);
      debug('tildes', comp);
      comp = replaceXRanges(comp, options);
      debug('xrange', comp);
      comp = replaceStars(comp, options);
      debug('stars', comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === 'x' || id === '*';
    var replaceTildes = (comp, options) => {
      return comp
        .trim()
        .split(/\s+/)
        .map((c) => replaceTilde(c, options))
        .join(' ');
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug('tilde', comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug('replaceTilde pr', pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug('tilde return', ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp
        .trim()
        .split(/\s+/)
        .map((c) => replaceCaret(c, options))
        .join(' ');
    };
    var replaceCaret = (comp, options) => {
      debug('caret', comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? '-0' : '';
      return comp.replace(r, (_, M, m, p, pr) => {
        debug('caret', comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === '0') {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug('replaceCaret pr', pr);
          if (M === '0') {
            if (m === '0') {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug('no pr');
          if (M === '0') {
            if (m === '0') {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug('caret return', ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug('replaceXRanges', comp, options);
      return comp
        .split(/\s+/)
        .map((c) => replaceXRange(c, options))
        .join(' ');
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === '=' && anyX) {
          gtlt = '';
        }
        pr = options.includePrerelease ? '-0' : '';
        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            ret = '<0.0.0-0';
          } else {
            ret = '*';
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === '>') {
            gtlt = '>=';
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            gtlt = '<';
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === '<') {
            pr = '-0';
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug('xRange return', ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug('replaceStars', comp, options);
      return comp.trim().replace(re[t.STAR], '');
    };
    var replaceGTE0 = (comp, options) => {
      debug('replaceGTE0', comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = '';
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? '-0' : ''}`;
      }
      if (isX(tM)) {
        to = '';
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set2, version4, options) => {
      for (let i = 0; i < set2.length; i++) {
        if (!set2[i].test(version4)) {
          return false;
        }
      }
      if (version4.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set2.length; i++) {
          debug(set2[i].semver);
          if (set2[i].semver === Comparator.ANY) {
            continue;
          }
          if (set2[i].semver.prerelease.length > 0) {
            const allowed = set2[i].semver;
            if (
              allowed.major === version4.major &&
              allowed.minor === version4.minor &&
              allowed.patch === version4.patch
            ) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  },
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  'node_modules/semver/classes/comparator.js'(exports, module) {
    'use strict';
    var ANY = Symbol('SemVer ANY');
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(' ');
        debug('comparator', comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = '';
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug('comp', this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : '';
        if (this.operator === '=') {
          this.operator = '';
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version4) {
        debug('Comparator.test', version4, this.options.loose);
        if (this.semver === ANY || version4 === ANY) {
          return true;
        }
        if (typeof version4 === 'string') {
          try {
            version4 = new SemVer(version4, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version4, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError('a Comparator is required');
        }
        if (this.operator === '') {
          if (this.value === '') {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === '') {
          if (comp.value === '') {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
          return false;
        }
        if (
          !options.includePrerelease &&
          (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))
        ) {
          return false;
        }
        if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
          return true;
        }
        if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
          return true;
        }
        if (
          this.semver.version === comp.semver.version &&
          this.operator.includes('=') &&
          comp.operator.includes('=')
        ) {
          return true;
        }
        if (
          cmp(this.semver, '<', comp.semver, options) &&
          this.operator.startsWith('>') &&
          comp.operator.startsWith('<')
        ) {
          return true;
        }
        if (
          cmp(this.semver, '>', comp.semver, options) &&
          this.operator.startsWith('<') &&
          comp.operator.startsWith('>')
        ) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug2();
    var SemVer = require_semver();
    var Range = require_range2();
  },
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  'node_modules/semver/functions/satisfies.js'(exports, module) {
    'use strict';
    var Range = require_range2();
    var satisfies = (version4, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version4);
    };
    module.exports = satisfies;
  },
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  'node_modules/semver/ranges/to-comparators.js'(exports, module) {
    'use strict';
    var Range = require_range2();
    var toComparators = (range, options) =>
      new Range(range, options).set.map((comp) =>
        comp
          .map((c) => c.value)
          .join(' ')
          .trim()
          .split(' ')
      );
    module.exports = toComparators;
  },
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  'node_modules/semver/ranges/max-satisfying.js'(exports, module) {
    'use strict';
    var SemVer = require_semver();
    var Range = require_range2();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  },
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  'node_modules/semver/ranges/min-satisfying.js'(exports, module) {
    'use strict';
    var SemVer = require_semver();
    var Range = require_range2();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  },
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  'node_modules/semver/ranges/min-version.js'(exports, module) {
    'use strict';
    var SemVer = require_semver();
    var Range = require_range2();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer('0.0.0');
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer('0.0.0-0');
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case '>':
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case '':
            case '>=':
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case '<':
            case '<=':
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  },
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  'node_modules/semver/ranges/valid.js'(exports, module) {
    'use strict';
    var Range = require_range2();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || '*';
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  },
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  'node_modules/semver/ranges/outside.js'(exports, module) {
    'use strict';
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range2();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version4, range, hilo, options) => {
      version4 = new SemVer(version4, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break;
        case '<':
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version4, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator('>=0.0.0');
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version4, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version4, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  },
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  'node_modules/semver/ranges/gtr.js'(exports, module) {
    'use strict';
    var outside = require_outside();
    var gtr = (version4, range, options) => outside(version4, range, '>', options);
    module.exports = gtr;
  },
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  'node_modules/semver/ranges/ltr.js'(exports, module) {
    'use strict';
    var outside = require_outside();
    var ltr = (version4, range, options) => outside(version4, range, '<', options);
    module.exports = ltr;
  },
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  'node_modules/semver/ranges/intersects.js'(exports, module) {
    'use strict';
    var Range = require_range2();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module.exports = intersects;
  },
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  'node_modules/semver/ranges/simplify.js'(exports, module) {
    'use strict';
    var satisfies = require_satisfies();
    var compare = require_compare();
    module.exports = (versions, range, options) => {
      const set2 = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version4 of v) {
        const included = satisfies(version4, range, options);
        if (included) {
          prev = version4;
          if (!first) {
            first = version4;
          }
        } else {
          if (prev) {
            set2.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set2.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set2) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push('*');
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(' || ');
      const original = typeof range.raw === 'string' ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  },
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  'node_modules/semver/ranges/subset.js'(exports, module) {
    'use strict';
    var Range = require_range2();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')];
    var minimumVersion = [new Comparator('>=0.0.0')];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === '>' || c.operator === '>=') {
          gt = higherGT(gt, c, options);
        } else if (c.operator === '<' || c.operator === '<=') {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre =
        lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre =
        gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (
        needDomLTPre &&
        needDomLTPre.prerelease.length === 1 &&
        lt.operator === '<' &&
        needDomLTPre.prerelease[0] === 0
      ) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
        hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
        if (gt) {
          if (needDomGTPre) {
            if (
              c.semver.prerelease &&
              c.semver.prerelease.length &&
              c.semver.major === needDomGTPre.major &&
              c.semver.minor === needDomGTPre.minor &&
              c.semver.patch === needDomGTPre.patch
            ) {
              needDomGTPre = false;
            }
          }
          if (c.operator === '>' || c.operator === '>=') {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (
              c.semver.prerelease &&
              c.semver.prerelease.length &&
              c.semver.major === needDomLTPre.major &&
              c.semver.minor === needDomLTPre.minor &&
              c.semver.patch === needDomLTPre.patch
            ) {
              needDomLTPre = false;
            }
          }
          if (c.operator === '<' || c.operator === '<=') {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
    };
    module.exports = subset;
  },
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  'node_modules/semver/index.js'(exports, module) {
    'use strict';
    var internalRe = require_re();
    var constants = require_constants2();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse2 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range2();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse: parse2,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers,
    };
  },
});

// node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS({
  'node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js'(exports, module) {
    var semver = require_semver2();
    module.exports = semver.satisfies(process.version, '>=15.7.0');
  },
});

// node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS({
  'node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js'(exports, module) {
    var semver = require_semver2();
    module.exports = semver.satisfies(process.version, '>=16.9.0');
  },
});

// node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS({
  'node_modules/jsonwebtoken/lib/validateAsymmetricKey.js'(exports, module) {
    var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
    var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
    var allowedAlgorithmsForKeys = {
      ec: ['ES256', 'ES384', 'ES512'],
      rsa: ['RS256', 'PS256', 'RS384', 'PS384', 'RS512', 'PS512'],
      'rsa-pss': ['PS256', 'PS384', 'PS512'],
    };
    var allowedCurves = {
      ES256: 'prime256v1',
      ES384: 'secp384r1',
      ES512: 'secp521r1',
    };
    module.exports = function (algorithm, key2) {
      if (!algorithm || !key2) return;
      const keyType = key2.asymmetricKeyType;
      if (!keyType) return;
      const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
      if (!allowedAlgorithms) {
        throw new Error(`Unknown key type "${keyType}".`);
      }
      if (!allowedAlgorithms.includes(algorithm)) {
        throw new Error(
          `"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(', ')}.`
        );
      }
      if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
        switch (keyType) {
          case 'ec':
            const keyCurve = key2.asymmetricKeyDetails.namedCurve;
            const allowedCurve = allowedCurves[algorithm];
            if (keyCurve !== allowedCurve) {
              throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
            }
            break;
          case 'rsa-pss':
            if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
              const length = parseInt(algorithm.slice(-3), 10);
              const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key2.asymmetricKeyDetails;
              if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
                throw new Error(
                  `Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`
                );
              }
              if (saltLength !== void 0 && saltLength > length >> 3) {
                throw new Error(
                  `Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`
                );
              }
            }
            break;
        }
      }
    };
  },
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  'node_modules/jsonwebtoken/lib/psSupported.js'(exports, module) {
    var semver = require_semver2();
    module.exports = semver.satisfies(process.version, '^6.12.0 || >=8.0.0');
  },
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  'node_modules/jsonwebtoken/verify.js'(exports, module) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var { KeyObject, createSecretKey, createPublicKey } = __require('crypto');
    var PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512'];
    var EC_KEY_ALGS = ['ES256', 'ES384', 'ES512'];
    var RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];
    var HS_ALGS = ['HS256', 'HS384', 'HS512'];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');
      RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');
    }
    module.exports = function (jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === 'function' && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      let done;
      if (callback) {
        done = callback;
      } else {
        done = function (err, data) {
          if (err) throw err;
          return data;
        };
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {
        return done(new JsonWebTokenError('clockTimestamp must be a number'));
      }
      if (
        options.nonce !== void 0 &&
        (typeof options.nonce !== 'string' || options.nonce.trim() === '')
      ) {
        return done(new JsonWebTokenError('nonce must be a non-empty string'));
      }
      if (
        options.allowInvalidAsymmetricKeyTypes !== void 0 &&
        typeof options.allowInvalidAsymmetricKeyTypes !== 'boolean'
      ) {
        return done(new JsonWebTokenError('allowInvalidAsymmetricKeyTypes must be a boolean'));
      }
      const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError('jwt must be provided'));
      }
      if (typeof jwtString !== 'string') {
        return done(new JsonWebTokenError('jwt must be a string'));
      }
      const parts = jwtString.split('.');
      if (parts.length !== 3) {
        return done(new JsonWebTokenError('jwt malformed'));
      }
      let decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError('invalid token'));
      }
      const header = decodedToken.header;
      let getSecret;
      if (typeof secretOrPublicKey === 'function') {
        if (!callback) {
          return done(
            new JsonWebTokenError(
              'verify must be called asynchronous if secret or public key is provided as a callback'
            )
          );
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = function (header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        };
      }
      return getSecret(header, function (err, secretOrPublicKey2) {
        if (err) {
          return done(
            new JsonWebTokenError('error in secret or public key callback: ' + err.message)
          );
        }
        const hasSignature = parts[2].trim() !== '';
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError('jwt signature is required'));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError('secret or public key must be provided'));
        }
        if (!hasSignature && !options.algorithms) {
          return done(
            new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens')
          );
        }
        if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
          try {
            secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
          } catch (_) {
            try {
              secretOrPublicKey2 = createSecretKey(
                typeof secretOrPublicKey2 === 'string'
                  ? Buffer.from(secretOrPublicKey2)
                  : secretOrPublicKey2
              );
            } catch (_2) {
              return done(new JsonWebTokenError('secretOrPublicKey is not valid key material'));
            }
          }
        }
        if (!options.algorithms) {
          if (secretOrPublicKey2.type === 'secret') {
            options.algorithms = HS_ALGS;
          } else if (['rsa', 'rsa-pss'].includes(secretOrPublicKey2.asymmetricKeyType)) {
            options.algorithms = RSA_KEY_ALGS;
          } else if (secretOrPublicKey2.asymmetricKeyType === 'ec') {
            options.algorithms = EC_KEY_ALGS;
          } else {
            options.algorithms = PUB_KEY_ALGS;
          }
        }
        if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
          return done(new JsonWebTokenError('invalid algorithm'));
        }
        if (header.alg.startsWith('HS') && secretOrPublicKey2.type !== 'secret') {
          return done(
            new JsonWebTokenError(
              `secretOrPublicKey must be a symmetric key when using ${header.alg}`
            )
          );
        } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== 'public') {
          return done(
            new JsonWebTokenError(
              `secretOrPublicKey must be an asymmetric key when using ${header.alg}`
            )
          );
        }
        if (!options.allowInvalidAsymmetricKeyTypes) {
          try {
            validateAsymmetricKey(header.alg, secretOrPublicKey2);
          } catch (e) {
            return done(e);
          }
        }
        let valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError('invalid signature'));
        }
        const payload = decodedToken.payload;
        if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== 'number') {
            return done(new JsonWebTokenError('invalid nbf value'));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {
          if (typeof payload.exp !== 'number') {
            return done(new JsonWebTokenError('invalid exp value'));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          const match = target.some(function (targetAudience) {
            return audiences.some(function (audience) {
              return audience instanceof RegExp
                ? audience.test(targetAudience)
                : audience === targetAudience;
            });
          });
          if (!match) {
            return done(
              new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or '))
            );
          }
        }
        if (options.issuer) {
          const invalid_issuer =
            (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||
            (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);
          if (invalid_issuer) {
            return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== 'number') {
            return done(new JsonWebTokenError('iat required when maxAge is specified'));
          }
          const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === 'undefined') {
            return done(
              new JsonWebTokenError(
                '"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'
              )
            );
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          const signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature,
          });
        }
        return done(null, payload);
      });
    };
  },
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS({
  'node_modules/lodash.includes/index.js'(exports, module) {
    var INFINITY2 = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN2 = 0 / 0;
    var argsTag = '[object Arguments]';
    var funcTag = '[object Function]';
    var genTag = '[object GeneratorFunction]';
    var stringTag = '[object String]';
    var symbolTag = '[object Symbol]';
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index2 = -1,
        length = array ? array.length : 0,
        result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length,
        index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index2 = fromIndex - 1,
        length = array.length;
      while (++index2 < length) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1,
        result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseValues(object, props) {
      return arrayMap(props, function (key2) {
        return object[key2];
      });
    }
    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray4(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length,
        skipIndexes = !!length;
      for (var key2 in value) {
        if (
          (inherited || hasOwnProperty2.call(value, key2)) &&
          !(skipIndexes && (key2 == 'length' || isIndex(key2, length)))
        ) {
          result.push(key2);
        }
      }
      return result;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key2 in Object(object)) {
        if (hasOwnProperty2.call(object, key2) && key2 != 'constructor') {
          result.push(key2);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return (
        !!length &&
        (typeof value == 'number' || reIsUint.test(value)) &&
        value > -1 &&
        value % 1 == 0 &&
        value < length
      );
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
      return value === proto;
    }
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString2(collection)
        ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1
        : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return (
        isArrayLikeObject(value) &&
        hasOwnProperty2.call(value, 'callee') &&
        (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag)
      );
    }
    var isArray4 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction3(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction3(value) {
      var tag2 = isObject2(value) ? objectToString.call(value) : '';
      return tag2 == funcTag || tag2 == genTag;
    }
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    function isString2(value) {
      return (
        typeof value == 'string' ||
        (!isArray4(value) && isObjectLike(value) && objectToString.call(value) == stringTag)
      );
    }
    function isSymbol(value) {
      return (
        typeof value == 'symbol' || (isObjectLike(value) && objectToString.call(value) == symbolTag)
      );
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY2 || value === -INFINITY2) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value),
        remainder = result % 1;
      return result === result ? (remainder ? result - remainder : result) : 0;
    }
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN2;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject2(other) ? other + '' : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value)
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : reIsBadHex.test(value)
          ? NAN2
          : +value;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    module.exports = includes;
  },
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS({
  'node_modules/lodash.isboolean/index.js'(exports, module) {
    var boolTag = '[object Boolean]';
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean2(value) {
      return (
        value === true ||
        value === false ||
        (isObjectLike(value) && objectToString.call(value) == boolTag)
      );
    }
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    module.exports = isBoolean2;
  },
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS({
  'node_modules/lodash.isinteger/index.js'(exports, module) {
    var INFINITY2 = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN2 = 0 / 0;
    var symbolTag = '[object Symbol]';
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    function isSymbol(value) {
      return (
        typeof value == 'symbol' || (isObjectLike(value) && objectToString.call(value) == symbolTag)
      );
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY2 || value === -INFINITY2) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value),
        remainder = result % 1;
      return result === result ? (remainder ? result - remainder : result) : 0;
    }
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN2;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject2(other) ? other + '' : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value)
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : reIsBadHex.test(value)
          ? NAN2
          : +value;
    }
    module.exports = isInteger;
  },
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS({
  'node_modules/lodash.isnumber/index.js'(exports, module) {
    var numberTag = '[object Number]';
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    function isNumber2(value) {
      return (
        typeof value == 'number' || (isObjectLike(value) && objectToString.call(value) == numberTag)
      );
    }
    module.exports = isNumber2;
  },
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS({
  'node_modules/lodash.isplainobject/index.js'(exports, module) {
    var objectTag = '[object Object]';
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != 'function') {
        try {
          result = !!(value + '');
        } catch (e) {}
      }
      return result;
    }
    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    function isPlainObject2(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty2.call(proto, 'constructor') && proto.constructor;
      return (
        typeof Ctor == 'function' &&
        Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString
      );
    }
    module.exports = isPlainObject2;
  },
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS({
  'node_modules/lodash.isstring/index.js'(exports, module) {
    var stringTag = '[object String]';
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray4 = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    function isString2(value) {
      return (
        typeof value == 'string' ||
        (!isArray4(value) && isObjectLike(value) && objectToString.call(value) == stringTag)
      );
    }
    module.exports = isString2;
  },
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS({
  'node_modules/lodash.once/index.js'(exports, module) {
    var FUNC_ERROR_TEXT = 'Expected a function';
    var INFINITY2 = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN2 = 0 / 0;
    var symbolTag = '[object Symbol]';
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function () {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once2(func) {
      return before(2, func);
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    function isSymbol(value) {
      return (
        typeof value == 'symbol' || (isObjectLike(value) && objectToString.call(value) == symbolTag)
      );
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY2 || value === -INFINITY2) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value),
        remainder = result % 1;
      return result === result ? (remainder ? result - remainder : result) : 0;
    }
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN2;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject2(other) ? other + '' : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value)
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : reIsBadHex.test(value)
          ? NAN2
          : +value;
    }
    module.exports = once2;
  },
});

// node_modules/jsonwebtoken/sign.js
var require_sign2 = __commonJS({
  'node_modules/jsonwebtoken/sign.js'(exports, module) {
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var jws = require_jws();
    var includes = require_lodash();
    var isBoolean2 = require_lodash2();
    var isInteger = require_lodash3();
    var isNumber2 = require_lodash4();
    var isPlainObject2 = require_lodash5();
    var isString2 = require_lodash6();
    var once2 = require_lodash7();
    var { KeyObject, createSecretKey, createPrivateKey } = __require('crypto');
    var SUPPORTED_ALGS = [
      'RS256',
      'RS384',
      'RS512',
      'ES256',
      'ES384',
      'ES512',
      'HS256',
      'HS384',
      'HS512',
      'none',
    ];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');
    }
    var sign_options_schema = {
      expiresIn: {
        isValid: function (value) {
          return isInteger(value) || (isString2(value) && value);
        },
        message: '"expiresIn" should be a number of seconds or string representing a timespan',
      },
      notBefore: {
        isValid: function (value) {
          return isInteger(value) || (isString2(value) && value);
        },
        message: '"notBefore" should be a number of seconds or string representing a timespan',
      },
      audience: {
        isValid: function (value) {
          return isString2(value) || Array.isArray(value);
        },
        message: '"audience" must be a string or array',
      },
      algorithm: {
        isValid: includes.bind(null, SUPPORTED_ALGS),
        message: '"algorithm" must be a valid string enum value',
      },
      header: { isValid: isPlainObject2, message: '"header" must be an object' },
      encoding: { isValid: isString2, message: '"encoding" must be a string' },
      issuer: { isValid: isString2, message: '"issuer" must be a string' },
      subject: { isValid: isString2, message: '"subject" must be a string' },
      jwtid: { isValid: isString2, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean2, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString2, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean2, message: '"mutatePayload" must be a boolean' },
      allowInsecureKeySizes: {
        isValid: isBoolean2,
        message: '"allowInsecureKeySizes" must be a boolean',
      },
      allowInvalidAsymmetricKeyTypes: {
        isValid: isBoolean2,
        message: '"allowInvalidAsymmetricKeyTypes" must be a boolean',
      },
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber2, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber2, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber2, message: '"nbf" should be a number of seconds' },
    };
    function validate3(schema, allowUnknown, object, parameterName) {
      if (!isPlainObject2(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function (key2) {
        const validator = schema[key2];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key2 + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object[key2])) {
          throw new Error(validator.message);
        }
      });
    }
    function validateOptions(options) {
      return validate3(sign_options_schema, false, options, 'options');
    }
    function validatePayload(payload) {
      return validate3(registered_claims_schema, true, payload, 'payload');
    }
    var options_to_payload = {
      audience: 'aud',
      issuer: 'iss',
      subject: 'sub',
      jwtid: 'jti',
    };
    var options_for_objects = [
      'expiresIn',
      'notBefore',
      'noTimestamp',
      'audience',
      'issuer',
      'subject',
      'jwtid',
    ];
    module.exports = function (payload, secretOrPrivateKey, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      const isObjectPayload = typeof payload === 'object' && !Buffer.isBuffer(payload);
      const header = Object.assign(
        {
          alg: options.algorithm || 'HS256',
          typ: isObjectPayload ? 'JWT' : void 0,
          kid: options.keyid,
        },
        options.header
      );
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      if (!secretOrPrivateKey && options.algorithm !== 'none') {
        return failure(new Error('secretOrPrivateKey must have a value'));
      }
      if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
        try {
          secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
        } catch (_) {
          try {
            secretOrPrivateKey = createSecretKey(
              typeof secretOrPrivateKey === 'string'
                ? Buffer.from(secretOrPrivateKey)
                : secretOrPrivateKey
            );
          } catch (_2) {
            return failure(new Error('secretOrPrivateKey is not valid key material'));
          }
        }
      }
      if (header.alg.startsWith('HS') && secretOrPrivateKey.type !== 'secret') {
        return failure(
          new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`)
        );
      } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
        if (secretOrPrivateKey.type !== 'private') {
          return failure(
            new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`)
          );
        }
        if (
          !options.allowInsecureKeySizes &&
          !header.alg.startsWith('ES') &&
          secretOrPrivateKey.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
          secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048
        ) {
          return failure(
            new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`)
          );
        }
      }
      if (typeof payload === 'undefined') {
        return failure(new Error('payload is required'));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error) {
          return failure(error);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        const invalid_options = options_for_objects.filter(function (opt) {
          return typeof options[opt] !== 'undefined';
        });
        if (invalid_options.length > 0) {
          return failure(
            new Error(
              'invalid ' + invalid_options.join(',') + ' option for ' + typeof payload + ' payload'
            )
          );
        }
      }
      if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {
        return failure(
          new Error('Bad "options.expiresIn" option the payload already has an "exp" property.')
        );
      }
      if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {
        return failure(
          new Error('Bad "options.notBefore" option the payload already has an "nbf" property.')
        );
      }
      try {
        validateOptions(options);
      } catch (error) {
        return failure(error);
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPrivateKey);
        } catch (error) {
          return failure(error);
        }
      }
      const timestamp = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp;
      }
      if (typeof options.notBefore !== 'undefined') {
        try {
          payload.nbf = timespan(options.notBefore, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === 'undefined') {
          return failure(
            new Error(
              '"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'
            )
          );
        }
      }
      if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {
        try {
          payload.exp = timespan(options.expiresIn, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === 'undefined') {
          return failure(
            new Error(
              '"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'
            )
          );
        }
      }
      Object.keys(options_to_payload).forEach(function (key2) {
        const claim = options_to_payload[key2];
        if (typeof options[key2] !== 'undefined') {
          if (typeof payload[claim] !== 'undefined') {
            return failure(
              new Error(
                'Bad "options.' +
                  key2 +
                  '" option. The payload already has an "' +
                  claim +
                  '" property.'
              )
            );
          }
          payload[claim] = options[key2];
        }
      });
      const encoding = options.encoding || 'utf8';
      if (typeof callback === 'function') {
        callback = callback && once2(callback);
        jws
          .createSign({
            header,
            privateKey: secretOrPrivateKey,
            payload,
            encoding,
          })
          .once('error', callback)
          .once('done', function (signature) {
            if (
              !options.allowInsecureKeySizes &&
              /^(?:RS|PS)/.test(header.alg) &&
              signature.length < 256
            ) {
              return callback(
                new Error(
                  `secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`
                )
              );
            }
            callback(null, signature);
          });
      } else {
        let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
        if (
          !options.allowInsecureKeySizes &&
          /^(?:RS|PS)/.test(header.alg) &&
          signature.length < 256
        ) {
          throw new Error(
            `secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`
          );
        }
        return signature;
      }
    };
  },
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  'node_modules/jsonwebtoken/index.js'(exports, module) {
    module.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign2(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError(),
    };
  },
});

// node_modules/@azure/msal-node/dist/client/ClientAssertion.mjs
var import_jsonwebtoken, ClientAssertion;
var init_ClientAssertion = __esm({
  'node_modules/@azure/msal-node/dist/client/ClientAssertion.mjs'() {
    'use strict';
    import_jsonwebtoken = __toESM(require_jsonwebtoken(), 1);
    init_index_node();
    init_EncodingUtils();
    init_Constants2();
    ClientAssertion = class _ClientAssertion {
      /**
       * Initialize the ClientAssertion class from the clientAssertion passed by the user
       * @param assertion - refer https://tools.ietf.org/html/rfc7521
       */
      static fromAssertion(assertion) {
        const clientAssertion = new _ClientAssertion();
        clientAssertion.jwt = assertion;
        return clientAssertion;
      }
      /**
       * @deprecated Use fromCertificateWithSha256Thumbprint instead, with a SHA-256 thumprint
       * Initialize the ClientAssertion class from the certificate passed by the user
       * @param thumbprint - identifier of a certificate
       * @param privateKey - secret key
       * @param publicCertificate - electronic document provided to prove the ownership of the public key
       */
      static fromCertificate(thumbprint, privateKey, publicCertificate) {
        const clientAssertion = new _ClientAssertion();
        clientAssertion.privateKey = privateKey;
        clientAssertion.thumbprint = thumbprint;
        clientAssertion.useSha256 = false;
        if (publicCertificate) {
          clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);
        }
        return clientAssertion;
      }
      /**
       * Initialize the ClientAssertion class from the certificate passed by the user
       * @param thumbprint - identifier of a certificate
       * @param privateKey - secret key
       * @param publicCertificate - electronic document provided to prove the ownership of the public key
       */
      static fromCertificateWithSha256Thumbprint(thumbprint, privateKey, publicCertificate) {
        const clientAssertion = new _ClientAssertion();
        clientAssertion.privateKey = privateKey;
        clientAssertion.thumbprint = thumbprint;
        clientAssertion.useSha256 = true;
        if (publicCertificate) {
          clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);
        }
        return clientAssertion;
      }
      /**
       * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is
       * @param cryptoProvider - library's crypto helper
       * @param issuer - iss claim
       * @param jwtAudience - aud claim
       */
      getJwt(cryptoProvider, issuer, jwtAudience) {
        if (this.privateKey && this.thumbprint) {
          if (
            this.jwt &&
            !this.isExpired() &&
            issuer === this.issuer &&
            jwtAudience === this.jwtAudience
          ) {
            return this.jwt;
          }
          return this.createJwt(cryptoProvider, issuer, jwtAudience);
        }
        if (this.jwt) {
          return this.jwt;
        }
        throw createClientAuthError(ClientAuthErrorCodes_exports.invalidAssertion);
      }
      /**
       * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3
       */
      createJwt(cryptoProvider, issuer, jwtAudience) {
        this.issuer = issuer;
        this.jwtAudience = jwtAudience;
        const issuedAt = TimeUtils_exports.nowSeconds();
        this.expirationTime = issuedAt + 600;
        const algorithm = this.useSha256 ? JwtConstants.PSS_256 : JwtConstants.RSA_256;
        const header = {
          alg: algorithm,
        };
        const thumbprintHeader = this.useSha256 ? JwtConstants.X5T_256 : JwtConstants.X5T;
        Object.assign(header, {
          [thumbprintHeader]: EncodingUtils.base64EncodeUrl(this.thumbprint, EncodingTypes.HEX),
        });
        if (this.publicCertificate) {
          Object.assign(header, {
            [JwtConstants.X5C]: this.publicCertificate,
          });
        }
        const payload = {
          [JwtConstants.AUDIENCE]: this.jwtAudience,
          [JwtConstants.EXPIRATION_TIME]: this.expirationTime,
          [JwtConstants.ISSUER]: this.issuer,
          [JwtConstants.SUBJECT]: this.issuer,
          [JwtConstants.NOT_BEFORE]: issuedAt,
          [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid(),
        };
        this.jwt = import_jsonwebtoken.default.sign(payload, this.privateKey, { header });
        return this.jwt;
      }
      /**
       * Utility API to check expiration
       */
      isExpired() {
        return this.expirationTime < TimeUtils_exports.nowSeconds();
      }
      /**
       * Extracts the raw certs from a given certificate string and returns them in an array.
       * @param publicCertificate - electronic document provided to prove the ownership of the public key
       */
      static parseCertificate(publicCertificate) {
        const regexToFindCerts =
          /-----BEGIN CERTIFICATE-----\r*\n(.+?)\r*\n-----END CERTIFICATE-----/gs;
        const certs = [];
        let matches2;
        while ((matches2 = regexToFindCerts.exec(publicCertificate)) !== null) {
          certs.push(matches2[1].replace(/\r*\n/g, Constants.EMPTY_STRING));
        }
        return certs;
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/packageMetadata.mjs
var name2, version3;
var init_packageMetadata2 = __esm({
  'node_modules/@azure/msal-node/dist/packageMetadata.mjs'() {
    'use strict';
    name2 = '@azure/msal-node';
    version3 = '3.8.0';
  },
});

// node_modules/@azure/msal-node/dist/client/UsernamePasswordClient.mjs
var UsernamePasswordClient;
var init_UsernamePasswordClient = __esm({
  'node_modules/@azure/msal-node/dist/client/UsernamePasswordClient.mjs'() {
    'use strict';
    init_index_node();
    UsernamePasswordClient = class extends BaseClient {
      constructor(configuration) {
        super(configuration);
      }
      /**
       * API to acquire a token by passing the username and password to the service in exchage of credentials
       * password_grant
       * @param request - CommonUsernamePasswordRequest
       */
      async acquireToken(request) {
        this.logger.info('in acquireToken call in username-password client');
        const reqTimestamp = TimeUtils_exports.nowSeconds();
        const response = await this.executeTokenRequest(this.authority, request);
        const responseHandler = new ResponseHandler(
          this.config.authOptions.clientId,
          this.cacheManager,
          this.cryptoUtils,
          this.logger,
          this.config.serializableCache,
          this.config.persistencePlugin
        );
        responseHandler.validateTokenResponse(response.body);
        const tokenResponse = responseHandler.handleServerTokenResponse(
          response.body,
          this.authority,
          reqTimestamp,
          request
        );
        return tokenResponse;
      }
      /**
       * Executes POST request to token endpoint
       * @param authority - authority object
       * @param request - CommonUsernamePasswordRequest provided by the developer
       */
      async executeTokenRequest(authority, request) {
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(
          authority.tokenEndpoint,
          queryParametersString
        );
        const requestBody = await this.createTokenRequestBody(request);
        const headers = this.createTokenRequestHeaders({
          credential: request.username,
          type: CcsCredentialType.UPN,
        });
        const thumbprint = {
          clientId: this.config.authOptions.clientId,
          authority: authority.canonicalAuthority,
          scopes: request.scopes,
          claims: request.claims,
          authenticationScheme: request.authenticationScheme,
          resourceRequestMethod: request.resourceRequestMethod,
          resourceRequestUri: request.resourceRequestUri,
          shrClaims: request.shrClaims,
          sshKid: request.sshKid,
        };
        return this.executePostToTokenEndpoint(
          endpoint,
          requestBody,
          headers,
          thumbprint,
          request.correlationId
        );
      }
      /**
       * Generates a map for all the params to be sent to the service
       * @param request - CommonUsernamePasswordRequest provided by the developer
       */
      async createTokenRequestBody(request) {
        const parameters = /* @__PURE__ */ new Map();
        RequestParameterBuilder_exports.addClientId(parameters, this.config.authOptions.clientId);
        RequestParameterBuilder_exports.addUsername(parameters, request.username);
        RequestParameterBuilder_exports.addPassword(parameters, request.password);
        RequestParameterBuilder_exports.addScopes(parameters, request.scopes);
        RequestParameterBuilder_exports.addResponseType(
          parameters,
          OAuthResponseType.IDTOKEN_TOKEN
        );
        RequestParameterBuilder_exports.addGrantType(
          parameters,
          GrantType.RESOURCE_OWNER_PASSWORD_GRANT
        );
        RequestParameterBuilder_exports.addClientInfo(parameters);
        RequestParameterBuilder_exports.addLibraryInfo(parameters, this.config.libraryInfo);
        RequestParameterBuilder_exports.addApplicationTelemetry(
          parameters,
          this.config.telemetry.application
        );
        RequestParameterBuilder_exports.addThrottling(parameters);
        if (this.serverTelemetryManager) {
          RequestParameterBuilder_exports.addServerTelemetry(
            parameters,
            this.serverTelemetryManager
          );
        }
        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        RequestParameterBuilder_exports.addCorrelationId(parameters, correlationId);
        if (this.config.clientCredentials.clientSecret) {
          RequestParameterBuilder_exports.addClientSecret(
            parameters,
            this.config.clientCredentials.clientSecret
          );
        }
        const clientAssertion = this.config.clientCredentials.clientAssertion;
        if (clientAssertion) {
          RequestParameterBuilder_exports.addClientAssertion(
            parameters,
            await getClientAssertion(
              clientAssertion.assertion,
              this.config.authOptions.clientId,
              request.resourceRequestUri
            )
          );
          RequestParameterBuilder_exports.addClientAssertionType(
            parameters,
            clientAssertion.assertionType
          );
        }
        if (
          !StringUtils.isEmptyObj(request.claims) ||
          (this.config.authOptions.clientCapabilities &&
            this.config.authOptions.clientCapabilities.length > 0)
        ) {
          RequestParameterBuilder_exports.addClaims(
            parameters,
            request.claims,
            this.config.authOptions.clientCapabilities
          );
        }
        if (this.config.systemOptions.preventCorsPreflight && request.username) {
          RequestParameterBuilder_exports.addCcsUpn(parameters, request.username);
        }
        return UrlUtils_exports.mapToQueryString(parameters);
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/protocol/Authorize.mjs
function getAuthCodeRequestUrl(config, authority, request, logger4) {
  const parameters = Authorize_exports.getStandardAuthorizeRequestParameters(
    {
      ...config.auth,
      authority,
      redirectUri: request.redirectUri || '',
    },
    request,
    logger4
  );
  RequestParameterBuilder_exports.addLibraryInfo(parameters, {
    sku: Constants2.MSAL_SKU,
    version: version3,
    cpu: process.arch || '',
    os: process.platform || '',
  });
  if (config.auth.protocolMode !== ProtocolMode.OIDC) {
    RequestParameterBuilder_exports.addApplicationTelemetry(
      parameters,
      config.telemetry.application
    );
  }
  RequestParameterBuilder_exports.addResponseType(parameters, OAuthResponseType.CODE);
  if (request.codeChallenge && request.codeChallengeMethod) {
    RequestParameterBuilder_exports.addCodeChallengeParams(
      parameters,
      request.codeChallenge,
      request.codeChallengeMethod
    );
  }
  RequestParameterBuilder_exports.addExtraQueryParameters(
    parameters,
    request.extraQueryParameters || {}
  );
  return Authorize_exports.getAuthorizeUrl(
    authority,
    parameters,
    config.auth.encodeExtraQueryParams,
    request.extraQueryParameters
  );
}
var init_Authorize2 = __esm({
  'node_modules/@azure/msal-node/dist/protocol/Authorize.mjs'() {
    'use strict';
    init_index_node();
    init_Constants2();
    init_packageMetadata2();
  },
});

// node_modules/@azure/msal-node/dist/client/ClientApplication.mjs
var ClientApplication;
var init_ClientApplication = __esm({
  'node_modules/@azure/msal-node/dist/client/ClientApplication.mjs'() {
    'use strict';
    init_index_node();
    init_Configuration();
    init_CryptoProvider();
    init_NodeStorage();
    init_Constants2();
    init_TokenCache();
    init_ClientAssertion();
    init_packageMetadata2();
    init_NodeAuthError();
    init_UsernamePasswordClient();
    init_Authorize2();
    ClientApplication = class {
      /**
       * Constructor for the ClientApplication
       */
      constructor(configuration) {
        this.config = buildAppConfiguration(configuration);
        this.cryptoProvider = new CryptoProvider();
        this.logger = new Logger(this.config.system.loggerOptions, name2, version3);
        this.storage = new NodeStorage(
          this.logger,
          this.config.auth.clientId,
          this.cryptoProvider,
          buildStaticAuthorityOptions(this.config.auth)
        );
        this.tokenCache = new TokenCache(this.storage, this.logger, this.config.cache.cachePlugin);
      }
      /**
       * Creates the URL of the authorization request, letting the user input credentials and consent to the
       * application. The URL targets the /authorize endpoint of the authority configured in the
       * application object.
       *
       * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI
       * sent in the request and should contain an authorization code, which can then be used to acquire tokens via
       * `acquireTokenByCode(AuthorizationCodeRequest)`.
       */
      async getAuthCodeUrl(request) {
        this.logger.info('getAuthCodeUrl called', request.correlationId);
        const validRequest = {
          ...request,
          ...(await this.initializeBaseRequest(request)),
          responseMode: request.responseMode || ResponseMode.QUERY,
          authenticationScheme: AuthenticationScheme.BEARER,
          state: request.state || '',
          nonce: request.nonce || '',
        };
        const discoveredAuthority = await this.createAuthority(
          validRequest.authority,
          validRequest.correlationId,
          void 0,
          request.azureCloudOptions
        );
        return getAuthCodeRequestUrl(this.config, discoveredAuthority, validRequest, this.logger);
      }
      /**
       * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0
       * Authorization Code flow.
       *
       * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0
       * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and
       * AuthorizationCodeRequest are the same.
       */
      async acquireTokenByCode(request, authCodePayLoad) {
        this.logger.info('acquireTokenByCode called');
        if (request.state && authCodePayLoad) {
          this.logger.info('acquireTokenByCode - validating state');
          this.validateState(request.state, authCodePayLoad.state || '');
          authCodePayLoad = { ...authCodePayLoad, state: '' };
        }
        const validRequest = {
          ...request,
          ...(await this.initializeBaseRequest(request)),
          authenticationScheme: AuthenticationScheme.BEARER,
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(
          ApiId.acquireTokenByCode,
          validRequest.correlationId
        );
        try {
          const discoveredAuthority = await this.createAuthority(
            validRequest.authority,
            validRequest.correlationId,
            void 0,
            request.azureCloudOptions
          );
          const authClientConfig = await this.buildOauthClientConfiguration(
            discoveredAuthority,
            validRequest.correlationId,
            validRequest.redirectUri,
            serverTelemetryManager
          );
          const authorizationCodeClient = new AuthorizationCodeClient(authClientConfig);
          this.logger.verbose('Auth code client created', validRequest.correlationId);
          return await authorizationCodeClient.acquireToken(validRequest, authCodePayLoad);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires a token by exchanging the refresh token provided for a new set of tokens.
       *
       * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is
       * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will
       * handle the caching and refreshing of tokens automatically.
       */
      async acquireTokenByRefreshToken(request) {
        this.logger.info('acquireTokenByRefreshToken called', request.correlationId);
        const validRequest = {
          ...request,
          ...(await this.initializeBaseRequest(request)),
          authenticationScheme: AuthenticationScheme.BEARER,
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(
          ApiId.acquireTokenByRefreshToken,
          validRequest.correlationId
        );
        try {
          const discoveredAuthority = await this.createAuthority(
            validRequest.authority,
            validRequest.correlationId,
            void 0,
            request.azureCloudOptions
          );
          const refreshTokenClientConfig = await this.buildOauthClientConfiguration(
            discoveredAuthority,
            validRequest.correlationId,
            validRequest.redirectUri || '',
            serverTelemetryManager
          );
          const refreshTokenClient = new RefreshTokenClient(refreshTokenClientConfig);
          this.logger.verbose('Refresh token client created', validRequest.correlationId);
          return await refreshTokenClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires a token silently when a user specifies the account the token is requested for.
       *
       * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.
       * There is also an optional "forceRefresh" boolean the user can send to bypass the cache for access_token and id_token.
       * In case the refresh_token is expired or not found, an error is thrown
       * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).
       */
      async acquireTokenSilent(request) {
        const validRequest = {
          ...request,
          ...(await this.initializeBaseRequest(request)),
          forceRefresh: request.forceRefresh || false,
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(
          ApiId.acquireTokenSilent,
          validRequest.correlationId,
          validRequest.forceRefresh
        );
        try {
          const discoveredAuthority = await this.createAuthority(
            validRequest.authority,
            validRequest.correlationId,
            void 0,
            request.azureCloudOptions
          );
          const clientConfiguration = await this.buildOauthClientConfiguration(
            discoveredAuthority,
            validRequest.correlationId,
            validRequest.redirectUri || '',
            serverTelemetryManager
          );
          const silentFlowClient = new SilentFlowClient(clientConfiguration);
          this.logger.verbose('Silent flow client created', validRequest.correlationId);
          try {
            await this.tokenCache.overwriteCache();
            return await this.acquireCachedTokenSilent(
              validRequest,
              silentFlowClient,
              clientConfiguration
            );
          } catch (error) {
            if (
              error instanceof ClientAuthError &&
              error.errorCode === ClientAuthErrorCodes_exports.tokenRefreshRequired
            ) {
              const refreshTokenClient = new RefreshTokenClient(clientConfiguration);
              return refreshTokenClient.acquireTokenByRefreshToken(validRequest);
            }
            throw error;
          }
        } catch (error) {
          if (error instanceof AuthError) {
            error.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(error);
          throw error;
        }
      }
      async acquireCachedTokenSilent(validRequest, silentFlowClient, clientConfiguration) {
        const [authResponse, cacheOutcome] = await silentFlowClient.acquireCachedToken({
          ...validRequest,
          scopes: validRequest.scopes?.length ? validRequest.scopes : [...OIDC_DEFAULT_SCOPES],
        });
        if (cacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {
          this.logger.info(
            "ClientApplication:acquireCachedTokenSilent - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed."
          );
          const refreshTokenClient = new RefreshTokenClient(clientConfiguration);
          try {
            await refreshTokenClient.acquireTokenByRefreshToken(validRequest);
          } catch {}
        }
        return authResponse;
      }
      /**
       * Acquires tokens with password grant by exchanging client applications username and password for credentials
       *
       * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.
       * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4
       * Microsoft's documentation and recommendations are at:
       * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword
       *
       * @param request - UsenamePasswordRequest
       * @deprecated - Use a more secure flow instead
       */
      async acquireTokenByUsernamePassword(request) {
        this.logger.info('acquireTokenByUsernamePassword called', request.correlationId);
        const validRequest = {
          ...request,
          ...(await this.initializeBaseRequest(request)),
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(
          ApiId.acquireTokenByUsernamePassword,
          validRequest.correlationId
        );
        try {
          const discoveredAuthority = await this.createAuthority(
            validRequest.authority,
            validRequest.correlationId,
            void 0,
            request.azureCloudOptions
          );
          const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(
            discoveredAuthority,
            validRequest.correlationId,
            '',
            serverTelemetryManager
          );
          const usernamePasswordClient = new UsernamePasswordClient(usernamePasswordClientConfig);
          this.logger.verbose('Username password client created', validRequest.correlationId);
          return await usernamePasswordClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Gets the token cache for the application.
       */
      getTokenCache() {
        this.logger.info('getTokenCache called');
        return this.tokenCache;
      }
      /**
       * Validates OIDC state by comparing the user cached state with the state received from the server.
       *
       * This API is provided for scenarios where you would use OAuth2.0 state parameter to mitigate against
       * CSRF attacks.
       * For more information about state, visit https://datatracker.ietf.org/doc/html/rfc6819#section-3.6.
       * @param state - Unique GUID generated by the user that is cached by the user and sent to the server during the first leg of the flow
       * @param cachedState - This string is sent back by the server with the authorization code
       */
      validateState(state2, cachedState) {
        if (!state2) {
          throw NodeAuthError.createStateNotFoundError();
        }
        if (state2 !== cachedState) {
          throw createClientAuthError(ClientAuthErrorCodes_exports.stateMismatch);
        }
      }
      /**
       * Returns the logger instance
       */
      getLogger() {
        return this.logger;
      }
      /**
       * Replaces the default logger set in configurations with new Logger with new configurations
       * @param logger - Logger instance
       */
      setLogger(logger4) {
        this.logger = logger4;
      }
      /**
       * Builds the common configuration to be passed to the common component based on the platform configurarion
       * @param authority - user passed authority in configuration
       * @param serverTelemetryManager - initializes servertelemetry if passed
       */
      async buildOauthClientConfiguration(
        discoveredAuthority,
        requestCorrelationId,
        redirectUri,
        serverTelemetryManager
      ) {
        this.logger.verbose('buildOauthClientConfiguration called', requestCorrelationId);
        this.logger.info(
          `Building oauth client configuration with the following authority: ${discoveredAuthority.tokenEndpoint}.`,
          requestCorrelationId
        );
        serverTelemetryManager?.updateRegionDiscoveryMetadata(
          discoveredAuthority.regionDiscoveryMetadata
        );
        const clientConfiguration = {
          authOptions: {
            clientId: this.config.auth.clientId,
            authority: discoveredAuthority,
            clientCapabilities: this.config.auth.clientCapabilities,
            redirectUri,
          },
          loggerOptions: {
            logLevel: this.config.system.loggerOptions.logLevel,
            loggerCallback: this.config.system.loggerOptions.loggerCallback,
            piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,
            correlationId: requestCorrelationId,
          },
          cacheOptions: {
            claimsBasedCachingEnabled: this.config.cache.claimsBasedCachingEnabled,
          },
          cryptoInterface: this.cryptoProvider,
          networkInterface: this.config.system.networkClient,
          storageInterface: this.storage,
          serverTelemetryManager,
          clientCredentials: {
            clientSecret: this.clientSecret,
            clientAssertion: await this.getClientAssertion(discoveredAuthority),
          },
          libraryInfo: {
            sku: Constants2.MSAL_SKU,
            version: version3,
            cpu: process.arch || Constants.EMPTY_STRING,
            os: process.platform || Constants.EMPTY_STRING,
          },
          telemetry: this.config.telemetry,
          persistencePlugin: this.config.cache.cachePlugin,
          serializableCache: this.tokenCache,
        };
        return clientConfiguration;
      }
      async getClientAssertion(authority) {
        if (this.developerProvidedClientAssertion) {
          this.clientAssertion = ClientAssertion.fromAssertion(
            await getClientAssertion(
              this.developerProvidedClientAssertion,
              this.config.auth.clientId,
              authority.tokenEndpoint
            )
          );
        }
        return (
          this.clientAssertion && {
            assertion: this.clientAssertion.getJwt(
              this.cryptoProvider,
              this.config.auth.clientId,
              authority.tokenEndpoint
            ),
            assertionType: Constants2.JWT_BEARER_ASSERTION_TYPE,
          }
        );
      }
      /**
       * Generates a request with the default scopes & generates a correlationId.
       * @param authRequest - BaseAuthRequest for initialization
       */
      async initializeBaseRequest(authRequest) {
        this.logger.verbose('initializeRequestScopes called', authRequest.correlationId);
        if (
          authRequest.authenticationScheme &&
          authRequest.authenticationScheme === AuthenticationScheme.POP
        ) {
          this.logger.verbose(
            "Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request",
            authRequest.correlationId
          );
        }
        authRequest.authenticationScheme = AuthenticationScheme.BEARER;
        if (
          this.config.cache.claimsBasedCachingEnabled &&
          authRequest.claims && // Checks for empty stringified object "{}" which doesn't qualify as requested claims
          !StringUtils.isEmptyObj(authRequest.claims)
        ) {
          authRequest.requestedClaimsHash = await this.cryptoProvider.hashString(
            authRequest.claims
          );
        }
        return {
          ...authRequest,
          scopes: [...((authRequest && authRequest.scopes) || []), ...OIDC_DEFAULT_SCOPES],
          correlationId:
            (authRequest && authRequest.correlationId) || this.cryptoProvider.createNewGuid(),
          authority: authRequest.authority || this.config.auth.authority,
        };
      }
      /**
       * Initializes the server telemetry payload
       * @param apiId - Id for a specific request
       * @param correlationId - GUID
       * @param forceRefresh - boolean to indicate network call
       */
      initializeServerTelemetryManager(apiId, correlationId, forceRefresh) {
        const telemetryPayload = {
          clientId: this.config.auth.clientId,
          correlationId,
          apiId,
          forceRefresh: forceRefresh || false,
        };
        return new ServerTelemetryManager(telemetryPayload, this.storage);
      }
      /**
       * Create authority instance. If authority not passed in request, default to authority set on the application
       * object. If no authority set in application object, then default to common authority.
       * @param authorityString - authority from user configuration
       */
      async createAuthority(
        authorityString,
        requestCorrelationId,
        azureRegionConfiguration,
        azureCloudOptions
      ) {
        this.logger.verbose('createAuthority called', requestCorrelationId);
        const authorityUrl = Authority.generateAuthority(
          authorityString,
          azureCloudOptions || this.config.auth.azureCloudOptions
        );
        const authorityOptions = {
          protocolMode: this.config.auth.protocolMode,
          knownAuthorities: this.config.auth.knownAuthorities,
          cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
          authorityMetadata: this.config.auth.authorityMetadata,
          azureRegionConfiguration,
          skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache,
        };
        return AuthorityFactory_exports.createDiscoveredInstance(
          authorityUrl,
          this.config.system.networkClient,
          this.storage,
          authorityOptions,
          this.logger,
          requestCorrelationId
        );
      }
      /**
       * Clear the cache
       */
      clearCache() {
        this.storage.clear();
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/network/LoopbackClient.mjs
import http3 from 'http';
var LoopbackClient;
var init_LoopbackClient = __esm({
  'node_modules/@azure/msal-node/dist/network/LoopbackClient.mjs'() {
    'use strict';
    init_index_node();
    init_NodeAuthError();
    init_Constants2();
    LoopbackClient = class {
      /**
       * Spins up a loopback server which returns the server response when the localhost redirectUri is hit
       * @param successTemplate
       * @param errorTemplate
       * @returns
       */
      async listenForAuthCode(successTemplate, errorTemplate) {
        if (this.server) {
          throw NodeAuthError.createLoopbackServerAlreadyExistsError();
        }
        return new Promise((resolve, reject) => {
          this.server = http3.createServer((req, res) => {
            const url2 = req.url;
            if (!url2) {
              res.end(errorTemplate || 'Error occurred loading redirectUrl');
              reject(NodeAuthError.createUnableToLoadRedirectUrlError());
              return;
            } else if (url2 === Constants.FORWARD_SLASH) {
              res.end(
                successTemplate ||
                  'Auth code was successfully acquired. You can close this window now.'
              );
              return;
            }
            const redirectUri = this.getRedirectUri();
            const parsedUrl = new URL(url2, redirectUri);
            const authCodeResponse =
              UrlUtils_exports.getDeserializedResponse(parsedUrl.search) || {};
            if (authCodeResponse.code) {
              res.writeHead(HttpStatus.REDIRECT, {
                location: redirectUri,
              });
              res.end();
            }
            if (authCodeResponse.error) {
              res.end(errorTemplate || `Error occurred: ${authCodeResponse.error}`);
            }
            resolve(authCodeResponse);
          });
          this.server.listen(0, '127.0.0.1');
        });
      }
      /**
       * Get the port that the loopback server is running on
       * @returns
       */
      getRedirectUri() {
        if (!this.server || !this.server.listening) {
          throw NodeAuthError.createNoLoopbackServerExistsError();
        }
        const address = this.server.address();
        if (!address || typeof address === 'string' || !address.port) {
          this.closeServer();
          throw NodeAuthError.createInvalidLoopbackAddressTypeError();
        }
        const port = address && address.port;
        return `${Constants2.HTTP_PROTOCOL}${Constants2.LOCALHOST}:${port}`;
      }
      /**
       * Close the loopback server
       */
      closeServer() {
        if (this.server) {
          this.server.close();
          if (typeof this.server.closeAllConnections === 'function') {
            this.server.closeAllConnections();
          }
          this.server.unref();
          this.server = void 0;
        }
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/client/DeviceCodeClient.mjs
var DeviceCodeClient;
var init_DeviceCodeClient = __esm({
  'node_modules/@azure/msal-node/dist/client/DeviceCodeClient.mjs'() {
    'use strict';
    init_index_node();
    DeviceCodeClient = class extends BaseClient {
      constructor(configuration) {
        super(configuration);
      }
      /**
       * Gets device code from device code endpoint, calls back to with device code response, and
       * polls token endpoint to exchange device code for tokens
       * @param request - developer provided CommonDeviceCodeRequest
       */
      async acquireToken(request) {
        const deviceCodeResponse = await this.getDeviceCode(request);
        request.deviceCodeCallback(deviceCodeResponse);
        const reqTimestamp = TimeUtils_exports.nowSeconds();
        const response = await this.acquireTokenWithDeviceCode(request, deviceCodeResponse);
        const responseHandler = new ResponseHandler(
          this.config.authOptions.clientId,
          this.cacheManager,
          this.cryptoUtils,
          this.logger,
          this.config.serializableCache,
          this.config.persistencePlugin
        );
        responseHandler.validateTokenResponse(response);
        return responseHandler.handleServerTokenResponse(
          response,
          this.authority,
          reqTimestamp,
          request
        );
      }
      /**
       * Creates device code request and executes http GET
       * @param request - developer provided CommonDeviceCodeRequest
       */
      async getDeviceCode(request) {
        const queryParametersString = this.createExtraQueryParameters(request);
        const endpoint = UrlString.appendQueryString(
          this.authority.deviceCodeEndpoint,
          queryParametersString
        );
        const queryString = this.createQueryString(request);
        const headers = this.createTokenRequestHeaders();
        const thumbprint = {
          clientId: this.config.authOptions.clientId,
          authority: request.authority,
          scopes: request.scopes,
          claims: request.claims,
          authenticationScheme: request.authenticationScheme,
          resourceRequestMethod: request.resourceRequestMethod,
          resourceRequestUri: request.resourceRequestUri,
          shrClaims: request.shrClaims,
          sshKid: request.sshKid,
        };
        return this.executePostRequestToDeviceCodeEndpoint(
          endpoint,
          queryString,
          headers,
          thumbprint,
          request.correlationId
        );
      }
      /**
       * Creates query string for the device code request
       * @param request - developer provided CommonDeviceCodeRequest
       */
      createExtraQueryParameters(request) {
        const parameters = /* @__PURE__ */ new Map();
        if (request.extraQueryParameters) {
          RequestParameterBuilder_exports.addExtraQueryParameters(
            parameters,
            request.extraQueryParameters
          );
        }
        return UrlUtils_exports.mapToQueryString(parameters);
      }
      /**
       * Executes POST request to device code endpoint
       * @param deviceCodeEndpoint - token endpoint
       * @param queryString - string to be used in the body of the request
       * @param headers - headers for the request
       * @param thumbprint - unique request thumbprint
       * @param correlationId - correlation id to be used in the request
       */
      async executePostRequestToDeviceCodeEndpoint(
        deviceCodeEndpoint,
        queryString,
        headers,
        thumbprint,
        correlationId
      ) {
        const {
          body: {
            user_code: userCode,
            device_code: deviceCode,
            verification_uri: verificationUri,
            expires_in: expiresIn,
            interval,
            message,
          },
        } = await this.sendPostRequest(
          thumbprint,
          deviceCodeEndpoint,
          {
            body: queryString,
            headers,
          },
          correlationId
        );
        return {
          userCode,
          deviceCode,
          verificationUri,
          expiresIn,
          interval,
          message,
        };
      }
      /**
       * Create device code endpoint query parameters and returns string
       * @param request - developer provided CommonDeviceCodeRequest
       */
      createQueryString(request) {
        const parameters = /* @__PURE__ */ new Map();
        RequestParameterBuilder_exports.addScopes(parameters, request.scopes);
        RequestParameterBuilder_exports.addClientId(parameters, this.config.authOptions.clientId);
        if (request.extraQueryParameters) {
          RequestParameterBuilder_exports.addExtraQueryParameters(
            parameters,
            request.extraQueryParameters
          );
        }
        if (
          request.claims ||
          (this.config.authOptions.clientCapabilities &&
            this.config.authOptions.clientCapabilities.length > 0)
        ) {
          RequestParameterBuilder_exports.addClaims(
            parameters,
            request.claims,
            this.config.authOptions.clientCapabilities
          );
        }
        return UrlUtils_exports.mapToQueryString(parameters);
      }
      /**
       * Breaks the polling with specific conditions
       * @param deviceCodeExpirationTime - expiration time for the device code request
       * @param userSpecifiedTimeout - developer provided timeout, to be compared against deviceCodeExpirationTime
       * @param userSpecifiedCancelFlag - boolean indicating the developer would like to cancel the request
       */
      continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, userSpecifiedCancelFlag) {
        if (userSpecifiedCancelFlag) {
          this.logger.error('Token request cancelled by setting DeviceCodeRequest.cancel = true');
          throw createClientAuthError(ClientAuthErrorCodes_exports.deviceCodePollingCancelled);
        } else if (
          userSpecifiedTimeout &&
          userSpecifiedTimeout < deviceCodeExpirationTime &&
          TimeUtils_exports.nowSeconds() > userSpecifiedTimeout
        ) {
          this.logger.error(
            `User defined timeout for device code polling reached. The timeout was set for ${userSpecifiedTimeout}`
          );
          throw createClientAuthError(ClientAuthErrorCodes_exports.userTimeoutReached);
        } else if (TimeUtils_exports.nowSeconds() > deviceCodeExpirationTime) {
          if (userSpecifiedTimeout) {
            this.logger.verbose(
              `User specified timeout ignored as the device code has expired before the timeout elapsed. The user specified timeout was set for ${userSpecifiedTimeout}`
            );
          }
          this.logger.error(
            `Device code expired. Expiration time of device code was ${deviceCodeExpirationTime}`
          );
          throw createClientAuthError(ClientAuthErrorCodes_exports.deviceCodeExpired);
        }
        return true;
      }
      /**
       * Creates token request with device code response and polls token endpoint at interval set by the device code response
       * @param request - developer provided CommonDeviceCodeRequest
       * @param deviceCodeResponse - DeviceCodeResponse returned by the security token service device code endpoint
       */
      async acquireTokenWithDeviceCode(request, deviceCodeResponse) {
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(
          this.authority.tokenEndpoint,
          queryParametersString
        );
        const requestBody = this.createTokenRequestBody(request, deviceCodeResponse);
        const headers = this.createTokenRequestHeaders();
        const userSpecifiedTimeout = request.timeout
          ? TimeUtils_exports.nowSeconds() + request.timeout
          : void 0;
        const deviceCodeExpirationTime =
          TimeUtils_exports.nowSeconds() + deviceCodeResponse.expiresIn;
        const pollingIntervalMilli = deviceCodeResponse.interval * 1e3;
        while (
          this.continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, request.cancel)
        ) {
          const thumbprint = {
            clientId: this.config.authOptions.clientId,
            authority: request.authority,
            scopes: request.scopes,
            claims: request.claims,
            authenticationScheme: request.authenticationScheme,
            resourceRequestMethod: request.resourceRequestMethod,
            resourceRequestUri: request.resourceRequestUri,
            shrClaims: request.shrClaims,
            sshKid: request.sshKid,
          };
          const response = await this.executePostToTokenEndpoint(
            endpoint,
            requestBody,
            headers,
            thumbprint,
            request.correlationId
          );
          if (response.body && response.body.error) {
            if (response.body.error === Constants.AUTHORIZATION_PENDING) {
              this.logger.info('Authorization pending. Continue polling.');
              await TimeUtils_exports.delay(pollingIntervalMilli);
            } else {
              this.logger.info('Unexpected error in polling from the server');
              throw createAuthError(AuthErrorCodes_exports.postRequestFailed, response.body.error);
            }
          } else {
            this.logger.verbose('Authorization completed successfully. Polling stopped.');
            return response.body;
          }
        }
        this.logger.error('Polling stopped for unknown reasons.');
        throw createClientAuthError(ClientAuthErrorCodes_exports.deviceCodeUnknownError);
      }
      /**
       * Creates query parameters and converts to string.
       * @param request - developer provided CommonDeviceCodeRequest
       * @param deviceCodeResponse - DeviceCodeResponse returned by the security token service device code endpoint
       */
      createTokenRequestBody(request, deviceCodeResponse) {
        const parameters = /* @__PURE__ */ new Map();
        RequestParameterBuilder_exports.addScopes(parameters, request.scopes);
        RequestParameterBuilder_exports.addClientId(parameters, this.config.authOptions.clientId);
        RequestParameterBuilder_exports.addGrantType(parameters, GrantType.DEVICE_CODE_GRANT);
        RequestParameterBuilder_exports.addDeviceCode(parameters, deviceCodeResponse.deviceCode);
        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        RequestParameterBuilder_exports.addCorrelationId(parameters, correlationId);
        RequestParameterBuilder_exports.addClientInfo(parameters);
        RequestParameterBuilder_exports.addLibraryInfo(parameters, this.config.libraryInfo);
        RequestParameterBuilder_exports.addApplicationTelemetry(
          parameters,
          this.config.telemetry.application
        );
        RequestParameterBuilder_exports.addThrottling(parameters);
        if (this.serverTelemetryManager) {
          RequestParameterBuilder_exports.addServerTelemetry(
            parameters,
            this.serverTelemetryManager
          );
        }
        if (
          !StringUtils.isEmptyObj(request.claims) ||
          (this.config.authOptions.clientCapabilities &&
            this.config.authOptions.clientCapabilities.length > 0)
        ) {
          RequestParameterBuilder_exports.addClaims(
            parameters,
            request.claims,
            this.config.authOptions.clientCapabilities
          );
        }
        return UrlUtils_exports.mapToQueryString(parameters);
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/client/PublicClientApplication.mjs
var PublicClientApplication;
var init_PublicClientApplication = __esm({
  'node_modules/@azure/msal-node/dist/client/PublicClientApplication.mjs'() {
    'use strict';
    init_Constants2();
    init_index_node();
    init_ClientApplication();
    init_NodeAuthError();
    init_LoopbackClient();
    init_DeviceCodeClient();
    init_packageMetadata2();
    PublicClientApplication = class extends ClientApplication {
      /**
       * Important attributes in the Configuration object for auth are:
       * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal.
       * - authority: the authority URL for your application.
       *
       * AAD authorities are of the form https://login.microsoftonline.com/\{Enter_the_Tenant_Info_Here\}.
       * - If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
       * - If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
       * - If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
       * - To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
       *
       * Azure B2C authorities are of the form https://\{instance\}/\{tenant\}/\{policy\}. Each policy is considered
       * its own authority. You will have to set the all of the knownAuthorities at the time of the client application
       * construction.
       *
       * ADFS authorities are of the form https://\{instance\}/adfs.
       */
      constructor(configuration) {
        super(configuration);
        if (this.config.broker.nativeBrokerPlugin) {
          if (this.config.broker.nativeBrokerPlugin.isBrokerAvailable) {
            this.nativeBrokerPlugin = this.config.broker.nativeBrokerPlugin;
            this.nativeBrokerPlugin.setLogger(this.config.system.loggerOptions);
          } else {
            this.logger.warning(
              'NativeBroker implementation was provided but the broker is unavailable.'
            );
          }
        }
        this.skus = ServerTelemetryManager.makeExtraSkuString({
          libraryName: Constants2.MSAL_SKU,
          libraryVersion: version3,
        });
      }
      /**
       * Acquires a token from the authority using OAuth2.0 device code flow.
       * This flow is designed for devices that do not have access to a browser or have input constraints.
       * The authorization server issues a DeviceCode object with a verification code, an end-user code,
       * and the end-user verification URI. The DeviceCode object is provided through a callback, and the end-user should be
       * instructed to use another device to navigate to the verification URI to input credentials.
       * Since the client cannot receive incoming requests, it polls the authorization server repeatedly
       * until the end-user completes input of credentials.
       */
      async acquireTokenByDeviceCode(request) {
        this.logger.info('acquireTokenByDeviceCode called', request.correlationId);
        const validRequest = Object.assign(request, await this.initializeBaseRequest(request));
        const serverTelemetryManager = this.initializeServerTelemetryManager(
          ApiId.acquireTokenByDeviceCode,
          validRequest.correlationId
        );
        try {
          const discoveredAuthority = await this.createAuthority(
            validRequest.authority,
            validRequest.correlationId,
            void 0,
            request.azureCloudOptions
          );
          const deviceCodeConfig = await this.buildOauthClientConfiguration(
            discoveredAuthority,
            validRequest.correlationId,
            '',
            serverTelemetryManager
          );
          const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);
          this.logger.verbose('Device code client created', validRequest.correlationId);
          return await deviceCodeClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires a token interactively via the browser by requesting an authorization code then exchanging it for a token.
       */
      async acquireTokenInteractive(request) {
        const correlationId = request.correlationId || this.cryptoProvider.createNewGuid();
        this.logger.trace('acquireTokenInteractive called', correlationId);
        const {
          openBrowser,
          successTemplate,
          errorTemplate,
          windowHandle,
          loopbackClient: customLoopbackClient,
          ...remainingProperties
        } = request;
        if (this.nativeBrokerPlugin) {
          const brokerRequest = {
            ...remainingProperties,
            clientId: this.config.auth.clientId,
            scopes: request.scopes || OIDC_DEFAULT_SCOPES,
            redirectUri: request.redirectUri || '',
            authority: request.authority || this.config.auth.authority,
            correlationId,
            extraParameters: {
              ...remainingProperties.extraQueryParameters,
              ...remainingProperties.tokenQueryParameters,
              [AADServerParamKeys_exports.X_CLIENT_EXTRA_SKU]: this.skus,
            },
            accountId: remainingProperties.account?.nativeAccountId,
          };
          return this.nativeBrokerPlugin.acquireTokenInteractive(brokerRequest, windowHandle);
        }
        if (request.redirectUri) {
          if (!this.config.broker.nativeBrokerPlugin) {
            throw NodeAuthError.createRedirectUriNotSupportedError();
          }
          request.redirectUri = '';
        }
        const { verifier, challenge } = await this.cryptoProvider.generatePkceCodes();
        const loopbackClient = customLoopbackClient || new LoopbackClient();
        let authCodeResponse = {};
        let authCodeListenerError = null;
        try {
          const authCodeListener = loopbackClient
            .listenForAuthCode(successTemplate, errorTemplate)
            .then((response) => {
              authCodeResponse = response;
            })
            .catch((e) => {
              authCodeListenerError = e;
            });
          const redirectUri = await this.waitForRedirectUri(loopbackClient);
          const validRequest = {
            ...remainingProperties,
            correlationId,
            scopes: request.scopes || OIDC_DEFAULT_SCOPES,
            redirectUri,
            responseMode: ResponseMode.QUERY,
            codeChallenge: challenge,
            codeChallengeMethod: CodeChallengeMethodValues.S256,
          };
          const authCodeUrl = await this.getAuthCodeUrl(validRequest);
          await openBrowser(authCodeUrl);
          await authCodeListener;
          if (authCodeListenerError) {
            throw authCodeListenerError;
          }
          if (authCodeResponse.error) {
            throw new ServerError(
              authCodeResponse.error,
              authCodeResponse.error_description,
              authCodeResponse.suberror
            );
          } else if (!authCodeResponse.code) {
            throw NodeAuthError.createNoAuthCodeInResponseError();
          }
          const clientInfo = authCodeResponse.client_info;
          const tokenRequest = {
            code: authCodeResponse.code,
            codeVerifier: verifier,
            clientInfo: clientInfo || Constants.EMPTY_STRING,
            ...validRequest,
          };
          return await this.acquireTokenByCode(tokenRequest);
        } finally {
          loopbackClient.closeServer();
        }
      }
      /**
       * Returns a token retrieved either from the cache or by exchanging the refresh token for a fresh access token. If brokering is enabled the token request will be serviced by the broker.
       * @param request - developer provided SilentFlowRequest
       * @returns
       */
      async acquireTokenSilent(request) {
        const correlationId = request.correlationId || this.cryptoProvider.createNewGuid();
        this.logger.trace('acquireTokenSilent called', correlationId);
        if (this.nativeBrokerPlugin) {
          const brokerRequest = {
            ...request,
            clientId: this.config.auth.clientId,
            scopes: request.scopes || OIDC_DEFAULT_SCOPES,
            redirectUri: request.redirectUri || '',
            authority: request.authority || this.config.auth.authority,
            correlationId,
            extraParameters: {
              ...request.tokenQueryParameters,
              [AADServerParamKeys_exports.X_CLIENT_EXTRA_SKU]: this.skus,
            },
            accountId: request.account.nativeAccountId,
            forceRefresh: request.forceRefresh || false,
          };
          return this.nativeBrokerPlugin.acquireTokenSilent(brokerRequest);
        }
        if (request.redirectUri) {
          if (!this.config.broker.nativeBrokerPlugin) {
            throw NodeAuthError.createRedirectUriNotSupportedError();
          }
          request.redirectUri = '';
        }
        return super.acquireTokenSilent(request);
      }
      /**
       * Removes cache artifacts associated with the given account
       * @param request - developer provided SignOutRequest
       * @returns
       */
      async signOut(request) {
        if (this.nativeBrokerPlugin && request.account.nativeAccountId) {
          const signoutRequest = {
            clientId: this.config.auth.clientId,
            accountId: request.account.nativeAccountId,
            correlationId: request.correlationId || this.cryptoProvider.createNewGuid(),
          };
          await this.nativeBrokerPlugin.signOut(signoutRequest);
        }
        await this.getTokenCache().removeAccount(request.account, request.correlationId);
      }
      /**
       * Returns all cached accounts for this application. If brokering is enabled this request will be serviced by the broker.
       * @returns
       */
      async getAllAccounts() {
        if (this.nativeBrokerPlugin) {
          const correlationId = this.cryptoProvider.createNewGuid();
          return this.nativeBrokerPlugin.getAllAccounts(this.config.auth.clientId, correlationId);
        }
        return this.getTokenCache().getAllAccounts();
      }
      /**
       * Attempts to retrieve the redirectUri from the loopback server. If the loopback server does not start listening for requests within the timeout this will throw.
       * @param loopbackClient - developer provided custom loopback server implementation
       * @returns
       */
      async waitForRedirectUri(loopbackClient) {
        return new Promise((resolve, reject) => {
          let ticks = 0;
          const id = setInterval(() => {
            if (
              LOOPBACK_SERVER_CONSTANTS.TIMEOUT_MS / LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS <
              ticks
            ) {
              clearInterval(id);
              reject(NodeAuthError.createLoopbackServerTimeoutError());
              return;
            }
            try {
              const r = loopbackClient.getRedirectUri();
              clearInterval(id);
              resolve(r);
              return;
            } catch (e) {
              if (
                e instanceof AuthError &&
                e.errorCode === NodeAuthErrorMessage.noLoopbackServerExists.code
              ) {
                ticks++;
                return;
              }
              clearInterval(id);
              reject(e);
              return;
            }
          }, LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS);
        });
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/client/ClientCredentialClient.mjs
var init_ClientCredentialClient = __esm({
  'node_modules/@azure/msal-node/dist/client/ClientCredentialClient.mjs'() {
    'use strict';
  },
});

// node_modules/@azure/msal-node/dist/client/OnBehalfOfClient.mjs
var init_OnBehalfOfClient = __esm({
  'node_modules/@azure/msal-node/dist/client/OnBehalfOfClient.mjs'() {
    'use strict';
    init_EncodingUtils();
  },
});

// node_modules/@azure/msal-node/dist/client/ConfidentialClientApplication.mjs
var init_ConfidentialClientApplication = __esm({
  'node_modules/@azure/msal-node/dist/client/ConfidentialClientApplication.mjs'() {
    'use strict';
    init_ClientApplication();
    init_ClientAssertion();
    init_Constants2();
    init_ClientCredentialClient();
    init_OnBehalfOfClient();
  },
});

// node_modules/@azure/msal-node/dist/utils/TimeUtils.mjs
function isIso8601(dateString) {
  if (typeof dateString !== 'string') {
    return false;
  }
  const date = new Date(dateString);
  return !isNaN(date.getTime()) && date.toISOString() === dateString;
}
var init_TimeUtils2 = __esm({
  'node_modules/@azure/msal-node/dist/utils/TimeUtils.mjs'() {
    'use strict';
  },
});

// node_modules/@azure/msal-node/dist/network/HttpClientWithRetries.mjs
var HttpClientWithRetries;
var init_HttpClientWithRetries = __esm({
  'node_modules/@azure/msal-node/dist/network/HttpClientWithRetries.mjs'() {
    'use strict';
    init_index_node();
    init_Constants2();
    HttpClientWithRetries = class {
      constructor(httpClientNoRetries, retryPolicy, logger4) {
        this.httpClientNoRetries = httpClientNoRetries;
        this.retryPolicy = retryPolicy;
        this.logger = logger4;
      }
      async sendNetworkRequestAsyncHelper(httpMethod, url2, options) {
        if (httpMethod === HttpMethod2.GET) {
          return this.httpClientNoRetries.sendGetRequestAsync(url2, options);
        } else {
          return this.httpClientNoRetries.sendPostRequestAsync(url2, options);
        }
      }
      async sendNetworkRequestAsync(httpMethod, url2, options) {
        let response = await this.sendNetworkRequestAsyncHelper(httpMethod, url2, options);
        if ('isNewRequest' in this.retryPolicy) {
          this.retryPolicy.isNewRequest = true;
        }
        let currentRetry = 0;
        while (
          await this.retryPolicy.pauseForRetry(
            response.status,
            currentRetry,
            this.logger,
            response.headers[HeaderNames.RETRY_AFTER]
          )
        ) {
          response = await this.sendNetworkRequestAsyncHelper(httpMethod, url2, options);
          currentRetry++;
        }
        return response;
      }
      async sendGetRequestAsync(url2, options) {
        return this.sendNetworkRequestAsync(HttpMethod2.GET, url2, options);
      }
      async sendPostRequestAsync(url2, options) {
        return this.sendNetworkRequestAsync(HttpMethod2.POST, url2, options);
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/BaseManagedIdentitySource.mjs
var ManagedIdentityUserAssignedIdQueryParameterNames, BaseManagedIdentitySource;
var init_BaseManagedIdentitySource = __esm({
  'node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/BaseManagedIdentitySource.mjs'() {
    'use strict';
    init_index_node();
    init_Constants2();
    init_ManagedIdentityError();
    init_TimeUtils2();
    init_HttpClientWithRetries();
    init_ManagedIdentityErrorCodes();
    ManagedIdentityUserAssignedIdQueryParameterNames = {
      MANAGED_IDENTITY_CLIENT_ID_2017: 'clientid',
      MANAGED_IDENTITY_CLIENT_ID: 'client_id',
      MANAGED_IDENTITY_OBJECT_ID: 'object_id',
      MANAGED_IDENTITY_RESOURCE_ID_IMDS: 'msi_res_id',
      MANAGED_IDENTITY_RESOURCE_ID_NON_IMDS: 'mi_res_id',
    };
    BaseManagedIdentitySource = class {
      constructor(logger4, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {
        this.logger = logger4;
        this.nodeStorage = nodeStorage;
        this.networkClient = networkClient;
        this.cryptoProvider = cryptoProvider;
        this.disableInternalRetries = disableInternalRetries;
      }
      async getServerTokenResponseAsync(
        response,
        _networkClient,
        _networkRequest,
        _networkRequestOptions
      ) {
        return this.getServerTokenResponse(response);
      }
      getServerTokenResponse(response) {
        let refreshIn, expiresIn;
        if (response.body.expires_on) {
          if (isIso8601(response.body.expires_on)) {
            response.body.expires_on = new Date(response.body.expires_on).getTime() / 1e3;
          }
          expiresIn = response.body.expires_on - TimeUtils_exports.nowSeconds();
          if (expiresIn > 2 * 3600) {
            refreshIn = expiresIn / 2;
          }
        }
        const serverTokenResponse = {
          status: response.status,
          // success
          access_token: response.body.access_token,
          expires_in: expiresIn,
          scope: response.body.resource,
          token_type: response.body.token_type,
          refresh_in: refreshIn,
          // error
          correlation_id: response.body.correlation_id || response.body.correlationId,
          error:
            typeof response.body.error === 'string'
              ? response.body.error
              : response.body.error?.code,
          error_description:
            response.body.message ||
            (typeof response.body.error === 'string'
              ? response.body.error_description
              : response.body.error?.message),
          error_codes: response.body.error_codes,
          timestamp: response.body.timestamp,
          trace_id: response.body.trace_id,
        };
        return serverTokenResponse;
      }
      async acquireTokenWithManagedIdentity(
        managedIdentityRequest,
        managedIdentityId,
        fakeAuthority,
        refreshAccessToken
      ) {
        const networkRequest = this.createRequest(
          managedIdentityRequest.resource,
          managedIdentityId
        );
        if (managedIdentityRequest.revokedTokenSha256Hash) {
          this.logger.info(
            `[Managed Identity] The following claims are present in the request: ${managedIdentityRequest.claims}`
          );
          networkRequest.queryParameters[ManagedIdentityQueryParameters.SHA256_TOKEN_TO_REFRESH] =
            managedIdentityRequest.revokedTokenSha256Hash;
        }
        if (managedIdentityRequest.clientCapabilities?.length) {
          const clientCapabilities = managedIdentityRequest.clientCapabilities.toString();
          this.logger.info(
            `[Managed Identity] The following client capabilities are present in the request: ${clientCapabilities}`
          );
          networkRequest.queryParameters[ManagedIdentityQueryParameters.XMS_CC] =
            clientCapabilities;
        }
        const headers = networkRequest.headers;
        headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
        const networkRequestOptions = { headers };
        if (Object.keys(networkRequest.bodyParameters).length) {
          networkRequestOptions.body = networkRequest.computeParametersBodyString();
        }
        const networkClientHelper = this.disableInternalRetries
          ? this.networkClient
          : new HttpClientWithRetries(this.networkClient, networkRequest.retryPolicy, this.logger);
        const reqTimestamp = TimeUtils_exports.nowSeconds();
        let response;
        try {
          if (networkRequest.httpMethod === HttpMethod2.POST) {
            response = await networkClientHelper.sendPostRequestAsync(
              networkRequest.computeUri(),
              networkRequestOptions
            );
          } else {
            response = await networkClientHelper.sendGetRequestAsync(
              networkRequest.computeUri(),
              networkRequestOptions
            );
          }
        } catch (error) {
          if (error instanceof AuthError) {
            throw error;
          } else {
            throw createClientAuthError(ClientAuthErrorCodes_exports.networkError);
          }
        }
        const responseHandler = new ResponseHandler(
          managedIdentityId.id,
          this.nodeStorage,
          this.cryptoProvider,
          this.logger,
          null,
          null
        );
        const serverTokenResponse = await this.getServerTokenResponseAsync(
          response,
          networkClientHelper,
          networkRequest,
          networkRequestOptions
        );
        responseHandler.validateTokenResponse(serverTokenResponse, refreshAccessToken);
        return responseHandler.handleServerTokenResponse(
          serverTokenResponse,
          fakeAuthority,
          reqTimestamp,
          managedIdentityRequest
        );
      }
      getManagedIdentityUserAssignedIdQueryParameterKey(
        managedIdentityIdType,
        isImds,
        usesApi2017
      ) {
        switch (managedIdentityIdType) {
          case ManagedIdentityIdType.USER_ASSIGNED_CLIENT_ID:
            this.logger.info(
              `[Managed Identity] [API version ${usesApi2017 ? '2017+' : '2019+'}] Adding user assigned client id to the request.`
            );
            return usesApi2017
              ? ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID_2017
              : ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID;
          case ManagedIdentityIdType.USER_ASSIGNED_RESOURCE_ID:
            this.logger.info('[Managed Identity] Adding user assigned resource id to the request.');
            return isImds
              ? ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_RESOURCE_ID_IMDS
              : ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_RESOURCE_ID_NON_IMDS;
          case ManagedIdentityIdType.USER_ASSIGNED_OBJECT_ID:
            this.logger.info('[Managed Identity] Adding user assigned object id to the request.');
            return ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_OBJECT_ID;
          default:
            throw createManagedIdentityError(invalidManagedIdentityIdType);
        }
      }
    };
    BaseManagedIdentitySource.getValidatedEnvVariableUrlString = (
      envVariableStringName,
      envVariable,
      sourceName,
      logger4
    ) => {
      try {
        return new UrlString(envVariable).urlString;
      } catch (error) {
        logger4.info(
          `[Managed Identity] ${sourceName} managed identity is unavailable because the '${envVariableStringName}' environment variable is malformed.`
        );
        throw createManagedIdentityError(
          MsiEnvironmentVariableUrlMalformedErrorCodes[envVariableStringName]
        );
      }
    };
  },
});

// node_modules/@azure/msal-node/dist/retry/LinearRetryStrategy.mjs
var init_LinearRetryStrategy = __esm({
  'node_modules/@azure/msal-node/dist/retry/LinearRetryStrategy.mjs'() {
    'use strict';
  },
});

// node_modules/@azure/msal-node/dist/retry/DefaultManagedIdentityRetryPolicy.mjs
var DEFAULT_MANAGED_IDENTITY_HTTP_STATUS_CODES_TO_RETRY_ON;
var init_DefaultManagedIdentityRetryPolicy = __esm({
  'node_modules/@azure/msal-node/dist/retry/DefaultManagedIdentityRetryPolicy.mjs'() {
    'use strict';
    init_dist();
    init_LinearRetryStrategy();
    DEFAULT_MANAGED_IDENTITY_HTTP_STATUS_CODES_TO_RETRY_ON = [
      HttpStatus.NOT_FOUND,
      HttpStatus.REQUEST_TIMEOUT,
      HttpStatus.TOO_MANY_REQUESTS,
      HttpStatus.SERVER_ERROR,
      HttpStatus.SERVICE_UNAVAILABLE,
      HttpStatus.GATEWAY_TIMEOUT,
    ];
  },
});

// node_modules/@azure/msal-node/dist/config/ManagedIdentityRequestParameters.mjs
var init_ManagedIdentityRequestParameters = __esm({
  'node_modules/@azure/msal-node/dist/config/ManagedIdentityRequestParameters.mjs'() {
    'use strict';
    init_DefaultManagedIdentityRetryPolicy();
  },
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/AppService.mjs
var init_AppService = __esm({
  'node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/AppService.mjs'() {
    'use strict';
    init_BaseManagedIdentitySource();
    init_Constants2();
    init_ManagedIdentityRequestParameters();
  },
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/AzureArc.mjs
var SUPPORTED_AZURE_ARC_PLATFORMS, AZURE_ARC_FILE_DETECTION;
var init_AzureArc = __esm({
  'node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/AzureArc.mjs'() {
    'use strict';
    init_ManagedIdentityRequestParameters();
    init_BaseManagedIdentitySource();
    init_ManagedIdentityError();
    init_Constants2();
    init_ManagedIdentityErrorCodes();
    SUPPORTED_AZURE_ARC_PLATFORMS = {
      win32: `${process.env['ProgramData']}\\AzureConnectedMachineAgent\\Tokens\\`,
      linux: '/var/opt/azcmagent/tokens/',
    };
    AZURE_ARC_FILE_DETECTION = {
      win32: `${process.env['ProgramFiles']}\\AzureConnectedMachineAgent\\himds.exe`,
      linux: '/opt/azcmagent/bin/himds',
    };
  },
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/CloudShell.mjs
var init_CloudShell = __esm({
  'node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/CloudShell.mjs'() {
    'use strict';
    init_ManagedIdentityRequestParameters();
    init_BaseManagedIdentitySource();
    init_Constants2();
    init_ManagedIdentityError();
    init_ManagedIdentityErrorCodes();
  },
});

// node_modules/@azure/msal-node/dist/retry/ExponentialRetryStrategy.mjs
var init_ExponentialRetryStrategy = __esm({
  'node_modules/@azure/msal-node/dist/retry/ExponentialRetryStrategy.mjs'() {
    'use strict';
  },
});

// node_modules/@azure/msal-node/dist/retry/ImdsRetryPolicy.mjs
var HTTP_STATUS_400_CODES_FOR_EXPONENTIAL_STRATEGY, HTTP_STATUS_GONE_RETRY_AFTER_MS;
var init_ImdsRetryPolicy = __esm({
  'node_modules/@azure/msal-node/dist/retry/ImdsRetryPolicy.mjs'() {
    'use strict';
    init_dist();
    init_ExponentialRetryStrategy();
    HTTP_STATUS_400_CODES_FOR_EXPONENTIAL_STRATEGY = [
      HttpStatus.NOT_FOUND,
      HttpStatus.REQUEST_TIMEOUT,
      HttpStatus.GONE,
      HttpStatus.TOO_MANY_REQUESTS,
    ];
    HTTP_STATUS_GONE_RETRY_AFTER_MS = 10 * 1e3;
  },
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/Imds.mjs
var IMDS_TOKEN_PATH, DEFAULT_IMDS_ENDPOINT;
var init_Imds = __esm({
  'node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/Imds.mjs'() {
    'use strict';
    init_ManagedIdentityRequestParameters();
    init_BaseManagedIdentitySource();
    init_Constants2();
    init_ImdsRetryPolicy();
    IMDS_TOKEN_PATH = '/metadata/identity/oauth2/token';
    DEFAULT_IMDS_ENDPOINT = `http://169.254.169.254${IMDS_TOKEN_PATH}`;
  },
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/ServiceFabric.mjs
var init_ServiceFabric = __esm({
  'node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/ServiceFabric.mjs'() {
    'use strict';
    init_ManagedIdentityRequestParameters();
    init_BaseManagedIdentitySource();
    init_Constants2();
  },
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/MachineLearning.mjs
var MANAGED_IDENTITY_MACHINE_LEARNING_UNSUPPORTED_ID_TYPE_ERROR;
var init_MachineLearning = __esm({
  'node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/MachineLearning.mjs'() {
    'use strict';
    init_BaseManagedIdentitySource();
    init_Constants2();
    init_ManagedIdentityRequestParameters();
    MANAGED_IDENTITY_MACHINE_LEARNING_UNSUPPORTED_ID_TYPE_ERROR = `Only client id is supported for user-assigned managed identity in ${ManagedIdentitySourceNames.MACHINE_LEARNING}.`;
  },
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentityClient.mjs
var init_ManagedIdentityClient = __esm({
  'node_modules/@azure/msal-node/dist/client/ManagedIdentityClient.mjs'() {
    'use strict';
    init_AppService();
    init_AzureArc();
    init_CloudShell();
    init_Imds();
    init_ServiceFabric();
    init_ManagedIdentityError();
    init_Constants2();
    init_MachineLearning();
    init_ManagedIdentityErrorCodes();
  },
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentityApplication.mjs
var SOURCES_THAT_SUPPORT_TOKEN_REVOCATION;
var init_ManagedIdentityApplication = __esm({
  'node_modules/@azure/msal-node/dist/client/ManagedIdentityApplication.mjs'() {
    'use strict';
    init_Configuration();
    init_packageMetadata2();
    init_CryptoProvider();
    init_ClientCredentialClient();
    init_ManagedIdentityClient();
    init_NodeStorage();
    init_Constants2();
    init_HashUtils();
    SOURCES_THAT_SUPPORT_TOKEN_REVOCATION = [ManagedIdentitySourceNames.SERVICE_FABRIC];
  },
});

// node_modules/@azure/msal-node/dist/cache/distributed/DistributedCachePlugin.mjs
var init_DistributedCachePlugin = __esm({
  'node_modules/@azure/msal-node/dist/cache/distributed/DistributedCachePlugin.mjs'() {
    'use strict';
  },
});

// node_modules/@azure/msal-node/dist/index.mjs
var init_dist2 = __esm({
  'node_modules/@azure/msal-node/dist/index.mjs'() {
    'use strict';
    init_internals();
    init_PublicClientApplication();
    init_ConfidentialClientApplication();
    init_ClientApplication();
    init_ClientCredentialClient();
    init_DeviceCodeClient();
    init_OnBehalfOfClient();
    init_ManagedIdentityApplication();
    init_UsernamePasswordClient();
    init_ClientAssertion();
    init_TokenCache();
    init_DistributedCachePlugin();
    init_Constants2();
    init_CryptoProvider();
    init_index_node();
    init_packageMetadata2();
  },
});

// src/auth/entraAuthProvider.ts
var entraAuthProvider_exports = {};
__export(entraAuthProvider_exports, {
  EntraAuthProvider: () => EntraAuthProvider,
});
var AZURE_DEVOPS_RESOURCE_ID, DEFAULT_BASE_SCOPES, OFFLINE_ACCESS_SCOPE, EntraAuthProvider;
var init_entraAuthProvider = __esm({
  'src/auth/entraAuthProvider.ts'() {
    'use strict';
    init_dist2();
    AZURE_DEVOPS_RESOURCE_ID = '499b84ac-1321-427f-aa17-267ca6975798';
    DEFAULT_BASE_SCOPES = [`${AZURE_DEVOPS_RESOURCE_ID}/.default`];
    OFFLINE_ACCESS_SCOPE = 'offline_access';
    EntraAuthProvider = class {
      config;
      secretStorage;
      connectionId;
      deviceCodeCallback;
      msalClient;
      cachedToken;
      refreshTokenKey;
      tokenCacheKey;
      // Refresh failure tracking to prevent constant retry attempts
      refreshFailureCount = 0;
      lastRefreshFailure;
      refreshBackoffUntil;
      maxRefreshFailures = 3;
      constructor(options) {
        this.config = options.config;
        this.secretStorage = options.secretStorage;
        this.connectionId = options.connectionId;
        this.deviceCodeCallback = options.deviceCodeCallback;
        this.refreshTokenKey = `azureDevOpsInt.entra.refreshToken.${this.connectionId}`;
        this.tokenCacheKey = `azureDevOpsInt.entra.tokenCache.${this.connectionId}`;
        const msalConfig = {
          auth: {
            clientId: this.config.clientId,
            authority: this.getAuthority(),
          },
          cache: {
            cachePlugin: this.createCachePlugin(),
          },
          system: {
            loggerOptions: {
              loggerCallback: (level, message, containsPii) => {
                if (containsPii) return;
                console.log(`[MSAL][${level}]`, message);
              },
              piiLoggingEnabled: false,
              logLevel: LogLevel3.Warning,
            },
          },
        };
        this.msalClient = new PublicClientApplication(msalConfig);
      }
      // Removed TokenLifecycleManager-specific methods
      /**
       * Get the authority URL for MSAL
       */
      getAuthority() {
        const tenantId = this.config.tenantId || 'organizations';
        console.log('[EntraAuthProvider] Using authority tenant:', tenantId);
        return `https://login.microsoftonline.com/${tenantId}`;
      }
      /**
       * Resolve requested scopes, ensuring offline_access is always included
       */
      resolveScopes() {
        const configuredScopes =
          Array.isArray(this.config.scopes) && this.config.scopes.length > 0
            ? this.config.scopes
            : DEFAULT_BASE_SCOPES;
        const scopeSet = /* @__PURE__ */ new Set();
        for (const scope of configuredScopes) {
          if (typeof scope === 'string') {
            const trimmed = scope.trim();
            if (trimmed.length > 0) {
              scopeSet.add(trimmed);
            }
          }
        }
        scopeSet.add(OFFLINE_ACCESS_SCOPE);
        return Array.from(scopeSet);
      }
      /**
       * Create a cache plugin that persists the MSAL token cache in secret storage
       */
      createCachePlugin() {
        return {
          beforeCacheAccess: async (context) => {
            try {
              const serialized = await this.secretStorage.get(this.tokenCacheKey);
              if (serialized) {
                context.tokenCache.deserialize(serialized);
              }
            } catch (error) {
              console.error('[EntraAuthProvider] Failed to load token cache:', error);
            }
          },
          afterCacheAccess: async (context) => {
            if (!context.cacheHasChanged) {
              return;
            }
            try {
              const serialized = context.tokenCache.serialize();
              await this.secretStorage.store(this.tokenCacheKey, serialized);
            } catch (error) {
              console.error('[EntraAuthProvider] Failed to persist token cache:', error);
            }
          },
        };
      }
      /**
       * Authenticate using device code flow (v1.9.3 proven approach)
       */
      async authenticate() {
        try {
          const scopes = this.resolveScopes();
          const silentResult = await this.trySilentAuthentication(scopes);
          if (silentResult.success) {
            this.refreshFailureCount = 0;
            this.lastRefreshFailure = void 0;
            this.refreshBackoffUntil = void 0;
            return silentResult;
          }
          const deviceCodeRequest = {
            deviceCodeCallback: async (response2) => {
              if (this.deviceCodeCallback) {
                await this.deviceCodeCallback(
                  response2.deviceCode,
                  response2.userCode,
                  response2.verificationUri,
                  response2.expiresIn
                );
              }
            },
            scopes,
          };
          const response = await this.msalClient.acquireTokenByDeviceCode(deviceCodeRequest);
          if (!response) {
            return {
              success: false,
              error: 'Failed to acquire token via device code flow',
            };
          }
          this.cachedToken = {
            accessToken: response.accessToken,
            expiresAt: response.expiresOn || new Date(Date.now() + 3600 * 1e3),
            scopes: response.scopes,
          };
          if (response.account) {
            const account = response.account;
            await this.storeAccount(account);
          }
          this.refreshFailureCount = 0;
          this.lastRefreshFailure = void 0;
          this.refreshBackoffUntil = void 0;
          return {
            success: true,
            accessToken: response.accessToken,
            expiresAt: response.expiresOn || void 0,
          };
        } catch (error) {
          console.error('[EntraAuthProvider] Authentication failed:', error);
          return {
            success: false,
            error: error.message || 'Authentication failed',
          };
        }
      }
      /**
       * Try silent authentication using cached account
       */
      async trySilentAuthentication(scopes) {
        try {
          let account = await this.getStoredAccount();
          if (!account) {
            try {
              const accounts = await this.msalClient.getTokenCache().getAllAccounts();
              account = accounts[0];
            } catch (cacheError) {
              console.error('[EntraAuthProvider] Failed to read accounts from cache:', cacheError);
            }
          }
          if (!account) {
            return { success: false, error: 'No cached account found' };
          }
          const silentRequest = {
            account,
            scopes,
            forceRefresh: false,
          };
          const response = await this.msalClient.acquireTokenSilent(silentRequest);
          if (!response) {
            return { success: false, error: 'Silent token acquisition returned no response' };
          }
          this.cachedToken = {
            accessToken: response.accessToken,
            expiresAt: response.expiresOn || new Date(Date.now() + 3600 * 1e3),
            scopes: response.scopes,
          };
          return {
            success: true,
            accessToken: response.accessToken,
            expiresAt: response.expiresOn || void 0,
          };
        } catch (error) {
          return { success: false, error: error.message };
        }
      }
      /**
       * Get a valid access token (from cache or by refreshing)
       */
      async getAccessToken() {
        if (this.cachedToken && this.cachedToken.expiresAt > new Date(Date.now() + 5 * 60 * 1e3)) {
          return this.cachedToken.accessToken;
        }
        const result = await this.refreshAccessToken();
        if (result.success && result.accessToken) {
          return result.accessToken;
        }
        return void 0;
      }
      /**
       * Refresh the access token using silent flow
       */
      async refreshAccessToken() {
        const scopes = this.resolveScopes();
        return this.trySilentAuthentication(scopes);
      }
      /**
       * Sign out and clear cached credentials
       */
      async signOut() {
        this.cachedToken = void 0;
        await this.secretStorage.delete(this.refreshTokenKey);
        await this.secretStorage.delete(this.tokenCacheKey);
        const accounts = await this.msalClient.getTokenCache().getAllAccounts();
        for (const account of accounts) {
          await this.msalClient.getTokenCache().removeAccount(account);
        }
      }
      /**
       * Reset token cache
       */
      async resetToken() {
        this.cachedToken = void 0;
        this.refreshFailureCount = 0;
        this.lastRefreshFailure = void 0;
        this.refreshBackoffUntil = void 0;
        try {
          await this.secretStorage.delete(this.tokenCacheKey);
          await this.secretStorage.delete(this.refreshTokenKey);
          const accounts = await this.msalClient.getTokenCache().getAllAccounts();
          for (const account of accounts) {
            await this.msalClient.getTokenCache().removeAccount(account);
          }
          console.log('[EntraAuthProvider] Token cache completely reset', {
            connectionId: this.connectionId,
            clearedAccounts: accounts.length,
          });
        } catch (error) {
          console.error('[EntraAuthProvider] Failed to clear token cache:', error);
        }
      }
      /**
       * Check if currently authenticated
       */
      async isAuthenticated() {
        try {
          const token = await this.getAccessToken();
          return !!token;
        } catch {
          return false;
        }
      }
      /**
       * Get token expiration info
       */
      async getTokenInfo() {
        if (!this.cachedToken) {
          await this.getAccessToken();
        }
        return this.cachedToken;
      }
      /**
       * Store account info securely
       */
      async storeAccount(account) {
        try {
          await this.secretStorage.store(this.refreshTokenKey, JSON.stringify(account));
        } catch (error) {
          console.error('[EntraAuthProvider] Failed to store account:', error);
        }
      }
      /**
       * Retrieve stored account info
       */
      async getStoredAccount() {
        try {
          const accountJson = await this.secretStorage.get(this.refreshTokenKey);
          if (!accountJson) {
            return void 0;
          }
          return JSON.parse(accountJson);
        } catch (error) {
          console.error('[EntraAuthProvider] Failed to retrieve account:', error);
          return void 0;
        }
      }
    };
  },
});

// src/fsm/functions/azureClientFunctions.ts
var azureClientFunctions_exports = {};
__export(azureClientFunctions_exports, {
  createAzureClient: () => createAzureClient,
  normalizeConnectionConfig: () => normalizeConnectionConfig,
  testClientConnectivity: () => testClientConnectivity,
  validateClientConfig: () => validateClientConfig,
});
async function getLoggerModule() {
  if (!loggerModulePromise) {
    loggerModulePromise = Promise.resolve().then(() => (init_FSMLogger(), FSMLogger_exports));
  }
  return loggerModulePromise;
}
async function getConnectionLogger(connectionId) {
  const { FSMComponent: FSMComponent2, fsmLogger: fsmLogger2 } = await getLoggerModule();
  return {
    FSMComponent: FSMComponent2,
    fsmLogger: fsmLogger2,
    fsmContext: { component: FSMComponent2.CONNECTION, connectionId },
  };
}
async function validateClientConfig(context) {
  const {
    FSMComponent: FSMComponent2,
    fsmLogger: fsmLogger2,
    fsmContext,
  } = await getConnectionLogger(context.connectionId);
  fsmLogger2.debug(FSMComponent2.CONNECTION, 'Validating client configuration', fsmContext, {
    hasCredential: !!context.credential,
    hasConfig: !!context.config,
    organization: context.config.organization,
    project: context.config.project,
  });
  const errors = [];
  const project = context.config.project?.trim();
  let organization = context.config.organization?.trim();
  if (!context.credential) {
    errors.push('No credential available');
  }
  if (!project) {
    errors.push('Project not specified');
  }
  const baseUrl = sanitizeUrl(context.config.baseUrl);
  const apiBaseUrl = sanitizeUrl(context.config.apiBaseUrl);
  if (context.config.baseUrl && baseUrl !== context.config.baseUrl) {
    fsmLogger2.debug(
      FSMComponent2.CONNECTION,
      'Normalized baseUrl for client configuration',
      fsmContext,
      {
        original: context.config.baseUrl,
        normalized: baseUrl,
      }
    );
  }
  if (context.config.apiBaseUrl && apiBaseUrl !== context.config.apiBaseUrl) {
    fsmLogger2.debug(
      FSMComponent2.CONNECTION,
      'Normalized apiBaseUrl for client configuration',
      fsmContext,
      {
        original: context.config.apiBaseUrl,
        normalized: apiBaseUrl,
      }
    );
  }
  const derivedOrganization = resolveOrganizationName({
    organization,
    project,
    baseUrl,
    apiBaseUrl,
  });
  if (!organization || organization.length === 0) {
    if (derivedOrganization) {
      organization = derivedOrganization;
    }
  } else if (
    derivedOrganization &&
    project &&
    organization.toLowerCase() === project.toLowerCase() &&
    derivedOrganization.toLowerCase() !== organization.toLowerCase()
  ) {
    fsmLogger2.info(
      FSMComponent2.CONNECTION,
      'Organization name matched project; using derived organization from URL',
      fsmContext,
      {
        originalOrganization: organization,
        derivedOrganization,
        project,
      }
    );
    organization = derivedOrganization;
  }
  if (!organization) {
    errors.push('Organization not specified');
  }
  if (errors.length > 0) {
    fsmLogger2.warn(
      FSMComponent2.CONNECTION,
      'Client configuration validation failed',
      fsmContext,
      { errors }
    );
    return { isValid: false, errors, context };
  }
  const safeOrganization = organization;
  const safeProject = project;
  const config = {
    organization: safeOrganization,
    project: safeProject,
    credential: context.credential,
    options: {
      ratePerSecond: 10,
      // Default rate limiting
      burst: 20,
      team: context.config.team,
      baseUrl,
      apiBaseUrl,
      authType: context.config.authMethod === 'entra' ? 'bearer' : 'pat',
      identityName: context.config.identityName,
      // onAuthFailure will be set by FSM
    },
  };
  fsmLogger2.debug(
    FSMComponent2.CONNECTION,
    'Client configuration validated successfully',
    fsmContext,
    {
      authType: config.options.authType,
      hasTeam: !!config.options.team,
      hasBaseUrl: !!config.options.baseUrl,
    }
  );
  return { isValid: true, config, context };
}
async function createAzureClient(context, config) {
  const {
    FSMComponent: FSMComponent2,
    fsmLogger: fsmLogger2,
    fsmContext,
  } = await getConnectionLogger(context.connectionId);
  fsmLogger2.debug(FSMComponent2.CONNECTION, 'Creating Azure DevOps client', fsmContext, {
    organization: config.organization,
    project: config.project,
    authType: config.options.authType,
    hasBaseUrl: !!config.options.baseUrl,
  });
  try {
    const { AzureDevOpsIntClient: AzureDevOpsIntClient2 } = await Promise.resolve().then(
      () => (init_azureClient2(), azureClient_exports)
    );
    const client2 = new AzureDevOpsIntClient2(
      config.organization,
      config.project,
      config.credential,
      config.options
    );
    fsmLogger2.info(
      FSMComponent2.CONNECTION,
      'Azure DevOps client created successfully',
      fsmContext,
      {
        organization: config.organization,
        project: config.project,
        authType: config.options.authType,
      }
    );
    return { client: client2, config, context };
  } catch (error) {
    fsmLogger2.error(FSMComponent2.CONNECTION, 'Failed to create Azure DevOps client', fsmContext, {
      error: error instanceof Error ? error.message : String(error),
      organization: config.organization,
      project: config.project,
    });
    throw error;
  }
}
async function testClientConnectivity(context, client2) {
  const {
    FSMComponent: FSMComponent2,
    fsmLogger: fsmLogger2,
    fsmContext,
  } = await getConnectionLogger(context.connectionId);
  fsmLogger2.debug(FSMComponent2.CONNECTION, 'Testing client connectivity', fsmContext);
  try {
    const userId = await client2.getAuthenticatedUserId();
    if (userId) {
      fsmLogger2.info(FSMComponent2.CONNECTION, 'Client connectivity test successful', fsmContext, {
        userId,
      });
      return { success: true, userId, context };
    } else {
      fsmLogger2.warn(
        FSMComponent2.CONNECTION,
        'Client connectivity test failed - no user ID',
        fsmContext
      );
      return { success: false, error: 'Unable to authenticate user', context };
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    fsmLogger2.error(FSMComponent2.CONNECTION, 'Client connectivity test failed', fsmContext, {
      error: errorMessage,
    });
    return { success: false, error: errorMessage, context };
  }
}
function normalizeConnectionConfig(rawConfig) {
  const errors = [];
  if (!rawConfig) {
    errors.push('Configuration is required');
    return { isValid: false, errors };
  }
  const organization = rawConfig.organization?.trim();
  const project = rawConfig.project?.trim();
  if (!organization) {
    errors.push('Organization is required');
  }
  if (!project) {
    errors.push('Project is required');
  }
  if (errors.length > 0) {
    return { isValid: false, errors };
  }
  const config = {
    organization,
    project,
    team: rawConfig.team?.trim(),
    baseUrl: rawConfig.baseUrl?.trim(),
    apiBaseUrl: rawConfig.apiBaseUrl?.trim(),
    authMethod: rawConfig.authMethod || 'pat',
    tenantId: rawConfig.tenantId?.trim(),
    identityName: rawConfig.identityName?.trim(),
  };
  return { isValid: true, config };
}
function sanitizeUrl(raw) {
  if (!raw) {
    return void 0;
  }
  const trimmed = raw.trim().replace(/\/+$/, '');
  try {
    const parsed = new URL(trimmed);
    parsed.pathname = parsed.pathname
      .split('/')
      .map((segment) => {
        if (!segment) {
          return segment;
        }
        try {
          return encodeURIComponent(decodeURIComponent(segment));
        } catch {
          return encodeURIComponent(segment);
        }
      })
      .join('/');
    return parsed.toString().replace(/\/$/, '');
  } catch {
    return encodeURI(trimmed);
  }
}
function resolveOrganizationName(params) {
  const { organization, project, baseUrl, apiBaseUrl } = params;
  const candidates = [
    organization?.trim(),
    extractOrganizationFromUrl(baseUrl),
    extractOrganizationFromUrl(apiBaseUrl),
  ];
  const normalized = candidates
    .map((value) => (value ? value.trim() : void 0))
    .filter((value) => !!value && value.length > 0);
  if (normalized.length === 0) {
    return void 0;
  }
  if (!project) {
    return normalized[0];
  }
  const projectLower = project.toLowerCase();
  for (const candidate of normalized) {
    if (candidate.toLowerCase() !== projectLower) {
      return candidate;
    }
  }
  return normalized[0];
}
function extractOrganizationFromUrl(raw) {
  if (!raw) {
    return void 0;
  }
  try {
    const parsed = new URL(raw);
    const host = parsed.hostname.toLowerCase();
    if (host.endsWith('.visualstudio.com')) {
      return host.replace('.visualstudio.com', '');
    }
    if (host === 'dev.azure.com') {
      const segments = parsed.pathname.split('/').filter(Boolean);
      if (segments.length > 0) {
        return decodeURIComponent(segments[0]);
      }
    }
  } catch {}
  return void 0;
}
var loggerModulePromise;
var init_azureClientFunctions = __esm({
  'src/fsm/functions/azureClientFunctions.ts'() {
    'use strict';
  },
});

// src/fsm/machines/connectionMachine.ts
async function discoverTenantFromOrganization(organizationUrl) {
  const context = { component: 'AUTH' /* AUTH */, connectionId: 'tenant-discovery' };
  try {
    logger3.debug('Starting enhanced tenant discovery', context, { organizationUrl });
    let orgName;
    if (organizationUrl.includes('dev.azure.com')) {
      const match = organizationUrl.match(/https?:\/\/dev\.azure\.com\/([^\/]+)/);
      orgName = match?.[1] || '';
      logger3.debug('Parsed organization from dev.azure.com format', context, {
        orgName,
        pattern: 'dev.azure.com',
      });
    } else if (organizationUrl.includes('visualstudio.com')) {
      const match = organizationUrl.match(/https?:\/\/([^\.]+)\.visualstudio\.com/);
      orgName = match?.[1] || '';
      logger3.debug('Parsed organization from visualstudio.com format', context, {
        orgName,
        pattern: 'visualstudio.com',
      });
    } else {
      logger3.warn('Unsupported organization URL format', context, { organizationUrl });
      return null;
    }
    if (!orgName) {
      logger3.warn('Could not extract organization name from URL', context, { organizationUrl });
      return null;
    }
    logger3.info('Extracted organization name for tenant discovery', context, {
      orgName,
      organizationUrl,
    });
    const vsspsResult = await tryVSSpsTenantDiscovery(orgName, context);
    if (vsspsResult) {
      logger3.info('\u2705 Tenant discovered via VSSPS API', context, {
        tenantId: vsspsResult,
        orgName,
      });
      return vsspsResult;
    }
    const restApiResult = await tryRestApiTenantDiscovery(organizationUrl, orgName, context);
    if (restApiResult) {
      logger3.info('\u2705 Tenant discovered via REST API', context, {
        tenantId: restApiResult,
        orgName,
      });
      return restApiResult;
    }
    const armResult = await tryArmTenantDiscovery(orgName, context);
    if (armResult) {
      logger3.info('\u2705 Tenant discovered via ARM API', context, {
        tenantId: armResult,
        orgName,
      });
      return armResult;
    }
    logger3.warn('\u274C All tenant discovery methods failed', context, {
      orgName,
      organizationUrl,
      message:
        'Organization might be private, use personal account, or require different tenant setup',
    });
    return null;
  } catch (error) {
    logger3.error('Tenant discovery failed with exception', context, {
      error: error instanceof Error ? error.message : String(error),
      organizationUrl,
    });
    return null;
  }
}
async function tryVSSpsTenantDiscovery(orgName, context) {
  try {
    const discoveryUrl = `https://app.vssps.visualstudio.com/_apis/organization/${orgName}/tenantinfo`;
    logger3.debug('Trying VSSPS tenant discovery', context, { discoveryUrl, orgName });
    const response = await fetch(discoveryUrl, {
      method: 'GET',
      headers: {
        Accept: 'application/json',
        'User-Agent': 'AzureDevOpsIntegration-VSCode',
      },
    });
    if (!response.ok) {
      logger3.debug('VSSPS tenant discovery failed', context, {
        status: response.status,
        statusText: response.statusText,
        reason: response.status === 404 ? 'Organization not found or private' : 'API error',
      });
      return null;
    }
    const data = await response.json();
    const tenantId = data?.tenantId;
    if (tenantId && typeof tenantId === 'string' && tenantId.trim() !== '') {
      return tenantId.trim();
    }
    logger3.debug('VSSPS API returned no valid tenant ID', context, { responseData: data });
    return null;
  } catch (error) {
    logger3.debug('VSSPS tenant discovery error', context, {
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}
async function tryRestApiTenantDiscovery(organizationUrl, orgName, context) {
  try {
    const apiUrl = `${organizationUrl}/_apis/connectionData`;
    logger3.debug('Trying REST API tenant discovery', context, { apiUrl, orgName });
    const response = await fetch(apiUrl, {
      method: 'GET',
      headers: {
        Accept: 'application/json',
        'User-Agent': 'AzureDevOpsIntegration-VSCode',
      },
    });
    if (!response.ok) {
      logger3.debug('REST API tenant discovery failed', context, {
        status: response.status,
        statusText: response.statusText,
      });
      return null;
    }
    const data = await response.json();
    const authenticatedUser = data?.authenticatedUser;
    const tenantId = authenticatedUser?.descriptor?.split(';')[0];
    if (tenantId && typeof tenantId === 'string' && tenantId.includes('-')) {
      logger3.debug('Found potential tenant ID in connection data', context, { tenantId });
      return tenantId;
    }
    logger3.debug('REST API returned no valid tenant ID', context, { responseData: data });
    return null;
  } catch (error) {
    logger3.debug('REST API tenant discovery error', context, {
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}
async function tryArmTenantDiscovery(orgName, context) {
  try {
    const armUrl = `https://management.azure.com/tenants?api-version=2020-01-01`;
    logger3.debug('Trying ARM tenant discovery', context, { armUrl, orgName });
    const response = await fetch(armUrl, {
      method: 'GET',
      headers: {
        Accept: 'application/json',
        'User-Agent': 'AzureDevOpsIntegration-VSCode',
      },
    });
    if (!response.ok) {
      logger3.debug('ARM tenant discovery failed (expected)', context, {
        status: response.status,
        reason: 'ARM API requires authentication',
      });
      return null;
    }
    logger3.debug('ARM API accessible but cannot match org to tenant', context);
    return null;
  } catch (error) {
    logger3.debug('ARM tenant discovery error (expected)', context, {
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}
var logger3,
  AZURE_DEVOPS_PUBLIC_CLIENT_ID,
  AZURE_DEVOPS_SCOPE,
  normalizeExpiryToMs,
  connectionMachine2;
var init_connectionMachine = __esm({
  'src/fsm/machines/connectionMachine.ts'() {
    'use strict';
    init_xstate_esm();
    init_FSMLogger();
    init_authFunctions();
    init_extensionHostBridge();
    logger3 = createComponentLogger('CONNECTION' /* CONNECTION */, 'connectionMachine');
    AZURE_DEVOPS_PUBLIC_CLIENT_ID = '872cd9fa-d31f-45e0-9eab-6e460a02d1f1';
    AZURE_DEVOPS_SCOPE = '499b84ac-1321-427f-aa17-267ca6975798/.default';
    normalizeExpiryToMs = (expiresAt) => {
      if (!expiresAt) {
        return void 0;
      }
      if (expiresAt instanceof Date) {
        return expiresAt.getTime();
      }
      if (typeof expiresAt === 'number') {
        return Number.isFinite(expiresAt) ? expiresAt : void 0;
      }
      if (typeof expiresAt === 'string') {
        const parsed = Date.parse(expiresAt);
        return Number.isNaN(parsed) ? void 0 : parsed;
      }
      return void 0;
    };
    connectionMachine2 = createMachine(
      {
        /** @xstate-layout N4IgpgJg5mDOIC5QGMD2A7dZkBcCWGAdBHrGptjpAMQDCA8gHKMCitAKgNoAMAuoqAAOqWHnwYBIAB6IAjACYAbPMIB2AJyaAHAGZuOnfIAsmgDQgAnokWyArIXW2tt1d3VHus10YC+P8+RYuAToxKSBlDQASiwAyixcfJLCouLokjIICsZqxupaqoo6Rfq25lYIJlpq3NzyOrJe8ty28rJ+ARhBaYQAhgCuOAAWYOj4yL346FDEYFQATgC2eOgrUAD6i3NDqBDUPPxIICliIRlyih4Omtpass6qsuWIWtxGNQ+Oiuqu6vIdIAiwSIA2Go3GkzWswWy1W002212+1khyEIlOEiOmVkl241xuWjuDyelkQqls6kItm4n10tlk6haAKBPVBIzGeAmUxmgkm6zZ1AgGDAhBWADdUABrEUskJ9QbsiHcwi8nD8hUIcWoLkhA4HZLotLnBDGLTvQryWyKWw6amEsqkhCaVRU6mWozFTTNdTMrqUOVs8GcyHTFV8gVgebzVDzFUAG0mADMY4tCLKQQqgzrQ6r1cNNegJTqMHqkkcTkasYhTeblFabXbnM8nW9CLJakpFF3jDZfRRgaFAxzszNwfNenmhmmRshJWt1mApKRuescFLRoLhaLC+u036B-KwcOQ6OxuPJ9PsHP4Yvl-O19L0AWi5CS3x9eXDWcqyajGa1HW1q2jSTaOrIhiKFSuiKNwhTqLIJjyKofbdAGmbHsqY4Tmyl6zvOt6wCuD4bkKWDbhK0p7v2rLoUqUJYReyAzteGwEUR65PlqxboHqKIGqk36gNicGEPoqh-uolzyFo9RGM22SyIQdY9qoxQ4sh-iAvuNFHnRoYMThTFXvhS6EfeHHUJG0axoICY4MmSxUahGa6cGmFnthCq4SxC6mexj7Ptqr48e+ZZogJmJCXIIliRJUkyToclgV47x-K0Tj5DYbgof6LmKm59EeReKwLL0wRimAk6bmRWqUemg60QV+lFThJWRmV+AVZOgXcaWqLHF+kXSNWf61paQGNg6FSNFolJ-sUtSeDYKU5QeQ56aeODnq1YzteVlURlGMbxkmKZOblDWuSOhAGV5bXjvt3VccFfX8Ri6Q-jWAHjQ2IFTXIbiQfoan1DS1riatPTIPMYAnusyBxng4LVSKtUytpcrQ7DK4I0jYw9S9oX9RWgnDQgyjNqa1SEraiiEiYRR2JDmMw3DuPI1Zx22adjn1WmrM44j4IE2kr2fhFH1ReTLRKeSi2STojKqPJTgqDaC0uEhloIczRBY3DgjRmKeAQJGKPkbufP6yuhuoMbpvzCLupE29lZS7aOiuot2Q0vcWjyVoXYOHS6iJYljzgbroTW-Otv22bnM2XZDmplbAux0bJuRk7b68B+4XvcaqjyJTzTvB6tp3AhbSPLYUfnbgNAACIAJKxAwzBsIkxODZLZNh17tQ+0S-uOtSnvtnUC3cNaTiKPXLI0B3rAcC3TDrAAYgAgi3AAyLBN-nA0S8aHuD548jNCP8nFJ7BgLToGiqLoOgL9pNDsPQADSLCMOsLAAA0AAKLcYiHzCsfQuP577n2Hn7ZsRgbSEA8FPWCBQPT5DftRaILAN4xFiAACXWFvAAquwAhR8SZDUyIYT2thqRD0vr7QkzZbQukcJ4cCDIWgyX+JpPmbJ1iJl6HgOMOD2BRAAJqUN7saBCNJCC6HEqoDQrQ-zgWbFaSClpnCvF0aHek9dBHCNEUvJgK9u6u1JtiMSyCTD5CqB4GCJcwJ-iBiHVSjNQ7z34RjPKQiRFiL2K3du5iu4yJPj+cC+RFGPyMCoxwpoNGOhMPYGCzg6YGBno0BeQsxgBNMXsGIEjpEQKoX3TIME0ly1qArJW8lxKQSKLaRkMl6StD4Z0aimM8lqhMUEugYSOARKgVLCk1SGGA0VrBeSo1RJOApB6GwgdpK5Lxn0wJzc27L3CWU2RP4Fmy0mXUmZrjEqEErhlau4kjCdK0t0ogccs7zAKQM4pUiRluzJioxSsFqTwWfvUcS6gA4qAMDcJwbDEpvHrk8h2ryzGd2GXsyJUtn6-LlgChKwLKaGFEigzwLQ-ytDNLCzO8L+lbNCUiyx4tRnfLuKJTFXhsUmEpoy8Si1lCqR+DiV+viHnRz8egBcR15jUHeaUnuqKyZtLbHWThjhyTiWbM-T2PCXBdncF2ZwWDnIisToMmlnzrEvEtPKy0iqXAuCStNHQ-5rS6MVvUOsvgBX6obmkUV1lqAhJ2ci6V9LMh3HsDiS1jQlU2ubMoT2iCp6BxxDNeuxERUw0TDDWAQxzZo09XKFN6w00ZqGDnEKecUVBsQA0Ohky4EsMdEod4DCFC2HmtkS0yaOIFrAOmuAWbE4nXsmdPm+bC29pLWLAuXzMhyypN7RQniKQuIqAYao1qFAMiMJcRobrNLoF2HASQ9UrHUMQAAWkUM2Rw+LaiqUaAock7h64kDIO-CAx6KkAwUHY7QjiZ51GjbUNsbpFY2iypoIxjURzvrkc62JyjVFJJ0NG4uhAr5umaUYHEbqukevWk1GYpsYQrHnFsYYuxoNRKMB6OD8SEPqKQ46QonsVHpXGroGSEGronjDGqNkFGpYITpjRhJai7gMYqPkRSrSXChzeJfZ+nH8rXVusMfjZMEJXCUbRxJ9H5Iz0pGhzwDRVJtB8Thi6h4lPcZU1OIyeEbx+XMo+NT2I-zUziSJxD8kvCKTjZaZofKW13IEZB6zLU7q7Qep1A6CoXPVnXW2S1ShHAegQqPaadhIJ2hcM4bhXwF7p3hOzMYcWTSzTxECikKjA6bttXIQwKhHX0LNF4edhgCvYwznbZ5pXDB4jSp4CkdMChmkprR5B0l6RuHHnUPVkQ310qnYgW5AdijypkzJB4xh2juos8YzZC3J2mrK64VDj8qvP0uJcZss0XRAQKKpWul9sP3I9cVjZhTetIPod7Jh18wLfEguJYoLh9A11aGS7rFKDulfpO8Gk5JH601UjJXFilnA3tNG4bVL2rbCu9TGWHlwHDKHibc6ugdlZgWhaJAwV27BOFgsF4VhAR3dqLbDhkokCg2lUlaFHS7K2PzbPYv4DisNaD8H4IAA */
        id: 'connection',
        types: {},
        initial: 'disconnected',
        context: {
          connectionId: '',
          config: {},
          authMethod: 'pat',
          isConnected: false,
          retryCount: 0,
          refreshFailureCount: 0,
          reauthInProgress: false,
          forceInteractive: false,
          accessTokenExpiresAt: void 0,
        },
        states: {
          disconnected: {
            entry: 'clearConnectionState',
            on: {
              CONNECT: {
                target: 'authenticating',
                actions: assign({
                  config: ({ event: event2 }) => event2.config,
                  connectionId: ({ event: event2 }) => event2.config.id,
                  authMethod: ({ event: event2 }) => event2.config.authMethod || 'pat',
                  retryCount: 0,
                  lastError: void 0,
                  forceInteractive: ({ event: event2 }) => !!event2.forceInteractive,
                  accessTokenExpiresAt: void 0,
                }),
              },
              RESET: {
                target: 'disconnected',
                actions: 'resetConnection',
              },
            },
          },
          authenticating: {
            initial: 'determining_method',
            states: {
              determining_method: {
                always: [
                  {
                    target: 'entra_auth',
                    guard: 'isEntraAuth',
                  },
                  {
                    target: 'pat_auth',
                    guard: 'isPATAuth',
                  },
                ],
              },
              pat_auth: {
                invoke: {
                  src: 'authenticateWithPAT',
                  input: ({ context }) => context,
                  onDone: {
                    target: '#connection.creating_client',
                    actions: assign({
                      credential: ({ event: event2 }) => event2.output.credential,
                      pat: ({ event: event2 }) => event2.output.credential,
                    }),
                  },
                  onError: {
                    target: '#connection.auth_failed',
                    actions: assign({
                      lastError: ({ event: event2 }) =>
                        event2.error?.message || 'PAT authentication failed',
                      retryCount: ({ context }) => context.retryCount + 1,
                    }),
                  },
                },
              },
              entra_auth: {
                initial: 'checking_existing_token',
                states: {
                  checking_existing_token: {
                    always: [
                      {
                        target: 'interactive_auth',
                        guard: 'shouldForceInteractiveAuth',
                      },
                    ],
                    invoke: {
                      src: 'checkExistingEntraToken',
                      input: ({ context }) => context,
                      onDone: [
                        {
                          target: '#connection.creating_client',
                          guard: 'hasValidToken',
                          actions: assign({
                            credential: ({ event: event2 }) => event2.output.token,
                            accessToken: ({ event: event2 }) => event2.output.token,
                            accessTokenExpiresAt: ({ event: event2 }) =>
                              normalizeExpiryToMs(event2.output.expiresAt),
                            // LEGACY AUTH REMOVED - authService replaced by FSM authentication
                          }),
                        },
                        {
                          target: 'interactive_auth',
                        },
                      ],
                      onError: {
                        target: 'interactive_auth',
                      },
                    },
                  },
                  interactive_auth: {
                    invoke: {
                      src: 'performInteractiveEntraAuth',
                      input: ({ context }) => context,
                      onDone: {
                        target: '#connection.creating_client',
                        actions: assign({
                          credential: ({ event: event2 }) => event2.output.token,
                          accessToken: ({ event: event2 }) => event2.output.token,
                          accessTokenExpiresAt: ({ event: event2 }) =>
                            normalizeExpiryToMs(event2.output.expiresAt),
                          // LEGACY AUTH REMOVED - authService replaced by FSM authentication
                          reauthInProgress: false,
                          forceInteractive: () => false,
                        }),
                      },
                      onError: {
                        target: '#connection.auth_failed',
                        actions: assign({
                          lastError: ({ event: event2 }) =>
                            event2.error?.message || 'Entra authentication failed',
                          retryCount: ({ context }) => context.retryCount + 1,
                          reauthInProgress: false,
                          forceInteractive: () => false,
                        }),
                      },
                    },
                    entry: assign({
                      reauthInProgress: true,
                    }),
                  },
                },
              },
            },
          },
          creating_client: {
            invoke: {
              src: 'createAzureClient',
              input: ({ context }) => context,
              onDone: {
                target: 'creating_provider',
                actions: assign({
                  client: ({ event: event2 }) => event2.output,
                }),
              },
              onError: {
                target: 'client_failed',
                actions: assign({
                  lastError: ({ event: event2 }) =>
                    event2.error?.message || 'Client creation failed',
                }),
              },
            },
          },
          creating_provider: {
            invoke: {
              src: 'createWorkItemsProvider',
              input: ({ context }) => context,
              onDone: {
                target: 'connected',
                actions: assign({
                  provider: ({ event: event2 }) => event2.output,
                  isConnected: true,
                  retryCount: 0,
                  lastError: void 0,
                }),
              },
              onError: {
                target: 'provider_failed',
                actions: assign({
                  lastError: ({ event: event2 }) =>
                    event2.error?.message || 'Provider creation failed',
                }),
              },
            },
          },
          connected: {
            entry: 'notifyConnectionSuccess',
            on: {
              DISCONNECT: 'disconnected',
              CONNECTION_FAILED: 'connection_error',
              TOKEN_EXPIRED: 'token_refresh',
              REFRESH_AUTH: 'token_refresh',
            },
          },
          auth_failed: {
            entry: 'notifyAuthFailure',
            on: {
              RETRY: {
                target: 'authenticating',
                guard: 'canRetry',
              },
              CONNECT: {
                target: 'authenticating',
                actions: assign({
                  retryCount: 0,
                }),
              },
              DISCONNECT: 'disconnected',
            },
          },
          client_failed: {
            entry: 'notifyClientFailure',
            on: {
              RETRY: {
                target: 'creating_client',
                guard: 'canRetry',
              },
              CONNECT: 'authenticating',
              DISCONNECT: 'disconnected',
            },
          },
          provider_failed: {
            entry: 'notifyProviderFailure',
            on: {
              RETRY: {
                target: 'creating_provider',
                guard: 'canRetry',
              },
              CONNECT: 'authenticating',
              DISCONNECT: 'disconnected',
            },
          },
          connection_error: {
            entry: 'notifyConnectionError',
            on: {
              RETRY: {
                target: 'authenticating',
                guard: 'canRetry',
              },
              CONNECT: 'authenticating',
              DISCONNECT: 'disconnected',
            },
          },
          token_refresh: {
            invoke: {
              src: 'refreshAuthToken',
              input: ({ context }) => context,
              onDone: {
                target: 'connected',
                actions: assign({
                  credential: ({ event: event2 }) => event2.output.token,
                  accessToken: ({ event: event2 }) => event2.output.token,
                  refreshFailureCount: 0,
                  lastRefreshFailure: void 0,
                  refreshBackoffUntil: void 0,
                }),
              },
              onError: {
                target: 'auth_failed',
                actions: assign({
                  lastError: ({ event: event2 }) => event2.error?.message || 'Token refresh failed',
                  refreshFailureCount: ({ context }) => context.refreshFailureCount + 1,
                  lastRefreshFailure: () => /* @__PURE__ */ new Date(),
                  refreshBackoffUntil: ({ context }) => {
                    const backoffMinutes = Math.min(
                      60,
                      Math.pow(2, context.refreshFailureCount) * 5
                    );
                    return new Date(Date.now() + backoffMinutes * 60 * 1e3);
                  },
                }),
              },
            },
          },
        },
      },
      {
        // Guards
        guards: {
          isEntraAuth: ({ context }) => context.authMethod === 'entra',
          isPATAuth: ({ context }) => context.authMethod === 'pat',
          canRetry: ({ context }) => context.retryCount < 3,
          hasValidToken: ({ event: event2 }) => {
            const output = event2.output;
            const token = output?.token;
            const expiresAt = output?.expiresAt;
            if (!token) {
              logger3.debug('Token validation: no token found');
              return false;
            }
            const valid = isTokenValid({ expiresAt });
            if (!valid) {
              logger3.info('Token validation: cached token expired or near expiry');
              return false;
            }
            logger3.debug(`Token validation: valid token found, length=${token.length}`);
            return true;
          },
          shouldForceInteractiveAuth: ({ context }) => context.forceInteractive === true,
        },
        // Actions
        actions: {
          clearConnectionState: assign({
            client: void 0,
            provider: void 0,
            credential: void 0,
            pat: void 0,
            accessToken: void 0,
            accessTokenExpiresAt: void 0,
            // LEGACY AUTH REMOVED - authService replaced by FSM authentication
            isConnected: false,
            lastError: void 0,
            forceInteractive: false,
          }),
          resetConnection: assign({
            retryCount: 0,
            refreshFailureCount: 0,
            lastRefreshFailure: void 0,
            refreshBackoffUntil: void 0,
            reauthInProgress: false,
            lastError: void 0,
            forceInteractive: false,
            accessTokenExpiresAt: void 0,
          }),
          notifyConnectionSuccess: ({ context }) => {
            logger3.info(`${context.connectionId} connected successfully`);
            if (context.provider) {
              logger3.info(`Triggering initial work items refresh for ${context.connectionId}`);
              try {
                const defaultQuery = 'My Activity';
                context.provider.refresh(defaultQuery);
              } catch (error) {
                logger3.error(
                  `Failed to trigger initial refresh: ${error instanceof Error ? error.message : String(error)}`
                );
              }
            } else {
              logger3.warn(`No provider available for initial refresh on ${context.connectionId}`);
            }
          },
          notifyAuthFailure: ({ context }) => {
            logger3.error(`${context.connectionId} authentication failed: ${context.lastError}`);
            if (context.lastError?.includes('network_error')) {
              import('vscode').then((vscode9) => {
                vscode9.window
                  .showErrorMessage(
                    `Authentication failed due to network error. This might be caused by corporate firewall/proxy. Try: 1) Check internet connection, 2) Contact IT about Microsoft auth endpoints, 3) Try from a different network.`,
                    'Retry Authentication',
                    'View Logs'
                  )
                  .then((selection) => {
                    if (selection === 'View Logs') {
                      vscode9.commands.executeCommand('azureDevOpsInt.showFSMLogs');
                    }
                  });
              });
            }
          },
          notifyClientFailure: ({ context }) => {
            logger3.error(`${context.connectionId} client creation failed: ${context.lastError}`);
          },
          notifyProviderFailure: ({ context }) => {
            logger3.error(`${context.connectionId} provider creation failed: ${context.lastError}`);
          },
          notifyConnectionError: ({ context }) => {
            logger3.error(`${context.connectionId} connection error: ${context.lastError}`);
          },
        },
        // Actors (service implementations)
        actors: {
          authenticateWithPAT: fromPromise(async ({ input }) => {
            logger3.debug(`Authenticating with PAT for ${input.connectionId}`);
            try {
              const extensionContext = getExtensionContextRef();
              if (!extensionContext) {
                throw new Error('Extension context not available');
              }
              const credential = await getSecretPAT(extensionContext, input.connectionId);
              if (!credential) {
                throw new Error('PAT not found in secrets');
              }
              return { credential };
            } catch (error) {
              logger3.error(
                `PAT authentication failed: ${error instanceof Error ? error.message : String(error)}`
              );
              throw error;
            }
          }),
          checkExistingEntraToken: fromPromise(async ({ input }) => {
            logger3.debug(`Checking existing Entra token for ${input.connectionId}`);
            try {
              const { EntraAuthProvider: EntraAuthProvider2 } = await Promise.resolve().then(
                () => (init_entraAuthProvider(), entraAuthProvider_exports)
              );
              const context = globalThis.extensionContext;
              if (!context) {
                logger3.warn('Extension context not available for Entra token check');
                return { token: null };
              }
              const clientId = AZURE_DEVOPS_PUBLIC_CLIENT_ID;
              let tenantId = input.config?.tenantId;
              const authContext = {
                component: 'AUTH' /* AUTH */,
                connectionId: input.connectionId,
              };
              let organizationName;
              let organizationUrl;
              if (input.config?.apiBaseUrl) {
                organizationUrl = input.config.apiBaseUrl;
                const apiUrlMatch = organizationUrl.match(
                  /https:\/\/(?:([^.]+)\.visualstudio\.com|dev\.azure\.com\/([^\/]+))/
                );
                organizationName = apiUrlMatch?.[1] || apiUrlMatch?.[2];
                logger3.debug(
                  'Using existing apiBaseUrl for token check tenant discovery',
                  authContext,
                  {
                    apiBaseUrl: input.config.apiBaseUrl,
                    extractedOrg: organizationName,
                  }
                );
              } else if (input.config?.baseUrl) {
                organizationUrl = input.config.baseUrl;
                const baseUrlMatch = organizationUrl.match(
                  /https:\/\/(?:([^.]+)\.visualstudio\.com|dev\.azure\.com\/([^\/]+))/
                );
                organizationName = baseUrlMatch?.[1] || baseUrlMatch?.[2];
                logger3.debug(
                  'Using existing baseUrl for token check tenant discovery',
                  authContext,
                  {
                    baseUrl: input.config.baseUrl,
                    extractedOrg: organizationName,
                  }
                );
              } else if (input.config?.organization) {
                organizationName = input.config.organization;
                organizationUrl = `https://dev.azure.com/${organizationName}`;
                logger3.debug(
                  'Constructing URL from organization name for token check (last resort)',
                  authContext,
                  {
                    organization: organizationName,
                    constructedUrl: organizationUrl,
                  }
                );
              }
              if (organizationName && organizationUrl) {
                logger3.info('Attempting tenant discovery for token check', authContext, {
                  organizationName,
                  organizationUrl,
                  source: input.config?.apiBaseUrl
                    ? 'apiBaseUrl'
                    : input.config?.baseUrl
                      ? 'baseUrl'
                      : 'organization',
                  originalTenantId: tenantId,
                });
                const discoveredTenant = await discoverTenantFromOrganization(organizationUrl);
                if (discoveredTenant) {
                  tenantId = discoveredTenant;
                  logger3.info('\u2705 Tenant discovered for existing token check', authContext, {
                    discoveredTenant: tenantId,
                    organizationName,
                    organizationUrl,
                    originalTenantId: input.config?.tenantId,
                  });
                } else {
                  logger3.warn(
                    '\u274C Tenant discovery failed for existing token check',
                    authContext,
                    {
                      organizationName,
                      organizationUrl,
                      reason: 'discoverTenantFromOrganization returned null',
                      fallbackToOriginal: tenantId,
                    }
                  );
                }
              } else {
                logger3.warn(
                  '\u274C Cannot discover tenant for token check - no organization information available',
                  authContext,
                  {
                    hasApiBaseUrl: !!input.config?.apiBaseUrl,
                    hasBaseUrl: !!input.config?.baseUrl,
                    hasOrganization: !!input.config?.organization,
                    config: input.config,
                    usingOriginalTenant: tenantId,
                  }
                );
              }
              const finalTenantId = tenantId || 'organizations';
              if (finalTenantId === 'organizations') {
                logger3.warn(
                  '\u26A0\uFE0F Using fallback tenant "organizations" for token check',
                  authContext,
                  {
                    originalTenantId: tenantId,
                    configTenantId: input.config?.tenantId,
                    discoveryAttempted: !input.config?.tenantId,
                  }
                );
              } else {
                logger3.info(
                  '\u2705 Using discovered/configured tenant for token check',
                  authContext,
                  {
                    tenantId: finalTenantId,
                    source: input.config?.tenantId ? 'config' : 'discovery',
                  }
                );
              }
              logger3.debug('Using tenant for existing token check', authContext, {
                tenantId: finalTenantId,
                clientId,
              });
              const authProvider = new EntraAuthProvider2({
                config: {
                  clientId,
                  tenantId: finalTenantId,
                  scopes: [AZURE_DEVOPS_SCOPE],
                  // Azure DevOps
                },
                secretStorage: context.secrets,
                connectionId: input.connectionId,
              });
              const isAuthenticated = await authProvider.isAuthenticated();
              if (isAuthenticated) {
                const tokenInfo = await authProvider.getTokenInfo();
                if (tokenInfo?.accessToken) {
                  const expiresAt = tokenInfo.expiresAt;
                  if (isTokenValid({ expiresAt })) {
                    logger3.info('Valid cached token found', authContext, { hasToken: true });
                    return {
                      token: tokenInfo.accessToken,
                      expiresAt: expiresAt?.toISOString?.() ?? expiresAt,
                    };
                  }
                  logger3.info('Cached token found but expired or near expiry', authContext, {
                    expiresAt: expiresAt?.toISOString?.() ?? null,
                  });
                } else {
                  logger3.debug('Authenticated but token info unavailable', authContext);
                }
              }
              logger3.debug('No valid cached token found', authContext);
              return { token: null };
            } catch (error) {
              const authContext = {
                component: 'AUTH' /* AUTH */,
                connectionId: input.connectionId,
              };
              logger3.error('Failed to check existing token', authContext, {
                error: error instanceof Error ? error.message : String(error),
                errorType: error instanceof Error ? error.constructor.name : 'Unknown',
              });
              return { token: null };
            }
          }),
          performInteractiveEntraAuth: fromPromise(async ({ input }) => {
            logger3.info(`Starting interactive Entra authentication for ${input.connectionId}`);
            try {
              const { EntraAuthProvider: EntraAuthProvider2 } = await Promise.resolve().then(
                () => (init_entraAuthProvider(), entraAuthProvider_exports)
              );
              const context = globalThis.extensionContext;
              if (!context) {
                throw new Error('Extension context not available for Entra authentication');
              }
              const clientId = AZURE_DEVOPS_PUBLIC_CLIENT_ID;
              let tenantId = input.config?.tenantId;
              let discoveredTenant = null;
              const isForceInteractive = input.forceInteractive === true;
              const authContext = {
                component: 'AUTH' /* AUTH */,
                connectionId: input.connectionId,
              };
              let organizationName;
              let organizationUrl;
              if (input.config?.apiBaseUrl) {
                organizationUrl = input.config.apiBaseUrl;
                const apiUrlMatch = organizationUrl.match(
                  /https:\/\/(?:([^.]+)\.visualstudio\.com|dev\.azure\.com\/([^\/]+))/
                );
                organizationName = apiUrlMatch?.[1] || apiUrlMatch?.[2];
                logger3.debug('Using existing apiBaseUrl for tenant discovery', authContext, {
                  apiBaseUrl: input.config.apiBaseUrl,
                  extractedOrg: organizationName,
                });
              } else if (input.config?.baseUrl) {
                organizationUrl = input.config.baseUrl;
                const baseUrlMatch = organizationUrl.match(
                  /https:\/\/(?:([^.]+)\.visualstudio\.com|dev\.azure\.com\/([^\/]+))/
                );
                organizationName = baseUrlMatch?.[1] || baseUrlMatch?.[2];
                logger3.debug('Using existing baseUrl for tenant discovery', authContext, {
                  baseUrl: input.config.baseUrl,
                  extractedOrg: organizationName,
                });
              } else if (input.config?.organization) {
                organizationName = input.config.organization;
                organizationUrl = `https://dev.azure.com/${organizationName}`;
                logger3.debug(
                  'Constructing URL from organization name (last resort)',
                  authContext,
                  {
                    organization: organizationName,
                    constructedUrl: organizationUrl,
                  }
                );
              }
              if (organizationName && organizationUrl) {
                logger3.info('Attempting tenant discovery for device code flow', authContext, {
                  organizationName,
                  organizationUrl,
                  source: input.config?.apiBaseUrl
                    ? 'apiBaseUrl'
                    : input.config?.baseUrl
                      ? 'baseUrl'
                      : 'organization',
                  originalTenantId: tenantId,
                });
                discoveredTenant = await discoverTenantFromOrganization(organizationUrl);
                if (discoveredTenant) {
                  tenantId = discoveredTenant;
                  logger3.info(
                    '\u2705 Tenant discovered successfully for device code flow',
                    authContext,
                    {
                      discoveredTenant: tenantId,
                      organizationName,
                      organizationUrl,
                      originalTenantId: input.config?.tenantId,
                    }
                  );
                } else {
                  logger3.warn('\u274C Tenant discovery failed for device code flow', authContext, {
                    organizationName,
                    organizationUrl,
                    reason: 'discoverTenantFromOrganization returned null',
                    fallbackToOriginal: tenantId,
                  });
                }
              } else {
                logger3.warn(
                  '\u274C Cannot discover tenant - no organization information available',
                  authContext,
                  {
                    hasApiBaseUrl: !!input.config?.apiBaseUrl,
                    hasBaseUrl: !!input.config?.baseUrl,
                    hasOrganization: !!input.config?.organization,
                    config: input.config,
                    usingOriginalTenant: tenantId,
                  }
                );
              }
              let finalTenantId = tenantId;
              if (discoveredTenant) {
                finalTenantId = discoveredTenant;
                logger3.info('\u2705 Using discovered tenant (most reliable)', authContext, {
                  discoveredTenant: finalTenantId,
                  source: 'discovery',
                  reliability: 'high',
                });
              } else if (!input.config?.tenantId || tenantId === 'organizations') {
                finalTenantId = 'organizations';
                logger3.info(
                  '\u2705 Using "organizations" tenant for MSAL automatic routing',
                  authContext,
                  {
                    originalTenantId: tenantId,
                    finalTenantId,
                    reason: 'v1.9.3 proven approach - let MSAL and Azure AD handle tenant routing',
                    recommendation:
                      'organizations endpoint supports work/school accounts with automatic tenant discovery',
                  }
                );
              } else {
                logger3.info('\u2705 Using user-configured tenant', authContext, {
                  tenantId: finalTenantId,
                  source: 'user-config',
                  note: 'Respecting user configuration despite discovery failure',
                });
              }
              logger3.debug('Final tenant selection for device code authentication', authContext, {
                originalConfigTenant: input.config?.tenantId,
                discoveredTenant,
                finalTenantId,
                selectionReason: discoveredTenant
                  ? 'discovery'
                  : !input.config?.tenantId || tenantId === 'organizations'
                    ? 'organizations-fallback'
                    : 'user-config',
                authType: 'device-code',
                organizationUrl: organizationUrl || 'not-available',
              });
              logger3.debug('Using tenant for interactive auth', authContext, {
                tenantId: finalTenantId,
                clientId,
              });
              if (input.config?.tenantId && input.config.tenantId !== finalTenantId) {
                logger3.info(
                  '\u{1F504} Tenant changed - clearing cached authentication',
                  authContext,
                  {
                    originalTenant: input.config.tenantId,
                    newTenant: finalTenantId,
                    reason: 'Prevent authentication conflicts from cached tokens',
                  }
                );
                try {
                  const cacheKey = `entra-cache-${input.connectionId}`;
                  await context.secrets.delete(cacheKey);
                  logger3.debug('Cleared cached authentication for tenant change', authContext, {
                    cacheKey,
                  });
                } catch (error) {
                  logger3.warn(
                    'Failed to clear authentication cache on tenant change',
                    authContext,
                    {
                      error: error instanceof Error ? error.message : String(error),
                    }
                  );
                }
              }
              const authProvider = new EntraAuthProvider2({
                config: {
                  clientId,
                  tenantId: finalTenantId,
                  scopes: [AZURE_DEVOPS_SCOPE],
                  // Azure DevOps
                },
                secretStorage: context.secrets,
                connectionId: input.connectionId,
                // Device code callback to show the device code to user
                deviceCodeCallback: async (deviceCode, userCode, verificationUri, expiresIn) => {
                  const authContext2 = {
                    component: 'AUTH' /* AUTH */,
                    connectionId: input.connectionId,
                  };
                  logger3.info('Device Code Flow started', authContext2, {
                    userCode,
                    verificationUri,
                    expiresInSeconds: expiresIn,
                    expiresInMinutes: Math.floor(expiresIn / 60),
                  });
                  const vscode9 = await import('vscode');
                  const expiresInMinutes = Math.floor(expiresIn / 60);
                  const connectionName = input.config?.organization || input.connectionId;
                  const action2 = await vscode9.window.showInformationMessage(
                    `Authentication code for ${connectionName}: ${userCode} (expires in ${expiresInMinutes}min)`,
                    'Open Browser & Copy Code'
                  );
                  logger3.info('Device code notification shown', authContext2, {
                    userCode,
                    verificationUri,
                    connectionName,
                    userAction: action2,
                  });
                  if (action2 === 'Open Browser & Copy Code') {
                    try {
                      await vscode9.env.clipboard.writeText(userCode);
                      logger3.info('Device code copied to clipboard', authContext2, { userCode });
                      const uri = vscode9.Uri.parse(verificationUri);
                      logger3.info('Opening external browser', authContext2, {
                        verificationUri,
                        parsedUri: uri.toString(),
                        scheme: uri.scheme,
                        authority: uri.authority,
                      });
                      const openResult = await vscode9.env.openExternal(uri);
                      logger3.info('Browser open result', authContext2, {
                        openResult,
                        verificationUri,
                        success: openResult,
                      });
                      vscode9.window.showInformationMessage(
                        `Code ${userCode} for ${connectionName} copied to clipboard - paste it in the browser!`,
                        { modal: false }
                      );
                      logger3.debug('User code copied and browser opened', authContext2, {
                        userCode,
                        verificationUri,
                        openResult,
                      });
                    } catch (error) {
                      logger3.error('Failed to open browser or copy code', authContext2, {
                        error: error instanceof Error ? error.message : String(error),
                        verificationUri,
                        userCode,
                      });
                      vscode9.window
                        .showErrorMessage(
                          `Could not open browser automatically. Please manually go to ${verificationUri} and enter code: ${userCode}`,
                          'Copy Code'
                        )
                        .then((fallbackAction) => {
                          if (fallbackAction === 'Copy Code') {
                            vscode9.env.clipboard.writeText(userCode);
                          }
                        });
                    }
                  }
                },
              });
              if (isForceInteractive) {
                logger3.info(
                  'Force interactive authentication requested - clearing cached credentials',
                  authContext,
                  {
                    requestSource: 'manual-interactive-trigger',
                  }
                );
                try {
                  await authProvider.resetToken();
                } catch (error) {
                  logger3.warn(
                    'Failed to reset cached credentials before forced interactive auth',
                    authContext,
                    {
                      error: error instanceof Error ? error.message : String(error),
                    }
                  );
                }
              } else {
                const isAuthenticated = await authProvider.isAuthenticated();
                if (isAuthenticated) {
                  const accessToken = await authProvider.getAccessToken();
                  if (accessToken) {
                    const tokenInfo = await authProvider.getTokenInfo();
                    const expiresAt = tokenInfo?.expiresAt;
                    if (isTokenValid({ expiresAt })) {
                      logger3.info('Valid cached token found', authContext, { hasToken: true });
                      return {
                        token: accessToken,
                        expiresAt: expiresAt?.toISOString?.() ?? expiresAt,
                        success: true,
                        message: 'Entra authentication successful - using cached token',
                      };
                    }
                    logger3.info('Cached token available but expired or near expiry', authContext, {
                      expiresAt: expiresAt?.toISOString?.() ?? null,
                    });
                  }
                }
              }
              logger3.info(
                isForceInteractive
                  ? 'Starting forced device code flow for authentication'
                  : 'Starting device code flow for authentication',
                authContext,
                {
                  forceInteractive: isForceInteractive,
                }
              );
              const authResult = await authProvider.authenticate();
              if (authResult.success && authResult.accessToken) {
                logger3.info('Interactive authentication successful', authContext, {
                  hasAccessToken: !!authResult.accessToken,
                });
                return {
                  token: authResult.accessToken,
                  expiresAt: authResult.expiresAt?.toISOString?.() ?? authResult.expiresAt,
                  success: true,
                  message: 'Entra authentication successful',
                };
              } else {
                logger3.error('Interactive authentication failed', authContext, {
                  error: authResult.error,
                  success: authResult.success,
                });
                throw new Error(authResult.error || 'Entra authentication failed');
              }
            } catch (error) {
              const authContext = {
                component: 'AUTH' /* AUTH */,
                connectionId: input.connectionId,
              };
              logger3.error('Authentication failed', authContext, {
                error: error instanceof Error ? error.message : String(error),
                errorType: error instanceof Error ? error.constructor.name : 'Unknown',
              });
              throw new Error(
                `Entra authentication failed: ${error instanceof Error ? error.message : String(error)}`
              );
            }
          }),
          createAzureClient: fromPromise(async ({ input }) => {
            const connectionContext = {
              component: 'CONNECTION' /* CONNECTION */,
              connectionId: input.connectionId,
            };
            const { validateClientConfig: validateClientConfig2, createAzureClient: createClient } =
              await Promise.resolve().then(
                () => (init_azureClientFunctions(), azureClientFunctions_exports)
              );
            const validationResult = await validateClientConfig2(input);
            if (!validationResult.isValid) {
              const errorMessage = `Client configuration validation failed: ${validationResult.errors?.join(', ')}`;
              fsmLogger.error('CONNECTION' /* CONNECTION */, errorMessage, connectionContext, {
                errors: validationResult.errors,
              });
              throw new Error(errorMessage);
            }
            const clientResult = await createClient(input, validationResult.config);
            fsmLogger.info(
              'CONNECTION' /* CONNECTION */,
              'Azure client created successfully via FSM',
              connectionContext,
              {
                organization: clientResult.config.organization,
                project: clientResult.config.project,
                authType: clientResult.config.options.authType,
              }
            );
            return clientResult.client;
          }),
          createWorkItemsProvider: fromPromise(async ({ input }) => {
            logger3.debug(`Creating provider for ${input.connectionId}`);
            if (!input.client) {
              throw new Error('No client available for provider creation');
            }
            try {
              const { WorkItemsProvider: WorkItemsProvider2 } = await Promise.resolve().then(
                () => (init_provider2(), provider_exports)
              );
              const provider2 = new WorkItemsProvider2(
                input.connectionId,
                input.client,
                (msg) => {
                  logger3.debug(`Provider ${input.connectionId}: ${msg}`);
                  forwardProviderMessage(input.connectionId, msg);
                },
                {
                  // Provider options
                }
              );
              logger3.info(`WorkItems provider created successfully for ${input.connectionId}`);
              return provider2;
            } catch (error) {
              logger3.error(
                `Failed to create WorkItems provider: ${error instanceof Error ? error.message : String(error)}`
              );
              throw error;
            }
          }),
          refreshAuthToken: fromPromise(async ({ input }) => {
            logger3.debug(`Refreshing auth token for ${input.connectionId}`);
            if (input.authMethod === 'pat') {
              try {
                const extensionContext = getExtensionContextRef();
                if (!extensionContext) {
                  throw new Error('Extension context not available');
                }
                const credential = await getSecretPAT(extensionContext, input.connectionId);
                if (!credential) {
                  throw new Error('PAT refresh failed - no PAT found');
                }
                return { token: credential };
              } catch (error) {
                logger3.error(
                  `PAT refresh failed: ${error instanceof Error ? error.message : String(error)}`
                );
                throw error;
              }
            } else {
              throw new Error('LEGACY AUTH REMOVED - FSM authentication implementation needed');
            }
          }),
        },
      }
    );
  },
});

// src/fsm/ConnectionFSMManager.ts
var ConnectionFSMManager_exports = {};
__export(ConnectionFSMManager_exports, {
  ConnectionFSMManager: () => ConnectionFSMManager,
  getConnectionFSMManager: () => getConnectionFSMManager,
  resetConnectionFSMManager: () => resetConnectionFSMManager,
});
function getConnectionFSMManager() {
  if (!connectionFSMManager) {
    connectionFSMManager = new ConnectionFSMManager();
  }
  return connectionFSMManager;
}
function resetConnectionFSMManager() {
  if (connectionFSMManager) {
    connectionFSMManager.cleanup();
  }
  connectionFSMManager = void 0;
}
var ConnectionFSMManager, connectionFSMManager;
var init_ConnectionFSMManager = __esm({
  'src/fsm/ConnectionFSMManager.ts'() {
    'use strict';
    init_xstate_esm();
    init_connectionMachine();
    init_FSMLogger();
    ConnectionFSMManager = class {
      connectionActors = /* @__PURE__ */ new Map();
      isEnabled = false;
      logger = createComponentLogger('CONNECTION' /* CONNECTION */, 'ConnectionFSMManager');
      constructor() {
        this.logger.info('ConnectionFSMManager created');
      }
      /**
       * Enable/disable the Connection FSM system
       */
      setEnabled(enabled) {
        this.isEnabled = enabled;
        this.logger.info(`Connection FSM ${enabled ? 'enabled' : 'disabled'}`);
      }
      /**
       * Create or get connection actor for a specific connection
       */
      getConnectionActor(connectionId) {
        if (!this.connectionActors.has(connectionId)) {
          const actor = createActor(connectionMachine2, {
            input: {
              connectionId,
              config: {},
              authMethod: 'pat',
              isConnected: false,
              retryCount: 0,
              refreshFailureCount: 0,
              reauthInProgress: false,
            },
          });
          actor.subscribe((state2) => {
            this.logger.debug(`${connectionId} state: ${String(state2.value)}`, {
              state: String(state2.value),
              connectionId,
            });
          });
          actor.start();
          this.connectionActors.set(connectionId, actor);
        }
        return this.connectionActors.get(connectionId);
      }
      /**
       * Connect to a specific connection (replaces ensureActiveConnection logic)
       */
      async connectToConnection(config, options = {}) {
        if (!this.isEnabled) {
          throw new Error('Connection FSM not enabled');
        }
        this.logger.info(`Connecting to ${config.id}...`, { connectionId: config.id });
        const actor = this.getConnectionActor(config.id);
        const forceInteractive = options?.interactive === true;
        actor.send({ type: 'CONNECT', config, forceInteractive });
        this.logger.logEvent('CONNECT', 'connecting', 'connectionMachine', {
          connectionId: config.id,
          forceInteractive,
        });
        const isInteractiveAuth = options?.interactive;
        const timeoutMs = isInteractiveAuth ? 9e5 : 3e4;
        return new Promise((resolve) => {
          const timeout = setTimeout(() => {
            resolve({
              success: false,
              error: `Connection timeout (${isInteractiveAuth ? '15min' : '30s'})`,
            });
          }, timeoutMs);
          const subscription = actor.subscribe((state2) => {
            if (state2.matches('connected')) {
              clearTimeout(timeout);
              subscription.unsubscribe();
              resolve({
                success: true,
                client: state2.context.client,
                provider: state2.context.provider,
                state: state2.context,
              });
            } else if (
              state2.matches('auth_failed') ||
              state2.matches('client_failed') ||
              state2.matches('provider_failed') ||
              state2.matches('connection_error')
            ) {
              clearTimeout(timeout);
              subscription.unsubscribe();
              resolve({
                success: false,
                error: state2.context.lastError || 'Connection failed',
                state: state2.context,
              });
            }
          });
        });
      }
      /**
       * Disconnect from a specific connection
       */
      disconnectFromConnection(connectionId) {
        const actor = this.connectionActors.get(connectionId);
        if (actor) {
          actor.send({ type: 'DISCONNECT' });
        }
      }
      /**
       * Retry connection for a specific connection
       */
      retryConnection(connectionId) {
        const actor = this.connectionActors.get(connectionId);
        if (actor) {
          actor.send({ type: 'RETRY' });
        }
      }
      /**
       * Reset connection state
       */
      resetConnection(connectionId) {
        const actor = this.connectionActors.get(connectionId);
        if (actor) {
          actor.send({ type: 'RESET' });
        }
      }
      /**
       * Handle token expiration
       */
      handleTokenExpired(connectionId) {
        const actor = this.connectionActors.get(connectionId);
        if (actor) {
          actor.send({ type: 'TOKEN_EXPIRED' });
        }
      }
      /**
       * Refresh authentication for a connection
       */
      refreshAuth(connectionId) {
        const actor = this.connectionActors.get(connectionId);
        if (actor) {
          actor.send({ type: 'REFRESH_AUTH' });
        }
      }
      /**
       * Get current state of a connection
       */
      getConnectionState(connectionId) {
        const actor = this.connectionActors.get(connectionId);
        return actor?.getSnapshot();
      }
      /**
       * Check if a connection is connected
       */
      isConnectionConnected(connectionId) {
        const state2 = this.getConnectionState(connectionId);
        return state2?.matches('connected') || false;
      }
      /**
       * Get client for a connected connection
       */
      getConnectionClient(connectionId) {
        const state2 = this.getConnectionState(connectionId);
        return state2?.context.client;
      }
      /**
       * Get provider for a connected connection
       */
      getConnectionProvider(connectionId) {
        const state2 = this.getConnectionState(connectionId);
        return state2?.context.provider;
      }
      /**
       * Get all connection states for debugging
       */
      getAllConnectionStates() {
        const states = {};
        for (const [connectionId, actor] of this.connectionActors.entries()) {
          const snapshot2 = actor.getSnapshot();
          states[connectionId] = {
            state: snapshot2.value,
            isConnected: snapshot2.context.isConnected,
            lastError: snapshot2.context.lastError,
            retryCount: snapshot2.context.retryCount,
            authMethod: snapshot2.context.authMethod,
          };
        }
        return states;
      }
      /**
       * Clean up connection actors
       */
      cleanup() {
        this.logger.info(`Cleaning up ${this.connectionActors.size} connection actors`);
        for (const [connectionId, actor] of this.connectionActors.entries()) {
          try {
            actor.send({ type: 'DISCONNECT' });
            actor.stop();
          } catch (error) {
            this.logger.error(
              `Error stopping actor for ${connectionId}: ${error instanceof Error ? error.message : String(error)}`
            );
          }
        }
        this.connectionActors.clear();
      }
      /**
       * Get debug information about the Connection FSM system
       */
      getDebugInfo() {
        return {
          isEnabled: this.isEnabled,
          activeConnections: this.connectionActors.size,
          connectionStates: this.getAllConnectionStates(),
        };
      }
    };
  },
});

// node_modules/openai/internal/tslib.mjs
function __classPrivateFieldSet(receiver, state2, value, kind, f) {
  if (kind === 'm') throw new TypeError('Private method is not writable');
  if (kind === 'a' && !f) throw new TypeError('Private accessor was defined without a setter');
  if (typeof state2 === 'function' ? receiver !== state2 || !f : !state2.has(receiver))
    throw new TypeError('Cannot write private member to an object whose class did not declare it');
  return (
    kind === 'a' ? f.call(receiver, value) : f ? (f.value = value) : state2.set(receiver, value),
    value
  );
}
function __classPrivateFieldGet(receiver, state2, kind, f) {
  if (kind === 'a' && !f) throw new TypeError('Private accessor was defined without a getter');
  if (typeof state2 === 'function' ? receiver !== state2 || !f : !state2.has(receiver))
    throw new TypeError('Cannot read private member from an object whose class did not declare it');
  return kind === 'm' ? f : kind === 'a' ? f.call(receiver) : f ? f.value : state2.get(receiver);
}
var init_tslib = __esm({
  'node_modules/openai/internal/tslib.mjs'() {},
});

// node_modules/openai/internal/utils/uuid.mjs
var uuid4;
var init_uuid = __esm({
  'node_modules/openai/internal/utils/uuid.mjs'() {
    uuid4 = function () {
      const { crypto: crypto10 } = globalThis;
      if (crypto10?.randomUUID) {
        uuid4 = crypto10.randomUUID.bind(crypto10);
        return crypto10.randomUUID();
      }
      const u8 = new Uint8Array(1);
      const randomByte = crypto10
        ? () => crypto10.getRandomValues(u8)[0]
        : () => (Math.random() * 255) & 255;
      return '10000000-1000-4000-8000-100000000000'.replace(/[018]/g, (c) =>
        (+c ^ (randomByte() & (15 >> (+c / 4)))).toString(16)
      );
    };
  },
});

// node_modules/openai/internal/errors.mjs
function isAbortError(err) {
  return (
    typeof err === 'object' &&
    err !== null && // Spec-compliant fetch implementations
    (('name' in err && err.name === 'AbortError') || // Expo fetch
      ('message' in err && String(err.message).includes('FetchRequestCanceledException')))
  );
}
var castToError;
var init_errors3 = __esm({
  'node_modules/openai/internal/errors.mjs'() {
    castToError = (err) => {
      if (err instanceof Error) return err;
      if (typeof err === 'object' && err !== null) {
        try {
          if (Object.prototype.toString.call(err) === '[object Error]') {
            const error = new Error(err.message, err.cause ? { cause: err.cause } : {});
            if (err.stack) error.stack = err.stack;
            if (err.cause && !error.cause) error.cause = err.cause;
            if (err.name) error.name = err.name;
            return error;
          }
        } catch {}
        try {
          return new Error(JSON.stringify(err));
        } catch {}
      }
      return new Error(err);
    };
  },
});

// node_modules/openai/core/error.mjs
var OpenAIError,
  APIError,
  APIUserAbortError,
  APIConnectionError,
  APIConnectionTimeoutError,
  BadRequestError,
  AuthenticationError,
  PermissionDeniedError,
  NotFoundError,
  ConflictError,
  UnprocessableEntityError,
  RateLimitError,
  InternalServerError,
  LengthFinishReasonError,
  ContentFilterFinishReasonError,
  InvalidWebhookSignatureError;
var init_error = __esm({
  'node_modules/openai/core/error.mjs'() {
    init_errors3();
    OpenAIError = class extends Error {};
    APIError = class _APIError extends OpenAIError {
      constructor(status, error, message, headers) {
        super(`${_APIError.makeMessage(status, error, message)}`);
        this.status = status;
        this.headers = headers;
        this.requestID = headers?.get('x-request-id');
        this.error = error;
        const data = error;
        this.code = data?.['code'];
        this.param = data?.['param'];
        this.type = data?.['type'];
      }
      static makeMessage(status, error, message) {
        const msg = error?.message
          ? typeof error.message === 'string'
            ? error.message
            : JSON.stringify(error.message)
          : error
            ? JSON.stringify(error)
            : message;
        if (status && msg) {
          return `${status} ${msg}`;
        }
        if (status) {
          return `${status} status code (no body)`;
        }
        if (msg) {
          return msg;
        }
        return '(no status code or body)';
      }
      static generate(status, errorResponse, message, headers) {
        if (!status || !headers) {
          return new APIConnectionError({ message, cause: castToError(errorResponse) });
        }
        const error = errorResponse?.['error'];
        if (status === 400) {
          return new BadRequestError(status, error, message, headers);
        }
        if (status === 401) {
          return new AuthenticationError(status, error, message, headers);
        }
        if (status === 403) {
          return new PermissionDeniedError(status, error, message, headers);
        }
        if (status === 404) {
          return new NotFoundError(status, error, message, headers);
        }
        if (status === 409) {
          return new ConflictError(status, error, message, headers);
        }
        if (status === 422) {
          return new UnprocessableEntityError(status, error, message, headers);
        }
        if (status === 429) {
          return new RateLimitError(status, error, message, headers);
        }
        if (status >= 500) {
          return new InternalServerError(status, error, message, headers);
        }
        return new _APIError(status, error, message, headers);
      }
    };
    APIUserAbortError = class extends APIError {
      constructor({ message } = {}) {
        super(void 0, void 0, message || 'Request was aborted.', void 0);
      }
    };
    APIConnectionError = class extends APIError {
      constructor({ message, cause }) {
        super(void 0, void 0, message || 'Connection error.', void 0);
        if (cause) this.cause = cause;
      }
    };
    APIConnectionTimeoutError = class extends APIConnectionError {
      constructor({ message } = {}) {
        super({ message: message ?? 'Request timed out.' });
      }
    };
    BadRequestError = class extends APIError {};
    AuthenticationError = class extends APIError {};
    PermissionDeniedError = class extends APIError {};
    NotFoundError = class extends APIError {};
    ConflictError = class extends APIError {};
    UnprocessableEntityError = class extends APIError {};
    RateLimitError = class extends APIError {};
    InternalServerError = class extends APIError {};
    LengthFinishReasonError = class extends OpenAIError {
      constructor() {
        super(`Could not parse response content as the length limit was reached`);
      }
    };
    ContentFilterFinishReasonError = class extends OpenAIError {
      constructor() {
        super(`Could not parse response content as the request was rejected by the content filter`);
      }
    };
    InvalidWebhookSignatureError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
  },
});

// node_modules/openai/internal/utils/values.mjs
function maybeObj(x) {
  if (typeof x !== 'object') {
    return {};
  }
  return x ?? {};
}
function isEmptyObj(obj) {
  if (!obj) return true;
  for (const _k in obj) return false;
  return true;
}
function hasOwn(obj, key2) {
  return Object.prototype.hasOwnProperty.call(obj, key2);
}
function isObj(obj) {
  return obj != null && typeof obj === 'object' && !Array.isArray(obj);
}
var startsWithSchemeRegexp,
  isAbsoluteURL2,
  isArray3,
  isReadonlyArray,
  validatePositiveInteger,
  safeJSON;
var init_values = __esm({
  'node_modules/openai/internal/utils/values.mjs'() {
    init_error();
    startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
    isAbsoluteURL2 = (url2) => {
      return startsWithSchemeRegexp.test(url2);
    };
    isArray3 = (val) => ((isArray3 = Array.isArray), isArray3(val));
    isReadonlyArray = isArray3;
    validatePositiveInteger = (name3, n) => {
      if (typeof n !== 'number' || !Number.isInteger(n)) {
        throw new OpenAIError(`${name3} must be an integer`);
      }
      if (n < 0) {
        throw new OpenAIError(`${name3} must be a positive integer`);
      }
      return n;
    };
    safeJSON = (text2) => {
      try {
        return JSON.parse(text2);
      } catch (err) {
        return void 0;
      }
    };
  },
});

// node_modules/openai/internal/utils/sleep.mjs
var sleep;
var init_sleep = __esm({
  'node_modules/openai/internal/utils/sleep.mjs'() {
    sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
  },
});

// node_modules/openai/version.mjs
var VERSION3;
var init_version2 = __esm({
  'node_modules/openai/version.mjs'() {
    VERSION3 = '6.4.0';
  },
});

// node_modules/openai/internal/detect-platform.mjs
function getDetectedPlatform() {
  if (typeof Deno !== 'undefined' && Deno.build != null) {
    return 'deno';
  }
  if (typeof EdgeRuntime !== 'undefined') {
    return 'edge';
  }
  if (
    Object.prototype.toString.call(
      typeof globalThis.process !== 'undefined' ? globalThis.process : 0
    ) === '[object process]'
  ) {
    return 'node';
  }
  return 'unknown';
}
function getBrowserInfo() {
  if (typeof navigator === 'undefined' || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: 'edge', pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: 'ie', pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: 'ie', pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: 'chrome', pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: 'firefox', pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: 'safari', pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ },
  ];
  for (const { key: key2, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key2, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var isRunningInBrowser,
  getPlatformProperties,
  normalizeArch,
  normalizePlatform,
  _platformHeaders,
  getPlatformHeaders;
var init_detect_platform = __esm({
  'node_modules/openai/internal/detect-platform.mjs'() {
    init_version2();
    isRunningInBrowser = () => {
      return (
        // @ts-ignore
        typeof window !== 'undefined' && // @ts-ignore
        typeof window.document !== 'undefined' && // @ts-ignore
        typeof navigator !== 'undefined'
      );
    };
    getPlatformProperties = () => {
      const detectedPlatform = getDetectedPlatform();
      if (detectedPlatform === 'deno') {
        return {
          'X-Stainless-Lang': 'js',
          'X-Stainless-Package-Version': VERSION3,
          'X-Stainless-OS': normalizePlatform(Deno.build.os),
          'X-Stainless-Arch': normalizeArch(Deno.build.arch),
          'X-Stainless-Runtime': 'deno',
          'X-Stainless-Runtime-Version':
            typeof Deno.version === 'string' ? Deno.version : (Deno.version?.deno ?? 'unknown'),
        };
      }
      if (typeof EdgeRuntime !== 'undefined') {
        return {
          'X-Stainless-Lang': 'js',
          'X-Stainless-Package-Version': VERSION3,
          'X-Stainless-OS': 'Unknown',
          'X-Stainless-Arch': `other:${EdgeRuntime}`,
          'X-Stainless-Runtime': 'edge',
          'X-Stainless-Runtime-Version': globalThis.process.version,
        };
      }
      if (detectedPlatform === 'node') {
        return {
          'X-Stainless-Lang': 'js',
          'X-Stainless-Package-Version': VERSION3,
          'X-Stainless-OS': normalizePlatform(globalThis.process.platform ?? 'unknown'),
          'X-Stainless-Arch': normalizeArch(globalThis.process.arch ?? 'unknown'),
          'X-Stainless-Runtime': 'node',
          'X-Stainless-Runtime-Version': globalThis.process.version ?? 'unknown',
        };
      }
      const browserInfo = getBrowserInfo();
      if (browserInfo) {
        return {
          'X-Stainless-Lang': 'js',
          'X-Stainless-Package-Version': VERSION3,
          'X-Stainless-OS': 'Unknown',
          'X-Stainless-Arch': 'unknown',
          'X-Stainless-Runtime': `browser:${browserInfo.browser}`,
          'X-Stainless-Runtime-Version': browserInfo.version,
        };
      }
      return {
        'X-Stainless-Lang': 'js',
        'X-Stainless-Package-Version': VERSION3,
        'X-Stainless-OS': 'Unknown',
        'X-Stainless-Arch': 'unknown',
        'X-Stainless-Runtime': 'unknown',
        'X-Stainless-Runtime-Version': 'unknown',
      };
    };
    normalizeArch = (arch) => {
      if (arch === 'x32') return 'x32';
      if (arch === 'x86_64' || arch === 'x64') return 'x64';
      if (arch === 'arm') return 'arm';
      if (arch === 'aarch64' || arch === 'arm64') return 'arm64';
      if (arch) return `other:${arch}`;
      return 'unknown';
    };
    normalizePlatform = (platform) => {
      platform = platform.toLowerCase();
      if (platform.includes('ios')) return 'iOS';
      if (platform === 'android') return 'Android';
      if (platform === 'darwin') return 'MacOS';
      if (platform === 'win32') return 'Windows';
      if (platform === 'freebsd') return 'FreeBSD';
      if (platform === 'openbsd') return 'OpenBSD';
      if (platform === 'linux') return 'Linux';
      if (platform) return `Other:${platform}`;
      return 'Unknown';
    };
    getPlatformHeaders = () => {
      return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
    };
  },
});

// node_modules/openai/internal/shims.mjs
function getDefaultFetch() {
  if (typeof fetch !== 'undefined') {
    return fetch;
  }
  throw new Error(
    '`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`'
  );
}
function makeReadableStream(...args) {
  const ReadableStream3 = globalThis.ReadableStream;
  if (typeof ReadableStream3 === 'undefined') {
    throw new Error(
      '`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`'
    );
  }
  return new ReadableStream3(...args);
}
function ReadableStreamFrom(iterable) {
  let iter =
    Symbol.asyncIterator in iterable
      ? iterable[Symbol.asyncIterator]()
      : iterable[Symbol.iterator]();
  return makeReadableStream({
    start() {},
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      await iter.return?.();
    },
  });
}
function ReadableStreamToAsyncIterable(stream4) {
  if (stream4[Symbol.asyncIterator]) return stream4;
  const reader = stream4.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done) reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    },
  };
}
async function CancelReadableStream(stream4) {
  if (stream4 === null || typeof stream4 !== 'object') return;
  if (stream4[Symbol.asyncIterator]) {
    await stream4[Symbol.asyncIterator]().return?.();
    return;
  }
  const reader = stream4.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}
var init_shims = __esm({
  'node_modules/openai/internal/shims.mjs'() {},
});

// node_modules/openai/internal/request-options.mjs
var FallbackEncoder;
var init_request_options = __esm({
  'node_modules/openai/internal/request-options.mjs'() {
    FallbackEncoder = ({ headers, body }) => {
      return {
        bodyHeaders: {
          'content-type': 'application/json',
        },
        body: JSON.stringify(body),
      };
    };
  },
});

// node_modules/openai/internal/qs/formats.mjs
var default_format, default_formatter, formatters, RFC1738;
var init_formats = __esm({
  'node_modules/openai/internal/qs/formats.mjs'() {
    default_format = 'RFC3986';
    default_formatter = (v) => String(v);
    formatters = {
      RFC1738: (v) => String(v).replace(/%20/g, '+'),
      RFC3986: default_formatter,
    };
    RFC1738 = 'RFC1738';
  },
});

// node_modules/openai/internal/qs/utils.mjs
function is_buffer(obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn) {
  if (isArray3(val)) {
    const mapped = [];
    for (let i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
}
var has, hex_table, limit, encode3;
var init_utils6 = __esm({
  'node_modules/openai/internal/qs/utils.mjs'() {
    init_formats();
    init_values();
    has = (obj, key2) => (
      (has = Object.hasOwn ?? Function.prototype.call.bind(Object.prototype.hasOwnProperty)),
      has(obj, key2)
    );
    hex_table = /* @__PURE__ */ (() => {
      const array = [];
      for (let i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
      }
      return array;
    })();
    limit = 1024;
    encode3 = (str2, _defaultEncoder, charset, _kind, format) => {
      if (str2.length === 0) {
        return str2;
      }
      let string = str2;
      if (typeof str2 === 'symbol') {
        string = Symbol.prototype.toString.call(str2);
      } else if (typeof str2 !== 'string') {
        string = String(str2);
      }
      if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
          return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
      }
      let out = '';
      for (let j = 0; j < string.length; j += limit) {
        const segment = string.length >= limit ? string.slice(j, j + limit) : string;
        const arr = [];
        for (let i = 0; i < segment.length; ++i) {
          let c = segment.charCodeAt(i);
          if (
            c === 45 || // -
            c === 46 || // .
            c === 95 || // _
            c === 126 || // ~
            (c >= 48 && c <= 57) || // 0-9
            (c >= 65 && c <= 90) || // a-z
            (c >= 97 && c <= 122) || // A-Z
            (format === RFC1738 && (c === 40 || c === 41))
          ) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr[arr.length] = hex_table[c];
            continue;
          }
          if (c < 2048) {
            arr[arr.length] = hex_table[192 | (c >> 6)] + hex_table[128 | (c & 63)];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr[arr.length] =
              hex_table[224 | (c >> 12)] +
              hex_table[128 | ((c >> 6) & 63)] +
              hex_table[128 | (c & 63)];
            continue;
          }
          i += 1;
          c = 65536 + (((c & 1023) << 10) | (segment.charCodeAt(i) & 1023));
          arr[arr.length] =
            hex_table[240 | (c >> 18)] +
            hex_table[128 | ((c >> 12) & 63)] +
            hex_table[128 | ((c >> 6) & 63)] +
            hex_table[128 | (c & 63)];
        }
        out += arr.join('');
      }
      return out;
    };
  },
});

// node_modules/openai/internal/qs/stringify.mjs
function is_non_nullish_primitive(v) {
  return (
    typeof v === 'string' ||
    typeof v === 'number' ||
    typeof v === 'boolean' ||
    typeof v === 'symbol' ||
    typeof v === 'bigint'
  );
}
function inner_stringify(
  object,
  prefix,
  generateArrayPrefix,
  commaRoundTrip,
  allowEmptyArrays,
  strictNullHandling,
  skipNulls,
  encodeDotInKeys,
  encoder,
  filter2,
  sort,
  allowDots,
  serializeDate,
  format,
  formatter,
  encodeValuesOnly,
  charset,
  sideChannel
) {
  let obj = object;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
    const pos = tmp_sc.get(object);
    step += 1;
    if (typeof pos !== 'undefined') {
      if (pos === step) {
        throw new RangeError('Cyclic object value');
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === 'undefined') {
      step = 0;
    }
  }
  if (typeof filter2 === 'function') {
    obj = filter2(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate?.(obj);
  } else if (generateArrayPrefix === 'comma' && isArray3(obj)) {
    obj = maybe_map(obj, function (value) {
      if (value instanceof Date) {
        return serializeDate?.(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly
        ? // @ts-expect-error
          encoder(prefix, defaults2.encoder, charset, 'key', format)
        : prefix;
    }
    obj = '';
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder) {
      const key_value = encodeValuesOnly
        ? prefix
        : encoder(prefix, defaults2.encoder, charset, 'key', format);
      return [
        formatter?.(key_value) +
          '=' + // @ts-expect-error
          formatter?.(encoder(obj, defaults2.encoder, charset, 'value', format)),
      ];
    }
    return [formatter?.(prefix) + '=' + formatter?.(String(obj))];
  }
  const values = [];
  if (typeof obj === 'undefined') {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === 'comma' && isArray3(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = maybe_map(obj, encoder);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(',') || null : void 0 }];
  } else if (isArray3(filter2)) {
    obj_keys = filter2;
  } else {
    const keys = Object.keys(obj);
    obj_keys = sort ? keys.sort(sort) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, '%2E') : String(prefix);
  const adjusted_prefix =
    commaRoundTrip && isArray3(obj) && obj.length === 1 ? encoded_prefix + '[]' : encoded_prefix;
  if (allowEmptyArrays && isArray3(obj) && obj.length === 0) {
    return adjusted_prefix + '[]';
  }
  for (let j = 0; j < obj_keys.length; ++j) {
    const key2 = obj_keys[j];
    const value =
      // @ts-ignore
      typeof key2 === 'object' && typeof key2.value !== 'undefined' ? key2.value : obj[key2];
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key2.replace(/\./g, '%2E') : key2;
    const key_prefix = isArray3(obj)
      ? typeof generateArrayPrefix === 'function'
        ? generateArrayPrefix(adjusted_prefix, encoded_key)
        : adjusted_prefix
      : adjusted_prefix + (allowDots ? '.' + encoded_key : '[' + encoded_key + ']');
    sideChannel.set(object, step);
    const valueSideChannel = /* @__PURE__ */ new WeakMap();
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(
      values,
      inner_stringify(
        value,
        key_prefix,
        generateArrayPrefix,
        commaRoundTrip,
        allowEmptyArrays,
        strictNullHandling,
        skipNulls,
        encodeDotInKeys,
        // @ts-ignore
        generateArrayPrefix === 'comma' && encodeValuesOnly && isArray3(obj) ? null : encoder,
        filter2,
        sort,
        allowDots,
        serializeDate,
        format,
        formatter,
        encodeValuesOnly,
        charset,
        valueSideChannel
      )
    );
  }
  return values;
}
function normalize_stringify_options(opts = defaults2) {
  if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
    throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
  }
  if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
    throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
  }
  if (
    opts.encoder !== null &&
    typeof opts.encoder !== 'undefined' &&
    typeof opts.encoder !== 'function'
  ) {
    throw new TypeError('Encoder has to be a function.');
  }
  const charset = opts.charset || defaults2.charset;
  if (
    typeof opts.charset !== 'undefined' &&
    opts.charset !== 'utf-8' &&
    opts.charset !== 'iso-8859-1'
  ) {
    throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
  }
  let format = default_format;
  if (typeof opts.format !== 'undefined') {
    if (!has(formatters, opts.format)) {
      throw new TypeError('Unknown format option provided.');
    }
    format = opts.format;
  }
  const formatter = formatters[format];
  let filter2 = defaults2.filter;
  if (typeof opts.filter === 'function' || isArray3(opts.filter)) {
    filter2 = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ('indices' in opts) {
    arrayFormat = opts.indices ? 'indices' : 'repeat';
  } else {
    arrayFormat = defaults2.arrayFormat;
  }
  if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
    throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
  }
  const allowDots =
    typeof opts.allowDots === 'undefined'
      ? !!opts.encodeDotInKeys === true
        ? true
        : defaults2.allowDots
      : !!opts.allowDots;
  return {
    addQueryPrefix:
      typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults2.addQueryPrefix,
    // @ts-ignore
    allowDots,
    allowEmptyArrays:
      typeof opts.allowEmptyArrays === 'boolean'
        ? !!opts.allowEmptyArrays
        : defaults2.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel:
      typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults2.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === 'undefined' ? defaults2.delimiter : opts.delimiter,
    encode: typeof opts.encode === 'boolean' ? opts.encode : defaults2.encode,
    encodeDotInKeys:
      typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults2.encodeDotInKeys,
    encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults2.encoder,
    encodeValuesOnly:
      typeof opts.encodeValuesOnly === 'boolean'
        ? opts.encodeValuesOnly
        : defaults2.encodeValuesOnly,
    filter: filter2,
    format,
    formatter,
    serializeDate:
      typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults2.serializeDate,
    skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults2.skipNulls,
    // @ts-ignore
    sort: typeof opts.sort === 'function' ? opts.sort : null,
    strictNullHandling:
      typeof opts.strictNullHandling === 'boolean'
        ? opts.strictNullHandling
        : defaults2.strictNullHandling,
  };
}
function stringify3(object, opts = {}) {
  let obj = object;
  const options = normalize_stringify_options(opts);
  let obj_keys;
  let filter2;
  if (typeof options.filter === 'function') {
    filter2 = options.filter;
    obj = filter2('', obj);
  } else if (isArray3(options.filter)) {
    filter2 = options.filter;
    obj_keys = filter2;
  }
  const keys = [];
  if (typeof obj !== 'object' || obj === null) {
    return '';
  }
  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options.sort) {
    obj_keys.sort(options.sort);
  }
  const sideChannel = /* @__PURE__ */ new WeakMap();
  for (let i = 0; i < obj_keys.length; ++i) {
    const key2 = obj_keys[i];
    if (options.skipNulls && obj[key2] === null) {
      continue;
    }
    push_to_array(
      keys,
      inner_stringify(
        obj[key2],
        key2,
        // @ts-expect-error
        generateArrayPrefix,
        commaRoundTrip,
        options.allowEmptyArrays,
        options.strictNullHandling,
        options.skipNulls,
        options.encodeDotInKeys,
        options.encode ? options.encoder : null,
        options.filter,
        options.sort,
        options.allowDots,
        options.serializeDate,
        options.format,
        options.formatter,
        options.encodeValuesOnly,
        options.charset,
        sideChannel
      )
    );
  }
  const joined = keys.join(options.delimiter);
  let prefix = options.addQueryPrefix === true ? '?' : '';
  if (options.charsetSentinel) {
    if (options.charset === 'iso-8859-1') {
      prefix += 'utf8=%26%2310003%3B&';
    } else {
      prefix += 'utf8=%E2%9C%93&';
    }
  }
  return joined.length > 0 ? prefix + joined : '';
}
var array_prefix_generators, push_to_array, toISOString, defaults2, sentinel;
var init_stringify3 = __esm({
  'node_modules/openai/internal/qs/stringify.mjs'() {
    init_utils6();
    init_formats();
    init_values();
    array_prefix_generators = {
      brackets(prefix) {
        return String(prefix) + '[]';
      },
      comma: 'comma',
      indices(prefix, key2) {
        return String(prefix) + '[' + key2 + ']';
      },
      repeat(prefix) {
        return String(prefix);
      },
    };
    push_to_array = function (arr, value_or_array) {
      Array.prototype.push.apply(arr, isArray3(value_or_array) ? value_or_array : [value_or_array]);
    };
    defaults2 = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: 'indices',
      charset: 'utf-8',
      charsetSentinel: false,
      delimiter: '&',
      encode: true,
      encodeDotInKeys: false,
      encoder: encode3,
      encodeValuesOnly: false,
      format: default_format,
      formatter: default_formatter,
      /** @deprecated */
      indices: false,
      serializeDate(date) {
        return (
          toISOString ?? (toISOString = Function.prototype.call.bind(Date.prototype.toISOString))
        )(date);
      },
      skipNulls: false,
      strictNullHandling: false,
    };
    sentinel = {};
  },
});

// node_modules/openai/internal/qs/index.mjs
var init_qs = __esm({
  'node_modules/openai/internal/qs/index.mjs'() {
    init_formats();
    init_stringify3();
  },
});

// node_modules/openai/internal/utils/bytes.mjs
function concatBytes(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index2 = 0;
  for (const buffer of buffers) {
    output.set(buffer, index2);
    index2 += buffer.length;
  }
  return output;
}
function encodeUTF8(str2) {
  let encoder;
  return (
    encodeUTF8_ ??
    ((encoder = new globalThis.TextEncoder()), (encodeUTF8_ = encoder.encode.bind(encoder)))
  )(str2);
}
function decodeUTF8(bytes) {
  let decoder;
  return (
    decodeUTF8_ ??
    ((decoder = new globalThis.TextDecoder()), (decodeUTF8_ = decoder.decode.bind(decoder)))
  )(bytes);
}
var encodeUTF8_, decodeUTF8_;
var init_bytes = __esm({
  'node_modules/openai/internal/utils/bytes.mjs'() {},
});

// node_modules/openai/internal/decoders/line.mjs
function findNewlineIndex(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i = startIndex ?? 0; i < buffer.length; i++) {
    if (buffer[i] === newline) {
      return { preceding: i, index: i + 1, carriage: false };
    }
    if (buffer[i] === carriage) {
      return { preceding: i, index: i + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 1; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (
      buffer[i] === carriage &&
      buffer[i + 1] === newline &&
      i + 3 < buffer.length &&
      buffer[i + 2] === carriage &&
      buffer[i + 3] === newline
    ) {
      return i + 4;
    }
  }
  return -1;
}
var _LineDecoder_buffer, _LineDecoder_carriageReturnIndex, LineDecoder;
var init_line = __esm({
  'node_modules/openai/internal/decoders/line.mjs'() {
    init_tslib();
    init_bytes();
    LineDecoder = class {
      constructor() {
        _LineDecoder_buffer.set(this, void 0);
        _LineDecoder_carriageReturnIndex.set(this, void 0);
        __classPrivateFieldSet(this, _LineDecoder_buffer, new Uint8Array(), 'f');
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, 'f');
      }
      decode(chunk) {
        if (chunk == null) {
          return [];
        }
        const binaryChunk =
          chunk instanceof ArrayBuffer
            ? new Uint8Array(chunk)
            : typeof chunk === 'string'
              ? encodeUTF8(chunk)
              : chunk;
        __classPrivateFieldSet(
          this,
          _LineDecoder_buffer,
          concatBytes([__classPrivateFieldGet(this, _LineDecoder_buffer, 'f'), binaryChunk]),
          'f'
        );
        const lines = [];
        let patternIndex;
        while (
          (patternIndex = findNewlineIndex(
            __classPrivateFieldGet(this, _LineDecoder_buffer, 'f'),
            __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, 'f')
          )) != null
        ) {
          if (
            patternIndex.carriage &&
            __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, 'f') == null
          ) {
            __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, 'f');
            continue;
          }
          if (
            __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, 'f') != null &&
            (patternIndex.index !==
              __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, 'f') + 1 ||
              patternIndex.carriage)
          ) {
            lines.push(
              decodeUTF8(
                __classPrivateFieldGet(this, _LineDecoder_buffer, 'f').subarray(
                  0,
                  __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, 'f') - 1
                )
              )
            );
            __classPrivateFieldSet(
              this,
              _LineDecoder_buffer,
              __classPrivateFieldGet(this, _LineDecoder_buffer, 'f').subarray(
                __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, 'f')
              ),
              'f'
            );
            __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, 'f');
            continue;
          }
          const endIndex =
            __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, 'f') !== null
              ? patternIndex.preceding - 1
              : patternIndex.preceding;
          const line = decodeUTF8(
            __classPrivateFieldGet(this, _LineDecoder_buffer, 'f').subarray(0, endIndex)
          );
          lines.push(line);
          __classPrivateFieldSet(
            this,
            _LineDecoder_buffer,
            __classPrivateFieldGet(this, _LineDecoder_buffer, 'f').subarray(patternIndex.index),
            'f'
          );
          __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, 'f');
        }
        return lines;
      }
      flush() {
        if (!__classPrivateFieldGet(this, _LineDecoder_buffer, 'f').length) {
          return [];
        }
        return this.decode('\n');
      }
    };
    ((_LineDecoder_buffer = /* @__PURE__ */ new WeakMap()),
      (_LineDecoder_carriageReturnIndex = /* @__PURE__ */ new WeakMap()));
    LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(['\n', '\r']);
    LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
  },
});

// node_modules/openai/internal/utils/log.mjs
function noop3() {}
function makeLogFn(fnLevel, logger4, logLevel) {
  if (!logger4 || levelNumbers[fnLevel] > levelNumbers[logLevel]) {
    return noop3;
  } else {
    return logger4[fnLevel].bind(logger4);
  }
}
function loggerFor(client2) {
  const logger4 = client2.logger;
  const logLevel = client2.logLevel ?? 'off';
  if (!logger4) {
    return noopLogger;
  }
  const cachedLogger = cachedLoggers.get(logger4);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn('error', logger4, logLevel),
    warn: makeLogFn('warn', logger4, logLevel),
    info: makeLogFn('info', logger4, logLevel),
    debug: makeLogFn('debug', logger4, logLevel),
  };
  cachedLoggers.set(logger4, [logLevel, levelLogger]);
  return levelLogger;
}
var levelNumbers, parseLogLevel, noopLogger, cachedLoggers, formatRequestDetails;
var init_log = __esm({
  'node_modules/openai/internal/utils/log.mjs'() {
    init_values();
    levelNumbers = {
      off: 0,
      error: 200,
      warn: 300,
      info: 400,
      debug: 500,
    };
    parseLogLevel = (maybeLevel, sourceName, client2) => {
      if (!maybeLevel) {
        return void 0;
      }
      if (hasOwn(levelNumbers, maybeLevel)) {
        return maybeLevel;
      }
      loggerFor(client2).warn(
        `${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`
      );
      return void 0;
    };
    noopLogger = {
      error: noop3,
      warn: noop3,
      info: noop3,
      debug: noop3,
    };
    cachedLoggers = /* @__PURE__ */ new WeakMap();
    formatRequestDetails = (details) => {
      if (details.options) {
        details.options = { ...details.options };
        delete details.options['headers'];
      }
      if (details.headers) {
        details.headers = Object.fromEntries(
          (details.headers instanceof Headers
            ? [...details.headers]
            : Object.entries(details.headers)
          ).map(([name3, value]) => [
            name3,
            name3.toLowerCase() === 'authorization' ||
            name3.toLowerCase() === 'cookie' ||
            name3.toLowerCase() === 'set-cookie'
              ? '***'
              : value,
          ])
        );
      }
      if ('retryOfRequestLogID' in details) {
        if (details.retryOfRequestLogID) {
          details.retryOf = details.retryOfRequestLogID;
        }
        delete details.retryOfRequestLogID;
      }
      return details;
    };
  },
});

// node_modules/openai/core/streaming.mjs
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    if (
      typeof globalThis.navigator !== 'undefined' &&
      globalThis.navigator.product === 'ReactNative'
    ) {
      throw new OpenAIError(
        `The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`
      );
    }
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse) yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse) yield sse;
  }
}
async function* iterSSEChunks(iterator2) {
  let data = new Uint8Array();
  for await (const chunk of iterator2) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk =
      chunk instanceof ArrayBuffer
        ? new Uint8Array(chunk)
        : typeof chunk === 'string'
          ? encodeUTF8(chunk)
          : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
function partition(str2, delimiter) {
  const index2 = str2.indexOf(delimiter);
  if (index2 !== -1) {
    return [str2.substring(0, index2), delimiter, str2.substring(index2 + delimiter.length)];
  }
  return [str2, '', ''];
}
var _Stream_client, Stream, SSEDecoder;
var init_streaming = __esm({
  'node_modules/openai/core/streaming.mjs'() {
    init_tslib();
    init_error();
    init_shims();
    init_line();
    init_shims();
    init_errors3();
    init_bytes();
    init_log();
    init_error();
    Stream = class _Stream {
      constructor(iterator2, controller, client2) {
        this.iterator = iterator2;
        _Stream_client.set(this, void 0);
        this.controller = controller;
        __classPrivateFieldSet(this, _Stream_client, client2, 'f');
      }
      static fromSSEResponse(response, controller, client2) {
        let consumed = false;
        const logger4 = client2 ? loggerFor(client2) : console;
        async function* iterator2() {
          if (consumed) {
            throw new OpenAIError(
              'Cannot iterate over a consumed stream, use `.tee()` to split the stream.'
            );
          }
          consumed = true;
          let done = false;
          try {
            for await (const sse of _iterSSEMessages(response, controller)) {
              if (done) continue;
              if (sse.data.startsWith('[DONE]')) {
                done = true;
                continue;
              }
              if (sse.event === null || !sse.event.startsWith('thread.')) {
                let data;
                try {
                  data = JSON.parse(sse.data);
                } catch (e) {
                  logger4.error(`Could not parse message into JSON:`, sse.data);
                  logger4.error(`From chunk:`, sse.raw);
                  throw e;
                }
                if (data && data.error) {
                  throw new APIError(void 0, data.error, void 0, response.headers);
                }
                yield data;
              } else {
                let data;
                try {
                  data = JSON.parse(sse.data);
                } catch (e) {
                  console.error(`Could not parse message into JSON:`, sse.data);
                  console.error(`From chunk:`, sse.raw);
                  throw e;
                }
                if (sse.event == 'error') {
                  throw new APIError(void 0, data.error, data.message, void 0);
                }
                yield { event: sse.event, data };
              }
            }
            done = true;
          } catch (e) {
            if (isAbortError(e)) return;
            throw e;
          } finally {
            if (!done) controller.abort();
          }
        }
        return new _Stream(iterator2, controller, client2);
      }
      /**
       * Generates a Stream from a newline-separated ReadableStream
       * where each item is a JSON value.
       */
      static fromReadableStream(readableStream, controller, client2) {
        let consumed = false;
        async function* iterLines() {
          const lineDecoder = new LineDecoder();
          const iter = ReadableStreamToAsyncIterable(readableStream);
          for await (const chunk of iter) {
            for (const line of lineDecoder.decode(chunk)) {
              yield line;
            }
          }
          for (const line of lineDecoder.flush()) {
            yield line;
          }
        }
        async function* iterator2() {
          if (consumed) {
            throw new OpenAIError(
              'Cannot iterate over a consumed stream, use `.tee()` to split the stream.'
            );
          }
          consumed = true;
          let done = false;
          try {
            for await (const line of iterLines()) {
              if (done) continue;
              if (line) yield JSON.parse(line);
            }
            done = true;
          } catch (e) {
            if (isAbortError(e)) return;
            throw e;
          } finally {
            if (!done) controller.abort();
          }
        }
        return new _Stream(iterator2, controller, client2);
      }
      [((_Stream_client = /* @__PURE__ */ new WeakMap()), Symbol.asyncIterator)]() {
        return this.iterator();
      }
      /**
       * Splits the stream into two streams which can be
       * independently read from at different speeds.
       */
      tee() {
        const left = [];
        const right = [];
        const iterator2 = this.iterator();
        const teeIterator = (queue) => {
          return {
            next: () => {
              if (queue.length === 0) {
                const result = iterator2.next();
                left.push(result);
                right.push(result);
              }
              return queue.shift();
            },
          };
        };
        return [
          new _Stream(
            () => teeIterator(left),
            this.controller,
            __classPrivateFieldGet(this, _Stream_client, 'f')
          ),
          new _Stream(
            () => teeIterator(right),
            this.controller,
            __classPrivateFieldGet(this, _Stream_client, 'f')
          ),
        ];
      }
      /**
       * Converts this stream to a newline-separated ReadableStream of
       * JSON stringified values in the stream
       * which can be turned back into a Stream with `Stream.fromReadableStream()`.
       */
      toReadableStream() {
        const self3 = this;
        let iter;
        return makeReadableStream({
          async start() {
            iter = self3[Symbol.asyncIterator]();
          },
          async pull(ctrl) {
            try {
              const { value, done } = await iter.next();
              if (done) return ctrl.close();
              const bytes = encodeUTF8(JSON.stringify(value) + '\n');
              ctrl.enqueue(bytes);
            } catch (err) {
              ctrl.error(err);
            }
          },
          async cancel() {
            await iter.return?.();
          },
        });
      }
    };
    SSEDecoder = class {
      constructor() {
        this.event = null;
        this.data = [];
        this.chunks = [];
      }
      decode(line) {
        if (line.endsWith('\r')) {
          line = line.substring(0, line.length - 1);
        }
        if (!line) {
          if (!this.event && !this.data.length) return null;
          const sse = {
            event: this.event,
            data: this.data.join('\n'),
            raw: this.chunks,
          };
          this.event = null;
          this.data = [];
          this.chunks = [];
          return sse;
        }
        this.chunks.push(line);
        if (line.startsWith(':')) {
          return null;
        }
        let [fieldname, _, value] = partition(line, ':');
        if (value.startsWith(' ')) {
          value = value.substring(1);
        }
        if (fieldname === 'event') {
          this.event = value;
        } else if (fieldname === 'data') {
          this.data.push(value);
        }
        return null;
      }
    };
  },
});

// node_modules/openai/internal/parse.mjs
async function defaultParseResponse(client2, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime } = props;
  const body = await (async () => {
    if (props.options.stream) {
      loggerFor(client2).debug(
        'response',
        response.status,
        response.url,
        response.headers,
        response.body
      );
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller, client2);
      }
      return Stream.fromSSEResponse(response, props.controller, client2);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get('content-type');
    const mediaType = contentType?.split(';')[0]?.trim();
    const isJSON = mediaType?.includes('application/json') || mediaType?.endsWith('+json');
    if (isJSON) {
      const json = await response.json();
      return addRequestID(json, response);
    }
    const text2 = await response.text();
    return text2;
  })();
  loggerFor(client2).debug(
    `[${requestLogID}] response parsed`,
    formatRequestDetails({
      retryOfRequestLogID,
      url: response.url,
      status: response.status,
      body,
      durationMs: Date.now() - startTime,
    })
  );
  return body;
}
function addRequestID(value, response) {
  if (!value || typeof value !== 'object' || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, '_request_id', {
    value: response.headers.get('x-request-id'),
    enumerable: false,
  });
}
var init_parse2 = __esm({
  'node_modules/openai/internal/parse.mjs'() {
    init_streaming();
    init_log();
  },
});

// node_modules/openai/core/api-promise.mjs
var _APIPromise_client, APIPromise;
var init_api_promise = __esm({
  'node_modules/openai/core/api-promise.mjs'() {
    init_tslib();
    init_parse2();
    APIPromise = class _APIPromise extends Promise {
      constructor(client2, responsePromise, parseResponse2 = defaultParseResponse) {
        super((resolve) => {
          resolve(null);
        });
        this.responsePromise = responsePromise;
        this.parseResponse = parseResponse2;
        _APIPromise_client.set(this, void 0);
        __classPrivateFieldSet(this, _APIPromise_client, client2, 'f');
      }
      _thenUnwrap(transform) {
        return new _APIPromise(
          __classPrivateFieldGet(this, _APIPromise_client, 'f'),
          this.responsePromise,
          async (client2, props) =>
            addRequestID(transform(await this.parseResponse(client2, props), props), props.response)
        );
      }
      /**
       * Gets the raw `Response` instance instead of parsing the response
       * data.
       *
       * If you want to parse the response body but still get the `Response`
       * instance, you can use {@link withResponse()}.
       *
       *  Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
       * to your `tsconfig.json`.
       */
      asResponse() {
        return this.responsePromise.then((p) => p.response);
      }
      /**
       * Gets the parsed response data, the raw `Response` instance and the ID of the request,
       * returned via the X-Request-ID header which is useful for debugging requests and reporting
       * issues to OpenAI.
       *
       * If you just want to get the raw `Response` instance without parsing it,
       * you can use {@link asResponse()}.
       *
       *  Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
       * to your `tsconfig.json`.
       */
      async withResponse() {
        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
        return { data, response, request_id: response.headers.get('x-request-id') };
      }
      parse() {
        if (!this.parsedPromise) {
          this.parsedPromise = this.responsePromise.then((data) =>
            this.parseResponse(__classPrivateFieldGet(this, _APIPromise_client, 'f'), data)
          );
        }
        return this.parsedPromise;
      }
      then(onfulfilled, onrejected) {
        return this.parse().then(onfulfilled, onrejected);
      }
      catch(onrejected) {
        return this.parse().catch(onrejected);
      }
      finally(onfinally) {
        return this.parse().finally(onfinally);
      }
    };
    _APIPromise_client = /* @__PURE__ */ new WeakMap();
  },
});

// node_modules/openai/core/pagination.mjs
var _AbstractPage_client, AbstractPage, PagePromise, Page, CursorPage, ConversationCursorPage;
var init_pagination = __esm({
  'node_modules/openai/core/pagination.mjs'() {
    init_tslib();
    init_error();
    init_parse2();
    init_api_promise();
    init_values();
    AbstractPage = class {
      constructor(client2, response, body, options) {
        _AbstractPage_client.set(this, void 0);
        __classPrivateFieldSet(this, _AbstractPage_client, client2, 'f');
        this.options = options;
        this.response = response;
        this.body = body;
      }
      hasNextPage() {
        const items = this.getPaginatedItems();
        if (!items.length) return false;
        return this.nextPageRequestOptions() != null;
      }
      async getNextPage() {
        const nextOptions = this.nextPageRequestOptions();
        if (!nextOptions) {
          throw new OpenAIError(
            'No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.'
          );
        }
        return await __classPrivateFieldGet(this, _AbstractPage_client, 'f').requestAPIList(
          this.constructor,
          nextOptions
        );
      }
      async *iterPages() {
        let page = this;
        yield page;
        while (page.hasNextPage()) {
          page = await page.getNextPage();
          yield page;
        }
      }
      async *[((_AbstractPage_client = /* @__PURE__ */ new WeakMap()), Symbol.asyncIterator)]() {
        for await (const page of this.iterPages()) {
          for (const item of page.getPaginatedItems()) {
            yield item;
          }
        }
      }
    };
    PagePromise = class extends APIPromise {
      constructor(client2, request, Page2) {
        super(
          client2,
          request,
          async (client3, props) =>
            new Page2(
              client3,
              props.response,
              await defaultParseResponse(client3, props),
              props.options
            )
        );
      }
      /**
       * Allow auto-paginating iteration on an unawaited list call, eg:
       *
       *    for await (const item of client.items.list()) {
       *      console.log(item)
       *    }
       */
      async *[Symbol.asyncIterator]() {
        const page = await this;
        for await (const item of page) {
          yield item;
        }
      }
    };
    Page = class extends AbstractPage {
      constructor(client2, response, body, options) {
        super(client2, response, body, options);
        this.data = body.data || [];
        this.object = body.object;
      }
      getPaginatedItems() {
        return this.data ?? [];
      }
      nextPageRequestOptions() {
        return null;
      }
    };
    CursorPage = class extends AbstractPage {
      constructor(client2, response, body, options) {
        super(client2, response, body, options);
        this.data = body.data || [];
        this.has_more = body.has_more || false;
      }
      getPaginatedItems() {
        return this.data ?? [];
      }
      hasNextPage() {
        if (this.has_more === false) {
          return false;
        }
        return super.hasNextPage();
      }
      nextPageRequestOptions() {
        const data = this.getPaginatedItems();
        const id = data[data.length - 1]?.id;
        if (!id) {
          return null;
        }
        return {
          ...this.options,
          query: {
            ...maybeObj(this.options.query),
            after: id,
          },
        };
      }
    };
    ConversationCursorPage = class extends AbstractPage {
      constructor(client2, response, body, options) {
        super(client2, response, body, options);
        this.data = body.data || [];
        this.has_more = body.has_more || false;
        this.last_id = body.last_id || '';
      }
      getPaginatedItems() {
        return this.data ?? [];
      }
      hasNextPage() {
        if (this.has_more === false) {
          return false;
        }
        return super.hasNextPage();
      }
      nextPageRequestOptions() {
        const cursor = this.last_id;
        if (!cursor) {
          return null;
        }
        return {
          ...this.options,
          query: {
            ...maybeObj(this.options.query),
            after: cursor,
          },
        };
      }
    };
  },
});

// node_modules/openai/internal/uploads.mjs
function makeFile(fileBits, fileName, options) {
  checkFileSupport();
  return new File(fileBits, fileName ?? 'unknown_file', options);
}
function getName(value) {
  return (
    (
      (typeof value === 'object' &&
        value !== null &&
        (('name' in value && value.name && String(value.name)) ||
          ('url' in value && value.url && String(value.url)) ||
          ('filename' in value && value.filename && String(value.filename)) ||
          ('path' in value && value.path && String(value.path)))) ||
      ''
    )
      .split(/[\\/]/)
      .pop() || void 0
  );
}
function supportsFormData(fetchObject) {
  const fetch2 = typeof fetchObject === 'function' ? fetchObject : fetchObject.fetch;
  const cached = supportsFormDataMap.get(fetch2);
  if (cached) return cached;
  const promise = (async () => {
    try {
      const FetchResponse =
        'Response' in fetch2 ? fetch2.Response : (await fetch2('data:,')).constructor;
      const data = new FormData();
      if (data.toString() === (await new FetchResponse(data).text())) {
        return false;
      }
      return true;
    } catch {
      return true;
    }
  })();
  supportsFormDataMap.set(fetch2, promise);
  return promise;
}
var checkFileSupport,
  isAsyncIterable,
  maybeMultipartFormRequestOptions,
  multipartFormRequestOptions,
  supportsFormDataMap,
  createForm,
  isNamedBlob,
  isUploadable,
  hasUploadableValue,
  addFormValue;
var init_uploads = __esm({
  'node_modules/openai/internal/uploads.mjs'() {
    init_shims();
    checkFileSupport = () => {
      if (typeof File === 'undefined') {
        const { process: process2 } = globalThis;
        const isOldNode =
          typeof process2?.versions?.node === 'string' &&
          parseInt(process2.versions.node.split('.')) < 20;
        throw new Error(
          '`File` is not defined as a global, which is required for file uploads.' +
            (isOldNode
              ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`."
              : '')
        );
      }
    };
    isAsyncIterable = (value) =>
      value != null &&
      typeof value === 'object' &&
      typeof value[Symbol.asyncIterator] === 'function';
    maybeMultipartFormRequestOptions = async (opts, fetch2) => {
      if (!hasUploadableValue(opts.body)) return opts;
      return { ...opts, body: await createForm(opts.body, fetch2) };
    };
    multipartFormRequestOptions = async (opts, fetch2) => {
      return { ...opts, body: await createForm(opts.body, fetch2) };
    };
    supportsFormDataMap = /* @__PURE__ */ new WeakMap();
    createForm = async (body, fetch2) => {
      if (!(await supportsFormData(fetch2))) {
        throw new TypeError(
          'The provided fetch function does not support file uploads with the current global FormData class.'
        );
      }
      const form = new FormData();
      await Promise.all(
        Object.entries(body || {}).map(([key2, value]) => addFormValue(form, key2, value))
      );
      return form;
    };
    isNamedBlob = (value) => value instanceof Blob && 'name' in value;
    isUploadable = (value) =>
      typeof value === 'object' &&
      value !== null &&
      (value instanceof Response || isAsyncIterable(value) || isNamedBlob(value));
    hasUploadableValue = (value) => {
      if (isUploadable(value)) return true;
      if (Array.isArray(value)) return value.some(hasUploadableValue);
      if (value && typeof value === 'object') {
        for (const k in value) {
          if (hasUploadableValue(value[k])) return true;
        }
      }
      return false;
    };
    addFormValue = async (form, key2, value) => {
      if (value === void 0) return;
      if (value == null) {
        throw new TypeError(
          `Received null for "${key2}"; to pass null in FormData, you must use the string 'null'`
        );
      }
      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
        form.append(key2, String(value));
      } else if (value instanceof Response) {
        form.append(key2, makeFile([await value.blob()], getName(value)));
      } else if (isAsyncIterable(value)) {
        form.append(
          key2,
          makeFile([await new Response(ReadableStreamFrom(value)).blob()], getName(value))
        );
      } else if (isNamedBlob(value)) {
        form.append(key2, value, getName(value));
      } else if (Array.isArray(value)) {
        await Promise.all(value.map((entry) => addFormValue(form, key2 + '[]', entry)));
      } else if (typeof value === 'object') {
        await Promise.all(
          Object.entries(value).map(([name3, prop2]) =>
            addFormValue(form, `${key2}[${name3}]`, prop2)
          )
        );
      } else {
        throw new TypeError(
          `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`
        );
      }
    };
  },
});

// node_modules/openai/internal/to-file.mjs
async function toFile(value, name3, options) {
  checkFileSupport();
  value = await value;
  if (isFileLike(value)) {
    if (value instanceof File) {
      return value;
    }
    return makeFile([await value.arrayBuffer()], value.name);
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name3 || (name3 = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile(await getBytes(blob), name3, options);
  }
  const parts = await getBytes(value);
  name3 || (name3 = getName(value));
  if (!options?.type) {
    const type = parts.find((part) => typeof part === 'object' && 'type' in part && part.type);
    if (typeof type === 'string') {
      options = { ...options, type };
    }
  }
  return makeFile(parts, name3, options);
}
async function getBytes(value) {
  let parts = [];
  if (
    typeof value === 'string' ||
    ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
    value instanceof ArrayBuffer
  ) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable(value)) {
    for await (const chunk of value) {
      parts.push(...(await getBytes(chunk)));
    }
  } else {
    const constructor = value?.constructor?.name;
    throw new Error(
      `Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ''}${propsForError(value)}`
    );
  }
  return parts;
}
function propsForError(value) {
  if (typeof value !== 'object' || value === null) return '';
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p) => `"${p}"`).join(', ')}]`;
}
var isBlobLike, isFileLike, isResponseLike;
var init_to_file = __esm({
  'node_modules/openai/internal/to-file.mjs'() {
    init_uploads();
    init_uploads();
    isBlobLike = (value) =>
      value != null &&
      typeof value === 'object' &&
      typeof value.size === 'number' &&
      typeof value.type === 'string' &&
      typeof value.text === 'function' &&
      typeof value.slice === 'function' &&
      typeof value.arrayBuffer === 'function';
    isFileLike = (value) =>
      value != null &&
      typeof value === 'object' &&
      typeof value.name === 'string' &&
      typeof value.lastModified === 'number' &&
      isBlobLike(value);
    isResponseLike = (value) =>
      value != null &&
      typeof value === 'object' &&
      typeof value.url === 'string' &&
      typeof value.blob === 'function';
  },
});

// node_modules/openai/core/uploads.mjs
var init_uploads2 = __esm({
  'node_modules/openai/core/uploads.mjs'() {
    init_to_file();
  },
});

// node_modules/openai/core/resource.mjs
var APIResource;
var init_resource = __esm({
  'node_modules/openai/core/resource.mjs'() {
    APIResource = class {
      constructor(client2) {
        this._client = client2;
      }
    };
  },
});

// node_modules/openai/internal/utils/path.mjs
function encodeURIPath(str2) {
  return str2.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
var EMPTY, createPathTagFunction, path3;
var init_path = __esm({
  'node_modules/openai/internal/utils/path.mjs'() {
    init_error();
    EMPTY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));
    createPathTagFunction = (pathEncoder = encodeURIPath) =>
      function path5(statics, ...params) {
        if (statics.length === 1) return statics[0];
        let postPath = false;
        const invalidSegments = [];
        const path6 = statics.reduce((previousValue, currentValue, index2) => {
          if (/[?#]/.test(currentValue)) {
            postPath = true;
          }
          const value = params[index2];
          let encoded = (postPath ? encodeURIComponent : pathEncoder)('' + value);
          if (
            index2 !== params.length &&
            (value == null ||
              (typeof value === 'object' && // handle values from other realms
                value.toString ===
                  Object.getPrototypeOf(
                    Object.getPrototypeOf(value.hasOwnProperty ?? EMPTY) ?? EMPTY
                  )?.toString))
          ) {
            encoded = value + '';
            invalidSegments.push({
              start: previousValue.length + currentValue.length,
              length: encoded.length,
              error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`,
            });
          }
          return previousValue + currentValue + (index2 === params.length ? '' : encoded);
        }, '');
        const pathOnly = path6.split(/[?#]/, 1)[0];
        const invalidSegmentPattern = /(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;
        let match;
        while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
          invalidSegments.push({
            start: match.index,
            length: match[0].length,
            error: `Value "${match[0]}" can't be safely passed as a path parameter`,
          });
        }
        invalidSegments.sort((a, b) => a.start - b.start);
        if (invalidSegments.length > 0) {
          let lastEnd = 0;
          const underline = invalidSegments.reduce((acc, segment) => {
            const spaces = ' '.repeat(segment.start - lastEnd);
            const arrows = '^'.repeat(segment.length);
            lastEnd = segment.start + segment.length;
            return acc + spaces + arrows;
          }, '');
          throw new OpenAIError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e) => e.error).join('\n')}
${path6}
${underline}`);
        }
        return path6;
      };
    path3 = /* @__PURE__ */ createPathTagFunction(encodeURIPath);
  },
});

// node_modules/openai/resources/chat/completions/messages.mjs
var Messages;
var init_messages = __esm({
  'node_modules/openai/resources/chat/completions/messages.mjs'() {
    init_resource();
    init_pagination();
    init_path();
    Messages = class extends APIResource {
      /**
       * Get the messages in a stored chat completion. Only Chat Completions that have
       * been created with the `store` parameter set to `true` will be returned.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const chatCompletionStoreMessage of client.chat.completions.messages.list(
       *   'completion_id',
       * )) {
       *   // ...
       * }
       * ```
       */
      list(completionID, query = {}, options) {
        return this._client.getAPIList(
          path3`/chat/completions/${completionID}/messages`,
          CursorPage,
          { query, ...options }
        );
      }
    };
  },
});

// node_modules/openai/error.mjs
var init_error2 = __esm({
  'node_modules/openai/error.mjs'() {
    init_error();
  },
});

// node_modules/openai/lib/parser.mjs
function isChatCompletionFunctionTool(tool) {
  return tool !== void 0 && 'function' in tool && tool.function !== void 0;
}
function isAutoParsableResponseFormat(response_format) {
  return response_format?.['$brand'] === 'auto-parseable-response-format';
}
function isAutoParsableTool(tool) {
  return tool?.['$brand'] === 'auto-parseable-tool';
}
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => {
        assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
        return {
          ...choice,
          message: {
            ...choice.message,
            parsed: null,
            ...(choice.message.tool_calls
              ? {
                  tool_calls: choice.message.tool_calls,
                }
              : void 0),
          },
        };
      }),
    };
  }
  return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    if (choice.finish_reason === 'length') {
      throw new LengthFinishReasonError();
    }
    if (choice.finish_reason === 'content_filter') {
      throw new ContentFilterFinishReasonError();
    }
    assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
    return {
      ...choice,
      message: {
        ...choice.message,
        ...(choice.message.tool_calls
          ? {
              tool_calls:
                choice.message.tool_calls?.map((toolCall) => parseToolCall(params, toolCall)) ??
                void 0,
            }
          : void 0),
        parsed:
          choice.message.content && !choice.message.refusal
            ? parseResponseFormat(params, choice.message.content)
            : null,
      },
    };
  });
  return { ...completion, choices };
}
function parseResponseFormat(params, content) {
  if (params.response_format?.type !== 'json_schema') {
    return null;
  }
  if (params.response_format?.type === 'json_schema') {
    if ('$parseRaw' in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
function parseToolCall(params, toolCall) {
  const inputTool = params.tools?.find(
    (inputTool2) =>
      isChatCompletionFunctionTool(inputTool2) &&
      inputTool2.function?.name === toolCall.function.name
  );
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool(inputTool)
        ? inputTool.$parseRaw(toolCall.function.arguments)
        : inputTool?.function.strict
          ? JSON.parse(toolCall.function.arguments)
          : null,
    },
  };
}
function shouldParseToolCall(params, toolCall) {
  if (!params || !('tools' in params) || !params.tools) {
    return false;
  }
  const inputTool = params.tools?.find(
    (inputTool2) =>
      isChatCompletionFunctionTool(inputTool2) &&
      inputTool2.function?.name === toolCall.function.name
  );
  return (
    isChatCompletionFunctionTool(inputTool) &&
    (isAutoParsableTool(inputTool) || inputTool?.function.strict || false)
  );
}
function hasAutoParseableInput(params) {
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return (
    params.tools?.some(
      (t) => isAutoParsableTool(t) || (t.type === 'function' && t.function.strict === true)
    ) ?? false
  );
}
function assertToolCallsAreChatCompletionFunctionToolCalls(toolCalls) {
  for (const toolCall of toolCalls || []) {
    if (toolCall.type !== 'function') {
      throw new OpenAIError(
        `Currently only \`function\` tool calls are supported; Received \`${toolCall.type}\``
      );
    }
  }
}
function validateInputTools(tools) {
  for (const tool of tools ?? []) {
    if (tool.type !== 'function') {
      throw new OpenAIError(
        `Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``
      );
    }
    if (tool.function.strict !== true) {
      throw new OpenAIError(
        `The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`
      );
    }
  }
}
var init_parser = __esm({
  'node_modules/openai/lib/parser.mjs'() {
    init_error2();
  },
});

// node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage, isToolMessage;
var init_chatCompletionUtils = __esm({
  'node_modules/openai/lib/chatCompletionUtils.mjs'() {
    isAssistantMessage = (message) => {
      return message?.role === 'assistant';
    };
    isToolMessage = (message) => {
      return message?.role === 'tool';
    };
  },
});

// node_modules/openai/lib/EventStream.mjs
var _EventStream_instances,
  _EventStream_connectedPromise,
  _EventStream_resolveConnectedPromise,
  _EventStream_rejectConnectedPromise,
  _EventStream_endPromise,
  _EventStream_resolveEndPromise,
  _EventStream_rejectEndPromise,
  _EventStream_listeners,
  _EventStream_ended,
  _EventStream_errored,
  _EventStream_aborted,
  _EventStream_catchingPromiseCreated,
  _EventStream_handleError,
  EventStream;
var init_EventStream = __esm({
  'node_modules/openai/lib/EventStream.mjs'() {
    init_tslib();
    init_error2();
    EventStream = class {
      constructor() {
        _EventStream_instances.add(this);
        this.controller = new AbortController();
        _EventStream_connectedPromise.set(this, void 0);
        _EventStream_resolveConnectedPromise.set(this, () => {});
        _EventStream_rejectConnectedPromise.set(this, () => {});
        _EventStream_endPromise.set(this, void 0);
        _EventStream_resolveEndPromise.set(this, () => {});
        _EventStream_rejectEndPromise.set(this, () => {});
        _EventStream_listeners.set(this, {});
        _EventStream_ended.set(this, false);
        _EventStream_errored.set(this, false);
        _EventStream_aborted.set(this, false);
        _EventStream_catchingPromiseCreated.set(this, false);
        __classPrivateFieldSet(
          this,
          _EventStream_connectedPromise,
          new Promise((resolve, reject) => {
            __classPrivateFieldSet(this, _EventStream_resolveConnectedPromise, resolve, 'f');
            __classPrivateFieldSet(this, _EventStream_rejectConnectedPromise, reject, 'f');
          }),
          'f'
        );
        __classPrivateFieldSet(
          this,
          _EventStream_endPromise,
          new Promise((resolve, reject) => {
            __classPrivateFieldSet(this, _EventStream_resolveEndPromise, resolve, 'f');
            __classPrivateFieldSet(this, _EventStream_rejectEndPromise, reject, 'f');
          }),
          'f'
        );
        __classPrivateFieldGet(this, _EventStream_connectedPromise, 'f').catch(() => {});
        __classPrivateFieldGet(this, _EventStream_endPromise, 'f').catch(() => {});
      }
      _run(executor) {
        setTimeout(() => {
          executor().then(
            () => {
              this._emitFinal();
              this._emit('end');
            },
            __classPrivateFieldGet(
              this,
              _EventStream_instances,
              'm',
              _EventStream_handleError
            ).bind(this)
          );
        }, 0);
      }
      _connected() {
        if (this.ended) return;
        __classPrivateFieldGet(this, _EventStream_resolveConnectedPromise, 'f').call(this);
        this._emit('connect');
      }
      get ended() {
        return __classPrivateFieldGet(this, _EventStream_ended, 'f');
      }
      get errored() {
        return __classPrivateFieldGet(this, _EventStream_errored, 'f');
      }
      get aborted() {
        return __classPrivateFieldGet(this, _EventStream_aborted, 'f');
      }
      abort() {
        this.controller.abort();
      }
      /**
       * Adds the listener function to the end of the listeners array for the event.
       * No checks are made to see if the listener has already been added. Multiple calls passing
       * the same combination of event and listener will result in the listener being added, and
       * called, multiple times.
       * @returns this ChatCompletionStream, so that calls can be chained
       */
      on(event2, listener) {
        const listeners =
          __classPrivateFieldGet(this, _EventStream_listeners, 'f')[event2] ||
          (__classPrivateFieldGet(this, _EventStream_listeners, 'f')[event2] = []);
        listeners.push({ listener });
        return this;
      }
      /**
       * Removes the specified listener from the listener array for the event.
       * off() will remove, at most, one instance of a listener from the listener array. If any single
       * listener has been added multiple times to the listener array for the specified event, then
       * off() must be called multiple times to remove each instance.
       * @returns this ChatCompletionStream, so that calls can be chained
       */
      off(event2, listener) {
        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, 'f')[event2];
        if (!listeners) return this;
        const index2 = listeners.findIndex((l) => l.listener === listener);
        if (index2 >= 0) listeners.splice(index2, 1);
        return this;
      }
      /**
       * Adds a one-time listener function for the event. The next time the event is triggered,
       * this listener is removed and then invoked.
       * @returns this ChatCompletionStream, so that calls can be chained
       */
      once(event2, listener) {
        const listeners =
          __classPrivateFieldGet(this, _EventStream_listeners, 'f')[event2] ||
          (__classPrivateFieldGet(this, _EventStream_listeners, 'f')[event2] = []);
        listeners.push({ listener, once: true });
        return this;
      }
      /**
       * This is similar to `.once()`, but returns a Promise that resolves the next time
       * the event is triggered, instead of calling a listener callback.
       * @returns a Promise that resolves the next time given event is triggered,
       * or rejects if an error is emitted.  (If you request the 'error' event,
       * returns a promise that resolves with the error).
       *
       * Example:
       *
       *   const message = await stream.emitted('message') // rejects if the stream errors
       */
      emitted(event2) {
        return new Promise((resolve, reject) => {
          __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, 'f');
          if (event2 !== 'error') this.once('error', reject);
          this.once(event2, resolve);
        });
      }
      async done() {
        __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, 'f');
        await __classPrivateFieldGet(this, _EventStream_endPromise, 'f');
      }
      _emit(event2, ...args) {
        if (__classPrivateFieldGet(this, _EventStream_ended, 'f')) {
          return;
        }
        if (event2 === 'end') {
          __classPrivateFieldSet(this, _EventStream_ended, true, 'f');
          __classPrivateFieldGet(this, _EventStream_resolveEndPromise, 'f').call(this);
        }
        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, 'f')[event2];
        if (listeners) {
          __classPrivateFieldGet(this, _EventStream_listeners, 'f')[event2] = listeners.filter(
            (l) => !l.once
          );
          listeners.forEach(({ listener }) => listener(...args));
        }
        if (event2 === 'abort') {
          const error = args[0];
          if (
            !__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, 'f') &&
            !listeners?.length
          ) {
            Promise.reject(error);
          }
          __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, 'f').call(this, error);
          __classPrivateFieldGet(this, _EventStream_rejectEndPromise, 'f').call(this, error);
          this._emit('end');
          return;
        }
        if (event2 === 'error') {
          const error = args[0];
          if (
            !__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, 'f') &&
            !listeners?.length
          ) {
            Promise.reject(error);
          }
          __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, 'f').call(this, error);
          __classPrivateFieldGet(this, _EventStream_rejectEndPromise, 'f').call(this, error);
          this._emit('end');
        }
      }
      _emitFinal() {}
    };
    ((_EventStream_connectedPromise = /* @__PURE__ */ new WeakMap()),
      (_EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap()),
      (_EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap()),
      (_EventStream_endPromise = /* @__PURE__ */ new WeakMap()),
      (_EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap()),
      (_EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap()),
      (_EventStream_listeners = /* @__PURE__ */ new WeakMap()),
      (_EventStream_ended = /* @__PURE__ */ new WeakMap()),
      (_EventStream_errored = /* @__PURE__ */ new WeakMap()),
      (_EventStream_aborted = /* @__PURE__ */ new WeakMap()),
      (_EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap()),
      (_EventStream_instances = /* @__PURE__ */ new WeakSet()),
      (_EventStream_handleError = function _EventStream_handleError2(error) {
        __classPrivateFieldSet(this, _EventStream_errored, true, 'f');
        if (error instanceof Error && error.name === 'AbortError') {
          error = new APIUserAbortError();
        }
        if (error instanceof APIUserAbortError) {
          __classPrivateFieldSet(this, _EventStream_aborted, true, 'f');
          return this._emit('abort', error);
        }
        if (error instanceof OpenAIError) {
          return this._emit('error', error);
        }
        if (error instanceof Error) {
          const openAIError = new OpenAIError(error.message);
          openAIError.cause = error;
          return this._emit('error', openAIError);
        }
        return this._emit('error', new OpenAIError(String(error)));
      }));
  },
});

// node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === 'function';
}
var init_RunnableFunction = __esm({
  'node_modules/openai/lib/RunnableFunction.mjs'() {},
});

// node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var _AbstractChatCompletionRunner_instances,
  _AbstractChatCompletionRunner_getFinalContent,
  _AbstractChatCompletionRunner_getFinalMessage,
  _AbstractChatCompletionRunner_getFinalFunctionToolCall,
  _AbstractChatCompletionRunner_getFinalFunctionToolCallResult,
  _AbstractChatCompletionRunner_calculateTotalUsage,
  _AbstractChatCompletionRunner_validateParams,
  _AbstractChatCompletionRunner_stringifyFunctionCallResult,
  DEFAULT_MAX_CHAT_COMPLETIONS,
  AbstractChatCompletionRunner;
var init_AbstractChatCompletionRunner = __esm({
  'node_modules/openai/lib/AbstractChatCompletionRunner.mjs'() {
    init_tslib();
    init_error2();
    init_parser();
    init_chatCompletionUtils();
    init_EventStream();
    init_RunnableFunction();
    DEFAULT_MAX_CHAT_COMPLETIONS = 10;
    AbstractChatCompletionRunner = class extends EventStream {
      constructor() {
        super(...arguments);
        _AbstractChatCompletionRunner_instances.add(this);
        this._chatCompletions = [];
        this.messages = [];
      }
      _addChatCompletion(chatCompletion) {
        this._chatCompletions.push(chatCompletion);
        this._emit('chatCompletion', chatCompletion);
        const message = chatCompletion.choices[0]?.message;
        if (message) this._addMessage(message);
        return chatCompletion;
      }
      _addMessage(message, emit2 = true) {
        if (!('content' in message)) message.content = null;
        this.messages.push(message);
        if (emit2) {
          this._emit('message', message);
          if (isToolMessage(message) && message.content) {
            this._emit('functionToolCallResult', message.content);
          } else if (isAssistantMessage(message) && message.tool_calls) {
            for (const tool_call of message.tool_calls) {
              if (tool_call.type === 'function') {
                this._emit('functionToolCall', tool_call.function);
              }
            }
          }
        }
      }
      /**
       * @returns a promise that resolves with the final ChatCompletion, or rejects
       * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
       */
      async finalChatCompletion() {
        await this.done();
        const completion = this._chatCompletions[this._chatCompletions.length - 1];
        if (!completion) throw new OpenAIError('stream ended without producing a ChatCompletion');
        return completion;
      }
      /**
       * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
       * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
       */
      async finalContent() {
        await this.done();
        return __classPrivateFieldGet(
          this,
          _AbstractChatCompletionRunner_instances,
          'm',
          _AbstractChatCompletionRunner_getFinalContent
        ).call(this);
      }
      /**
       * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
       * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
       */
      async finalMessage() {
        await this.done();
        return __classPrivateFieldGet(
          this,
          _AbstractChatCompletionRunner_instances,
          'm',
          _AbstractChatCompletionRunner_getFinalMessage
        ).call(this);
      }
      /**
       * @returns a promise that resolves with the content of the final FunctionCall, or rejects
       * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
       */
      async finalFunctionToolCall() {
        await this.done();
        return __classPrivateFieldGet(
          this,
          _AbstractChatCompletionRunner_instances,
          'm',
          _AbstractChatCompletionRunner_getFinalFunctionToolCall
        ).call(this);
      }
      async finalFunctionToolCallResult() {
        await this.done();
        return __classPrivateFieldGet(
          this,
          _AbstractChatCompletionRunner_instances,
          'm',
          _AbstractChatCompletionRunner_getFinalFunctionToolCallResult
        ).call(this);
      }
      async totalUsage() {
        await this.done();
        return __classPrivateFieldGet(
          this,
          _AbstractChatCompletionRunner_instances,
          'm',
          _AbstractChatCompletionRunner_calculateTotalUsage
        ).call(this);
      }
      allChatCompletions() {
        return [...this._chatCompletions];
      }
      _emitFinal() {
        const completion = this._chatCompletions[this._chatCompletions.length - 1];
        if (completion) this._emit('finalChatCompletion', completion);
        const finalMessage = __classPrivateFieldGet(
          this,
          _AbstractChatCompletionRunner_instances,
          'm',
          _AbstractChatCompletionRunner_getFinalMessage
        ).call(this);
        if (finalMessage) this._emit('finalMessage', finalMessage);
        const finalContent = __classPrivateFieldGet(
          this,
          _AbstractChatCompletionRunner_instances,
          'm',
          _AbstractChatCompletionRunner_getFinalContent
        ).call(this);
        if (finalContent) this._emit('finalContent', finalContent);
        const finalFunctionCall = __classPrivateFieldGet(
          this,
          _AbstractChatCompletionRunner_instances,
          'm',
          _AbstractChatCompletionRunner_getFinalFunctionToolCall
        ).call(this);
        if (finalFunctionCall) this._emit('finalFunctionToolCall', finalFunctionCall);
        const finalFunctionCallResult = __classPrivateFieldGet(
          this,
          _AbstractChatCompletionRunner_instances,
          'm',
          _AbstractChatCompletionRunner_getFinalFunctionToolCallResult
        ).call(this);
        if (finalFunctionCallResult != null)
          this._emit('finalFunctionToolCallResult', finalFunctionCallResult);
        if (this._chatCompletions.some((c) => c.usage)) {
          this._emit(
            'totalUsage',
            __classPrivateFieldGet(
              this,
              _AbstractChatCompletionRunner_instances,
              'm',
              _AbstractChatCompletionRunner_calculateTotalUsage
            ).call(this)
          );
        }
      }
      async _createChatCompletion(client2, params, options) {
        const signal = options?.signal;
        if (signal) {
          if (signal.aborted) this.controller.abort();
          signal.addEventListener('abort', () => this.controller.abort());
        }
        __classPrivateFieldGet(
          this,
          _AbstractChatCompletionRunner_instances,
          'm',
          _AbstractChatCompletionRunner_validateParams
        ).call(this, params);
        const chatCompletion = await client2.chat.completions.create(
          { ...params, stream: false },
          { ...options, signal: this.controller.signal }
        );
        this._connected();
        return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
      }
      async _runChatCompletion(client2, params, options) {
        for (const message of params.messages) {
          this._addMessage(message, false);
        }
        return await this._createChatCompletion(client2, params, options);
      }
      async _runTools(client2, params, options) {
        const role = 'tool';
        const { tool_choice = 'auto', stream: stream4, ...restParams } = params;
        const singleFunctionToCall =
          typeof tool_choice !== 'string' &&
          tool_choice.type === 'function' &&
          tool_choice?.function?.name;
        const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
        const inputTools = params.tools.map((tool) => {
          if (isAutoParsableTool(tool)) {
            if (!tool.$callback) {
              throw new OpenAIError(
                'Tool given to `.runTools()` that does not have an associated function'
              );
            }
            return {
              type: 'function',
              function: {
                function: tool.$callback,
                name: tool.function.name,
                description: tool.function.description || '',
                parameters: tool.function.parameters,
                parse: tool.$parseRaw,
                strict: true,
              },
            };
          }
          return tool;
        });
        const functionsByName = {};
        for (const f of inputTools) {
          if (f.type === 'function') {
            functionsByName[f.function.name || f.function.function.name] = f.function;
          }
        }
        const tools =
          'tools' in params
            ? inputTools.map((t) =>
                t.type === 'function'
                  ? {
                      type: 'function',
                      function: {
                        name: t.function.name || t.function.function.name,
                        parameters: t.function.parameters,
                        description: t.function.description,
                        strict: t.function.strict,
                      },
                    }
                  : t
              )
            : void 0;
        for (const message of params.messages) {
          this._addMessage(message, false);
        }
        for (let i = 0; i < maxChatCompletions; ++i) {
          const chatCompletion = await this._createChatCompletion(
            client2,
            {
              ...restParams,
              tool_choice,
              tools,
              messages: [...this.messages],
            },
            options
          );
          const message = chatCompletion.choices[0]?.message;
          if (!message) {
            throw new OpenAIError(`missing message in ChatCompletion response`);
          }
          if (!message.tool_calls?.length) {
            return;
          }
          for (const tool_call of message.tool_calls) {
            if (tool_call.type !== 'function') continue;
            const tool_call_id = tool_call.id;
            const { name: name3, arguments: args } = tool_call.function;
            const fn = functionsByName[name3];
            if (!fn) {
              const content2 = `Invalid tool_call: ${JSON.stringify(name3)}. Available options are: ${Object.keys(
                functionsByName
              )
                .map((name4) => JSON.stringify(name4))
                .join(', ')}. Please try again`;
              this._addMessage({ role, tool_call_id, content: content2 });
              continue;
            } else if (singleFunctionToCall && singleFunctionToCall !== name3) {
              const content2 = `Invalid tool_call: ${JSON.stringify(name3)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
              this._addMessage({ role, tool_call_id, content: content2 });
              continue;
            }
            let parsed;
            try {
              parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
            } catch (error) {
              const content2 = error instanceof Error ? error.message : String(error);
              this._addMessage({ role, tool_call_id, content: content2 });
              continue;
            }
            const rawContent = await fn.function(parsed, this);
            const content = __classPrivateFieldGet(
              this,
              _AbstractChatCompletionRunner_instances,
              'm',
              _AbstractChatCompletionRunner_stringifyFunctionCallResult
            ).call(this, rawContent);
            this._addMessage({ role, tool_call_id, content });
            if (singleFunctionToCall) {
              return;
            }
          }
        }
        return;
      }
    };
    ((_AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet()),
      (_AbstractChatCompletionRunner_getFinalContent =
        function _AbstractChatCompletionRunner_getFinalContent2() {
          return (
            __classPrivateFieldGet(
              this,
              _AbstractChatCompletionRunner_instances,
              'm',
              _AbstractChatCompletionRunner_getFinalMessage
            ).call(this).content ?? null
          );
        }),
      (_AbstractChatCompletionRunner_getFinalMessage =
        function _AbstractChatCompletionRunner_getFinalMessage2() {
          let i = this.messages.length;
          while (i-- > 0) {
            const message = this.messages[i];
            if (isAssistantMessage(message)) {
              const ret = {
                ...message,
                content: message.content ?? null,
                refusal: message.refusal ?? null,
              };
              return ret;
            }
          }
          throw new OpenAIError(
            'stream ended without producing a ChatCompletionMessage with role=assistant'
          );
        }),
      (_AbstractChatCompletionRunner_getFinalFunctionToolCall =
        function _AbstractChatCompletionRunner_getFinalFunctionToolCall2() {
          for (let i = this.messages.length - 1; i >= 0; i--) {
            const message = this.messages[i];
            if (isAssistantMessage(message) && message?.tool_calls?.length) {
              return message.tool_calls.filter((x) => x.type === 'function').at(-1)?.function;
            }
          }
          return;
        }),
      (_AbstractChatCompletionRunner_getFinalFunctionToolCallResult =
        function _AbstractChatCompletionRunner_getFinalFunctionToolCallResult2() {
          for (let i = this.messages.length - 1; i >= 0; i--) {
            const message = this.messages[i];
            if (
              isToolMessage(message) &&
              message.content != null &&
              typeof message.content === 'string' &&
              this.messages.some(
                (x) =>
                  x.role === 'assistant' &&
                  x.tool_calls?.some((y) => y.type === 'function' && y.id === message.tool_call_id)
              )
            ) {
              return message.content;
            }
          }
          return;
        }),
      (_AbstractChatCompletionRunner_calculateTotalUsage =
        function _AbstractChatCompletionRunner_calculateTotalUsage2() {
          const total = {
            completion_tokens: 0,
            prompt_tokens: 0,
            total_tokens: 0,
          };
          for (const { usage } of this._chatCompletions) {
            if (usage) {
              total.completion_tokens += usage.completion_tokens;
              total.prompt_tokens += usage.prompt_tokens;
              total.total_tokens += usage.total_tokens;
            }
          }
          return total;
        }),
      (_AbstractChatCompletionRunner_validateParams =
        function _AbstractChatCompletionRunner_validateParams2(params) {
          if (params.n != null && params.n > 1) {
            throw new OpenAIError(
              'ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.'
            );
          }
        }),
      (_AbstractChatCompletionRunner_stringifyFunctionCallResult =
        function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
          return typeof rawContent === 'string'
            ? rawContent
            : rawContent === void 0
              ? 'undefined'
              : JSON.stringify(rawContent);
        }));
  },
});

// node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner;
var init_ChatCompletionRunner = __esm({
  'node_modules/openai/lib/ChatCompletionRunner.mjs'() {
    init_AbstractChatCompletionRunner();
    init_chatCompletionUtils();
    ChatCompletionRunner = class _ChatCompletionRunner extends AbstractChatCompletionRunner {
      static runTools(client2, params, options) {
        const runner = new _ChatCompletionRunner();
        const opts = {
          ...options,
          headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runTools' },
        };
        runner._run(() => runner._runTools(client2, params, opts));
        return runner;
      }
      _addMessage(message, emit2 = true) {
        super._addMessage(message, emit2);
        if (isAssistantMessage(message) && message.content) {
          this._emit('content', message.content);
        }
      }
    };
  },
});

// node_modules/openai/_vendor/partial-json-parser/parser.mjs
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== 'string') {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
var STR,
  NUM,
  ARR,
  OBJ,
  NULL,
  BOOL,
  NAN,
  INFINITY,
  MINUS_INFINITY,
  INF,
  SPECIAL,
  ATOM,
  COLLECTION,
  ALL,
  Allow,
  PartialJSON,
  MalformedJSON,
  _parseJSON,
  partialParse;
var init_parser2 = __esm({
  'node_modules/openai/_vendor/partial-json-parser/parser.mjs'() {
    STR = 1;
    NUM = 2;
    ARR = 4;
    OBJ = 8;
    NULL = 16;
    BOOL = 32;
    NAN = 64;
    INFINITY = 128;
    MINUS_INFINITY = 256;
    INF = INFINITY | MINUS_INFINITY;
    SPECIAL = NULL | BOOL | INF | NAN;
    ATOM = STR | NUM | SPECIAL;
    COLLECTION = ARR | OBJ;
    ALL = ATOM | COLLECTION;
    Allow = {
      STR,
      NUM,
      ARR,
      OBJ,
      NULL,
      BOOL,
      NAN,
      INFINITY,
      MINUS_INFINITY,
      INF,
      SPECIAL,
      ATOM,
      COLLECTION,
      ALL,
    };
    PartialJSON = class extends Error {};
    MalformedJSON = class extends Error {};
    _parseJSON = (jsonString, allow) => {
      const length = jsonString.length;
      let index2 = 0;
      const markPartialJSON = (msg) => {
        throw new PartialJSON(`${msg} at position ${index2}`);
      };
      const throwMalformedError = (msg) => {
        throw new MalformedJSON(`${msg} at position ${index2}`);
      };
      const parseAny = () => {
        skipBlank();
        if (index2 >= length) markPartialJSON('Unexpected end of input');
        if (jsonString[index2] === '"') return parseStr();
        if (jsonString[index2] === '{') return parseObj();
        if (jsonString[index2] === '[') return parseArr();
        if (
          jsonString.substring(index2, index2 + 4) === 'null' ||
          (Allow.NULL & allow &&
            length - index2 < 4 &&
            'null'.startsWith(jsonString.substring(index2)))
        ) {
          index2 += 4;
          return null;
        }
        if (
          jsonString.substring(index2, index2 + 4) === 'true' ||
          (Allow.BOOL & allow &&
            length - index2 < 4 &&
            'true'.startsWith(jsonString.substring(index2)))
        ) {
          index2 += 4;
          return true;
        }
        if (
          jsonString.substring(index2, index2 + 5) === 'false' ||
          (Allow.BOOL & allow &&
            length - index2 < 5 &&
            'false'.startsWith(jsonString.substring(index2)))
        ) {
          index2 += 5;
          return false;
        }
        if (
          jsonString.substring(index2, index2 + 8) === 'Infinity' ||
          (Allow.INFINITY & allow &&
            length - index2 < 8 &&
            'Infinity'.startsWith(jsonString.substring(index2)))
        ) {
          index2 += 8;
          return Infinity;
        }
        if (
          jsonString.substring(index2, index2 + 9) === '-Infinity' ||
          (Allow.MINUS_INFINITY & allow &&
            1 < length - index2 &&
            length - index2 < 9 &&
            '-Infinity'.startsWith(jsonString.substring(index2)))
        ) {
          index2 += 9;
          return -Infinity;
        }
        if (
          jsonString.substring(index2, index2 + 3) === 'NaN' ||
          (Allow.NAN & allow &&
            length - index2 < 3 &&
            'NaN'.startsWith(jsonString.substring(index2)))
        ) {
          index2 += 3;
          return NaN;
        }
        return parseNum();
      };
      const parseStr = () => {
        const start = index2;
        let escape2 = false;
        index2++;
        while (
          index2 < length &&
          (jsonString[index2] !== '"' || (escape2 && jsonString[index2 - 1] === '\\'))
        ) {
          escape2 = jsonString[index2] === '\\' ? !escape2 : false;
          index2++;
        }
        if (jsonString.charAt(index2) == '"') {
          try {
            return JSON.parse(jsonString.substring(start, ++index2 - Number(escape2)));
          } catch (e) {
            throwMalformedError(String(e));
          }
        } else if (Allow.STR & allow) {
          try {
            return JSON.parse(jsonString.substring(start, index2 - Number(escape2)) + '"');
          } catch (e) {
            return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('\\')) + '"');
          }
        }
        markPartialJSON('Unterminated string literal');
      };
      const parseObj = () => {
        index2++;
        skipBlank();
        const obj = {};
        try {
          while (jsonString[index2] !== '}') {
            skipBlank();
            if (index2 >= length && Allow.OBJ & allow) return obj;
            const key2 = parseStr();
            skipBlank();
            index2++;
            try {
              const value = parseAny();
              Object.defineProperty(obj, key2, {
                value,
                writable: true,
                enumerable: true,
                configurable: true,
              });
            } catch (e) {
              if (Allow.OBJ & allow) return obj;
              else throw e;
            }
            skipBlank();
            if (jsonString[index2] === ',') index2++;
          }
        } catch (e) {
          if (Allow.OBJ & allow) return obj;
          else markPartialJSON("Expected '}' at end of object");
        }
        index2++;
        return obj;
      };
      const parseArr = () => {
        index2++;
        const arr = [];
        try {
          while (jsonString[index2] !== ']') {
            arr.push(parseAny());
            skipBlank();
            if (jsonString[index2] === ',') {
              index2++;
            }
          }
        } catch (e) {
          if (Allow.ARR & allow) {
            return arr;
          }
          markPartialJSON("Expected ']' at end of array");
        }
        index2++;
        return arr;
      };
      const parseNum = () => {
        if (index2 === 0) {
          if (jsonString === '-' && Allow.NUM & allow) markPartialJSON("Not sure what '-' is");
          try {
            return JSON.parse(jsonString);
          } catch (e) {
            if (Allow.NUM & allow) {
              try {
                if ('.' === jsonString[jsonString.length - 1])
                  return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('.')));
                return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('e')));
              } catch (e2) {}
            }
            throwMalformedError(String(e));
          }
        }
        const start = index2;
        if (jsonString[index2] === '-') index2++;
        while (jsonString[index2] && !',]}'.includes(jsonString[index2])) index2++;
        if (index2 == length && !(Allow.NUM & allow))
          markPartialJSON('Unterminated number literal');
        try {
          return JSON.parse(jsonString.substring(start, index2));
        } catch (e) {
          if (jsonString.substring(start, index2) === '-' && Allow.NUM & allow)
            markPartialJSON("Not sure what '-' is");
          try {
            return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('e')));
          } catch (e2) {
            throwMalformedError(String(e2));
          }
        }
      };
      const skipBlank = () => {
        while (index2 < length && ' \n\r	'.includes(jsonString[index2])) {
          index2++;
        }
      };
      return parseAny();
    };
    partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);
  },
});

// node_modules/openai/streaming.mjs
var init_streaming2 = __esm({
  'node_modules/openai/streaming.mjs'() {
    init_streaming();
  },
});

// node_modules/openai/lib/ChatCompletionStream.mjs
function finalizeChatCompletion(snapshot2, params) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot2;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index: index2, logprobs, ...choiceRest }) => {
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index2}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index2}`);
      }
      if (function_call) {
        const { arguments: args, name: name3 } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index2}`);
        }
        if (!name3) {
          throw new OpenAIError(`missing function_call.name for choice ${index2}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name: name3 },
            role,
            refusal: message.refusal ?? null,
          },
          finish_reason,
          index: index2,
          logprobs,
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index: index2,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: message.refusal ?? null,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name: name3, ...fnRest } = fn || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].id
${str(snapshot2)}`);
              }
              if (type == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].type
${str(snapshot2)}`);
              }
              if (name3 == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].function.name
${str(snapshot2)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].function.arguments
${str(snapshot2)}`);
              }
              return {
                ...toolRest,
                id: id2,
                type,
                function: { ...fnRest, name: name3, arguments: args },
              };
            }),
          },
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: message.refusal ?? null },
        finish_reason,
        index: index2,
        logprobs,
      };
    }),
    created,
    model,
    object: 'chat.completion',
    ...(system_fingerprint ? { system_fingerprint } : {}),
  };
  return maybeParseChatCompletion(completion, params);
}
function str(x) {
  return JSON.stringify(x);
}
function assertIsEmpty(obj) {
  return;
}
function assertNever(_x) {}
var _ChatCompletionStream_instances,
  _ChatCompletionStream_params,
  _ChatCompletionStream_choiceEventStates,
  _ChatCompletionStream_currentChatCompletionSnapshot,
  _ChatCompletionStream_beginRequest,
  _ChatCompletionStream_getChoiceEventState,
  _ChatCompletionStream_addChunk,
  _ChatCompletionStream_emitToolCallDoneEvent,
  _ChatCompletionStream_emitContentDoneEvents,
  _ChatCompletionStream_endRequest,
  _ChatCompletionStream_getAutoParseableResponseFormat,
  _ChatCompletionStream_accumulateChatCompletion,
  ChatCompletionStream;
var init_ChatCompletionStream = __esm({
  'node_modules/openai/lib/ChatCompletionStream.mjs'() {
    init_tslib();
    init_parser2();
    init_error2();
    init_parser();
    init_streaming2();
    init_AbstractChatCompletionRunner();
    ChatCompletionStream = class _ChatCompletionStream extends AbstractChatCompletionRunner {
      constructor(params) {
        super();
        _ChatCompletionStream_instances.add(this);
        _ChatCompletionStream_params.set(this, void 0);
        _ChatCompletionStream_choiceEventStates.set(this, void 0);
        _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
        __classPrivateFieldSet(this, _ChatCompletionStream_params, params, 'f');
        __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], 'f');
      }
      get currentChatCompletionSnapshot() {
        return __classPrivateFieldGet(
          this,
          _ChatCompletionStream_currentChatCompletionSnapshot,
          'f'
        );
      }
      /**
       * Intended for use on the frontend, consuming a stream produced with
       * `.toReadableStream()` on the backend.
       *
       * Note that messages sent to the model do not appear in `.on('message')`
       * in this context.
       */
      static fromReadableStream(stream4) {
        const runner = new _ChatCompletionStream(null);
        runner._run(() => runner._fromReadableStream(stream4));
        return runner;
      }
      static createChatCompletion(client2, params, options) {
        const runner = new _ChatCompletionStream(params);
        runner._run(() =>
          runner._runChatCompletion(
            client2,
            { ...params, stream: true },
            { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } }
          )
        );
        return runner;
      }
      async _createChatCompletion(client2, params, options) {
        super._createChatCompletion;
        const signal = options?.signal;
        if (signal) {
          if (signal.aborted) this.controller.abort();
          signal.addEventListener('abort', () => this.controller.abort());
        }
        __classPrivateFieldGet(
          this,
          _ChatCompletionStream_instances,
          'm',
          _ChatCompletionStream_beginRequest
        ).call(this);
        const stream4 = await client2.chat.completions.create(
          { ...params, stream: true },
          { ...options, signal: this.controller.signal }
        );
        this._connected();
        for await (const chunk of stream4) {
          __classPrivateFieldGet(
            this,
            _ChatCompletionStream_instances,
            'm',
            _ChatCompletionStream_addChunk
          ).call(this, chunk);
        }
        if (stream4.controller.signal?.aborted) {
          throw new APIUserAbortError();
        }
        return this._addChatCompletion(
          __classPrivateFieldGet(
            this,
            _ChatCompletionStream_instances,
            'm',
            _ChatCompletionStream_endRequest
          ).call(this)
        );
      }
      async _fromReadableStream(readableStream, options) {
        const signal = options?.signal;
        if (signal) {
          if (signal.aborted) this.controller.abort();
          signal.addEventListener('abort', () => this.controller.abort());
        }
        __classPrivateFieldGet(
          this,
          _ChatCompletionStream_instances,
          'm',
          _ChatCompletionStream_beginRequest
        ).call(this);
        this._connected();
        const stream4 = Stream.fromReadableStream(readableStream, this.controller);
        let chatId;
        for await (const chunk of stream4) {
          if (chatId && chatId !== chunk.id) {
            this._addChatCompletion(
              __classPrivateFieldGet(
                this,
                _ChatCompletionStream_instances,
                'm',
                _ChatCompletionStream_endRequest
              ).call(this)
            );
          }
          __classPrivateFieldGet(
            this,
            _ChatCompletionStream_instances,
            'm',
            _ChatCompletionStream_addChunk
          ).call(this, chunk);
          chatId = chunk.id;
        }
        if (stream4.controller.signal?.aborted) {
          throw new APIUserAbortError();
        }
        return this._addChatCompletion(
          __classPrivateFieldGet(
            this,
            _ChatCompletionStream_instances,
            'm',
            _ChatCompletionStream_endRequest
          ).call(this)
        );
      }
      [((_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap()),
      (_ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap()),
      (_ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap()),
      (_ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet()),
      (_ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
        if (this.ended) return;
        __classPrivateFieldSet(
          this,
          _ChatCompletionStream_currentChatCompletionSnapshot,
          void 0,
          'f'
        );
      }),
      (_ChatCompletionStream_getChoiceEventState =
        function _ChatCompletionStream_getChoiceEventState2(choice) {
          let state2 = __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, 'f')[
            choice.index
          ];
          if (state2) {
            return state2;
          }
          state2 = {
            content_done: false,
            refusal_done: false,
            logprobs_content_done: false,
            logprobs_refusal_done: false,
            done_tool_calls: /* @__PURE__ */ new Set(),
            current_tool_call_index: null,
          };
          __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, 'f')[choice.index] =
            state2;
          return state2;
        }),
      (_ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
        if (this.ended) return;
        const completion = __classPrivateFieldGet(
          this,
          _ChatCompletionStream_instances,
          'm',
          _ChatCompletionStream_accumulateChatCompletion
        ).call(this, chunk);
        this._emit('chunk', chunk, completion);
        for (const choice of chunk.choices) {
          const choiceSnapshot = completion.choices[choice.index];
          if (
            choice.delta.content != null &&
            choiceSnapshot.message?.role === 'assistant' &&
            choiceSnapshot.message?.content
          ) {
            this._emit('content', choice.delta.content, choiceSnapshot.message.content);
            this._emit('content.delta', {
              delta: choice.delta.content,
              snapshot: choiceSnapshot.message.content,
              parsed: choiceSnapshot.message.parsed,
            });
          }
          if (
            choice.delta.refusal != null &&
            choiceSnapshot.message?.role === 'assistant' &&
            choiceSnapshot.message?.refusal
          ) {
            this._emit('refusal.delta', {
              delta: choice.delta.refusal,
              snapshot: choiceSnapshot.message.refusal,
            });
          }
          if (choice.logprobs?.content != null && choiceSnapshot.message?.role === 'assistant') {
            this._emit('logprobs.content.delta', {
              content: choice.logprobs?.content,
              snapshot: choiceSnapshot.logprobs?.content ?? [],
            });
          }
          if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === 'assistant') {
            this._emit('logprobs.refusal.delta', {
              refusal: choice.logprobs?.refusal,
              snapshot: choiceSnapshot.logprobs?.refusal ?? [],
            });
          }
          const state2 = __classPrivateFieldGet(
            this,
            _ChatCompletionStream_instances,
            'm',
            _ChatCompletionStream_getChoiceEventState
          ).call(this, choiceSnapshot);
          if (choiceSnapshot.finish_reason) {
            __classPrivateFieldGet(
              this,
              _ChatCompletionStream_instances,
              'm',
              _ChatCompletionStream_emitContentDoneEvents
            ).call(this, choiceSnapshot);
            if (state2.current_tool_call_index != null) {
              __classPrivateFieldGet(
                this,
                _ChatCompletionStream_instances,
                'm',
                _ChatCompletionStream_emitToolCallDoneEvent
              ).call(this, choiceSnapshot, state2.current_tool_call_index);
            }
          }
          for (const toolCall of choice.delta.tool_calls ?? []) {
            if (state2.current_tool_call_index !== toolCall.index) {
              __classPrivateFieldGet(
                this,
                _ChatCompletionStream_instances,
                'm',
                _ChatCompletionStream_emitContentDoneEvents
              ).call(this, choiceSnapshot);
              if (state2.current_tool_call_index != null) {
                __classPrivateFieldGet(
                  this,
                  _ChatCompletionStream_instances,
                  'm',
                  _ChatCompletionStream_emitToolCallDoneEvent
                ).call(this, choiceSnapshot, state2.current_tool_call_index);
              }
            }
            state2.current_tool_call_index = toolCall.index;
          }
          for (const toolCallDelta of choice.delta.tool_calls ?? []) {
            const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];
            if (!toolCallSnapshot?.type) {
              continue;
            }
            if (toolCallSnapshot?.type === 'function') {
              this._emit('tool_calls.function.arguments.delta', {
                name: toolCallSnapshot.function?.name,
                index: toolCallDelta.index,
                arguments: toolCallSnapshot.function.arguments,
                parsed_arguments: toolCallSnapshot.function.parsed_arguments,
                arguments_delta: toolCallDelta.function?.arguments ?? '',
              });
            } else {
              assertNever(toolCallSnapshot?.type);
            }
          }
        }
      }),
      (_ChatCompletionStream_emitToolCallDoneEvent =
        function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
          const state2 = __classPrivateFieldGet(
            this,
            _ChatCompletionStream_instances,
            'm',
            _ChatCompletionStream_getChoiceEventState
          ).call(this, choiceSnapshot);
          if (state2.done_tool_calls.has(toolCallIndex)) {
            return;
          }
          const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];
          if (!toolCallSnapshot) {
            throw new Error('no tool call snapshot');
          }
          if (!toolCallSnapshot.type) {
            throw new Error('tool call snapshot missing `type`');
          }
          if (toolCallSnapshot.type === 'function') {
            const inputTool = __classPrivateFieldGet(
              this,
              _ChatCompletionStream_params,
              'f'
            )?.tools?.find(
              (tool) =>
                isChatCompletionFunctionTool(tool) &&
                tool.function.name === toolCallSnapshot.function.name
            );
            this._emit('tool_calls.function.arguments.done', {
              name: toolCallSnapshot.function.name,
              index: toolCallIndex,
              arguments: toolCallSnapshot.function.arguments,
              parsed_arguments: isAutoParsableTool(inputTool)
                ? inputTool.$parseRaw(toolCallSnapshot.function.arguments)
                : inputTool?.function.strict
                  ? JSON.parse(toolCallSnapshot.function.arguments)
                  : null,
            });
          } else {
            assertNever(toolCallSnapshot.type);
          }
        }),
      (_ChatCompletionStream_emitContentDoneEvents =
        function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
          const state2 = __classPrivateFieldGet(
            this,
            _ChatCompletionStream_instances,
            'm',
            _ChatCompletionStream_getChoiceEventState
          ).call(this, choiceSnapshot);
          if (choiceSnapshot.message.content && !state2.content_done) {
            state2.content_done = true;
            const responseFormat = __classPrivateFieldGet(
              this,
              _ChatCompletionStream_instances,
              'm',
              _ChatCompletionStream_getAutoParseableResponseFormat
            ).call(this);
            this._emit('content.done', {
              content: choiceSnapshot.message.content,
              parsed: responseFormat
                ? responseFormat.$parseRaw(choiceSnapshot.message.content)
                : null,
            });
          }
          if (choiceSnapshot.message.refusal && !state2.refusal_done) {
            state2.refusal_done = true;
            this._emit('refusal.done', { refusal: choiceSnapshot.message.refusal });
          }
          if (choiceSnapshot.logprobs?.content && !state2.logprobs_content_done) {
            state2.logprobs_content_done = true;
            this._emit('logprobs.content.done', { content: choiceSnapshot.logprobs.content });
          }
          if (choiceSnapshot.logprobs?.refusal && !state2.logprobs_refusal_done) {
            state2.logprobs_refusal_done = true;
            this._emit('logprobs.refusal.done', { refusal: choiceSnapshot.logprobs.refusal });
          }
        }),
      (_ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
        if (this.ended) {
          throw new OpenAIError(`stream has ended, this shouldn't happen`);
        }
        const snapshot2 = __classPrivateFieldGet(
          this,
          _ChatCompletionStream_currentChatCompletionSnapshot,
          'f'
        );
        if (!snapshot2) {
          throw new OpenAIError(`request ended without sending any chunks`);
        }
        __classPrivateFieldSet(
          this,
          _ChatCompletionStream_currentChatCompletionSnapshot,
          void 0,
          'f'
        );
        __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], 'f');
        return finalizeChatCompletion(
          snapshot2,
          __classPrivateFieldGet(this, _ChatCompletionStream_params, 'f')
        );
      }),
      (_ChatCompletionStream_getAutoParseableResponseFormat =
        function _ChatCompletionStream_getAutoParseableResponseFormat2() {
          const responseFormat = __classPrivateFieldGet(
            this,
            _ChatCompletionStream_params,
            'f'
          )?.response_format;
          if (isAutoParsableResponseFormat(responseFormat)) {
            return responseFormat;
          }
          return null;
        }),
      (_ChatCompletionStream_accumulateChatCompletion =
        function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
          var _a3, _b, _c, _d;
          let snapshot2 = __classPrivateFieldGet(
            this,
            _ChatCompletionStream_currentChatCompletionSnapshot,
            'f'
          );
          const { choices, ...rest } = chunk;
          if (!snapshot2) {
            snapshot2 = __classPrivateFieldSet(
              this,
              _ChatCompletionStream_currentChatCompletionSnapshot,
              {
                ...rest,
                choices: [],
              },
              'f'
            );
          } else {
            Object.assign(snapshot2, rest);
          }
          for (const {
            delta,
            finish_reason,
            index: index2,
            logprobs = null,
            ...other
          } of chunk.choices) {
            let choice = snapshot2.choices[index2];
            if (!choice) {
              choice = snapshot2.choices[index2] = {
                finish_reason,
                index: index2,
                message: {},
                logprobs,
                ...other,
              };
            }
            if (logprobs) {
              if (!choice.logprobs) {
                choice.logprobs = Object.assign({}, logprobs);
              } else {
                const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
                assertIsEmpty(rest3);
                Object.assign(choice.logprobs, rest3);
                if (content2) {
                  (_a3 = choice.logprobs).content ?? (_a3.content = []);
                  choice.logprobs.content.push(...content2);
                }
                if (refusal2) {
                  (_b = choice.logprobs).refusal ?? (_b.refusal = []);
                  choice.logprobs.refusal.push(...refusal2);
                }
              }
            }
            if (finish_reason) {
              choice.finish_reason = finish_reason;
              if (
                __classPrivateFieldGet(this, _ChatCompletionStream_params, 'f') &&
                hasAutoParseableInput(
                  __classPrivateFieldGet(this, _ChatCompletionStream_params, 'f')
                )
              ) {
                if (finish_reason === 'length') {
                  throw new LengthFinishReasonError();
                }
                if (finish_reason === 'content_filter') {
                  throw new ContentFilterFinishReasonError();
                }
              }
            }
            Object.assign(choice, other);
            if (!delta) continue;
            const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
            assertIsEmpty(rest2);
            Object.assign(choice.message, rest2);
            if (refusal) {
              choice.message.refusal = (choice.message.refusal || '') + refusal;
            }
            if (role) choice.message.role = role;
            if (function_call) {
              if (!choice.message.function_call) {
                choice.message.function_call = function_call;
              } else {
                if (function_call.name) choice.message.function_call.name = function_call.name;
                if (function_call.arguments) {
                  (_c = choice.message.function_call).arguments ?? (_c.arguments = '');
                  choice.message.function_call.arguments += function_call.arguments;
                }
              }
            }
            if (content) {
              choice.message.content = (choice.message.content || '') + content;
              if (
                !choice.message.refusal &&
                __classPrivateFieldGet(
                  this,
                  _ChatCompletionStream_instances,
                  'm',
                  _ChatCompletionStream_getAutoParseableResponseFormat
                ).call(this)
              ) {
                choice.message.parsed = partialParse(choice.message.content);
              }
            }
            if (tool_calls) {
              if (!choice.message.tool_calls) choice.message.tool_calls = [];
              for (const { index: index3, id, type, function: fn, ...rest3 } of tool_calls) {
                const tool_call = (_d = choice.message.tool_calls)[index3] ?? (_d[index3] = {});
                Object.assign(tool_call, rest3);
                if (id) tool_call.id = id;
                if (type) tool_call.type = type;
                if (fn)
                  tool_call.function ??
                    (tool_call.function = { name: fn.name ?? '', arguments: '' });
                if (fn?.name) tool_call.function.name = fn.name;
                if (fn?.arguments) {
                  tool_call.function.arguments += fn.arguments;
                  if (
                    shouldParseToolCall(
                      __classPrivateFieldGet(this, _ChatCompletionStream_params, 'f'),
                      tool_call
                    )
                  ) {
                    tool_call.function.parsed_arguments = partialParse(
                      tool_call.function.arguments
                    );
                  }
                }
              }
            }
          }
          return snapshot2;
        }),
      Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on('chunk', (chunk) => {
          const reader = readQueue.shift();
          if (reader) {
            reader.resolve(chunk);
          } else {
            pushQueue.push(chunk);
          }
        });
        this.on('end', () => {
          done = true;
          for (const reader of readQueue) {
            reader.resolve(void 0);
          }
          readQueue.length = 0;
        });
        this.on('abort', (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        this.on('error', (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        return {
          next: async () => {
            if (!pushQueue.length) {
              if (done) {
                return { value: void 0, done: true };
              }
              return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then(
                (chunk2) =>
                  chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true }
              );
            }
            const chunk = pushQueue.shift();
            return { value: chunk, done: false };
          },
          return: async () => {
            this.abort();
            return { value: void 0, done: true };
          },
        };
      }
      toReadableStream() {
        const stream4 = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
        return stream4.toReadableStream();
      }
    };
  },
});

// node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner;
var init_ChatCompletionStreamingRunner = __esm({
  'node_modules/openai/lib/ChatCompletionStreamingRunner.mjs'() {
    init_ChatCompletionStream();
    ChatCompletionStreamingRunner = class _ChatCompletionStreamingRunner extends (
      ChatCompletionStream
    ) {
      static fromReadableStream(stream4) {
        const runner = new _ChatCompletionStreamingRunner(null);
        runner._run(() => runner._fromReadableStream(stream4));
        return runner;
      }
      static runTools(client2, params, options) {
        const runner = new _ChatCompletionStreamingRunner(
          // @ts-expect-error TODO these types are incompatible
          params
        );
        const opts = {
          ...options,
          headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'runTools' },
        };
        runner._run(() => runner._runTools(client2, params, opts));
        return runner;
      }
    };
  },
});

// node_modules/openai/resources/chat/completions/completions.mjs
var Completions;
var init_completions = __esm({
  'node_modules/openai/resources/chat/completions/completions.mjs'() {
    init_resource();
    init_messages();
    init_messages();
    init_pagination();
    init_path();
    init_ChatCompletionRunner();
    init_ChatCompletionStreamingRunner();
    init_ChatCompletionStream();
    init_parser();
    init_ChatCompletionStreamingRunner();
    init_RunnableFunction();
    init_ChatCompletionStream();
    init_ChatCompletionRunner();
    Completions = class extends APIResource {
      constructor() {
        super(...arguments);
        this.messages = new Messages(this._client);
      }
      create(body, options) {
        return this._client.post('/chat/completions', {
          body,
          ...options,
          stream: body.stream ?? false,
        });
      }
      /**
       * Get a stored chat completion. Only Chat Completions that have been created with
       * the `store` parameter set to `true` will be returned.
       *
       * @example
       * ```ts
       * const chatCompletion =
       *   await client.chat.completions.retrieve('completion_id');
       * ```
       */
      retrieve(completionID, options) {
        return this._client.get(path3`/chat/completions/${completionID}`, options);
      }
      /**
       * Modify a stored chat completion. Only Chat Completions that have been created
       * with the `store` parameter set to `true` can be modified. Currently, the only
       * supported modification is to update the `metadata` field.
       *
       * @example
       * ```ts
       * const chatCompletion = await client.chat.completions.update(
       *   'completion_id',
       *   { metadata: { foo: 'string' } },
       * );
       * ```
       */
      update(completionID, body, options) {
        return this._client.post(path3`/chat/completions/${completionID}`, { body, ...options });
      }
      /**
       * List stored Chat Completions. Only Chat Completions that have been stored with
       * the `store` parameter set to `true` will be returned.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const chatCompletion of client.chat.completions.list()) {
       *   // ...
       * }
       * ```
       */
      list(query = {}, options) {
        return this._client.getAPIList('/chat/completions', CursorPage, { query, ...options });
      }
      /**
       * Delete a stored chat completion. Only Chat Completions that have been created
       * with the `store` parameter set to `true` can be deleted.
       *
       * @example
       * ```ts
       * const chatCompletionDeleted =
       *   await client.chat.completions.delete('completion_id');
       * ```
       */
      delete(completionID, options) {
        return this._client.delete(path3`/chat/completions/${completionID}`, options);
      }
      parse(body, options) {
        validateInputTools(body.tools);
        return this._client.chat.completions
          .create(body, {
            ...options,
            headers: {
              ...options?.headers,
              'X-Stainless-Helper-Method': 'chat.completions.parse',
            },
          })
          ._thenUnwrap((completion) => parseChatCompletion(completion, body));
      }
      runTools(body, options) {
        if (body.stream) {
          return ChatCompletionStreamingRunner.runTools(this._client, body, options);
        }
        return ChatCompletionRunner.runTools(this._client, body, options);
      }
      /**
       * Creates a chat completion stream
       */
      stream(body, options) {
        return ChatCompletionStream.createChatCompletion(this._client, body, options);
      }
    };
    Completions.Messages = Messages;
  },
});

// node_modules/openai/resources/chat/chat.mjs
var Chat;
var init_chat = __esm({
  'node_modules/openai/resources/chat/chat.mjs'() {
    init_resource();
    init_completions();
    init_completions();
    Chat = class extends APIResource {
      constructor() {
        super(...arguments);
        this.completions = new Completions(this._client);
      }
    };
    Chat.Completions = Completions;
  },
});

// node_modules/openai/resources/chat/completions/index.mjs
var init_completions2 = __esm({
  'node_modules/openai/resources/chat/completions/index.mjs'() {
    init_completions();
    init_completions();
    init_messages();
  },
});

// node_modules/openai/resources/chat/index.mjs
var init_chat2 = __esm({
  'node_modules/openai/resources/chat/index.mjs'() {
    init_chat();
    init_completions2();
  },
});

// node_modules/openai/resources/shared.mjs
var init_shared3 = __esm({
  'node_modules/openai/resources/shared.mjs'() {},
});

// node_modules/openai/internal/headers.mjs
function* iterateHeaders(headers) {
  if (!headers) return;
  if (brand_privateNullableHeaders in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name3 of nulls) {
      yield [name3, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers ?? {});
  }
  for (let row of iter) {
    const name3 = row[0];
    if (typeof name3 !== 'string') throw new TypeError('expected header name to be a string');
    const values = isReadonlyArray(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === void 0) continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name3, null];
      }
      yield [name3, value];
    }
  }
}
var brand_privateNullableHeaders, buildHeaders;
var init_headers = __esm({
  'node_modules/openai/internal/headers.mjs'() {
    init_values();
    brand_privateNullableHeaders = /* @__PURE__ */ Symbol('brand.privateNullableHeaders');
    buildHeaders = (newHeaders) => {
      const targetHeaders = new Headers();
      const nullHeaders = /* @__PURE__ */ new Set();
      for (const headers of newHeaders) {
        const seenHeaders = /* @__PURE__ */ new Set();
        for (const [name3, value] of iterateHeaders(headers)) {
          const lowerName = name3.toLowerCase();
          if (!seenHeaders.has(lowerName)) {
            targetHeaders.delete(name3);
            seenHeaders.add(lowerName);
          }
          if (value === null) {
            targetHeaders.delete(name3);
            nullHeaders.add(lowerName);
          } else {
            targetHeaders.append(name3, value);
            nullHeaders.delete(lowerName);
          }
        }
      }
      return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };
    };
  },
});

// node_modules/openai/resources/audio/speech.mjs
var Speech;
var init_speech = __esm({
  'node_modules/openai/resources/audio/speech.mjs'() {
    init_resource();
    init_headers();
    Speech = class extends APIResource {
      /**
       * Generates audio from the input text.
       *
       * @example
       * ```ts
       * const speech = await client.audio.speech.create({
       *   input: 'input',
       *   model: 'string',
       *   voice: 'ash',
       * });
       *
       * const content = await speech.blob();
       * console.log(content);
       * ```
       */
      create(body, options) {
        return this._client.post('/audio/speech', {
          body,
          ...options,
          headers: buildHeaders([{ Accept: 'application/octet-stream' }, options?.headers]),
          __binaryResponse: true,
        });
      }
    };
  },
});

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions;
var init_transcriptions = __esm({
  'node_modules/openai/resources/audio/transcriptions.mjs'() {
    init_resource();
    init_uploads();
    Transcriptions = class extends APIResource {
      create(body, options) {
        return this._client.post(
          '/audio/transcriptions',
          multipartFormRequestOptions(
            {
              body,
              ...options,
              stream: body.stream ?? false,
              __metadata: { model: body.model },
            },
            this._client
          )
        );
      }
    };
  },
});

// node_modules/openai/resources/audio/translations.mjs
var Translations;
var init_translations = __esm({
  'node_modules/openai/resources/audio/translations.mjs'() {
    init_resource();
    init_uploads();
    Translations = class extends APIResource {
      create(body, options) {
        return this._client.post(
          '/audio/translations',
          multipartFormRequestOptions(
            { body, ...options, __metadata: { model: body.model } },
            this._client
          )
        );
      }
    };
  },
});

// node_modules/openai/resources/audio/audio.mjs
var Audio;
var init_audio = __esm({
  'node_modules/openai/resources/audio/audio.mjs'() {
    init_resource();
    init_speech();
    init_speech();
    init_transcriptions();
    init_transcriptions();
    init_translations();
    init_translations();
    Audio = class extends APIResource {
      constructor() {
        super(...arguments);
        this.transcriptions = new Transcriptions(this._client);
        this.translations = new Translations(this._client);
        this.speech = new Speech(this._client);
      }
    };
    Audio.Transcriptions = Transcriptions;
    Audio.Translations = Translations;
    Audio.Speech = Speech;
  },
});

// node_modules/openai/resources/batches.mjs
var Batches;
var init_batches = __esm({
  'node_modules/openai/resources/batches.mjs'() {
    init_resource();
    init_pagination();
    init_path();
    Batches = class extends APIResource {
      /**
       * Creates and executes a batch from an uploaded file of requests
       */
      create(body, options) {
        return this._client.post('/batches', { body, ...options });
      }
      /**
       * Retrieves a batch.
       */
      retrieve(batchID, options) {
        return this._client.get(path3`/batches/${batchID}`, options);
      }
      /**
       * List your organization's batches.
       */
      list(query = {}, options) {
        return this._client.getAPIList('/batches', CursorPage, { query, ...options });
      }
      /**
       * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
       * 10 minutes, before changing to `cancelled`, where it will have partial results
       * (if any) available in the output file.
       */
      cancel(batchID, options) {
        return this._client.post(path3`/batches/${batchID}/cancel`, options);
      }
    };
  },
});

// node_modules/openai/resources/beta/assistants.mjs
var Assistants;
var init_assistants = __esm({
  'node_modules/openai/resources/beta/assistants.mjs'() {
    init_resource();
    init_pagination();
    init_headers();
    init_path();
    Assistants = class extends APIResource {
      /**
       * Create an assistant with a model and instructions.
       *
       * @example
       * ```ts
       * const assistant = await client.beta.assistants.create({
       *   model: 'gpt-4o',
       * });
       * ```
       */
      create(body, options) {
        return this._client.post('/assistants', {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Retrieves an assistant.
       *
       * @example
       * ```ts
       * const assistant = await client.beta.assistants.retrieve(
       *   'assistant_id',
       * );
       * ```
       */
      retrieve(assistantID, options) {
        return this._client.get(path3`/assistants/${assistantID}`, {
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Modifies an assistant.
       *
       * @example
       * ```ts
       * const assistant = await client.beta.assistants.update(
       *   'assistant_id',
       * );
       * ```
       */
      update(assistantID, body, options) {
        return this._client.post(path3`/assistants/${assistantID}`, {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Returns a list of assistants.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const assistant of client.beta.assistants.list()) {
       *   // ...
       * }
       * ```
       */
      list(query = {}, options) {
        return this._client.getAPIList('/assistants', CursorPage, {
          query,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Delete an assistant.
       *
       * @example
       * ```ts
       * const assistantDeleted =
       *   await client.beta.assistants.delete('assistant_id');
       * ```
       */
      delete(assistantID, options) {
        return this._client.delete(path3`/assistants/${assistantID}`, {
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
    };
  },
});

// node_modules/openai/resources/beta/realtime/sessions.mjs
var Sessions;
var init_sessions = __esm({
  'node_modules/openai/resources/beta/realtime/sessions.mjs'() {
    init_resource();
    init_headers();
    Sessions = class extends APIResource {
      /**
       * Create an ephemeral API token for use in client-side applications with the
       * Realtime API. Can be configured with the same session parameters as the
       * `session.update` client event.
       *
       * It responds with a session object, plus a `client_secret` key which contains a
       * usable ephemeral API token that can be used to authenticate browser clients for
       * the Realtime API.
       *
       * @example
       * ```ts
       * const session =
       *   await client.beta.realtime.sessions.create();
       * ```
       */
      create(body, options) {
        return this._client.post('/realtime/sessions', {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
    };
  },
});

// node_modules/openai/resources/beta/realtime/transcription-sessions.mjs
var TranscriptionSessions;
var init_transcription_sessions = __esm({
  'node_modules/openai/resources/beta/realtime/transcription-sessions.mjs'() {
    init_resource();
    init_headers();
    TranscriptionSessions = class extends APIResource {
      /**
       * Create an ephemeral API token for use in client-side applications with the
       * Realtime API specifically for realtime transcriptions. Can be configured with
       * the same session parameters as the `transcription_session.update` client event.
       *
       * It responds with a session object, plus a `client_secret` key which contains a
       * usable ephemeral API token that can be used to authenticate browser clients for
       * the Realtime API.
       *
       * @example
       * ```ts
       * const transcriptionSession =
       *   await client.beta.realtime.transcriptionSessions.create();
       * ```
       */
      create(body, options) {
        return this._client.post('/realtime/transcription_sessions', {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
    };
  },
});

// node_modules/openai/resources/beta/realtime/realtime.mjs
var Realtime;
var init_realtime = __esm({
  'node_modules/openai/resources/beta/realtime/realtime.mjs'() {
    init_resource();
    init_sessions();
    init_sessions();
    init_transcription_sessions();
    init_transcription_sessions();
    Realtime = class extends APIResource {
      constructor() {
        super(...arguments);
        this.sessions = new Sessions(this._client);
        this.transcriptionSessions = new TranscriptionSessions(this._client);
      }
    };
    Realtime.Sessions = Sessions;
    Realtime.TranscriptionSessions = TranscriptionSessions;
  },
});

// node_modules/openai/resources/beta/chatkit/sessions.mjs
var Sessions2;
var init_sessions2 = __esm({
  'node_modules/openai/resources/beta/chatkit/sessions.mjs'() {
    init_resource();
    init_headers();
    init_path();
    Sessions2 = class extends APIResource {
      /**
       * Create a ChatKit session
       *
       * @example
       * ```ts
       * const chatSession =
       *   await client.beta.chatkit.sessions.create({
       *     user: 'x',
       *     workflow: { id: 'id' },
       *   });
       * ```
       */
      create(body, options) {
        return this._client.post('/chatkit/sessions', {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'chatkit_beta=v1' }, options?.headers]),
        });
      }
      /**
       * Cancel a ChatKit session
       *
       * @example
       * ```ts
       * const chatSession =
       *   await client.beta.chatkit.sessions.cancel('cksess_123');
       * ```
       */
      cancel(sessionID, options) {
        return this._client.post(path3`/chatkit/sessions/${sessionID}/cancel`, {
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'chatkit_beta=v1' }, options?.headers]),
        });
      }
    };
  },
});

// node_modules/openai/resources/beta/chatkit/threads.mjs
var Threads;
var init_threads = __esm({
  'node_modules/openai/resources/beta/chatkit/threads.mjs'() {
    init_resource();
    init_pagination();
    init_headers();
    init_path();
    Threads = class extends APIResource {
      /**
       * Retrieve a ChatKit thread
       *
       * @example
       * ```ts
       * const chatkitThread =
       *   await client.beta.chatkit.threads.retrieve('cthr_123');
       * ```
       */
      retrieve(threadID, options) {
        return this._client.get(path3`/chatkit/threads/${threadID}`, {
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'chatkit_beta=v1' }, options?.headers]),
        });
      }
      /**
       * List ChatKit threads
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const chatkitThread of client.beta.chatkit.threads.list()) {
       *   // ...
       * }
       * ```
       */
      list(query = {}, options) {
        return this._client.getAPIList('/chatkit/threads', ConversationCursorPage, {
          query,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'chatkit_beta=v1' }, options?.headers]),
        });
      }
      /**
       * Delete a ChatKit thread
       *
       * @example
       * ```ts
       * const thread = await client.beta.chatkit.threads.delete(
       *   'cthr_123',
       * );
       * ```
       */
      delete(threadID, options) {
        return this._client.delete(path3`/chatkit/threads/${threadID}`, {
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'chatkit_beta=v1' }, options?.headers]),
        });
      }
      /**
       * List ChatKit thread items
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const thread of client.beta.chatkit.threads.listItems(
       *   'cthr_123',
       * )) {
       *   // ...
       * }
       * ```
       */
      listItems(threadID, query = {}, options) {
        return this._client.getAPIList(
          path3`/chatkit/threads/${threadID}/items`,
          ConversationCursorPage,
          {
            query,
            ...options,
            headers: buildHeaders([{ 'OpenAI-Beta': 'chatkit_beta=v1' }, options?.headers]),
          }
        );
      }
    };
  },
});

// node_modules/openai/resources/beta/chatkit/chatkit.mjs
var ChatKit;
var init_chatkit = __esm({
  'node_modules/openai/resources/beta/chatkit/chatkit.mjs'() {
    init_resource();
    init_sessions2();
    init_sessions2();
    init_threads();
    init_threads();
    init_headers();
    init_uploads();
    ChatKit = class extends APIResource {
      constructor() {
        super(...arguments);
        this.sessions = new Sessions2(this._client);
        this.threads = new Threads(this._client);
      }
      /**
       * Upload a ChatKit file
       *
       * @example
       * ```ts
       * const response = await client.beta.chatkit.uploadFile({
       *   file: fs.createReadStream('path/to/file'),
       * });
       * ```
       */
      uploadFile(body, options) {
        return this._client.post(
          '/chatkit/files',
          maybeMultipartFormRequestOptions(
            {
              body,
              ...options,
              headers: buildHeaders([{ 'OpenAI-Beta': 'chatkit_beta=v1' }, options?.headers]),
            },
            this._client
          )
        );
      }
    };
    ChatKit.Sessions = Sessions2;
    ChatKit.Threads = Threads;
  },
});

// node_modules/openai/resources/beta/threads/messages.mjs
var Messages2;
var init_messages2 = __esm({
  'node_modules/openai/resources/beta/threads/messages.mjs'() {
    init_resource();
    init_pagination();
    init_headers();
    init_path();
    Messages2 = class extends APIResource {
      /**
       * Create a message.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      create(threadID, body, options) {
        return this._client.post(path3`/threads/${threadID}/messages`, {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Retrieve a message.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      retrieve(messageID, params, options) {
        const { thread_id } = params;
        return this._client.get(path3`/threads/${thread_id}/messages/${messageID}`, {
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Modifies a message.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      update(messageID, params, options) {
        const { thread_id, ...body } = params;
        return this._client.post(path3`/threads/${thread_id}/messages/${messageID}`, {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Returns a list of messages for a given thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      list(threadID, query = {}, options) {
        return this._client.getAPIList(path3`/threads/${threadID}/messages`, CursorPage, {
          query,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Deletes a message.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      delete(messageID, params, options) {
        const { thread_id } = params;
        return this._client.delete(path3`/threads/${thread_id}/messages/${messageID}`, {
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
    };
  },
});

// node_modules/openai/resources/beta/threads/runs/steps.mjs
var Steps;
var init_steps = __esm({
  'node_modules/openai/resources/beta/threads/runs/steps.mjs'() {
    init_resource();
    init_pagination();
    init_headers();
    init_path();
    Steps = class extends APIResource {
      /**
       * Retrieves a run step.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      retrieve(stepID, params, options) {
        const { thread_id, run_id, ...query } = params;
        return this._client.get(path3`/threads/${thread_id}/runs/${run_id}/steps/${stepID}`, {
          query,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Returns a list of run steps belonging to a run.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      list(runID, params, options) {
        const { thread_id, ...query } = params;
        return this._client.getAPIList(
          path3`/threads/${thread_id}/runs/${runID}/steps`,
          CursorPage,
          {
            query,
            ...options,
            headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
          }
        );
      }
    };
  },
});

// node_modules/openai/internal/utils/base64.mjs
var toFloat32Array;
var init_base64 = __esm({
  'node_modules/openai/internal/utils/base64.mjs'() {
    init_error();
    init_bytes();
    toFloat32Array = (base64Str) => {
      if (typeof Buffer !== 'undefined') {
        const buf = Buffer.from(base64Str, 'base64');
        return Array.from(
          new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT)
        );
      } else {
        const binaryStr = atob(base64Str);
        const len = binaryStr.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
        }
        return Array.from(new Float32Array(bytes.buffer));
      }
    };
  },
});

// node_modules/openai/internal/utils/env.mjs
var readEnv;
var init_env = __esm({
  'node_modules/openai/internal/utils/env.mjs'() {
    readEnv = (env2) => {
      if (typeof globalThis.process !== 'undefined') {
        return globalThis.process.env?.[env2]?.trim() ?? void 0;
      }
      if (typeof globalThis.Deno !== 'undefined') {
        return globalThis.Deno.env?.get?.(env2)?.trim();
      }
      return void 0;
    };
  },
});

// node_modules/openai/internal/utils.mjs
var init_utils7 = __esm({
  'node_modules/openai/internal/utils.mjs'() {
    init_values();
    init_base64();
    init_env();
    init_log();
    init_uuid();
    init_sleep();
  },
});

// node_modules/openai/lib/AssistantStream.mjs
function assertNever2(_x) {}
var _AssistantStream_instances,
  _a,
  _AssistantStream_events,
  _AssistantStream_runStepSnapshots,
  _AssistantStream_messageSnapshots,
  _AssistantStream_messageSnapshot,
  _AssistantStream_finalRun,
  _AssistantStream_currentContentIndex,
  _AssistantStream_currentContent,
  _AssistantStream_currentToolCallIndex,
  _AssistantStream_currentToolCall,
  _AssistantStream_currentEvent,
  _AssistantStream_currentRunSnapshot,
  _AssistantStream_currentRunStepSnapshot,
  _AssistantStream_addEvent,
  _AssistantStream_endRequest,
  _AssistantStream_handleMessage,
  _AssistantStream_handleRunStep,
  _AssistantStream_handleEvent,
  _AssistantStream_accumulateRunStep,
  _AssistantStream_accumulateMessage,
  _AssistantStream_accumulateContent,
  _AssistantStream_handleRun,
  AssistantStream;
var init_AssistantStream = __esm({
  'node_modules/openai/lib/AssistantStream.mjs'() {
    init_tslib();
    init_streaming2();
    init_error2();
    init_EventStream();
    init_utils7();
    AssistantStream = class extends EventStream {
      constructor() {
        super(...arguments);
        _AssistantStream_instances.add(this);
        _AssistantStream_events.set(this, []);
        _AssistantStream_runStepSnapshots.set(this, {});
        _AssistantStream_messageSnapshots.set(this, {});
        _AssistantStream_messageSnapshot.set(this, void 0);
        _AssistantStream_finalRun.set(this, void 0);
        _AssistantStream_currentContentIndex.set(this, void 0);
        _AssistantStream_currentContent.set(this, void 0);
        _AssistantStream_currentToolCallIndex.set(this, void 0);
        _AssistantStream_currentToolCall.set(this, void 0);
        _AssistantStream_currentEvent.set(this, void 0);
        _AssistantStream_currentRunSnapshot.set(this, void 0);
        _AssistantStream_currentRunStepSnapshot.set(this, void 0);
      }
      [((_AssistantStream_events = /* @__PURE__ */ new WeakMap()),
      (_AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap()),
      (_AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap()),
      (_AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap()),
      (_AssistantStream_finalRun = /* @__PURE__ */ new WeakMap()),
      (_AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap()),
      (_AssistantStream_currentContent = /* @__PURE__ */ new WeakMap()),
      (_AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap()),
      (_AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap()),
      (_AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap()),
      (_AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap()),
      (_AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap()),
      (_AssistantStream_instances = /* @__PURE__ */ new WeakSet()),
      Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on('event', (event2) => {
          const reader = readQueue.shift();
          if (reader) {
            reader.resolve(event2);
          } else {
            pushQueue.push(event2);
          }
        });
        this.on('end', () => {
          done = true;
          for (const reader of readQueue) {
            reader.resolve(void 0);
          }
          readQueue.length = 0;
        });
        this.on('abort', (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        this.on('error', (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        return {
          next: async () => {
            if (!pushQueue.length) {
              if (done) {
                return { value: void 0, done: true };
              }
              return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then(
                (chunk2) =>
                  chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true }
              );
            }
            const chunk = pushQueue.shift();
            return { value: chunk, done: false };
          },
          return: async () => {
            this.abort();
            return { value: void 0, done: true };
          },
        };
      }
      static fromReadableStream(stream4) {
        const runner = new _a();
        runner._run(() => runner._fromReadableStream(stream4));
        return runner;
      }
      async _fromReadableStream(readableStream, options) {
        const signal = options?.signal;
        if (signal) {
          if (signal.aborted) this.controller.abort();
          signal.addEventListener('abort', () => this.controller.abort());
        }
        this._connected();
        const stream4 = Stream.fromReadableStream(readableStream, this.controller);
        for await (const event2 of stream4) {
          __classPrivateFieldGet(
            this,
            _AssistantStream_instances,
            'm',
            _AssistantStream_addEvent
          ).call(this, event2);
        }
        if (stream4.controller.signal?.aborted) {
          throw new APIUserAbortError();
        }
        return this._addRun(
          __classPrivateFieldGet(
            this,
            _AssistantStream_instances,
            'm',
            _AssistantStream_endRequest
          ).call(this)
        );
      }
      toReadableStream() {
        const stream4 = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
        return stream4.toReadableStream();
      }
      static createToolAssistantStream(runId, runs, params, options) {
        const runner = new _a();
        runner._run(() =>
          runner._runToolAssistantStream(runId, runs, params, {
            ...options,
            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },
          })
        );
        return runner;
      }
      async _createToolAssistantStream(run2, runId, params, options) {
        const signal = options?.signal;
        if (signal) {
          if (signal.aborted) this.controller.abort();
          signal.addEventListener('abort', () => this.controller.abort());
        }
        const body = { ...params, stream: true };
        const stream4 = await run2.submitToolOutputs(runId, body, {
          ...options,
          signal: this.controller.signal,
        });
        this._connected();
        for await (const event2 of stream4) {
          __classPrivateFieldGet(
            this,
            _AssistantStream_instances,
            'm',
            _AssistantStream_addEvent
          ).call(this, event2);
        }
        if (stream4.controller.signal?.aborted) {
          throw new APIUserAbortError();
        }
        return this._addRun(
          __classPrivateFieldGet(
            this,
            _AssistantStream_instances,
            'm',
            _AssistantStream_endRequest
          ).call(this)
        );
      }
      static createThreadAssistantStream(params, thread, options) {
        const runner = new _a();
        runner._run(() =>
          runner._threadAssistantStream(params, thread, {
            ...options,
            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },
          })
        );
        return runner;
      }
      static createAssistantStream(threadId, runs, params, options) {
        const runner = new _a();
        runner._run(() =>
          runner._runAssistantStream(threadId, runs, params, {
            ...options,
            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },
          })
        );
        return runner;
      }
      currentEvent() {
        return __classPrivateFieldGet(this, _AssistantStream_currentEvent, 'f');
      }
      currentRun() {
        return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, 'f');
      }
      currentMessageSnapshot() {
        return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, 'f');
      }
      currentRunStepSnapshot() {
        return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, 'f');
      }
      async finalRunSteps() {
        await this.done();
        return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, 'f'));
      }
      async finalMessages() {
        await this.done();
        return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, 'f'));
      }
      async finalRun() {
        await this.done();
        if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, 'f'))
          throw Error('Final run was not received.');
        return __classPrivateFieldGet(this, _AssistantStream_finalRun, 'f');
      }
      async _createThreadAssistantStream(thread, params, options) {
        const signal = options?.signal;
        if (signal) {
          if (signal.aborted) this.controller.abort();
          signal.addEventListener('abort', () => this.controller.abort());
        }
        const body = { ...params, stream: true };
        const stream4 = await thread.createAndRun(body, {
          ...options,
          signal: this.controller.signal,
        });
        this._connected();
        for await (const event2 of stream4) {
          __classPrivateFieldGet(
            this,
            _AssistantStream_instances,
            'm',
            _AssistantStream_addEvent
          ).call(this, event2);
        }
        if (stream4.controller.signal?.aborted) {
          throw new APIUserAbortError();
        }
        return this._addRun(
          __classPrivateFieldGet(
            this,
            _AssistantStream_instances,
            'm',
            _AssistantStream_endRequest
          ).call(this)
        );
      }
      async _createAssistantStream(run2, threadId, params, options) {
        const signal = options?.signal;
        if (signal) {
          if (signal.aborted) this.controller.abort();
          signal.addEventListener('abort', () => this.controller.abort());
        }
        const body = { ...params, stream: true };
        const stream4 = await run2.create(threadId, body, {
          ...options,
          signal: this.controller.signal,
        });
        this._connected();
        for await (const event2 of stream4) {
          __classPrivateFieldGet(
            this,
            _AssistantStream_instances,
            'm',
            _AssistantStream_addEvent
          ).call(this, event2);
        }
        if (stream4.controller.signal?.aborted) {
          throw new APIUserAbortError();
        }
        return this._addRun(
          __classPrivateFieldGet(
            this,
            _AssistantStream_instances,
            'm',
            _AssistantStream_endRequest
          ).call(this)
        );
      }
      static accumulateDelta(acc, delta) {
        for (const [key2, deltaValue] of Object.entries(delta)) {
          if (!acc.hasOwnProperty(key2)) {
            acc[key2] = deltaValue;
            continue;
          }
          let accValue = acc[key2];
          if (accValue === null || accValue === void 0) {
            acc[key2] = deltaValue;
            continue;
          }
          if (key2 === 'index' || key2 === 'type') {
            acc[key2] = deltaValue;
            continue;
          }
          if (typeof accValue === 'string' && typeof deltaValue === 'string') {
            accValue += deltaValue;
          } else if (typeof accValue === 'number' && typeof deltaValue === 'number') {
            accValue += deltaValue;
          } else if (isObj(accValue) && isObj(deltaValue)) {
            accValue = this.accumulateDelta(accValue, deltaValue);
          } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
            if (accValue.every((x) => typeof x === 'string' || typeof x === 'number')) {
              accValue.push(...deltaValue);
              continue;
            }
            for (const deltaEntry of deltaValue) {
              if (!isObj(deltaEntry)) {
                throw new Error(
                  `Expected array delta entry to be an object but got: ${deltaEntry}`
                );
              }
              const index2 = deltaEntry['index'];
              if (index2 == null) {
                console.error(deltaEntry);
                throw new Error('Expected array delta entry to have an `index` property');
              }
              if (typeof index2 !== 'number') {
                throw new Error(
                  `Expected array delta entry \`index\` property to be a number but got ${index2}`
                );
              }
              const accEntry = accValue[index2];
              if (accEntry == null) {
                accValue.push(deltaEntry);
              } else {
                accValue[index2] = this.accumulateDelta(accEntry, deltaEntry);
              }
            }
            continue;
          } else {
            throw Error(
              `Unhandled record type: ${key2}, deltaValue: ${deltaValue}, accValue: ${accValue}`
            );
          }
          acc[key2] = accValue;
        }
        return acc;
      }
      _addRun(run2) {
        return run2;
      }
      async _threadAssistantStream(params, thread, options) {
        return await this._createThreadAssistantStream(thread, params, options);
      }
      async _runAssistantStream(threadId, runs, params, options) {
        return await this._createAssistantStream(runs, threadId, params, options);
      }
      async _runToolAssistantStream(runId, runs, params, options) {
        return await this._createToolAssistantStream(runs, runId, params, options);
      }
    };
    ((_a = AssistantStream),
      (_AssistantStream_addEvent = function _AssistantStream_addEvent2(event2) {
        if (this.ended) return;
        __classPrivateFieldSet(this, _AssistantStream_currentEvent, event2, 'f');
        __classPrivateFieldGet(
          this,
          _AssistantStream_instances,
          'm',
          _AssistantStream_handleEvent
        ).call(this, event2);
        switch (event2.event) {
          case 'thread.created':
            break;
          case 'thread.run.created':
          case 'thread.run.queued':
          case 'thread.run.in_progress':
          case 'thread.run.requires_action':
          case 'thread.run.completed':
          case 'thread.run.incomplete':
          case 'thread.run.failed':
          case 'thread.run.cancelling':
          case 'thread.run.cancelled':
          case 'thread.run.expired':
            __classPrivateFieldGet(
              this,
              _AssistantStream_instances,
              'm',
              _AssistantStream_handleRun
            ).call(this, event2);
            break;
          case 'thread.run.step.created':
          case 'thread.run.step.in_progress':
          case 'thread.run.step.delta':
          case 'thread.run.step.completed':
          case 'thread.run.step.failed':
          case 'thread.run.step.cancelled':
          case 'thread.run.step.expired':
            __classPrivateFieldGet(
              this,
              _AssistantStream_instances,
              'm',
              _AssistantStream_handleRunStep
            ).call(this, event2);
            break;
          case 'thread.message.created':
          case 'thread.message.in_progress':
          case 'thread.message.delta':
          case 'thread.message.completed':
          case 'thread.message.incomplete':
            __classPrivateFieldGet(
              this,
              _AssistantStream_instances,
              'm',
              _AssistantStream_handleMessage
            ).call(this, event2);
            break;
          case 'error':
            throw new Error(
              'Encountered an error event in event processing - errors should be processed earlier'
            );
          default:
            assertNever2(event2);
        }
      }),
      (_AssistantStream_endRequest = function _AssistantStream_endRequest2() {
        if (this.ended) {
          throw new OpenAIError(`stream has ended, this shouldn't happen`);
        }
        if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, 'f'))
          throw Error('Final run has not been received');
        return __classPrivateFieldGet(this, _AssistantStream_finalRun, 'f');
      }),
      (_AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event2) {
        const [accumulatedMessage, newContent] = __classPrivateFieldGet(
          this,
          _AssistantStream_instances,
          'm',
          _AssistantStream_accumulateMessage
        ).call(this, event2, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, 'f'));
        __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, 'f');
        __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, 'f')[
          accumulatedMessage.id
        ] = accumulatedMessage;
        for (const content of newContent) {
          const snapshotContent = accumulatedMessage.content[content.index];
          if (snapshotContent?.type == 'text') {
            this._emit('textCreated', snapshotContent.text);
          }
        }
        switch (event2.event) {
          case 'thread.message.created':
            this._emit('messageCreated', event2.data);
            break;
          case 'thread.message.in_progress':
            break;
          case 'thread.message.delta':
            this._emit('messageDelta', event2.data.delta, accumulatedMessage);
            if (event2.data.delta.content) {
              for (const content of event2.data.delta.content) {
                if (content.type == 'text' && content.text) {
                  let textDelta = content.text;
                  let snapshot2 = accumulatedMessage.content[content.index];
                  if (snapshot2 && snapshot2.type == 'text') {
                    this._emit('textDelta', textDelta, snapshot2.text);
                  } else {
                    throw Error(
                      'The snapshot associated with this text delta is not text or missing'
                    );
                  }
                }
                if (
                  content.index !=
                  __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, 'f')
                ) {
                  if (__classPrivateFieldGet(this, _AssistantStream_currentContent, 'f')) {
                    switch (
                      __classPrivateFieldGet(this, _AssistantStream_currentContent, 'f').type
                    ) {
                      case 'text':
                        this._emit(
                          'textDone',
                          __classPrivateFieldGet(this, _AssistantStream_currentContent, 'f').text,
                          __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, 'f')
                        );
                        break;
                      case 'image_file':
                        this._emit(
                          'imageFileDone',
                          __classPrivateFieldGet(this, _AssistantStream_currentContent, 'f')
                            .image_file,
                          __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, 'f')
                        );
                        break;
                    }
                  }
                  __classPrivateFieldSet(
                    this,
                    _AssistantStream_currentContentIndex,
                    content.index,
                    'f'
                  );
                }
                __classPrivateFieldSet(
                  this,
                  _AssistantStream_currentContent,
                  accumulatedMessage.content[content.index],
                  'f'
                );
              }
            }
            break;
          case 'thread.message.completed':
          case 'thread.message.incomplete':
            if (
              __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, 'f') !== void 0
            ) {
              const currentContent =
                event2.data.content[
                  __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, 'f')
                ];
              if (currentContent) {
                switch (currentContent.type) {
                  case 'image_file':
                    this._emit(
                      'imageFileDone',
                      currentContent.image_file,
                      __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, 'f')
                    );
                    break;
                  case 'text':
                    this._emit(
                      'textDone',
                      currentContent.text,
                      __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, 'f')
                    );
                    break;
                }
              }
            }
            if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, 'f')) {
              this._emit('messageDone', event2.data);
            }
            __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, void 0, 'f');
        }
      }),
      (_AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event2) {
        const accumulatedRunStep = __classPrivateFieldGet(
          this,
          _AssistantStream_instances,
          'm',
          _AssistantStream_accumulateRunStep
        ).call(this, event2);
        __classPrivateFieldSet(
          this,
          _AssistantStream_currentRunStepSnapshot,
          accumulatedRunStep,
          'f'
        );
        switch (event2.event) {
          case 'thread.run.step.created':
            this._emit('runStepCreated', event2.data);
            break;
          case 'thread.run.step.delta':
            const delta = event2.data.delta;
            if (
              delta.step_details &&
              delta.step_details.type == 'tool_calls' &&
              delta.step_details.tool_calls &&
              accumulatedRunStep.step_details.type == 'tool_calls'
            ) {
              for (const toolCall of delta.step_details.tool_calls) {
                if (
                  toolCall.index ==
                  __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, 'f')
                ) {
                  this._emit(
                    'toolCallDelta',
                    toolCall,
                    accumulatedRunStep.step_details.tool_calls[toolCall.index]
                  );
                } else {
                  if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, 'f')) {
                    this._emit(
                      'toolCallDone',
                      __classPrivateFieldGet(this, _AssistantStream_currentToolCall, 'f')
                    );
                  }
                  __classPrivateFieldSet(
                    this,
                    _AssistantStream_currentToolCallIndex,
                    toolCall.index,
                    'f'
                  );
                  __classPrivateFieldSet(
                    this,
                    _AssistantStream_currentToolCall,
                    accumulatedRunStep.step_details.tool_calls[toolCall.index],
                    'f'
                  );
                  if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, 'f'))
                    this._emit(
                      'toolCallCreated',
                      __classPrivateFieldGet(this, _AssistantStream_currentToolCall, 'f')
                    );
                }
              }
            }
            this._emit('runStepDelta', event2.data.delta, accumulatedRunStep);
            break;
          case 'thread.run.step.completed':
          case 'thread.run.step.failed':
          case 'thread.run.step.cancelled':
          case 'thread.run.step.expired':
            __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, void 0, 'f');
            const details = event2.data.step_details;
            if (details.type == 'tool_calls') {
              if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, 'f')) {
                this._emit(
                  'toolCallDone',
                  __classPrivateFieldGet(this, _AssistantStream_currentToolCall, 'f')
                );
                __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, 'f');
              }
            }
            this._emit('runStepDone', event2.data, accumulatedRunStep);
            break;
          case 'thread.run.step.in_progress':
            break;
        }
      }),
      (_AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event2) {
        __classPrivateFieldGet(this, _AssistantStream_events, 'f').push(event2);
        this._emit('event', event2);
      }),
      (_AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event2) {
        switch (event2.event) {
          case 'thread.run.step.created':
            __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, 'f')[event2.data.id] =
              event2.data;
            return event2.data;
          case 'thread.run.step.delta':
            let snapshot2 = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, 'f')[
              event2.data.id
            ];
            if (!snapshot2) {
              throw Error('Received a RunStepDelta before creation of a snapshot');
            }
            let data = event2.data;
            if (data.delta) {
              const accumulated = _a.accumulateDelta(snapshot2, data.delta);
              __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, 'f')[event2.data.id] =
                accumulated;
            }
            return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, 'f')[
              event2.data.id
            ];
          case 'thread.run.step.completed':
          case 'thread.run.step.failed':
          case 'thread.run.step.cancelled':
          case 'thread.run.step.expired':
          case 'thread.run.step.in_progress':
            __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, 'f')[event2.data.id] =
              event2.data;
            break;
        }
        if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, 'f')[event2.data.id])
          return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, 'f')[
            event2.data.id
          ];
        throw new Error('No snapshot available');
      }),
      (_AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(
        event2,
        snapshot2
      ) {
        let newContent = [];
        switch (event2.event) {
          case 'thread.message.created':
            return [event2.data, newContent];
          case 'thread.message.delta':
            if (!snapshot2) {
              throw Error(
                'Received a delta with no existing snapshot (there should be one from message creation)'
              );
            }
            let data = event2.data;
            if (data.delta.content) {
              for (const contentElement of data.delta.content) {
                if (contentElement.index in snapshot2.content) {
                  let currentContent = snapshot2.content[contentElement.index];
                  snapshot2.content[contentElement.index] = __classPrivateFieldGet(
                    this,
                    _AssistantStream_instances,
                    'm',
                    _AssistantStream_accumulateContent
                  ).call(this, contentElement, currentContent);
                } else {
                  snapshot2.content[contentElement.index] = contentElement;
                  newContent.push(contentElement);
                }
              }
            }
            return [snapshot2, newContent];
          case 'thread.message.in_progress':
          case 'thread.message.completed':
          case 'thread.message.incomplete':
            if (snapshot2) {
              return [snapshot2, newContent];
            } else {
              throw Error('Received thread message event with no existing snapshot');
            }
        }
        throw Error('Tried to accumulate a non-message event');
      }),
      (_AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(
        contentElement,
        currentContent
      ) {
        return _a.accumulateDelta(currentContent, contentElement);
      }),
      (_AssistantStream_handleRun = function _AssistantStream_handleRun2(event2) {
        __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event2.data, 'f');
        switch (event2.event) {
          case 'thread.run.created':
            break;
          case 'thread.run.queued':
            break;
          case 'thread.run.in_progress':
            break;
          case 'thread.run.requires_action':
          case 'thread.run.cancelled':
          case 'thread.run.failed':
          case 'thread.run.completed':
          case 'thread.run.expired':
          case 'thread.run.incomplete':
            __classPrivateFieldSet(this, _AssistantStream_finalRun, event2.data, 'f');
            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, 'f')) {
              this._emit(
                'toolCallDone',
                __classPrivateFieldGet(this, _AssistantStream_currentToolCall, 'f')
              );
              __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, 'f');
            }
            break;
          case 'thread.run.cancelling':
            break;
        }
      }));
  },
});

// node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs;
var init_runs = __esm({
  'node_modules/openai/resources/beta/threads/runs/runs.mjs'() {
    init_resource();
    init_steps();
    init_steps();
    init_pagination();
    init_headers();
    init_AssistantStream();
    init_sleep();
    init_path();
    Runs = class extends APIResource {
      constructor() {
        super(...arguments);
        this.steps = new Steps(this._client);
      }
      create(threadID, params, options) {
        const { include, ...body } = params;
        return this._client.post(path3`/threads/${threadID}/runs`, {
          query: { include },
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
          stream: params.stream ?? false,
        });
      }
      /**
       * Retrieves a run.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      retrieve(runID, params, options) {
        const { thread_id } = params;
        return this._client.get(path3`/threads/${thread_id}/runs/${runID}`, {
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Modifies a run.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      update(runID, params, options) {
        const { thread_id, ...body } = params;
        return this._client.post(path3`/threads/${thread_id}/runs/${runID}`, {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Returns a list of runs belonging to a thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      list(threadID, query = {}, options) {
        return this._client.getAPIList(path3`/threads/${threadID}/runs`, CursorPage, {
          query,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Cancels a run that is `in_progress`.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      cancel(runID, params, options) {
        const { thread_id } = params;
        return this._client.post(path3`/threads/${thread_id}/runs/${runID}/cancel`, {
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * A helper to create a run an poll for a terminal state. More information on Run
       * lifecycles can be found here:
       * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
       */
      async createAndPoll(threadId, body, options) {
        const run2 = await this.create(threadId, body, options);
        return await this.poll(run2.id, { thread_id: threadId }, options);
      }
      /**
       * Create a Run stream
       *
       * @deprecated use `stream` instead
       */
      createAndStream(threadId, body, options) {
        return AssistantStream.createAssistantStream(
          threadId,
          this._client.beta.threads.runs,
          body,
          options
        );
      }
      /**
       * A helper to poll a run status until it reaches a terminal state. More
       * information on Run lifecycles can be found here:
       * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
       */
      async poll(runId, params, options) {
        const headers = buildHeaders([
          options?.headers,
          {
            'X-Stainless-Poll-Helper': 'true',
            'X-Stainless-Custom-Poll-Interval': options?.pollIntervalMs?.toString() ?? void 0,
          },
        ]);
        while (true) {
          const { data: run2, response } = await this.retrieve(runId, params, {
            ...options,
            headers: { ...options?.headers, ...headers },
          }).withResponse();
          switch (run2.status) {
            //If we are in any sort of intermediate state we poll
            case 'queued':
            case 'in_progress':
            case 'cancelling':
              let sleepInterval = 5e3;
              if (options?.pollIntervalMs) {
                sleepInterval = options.pollIntervalMs;
              } else {
                const headerInterval = response.headers.get('openai-poll-after-ms');
                if (headerInterval) {
                  const headerIntervalMs = parseInt(headerInterval);
                  if (!isNaN(headerIntervalMs)) {
                    sleepInterval = headerIntervalMs;
                  }
                }
              }
              await sleep(sleepInterval);
              break;
            //We return the run in any terminal state.
            case 'requires_action':
            case 'incomplete':
            case 'cancelled':
            case 'completed':
            case 'failed':
            case 'expired':
              return run2;
          }
        }
      }
      /**
       * Create a Run stream
       */
      stream(threadId, body, options) {
        return AssistantStream.createAssistantStream(
          threadId,
          this._client.beta.threads.runs,
          body,
          options
        );
      }
      submitToolOutputs(runID, params, options) {
        const { thread_id, ...body } = params;
        return this._client.post(path3`/threads/${thread_id}/runs/${runID}/submit_tool_outputs`, {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
          stream: params.stream ?? false,
        });
      }
      /**
       * A helper to submit a tool output to a run and poll for a terminal run state.
       * More information on Run lifecycles can be found here:
       * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
       */
      async submitToolOutputsAndPoll(runId, params, options) {
        const run2 = await this.submitToolOutputs(runId, params, options);
        return await this.poll(run2.id, params, options);
      }
      /**
       * Submit the tool outputs from a previous run and stream the run to a terminal
       * state. More information on Run lifecycles can be found here:
       * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
       */
      submitToolOutputsStream(runId, params, options) {
        return AssistantStream.createToolAssistantStream(
          runId,
          this._client.beta.threads.runs,
          params,
          options
        );
      }
    };
    Runs.Steps = Steps;
  },
});

// node_modules/openai/resources/beta/threads/threads.mjs
var Threads2;
var init_threads2 = __esm({
  'node_modules/openai/resources/beta/threads/threads.mjs'() {
    init_resource();
    init_messages2();
    init_messages2();
    init_runs();
    init_runs();
    init_headers();
    init_AssistantStream();
    init_path();
    Threads2 = class extends APIResource {
      constructor() {
        super(...arguments);
        this.runs = new Runs(this._client);
        this.messages = new Messages2(this._client);
      }
      /**
       * Create a thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      create(body = {}, options) {
        return this._client.post('/threads', {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Retrieves a thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      retrieve(threadID, options) {
        return this._client.get(path3`/threads/${threadID}`, {
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Modifies a thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      update(threadID, body, options) {
        return this._client.post(path3`/threads/${threadID}`, {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Delete a thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      delete(threadID, options) {
        return this._client.delete(path3`/threads/${threadID}`, {
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      createAndRun(body, options) {
        return this._client.post('/threads/runs', {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
          stream: body.stream ?? false,
        });
      }
      /**
       * A helper to create a thread, start a run and then poll for a terminal state.
       * More information on Run lifecycles can be found here:
       * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
       */
      async createAndRunPoll(body, options) {
        const run2 = await this.createAndRun(body, options);
        return await this.runs.poll(run2.id, { thread_id: run2.thread_id }, options);
      }
      /**
       * Create a thread and stream the run back
       */
      createAndRunStream(body, options) {
        return AssistantStream.createThreadAssistantStream(
          body,
          this._client.beta.threads,
          options
        );
      }
    };
    Threads2.Runs = Runs;
    Threads2.Messages = Messages2;
  },
});

// node_modules/openai/resources/beta/beta.mjs
var Beta;
var init_beta = __esm({
  'node_modules/openai/resources/beta/beta.mjs'() {
    init_resource();
    init_assistants();
    init_assistants();
    init_realtime();
    init_realtime();
    init_chatkit();
    init_chatkit();
    init_threads2();
    init_threads2();
    Beta = class extends APIResource {
      constructor() {
        super(...arguments);
        this.realtime = new Realtime(this._client);
        this.chatkit = new ChatKit(this._client);
        this.assistants = new Assistants(this._client);
        this.threads = new Threads2(this._client);
      }
    };
    Beta.Realtime = Realtime;
    Beta.ChatKit = ChatKit;
    Beta.Assistants = Assistants;
    Beta.Threads = Threads2;
  },
});

// node_modules/openai/resources/completions.mjs
var Completions2;
var init_completions3 = __esm({
  'node_modules/openai/resources/completions.mjs'() {
    init_resource();
    Completions2 = class extends APIResource {
      create(body, options) {
        return this._client.post('/completions', {
          body,
          ...options,
          stream: body.stream ?? false,
        });
      }
    };
  },
});

// node_modules/openai/resources/containers/files/content.mjs
var Content;
var init_content = __esm({
  'node_modules/openai/resources/containers/files/content.mjs'() {
    init_resource();
    init_headers();
    init_path();
    Content = class extends APIResource {
      /**
       * Retrieve Container File Content
       */
      retrieve(fileID, params, options) {
        const { container_id } = params;
        return this._client.get(path3`/containers/${container_id}/files/${fileID}/content`, {
          ...options,
          headers: buildHeaders([{ Accept: 'application/binary' }, options?.headers]),
          __binaryResponse: true,
        });
      }
    };
  },
});

// node_modules/openai/resources/containers/files/files.mjs
var Files;
var init_files = __esm({
  'node_modules/openai/resources/containers/files/files.mjs'() {
    init_resource();
    init_content();
    init_content();
    init_pagination();
    init_headers();
    init_uploads();
    init_path();
    Files = class extends APIResource {
      constructor() {
        super(...arguments);
        this.content = new Content(this._client);
      }
      /**
       * Create a Container File
       *
       * You can send either a multipart/form-data request with the raw file content, or
       * a JSON request with a file ID.
       */
      create(containerID, body, options) {
        return this._client.post(
          path3`/containers/${containerID}/files`,
          multipartFormRequestOptions({ body, ...options }, this._client)
        );
      }
      /**
       * Retrieve Container File
       */
      retrieve(fileID, params, options) {
        const { container_id } = params;
        return this._client.get(path3`/containers/${container_id}/files/${fileID}`, options);
      }
      /**
       * List Container files
       */
      list(containerID, query = {}, options) {
        return this._client.getAPIList(path3`/containers/${containerID}/files`, CursorPage, {
          query,
          ...options,
        });
      }
      /**
       * Delete Container File
       */
      delete(fileID, params, options) {
        const { container_id } = params;
        return this._client.delete(path3`/containers/${container_id}/files/${fileID}`, {
          ...options,
          headers: buildHeaders([{ Accept: '*/*' }, options?.headers]),
        });
      }
    };
    Files.Content = Content;
  },
});

// node_modules/openai/resources/containers/containers.mjs
var Containers;
var init_containers = __esm({
  'node_modules/openai/resources/containers/containers.mjs'() {
    init_resource();
    init_files();
    init_files();
    init_pagination();
    init_headers();
    init_path();
    Containers = class extends APIResource {
      constructor() {
        super(...arguments);
        this.files = new Files(this._client);
      }
      /**
       * Create Container
       */
      create(body, options) {
        return this._client.post('/containers', { body, ...options });
      }
      /**
       * Retrieve Container
       */
      retrieve(containerID, options) {
        return this._client.get(path3`/containers/${containerID}`, options);
      }
      /**
       * List Containers
       */
      list(query = {}, options) {
        return this._client.getAPIList('/containers', CursorPage, { query, ...options });
      }
      /**
       * Delete Container
       */
      delete(containerID, options) {
        return this._client.delete(path3`/containers/${containerID}`, {
          ...options,
          headers: buildHeaders([{ Accept: '*/*' }, options?.headers]),
        });
      }
    };
    Containers.Files = Files;
  },
});

// node_modules/openai/resources/conversations/items.mjs
var Items;
var init_items = __esm({
  'node_modules/openai/resources/conversations/items.mjs'() {
    init_resource();
    init_pagination();
    init_path();
    Items = class extends APIResource {
      /**
       * Create items in a conversation with the given ID.
       */
      create(conversationID, params, options) {
        const { include, ...body } = params;
        return this._client.post(path3`/conversations/${conversationID}/items`, {
          query: { include },
          body,
          ...options,
        });
      }
      /**
       * Get a single item from a conversation with the given IDs.
       */
      retrieve(itemID, params, options) {
        const { conversation_id, ...query } = params;
        return this._client.get(path3`/conversations/${conversation_id}/items/${itemID}`, {
          query,
          ...options,
        });
      }
      /**
       * List all items for a conversation with the given ID.
       */
      list(conversationID, query = {}, options) {
        return this._client.getAPIList(
          path3`/conversations/${conversationID}/items`,
          ConversationCursorPage,
          { query, ...options }
        );
      }
      /**
       * Delete an item from a conversation with the given IDs.
       */
      delete(itemID, params, options) {
        const { conversation_id } = params;
        return this._client.delete(
          path3`/conversations/${conversation_id}/items/${itemID}`,
          options
        );
      }
    };
  },
});

// node_modules/openai/resources/conversations/conversations.mjs
var Conversations;
var init_conversations = __esm({
  'node_modules/openai/resources/conversations/conversations.mjs'() {
    init_resource();
    init_items();
    init_items();
    init_path();
    Conversations = class extends APIResource {
      constructor() {
        super(...arguments);
        this.items = new Items(this._client);
      }
      /**
       * Create a conversation.
       */
      create(body = {}, options) {
        return this._client.post('/conversations', { body, ...options });
      }
      /**
       * Get a conversation
       */
      retrieve(conversationID, options) {
        return this._client.get(path3`/conversations/${conversationID}`, options);
      }
      /**
       * Update a conversation
       */
      update(conversationID, body, options) {
        return this._client.post(path3`/conversations/${conversationID}`, { body, ...options });
      }
      /**
       * Delete a conversation. Items in the conversation will not be deleted.
       */
      delete(conversationID, options) {
        return this._client.delete(path3`/conversations/${conversationID}`, options);
      }
    };
    Conversations.Items = Items;
  },
});

// node_modules/openai/resources/embeddings.mjs
var Embeddings;
var init_embeddings = __esm({
  'node_modules/openai/resources/embeddings.mjs'() {
    init_resource();
    init_utils7();
    Embeddings = class extends APIResource {
      /**
       * Creates an embedding vector representing the input text.
       *
       * @example
       * ```ts
       * const createEmbeddingResponse =
       *   await client.embeddings.create({
       *     input: 'The quick brown fox jumped over the lazy dog',
       *     model: 'text-embedding-3-small',
       *   });
       * ```
       */
      create(body, options) {
        const hasUserProvidedEncodingFormat = !!body.encoding_format;
        let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : 'base64';
        if (hasUserProvidedEncodingFormat) {
          loggerFor(this._client).debug(
            'embeddings/user defined encoding_format:',
            body.encoding_format
          );
        }
        const response = this._client.post('/embeddings', {
          body: {
            ...body,
            encoding_format,
          },
          ...options,
        });
        if (hasUserProvidedEncodingFormat) {
          return response;
        }
        loggerFor(this._client).debug('embeddings/decoding base64 embeddings from base64');
        return response._thenUnwrap((response2) => {
          if (response2 && response2.data) {
            response2.data.forEach((embeddingBase64Obj) => {
              const embeddingBase64Str = embeddingBase64Obj.embedding;
              embeddingBase64Obj.embedding = toFloat32Array(embeddingBase64Str);
            });
          }
          return response2;
        });
      }
    };
  },
});

// node_modules/openai/resources/evals/runs/output-items.mjs
var OutputItems;
var init_output_items = __esm({
  'node_modules/openai/resources/evals/runs/output-items.mjs'() {
    init_resource();
    init_pagination();
    init_path();
    OutputItems = class extends APIResource {
      /**
       * Get an evaluation run output item by ID.
       */
      retrieve(outputItemID, params, options) {
        const { eval_id, run_id } = params;
        return this._client.get(
          path3`/evals/${eval_id}/runs/${run_id}/output_items/${outputItemID}`,
          options
        );
      }
      /**
       * Get a list of output items for an evaluation run.
       */
      list(runID, params, options) {
        const { eval_id, ...query } = params;
        return this._client.getAPIList(
          path3`/evals/${eval_id}/runs/${runID}/output_items`,
          CursorPage,
          { query, ...options }
        );
      }
    };
  },
});

// node_modules/openai/resources/evals/runs/runs.mjs
var Runs2;
var init_runs2 = __esm({
  'node_modules/openai/resources/evals/runs/runs.mjs'() {
    init_resource();
    init_output_items();
    init_output_items();
    init_pagination();
    init_path();
    Runs2 = class extends APIResource {
      constructor() {
        super(...arguments);
        this.outputItems = new OutputItems(this._client);
      }
      /**
       * Kicks off a new run for a given evaluation, specifying the data source, and what
       * model configuration to use to test. The datasource will be validated against the
       * schema specified in the config of the evaluation.
       */
      create(evalID, body, options) {
        return this._client.post(path3`/evals/${evalID}/runs`, { body, ...options });
      }
      /**
       * Get an evaluation run by ID.
       */
      retrieve(runID, params, options) {
        const { eval_id } = params;
        return this._client.get(path3`/evals/${eval_id}/runs/${runID}`, options);
      }
      /**
       * Get a list of runs for an evaluation.
       */
      list(evalID, query = {}, options) {
        return this._client.getAPIList(path3`/evals/${evalID}/runs`, CursorPage, {
          query,
          ...options,
        });
      }
      /**
       * Delete an eval run.
       */
      delete(runID, params, options) {
        const { eval_id } = params;
        return this._client.delete(path3`/evals/${eval_id}/runs/${runID}`, options);
      }
      /**
       * Cancel an ongoing evaluation run.
       */
      cancel(runID, params, options) {
        const { eval_id } = params;
        return this._client.post(path3`/evals/${eval_id}/runs/${runID}`, options);
      }
    };
    Runs2.OutputItems = OutputItems;
  },
});

// node_modules/openai/resources/evals/evals.mjs
var Evals;
var init_evals = __esm({
  'node_modules/openai/resources/evals/evals.mjs'() {
    init_resource();
    init_runs2();
    init_runs2();
    init_pagination();
    init_path();
    Evals = class extends APIResource {
      constructor() {
        super(...arguments);
        this.runs = new Runs2(this._client);
      }
      /**
       * Create the structure of an evaluation that can be used to test a model's
       * performance. An evaluation is a set of testing criteria and the config for a
       * data source, which dictates the schema of the data used in the evaluation. After
       * creating an evaluation, you can run it on different models and model parameters.
       * We support several types of graders and datasources. For more information, see
       * the [Evals guide](https://platform.openai.com/docs/guides/evals).
       */
      create(body, options) {
        return this._client.post('/evals', { body, ...options });
      }
      /**
       * Get an evaluation by ID.
       */
      retrieve(evalID, options) {
        return this._client.get(path3`/evals/${evalID}`, options);
      }
      /**
       * Update certain properties of an evaluation.
       */
      update(evalID, body, options) {
        return this._client.post(path3`/evals/${evalID}`, { body, ...options });
      }
      /**
       * List evaluations for a project.
       */
      list(query = {}, options) {
        return this._client.getAPIList('/evals', CursorPage, { query, ...options });
      }
      /**
       * Delete an evaluation.
       */
      delete(evalID, options) {
        return this._client.delete(path3`/evals/${evalID}`, options);
      }
    };
    Evals.Runs = Runs2;
  },
});

// node_modules/openai/resources/files.mjs
var Files2;
var init_files2 = __esm({
  'node_modules/openai/resources/files.mjs'() {
    init_resource();
    init_pagination();
    init_headers();
    init_sleep();
    init_error2();
    init_uploads();
    init_path();
    Files2 = class extends APIResource {
      /**
       * Upload a file that can be used across various endpoints. Individual files can be
       * up to 512 MB, and the size of all files uploaded by one organization can be up
       * to 1 TB.
       *
       * The Assistants API supports files up to 2 million tokens and of specific file
       * types. See the
       * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
       * details.
       *
       * The Fine-tuning API only supports `.jsonl` files. The input also has certain
       * required formats for fine-tuning
       * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
       * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
       * models.
       *
       * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
       * has a specific required
       * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
       *
       * Please [contact us](https://help.openai.com/) if you need to increase these
       * storage limits.
       */
      create(body, options) {
        return this._client.post(
          '/files',
          multipartFormRequestOptions({ body, ...options }, this._client)
        );
      }
      /**
       * Returns information about a specific file.
       */
      retrieve(fileID, options) {
        return this._client.get(path3`/files/${fileID}`, options);
      }
      /**
       * Returns a list of files.
       */
      list(query = {}, options) {
        return this._client.getAPIList('/files', CursorPage, { query, ...options });
      }
      /**
       * Delete a file and remove it from all vector stores.
       */
      delete(fileID, options) {
        return this._client.delete(path3`/files/${fileID}`, options);
      }
      /**
       * Returns the contents of the specified file.
       */
      content(fileID, options) {
        return this._client.get(path3`/files/${fileID}/content`, {
          ...options,
          headers: buildHeaders([{ Accept: 'application/binary' }, options?.headers]),
          __binaryResponse: true,
        });
      }
      /**
       * Waits for the given file to be processed, default timeout is 30 mins.
       */
      async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
        const TERMINAL_STATES = /* @__PURE__ */ new Set(['processed', 'error', 'deleted']);
        const start = Date.now();
        let file = await this.retrieve(id);
        while (!file.status || !TERMINAL_STATES.has(file.status)) {
          await sleep(pollInterval);
          file = await this.retrieve(id);
          if (Date.now() - start > maxWait) {
            throw new APIConnectionTimeoutError({
              message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`,
            });
          }
        }
        return file;
      }
    };
  },
});

// node_modules/openai/resources/fine-tuning/methods.mjs
var Methods;
var init_methods = __esm({
  'node_modules/openai/resources/fine-tuning/methods.mjs'() {
    init_resource();
    Methods = class extends APIResource {};
  },
});

// node_modules/openai/resources/fine-tuning/alpha/graders.mjs
var Graders;
var init_graders = __esm({
  'node_modules/openai/resources/fine-tuning/alpha/graders.mjs'() {
    init_resource();
    Graders = class extends APIResource {
      /**
       * Run a grader.
       *
       * @example
       * ```ts
       * const response = await client.fineTuning.alpha.graders.run({
       *   grader: {
       *     input: 'input',
       *     name: 'name',
       *     operation: 'eq',
       *     reference: 'reference',
       *     type: 'string_check',
       *   },
       *   model_sample: 'model_sample',
       * });
       * ```
       */
      run(body, options) {
        return this._client.post('/fine_tuning/alpha/graders/run', { body, ...options });
      }
      /**
       * Validate a grader.
       *
       * @example
       * ```ts
       * const response =
       *   await client.fineTuning.alpha.graders.validate({
       *     grader: {
       *       input: 'input',
       *       name: 'name',
       *       operation: 'eq',
       *       reference: 'reference',
       *       type: 'string_check',
       *     },
       *   });
       * ```
       */
      validate(body, options) {
        return this._client.post('/fine_tuning/alpha/graders/validate', { body, ...options });
      }
    };
  },
});

// node_modules/openai/resources/fine-tuning/alpha/alpha.mjs
var Alpha;
var init_alpha = __esm({
  'node_modules/openai/resources/fine-tuning/alpha/alpha.mjs'() {
    init_resource();
    init_graders();
    init_graders();
    Alpha = class extends APIResource {
      constructor() {
        super(...arguments);
        this.graders = new Graders(this._client);
      }
    };
    Alpha.Graders = Graders;
  },
});

// node_modules/openai/resources/fine-tuning/checkpoints/permissions.mjs
var Permissions;
var init_permissions = __esm({
  'node_modules/openai/resources/fine-tuning/checkpoints/permissions.mjs'() {
    init_resource();
    init_pagination();
    init_path();
    Permissions = class extends APIResource {
      /**
       * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
       *
       * This enables organization owners to share fine-tuned models with other projects
       * in their organization.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
       *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
       *   { project_ids: ['string'] },
       * )) {
       *   // ...
       * }
       * ```
       */
      create(fineTunedModelCheckpoint, body, options) {
        return this._client.getAPIList(
          path3`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`,
          Page,
          { body, method: 'post', ...options }
        );
      }
      /**
       * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
       *
       * Organization owners can use this endpoint to view all permissions for a
       * fine-tuned model checkpoint.
       *
       * @example
       * ```ts
       * const permission =
       *   await client.fineTuning.checkpoints.permissions.retrieve(
       *     'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       *   );
       * ```
       */
      retrieve(fineTunedModelCheckpoint, query = {}, options) {
        return this._client.get(
          path3`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`,
          {
            query,
            ...options,
          }
        );
      }
      /**
       * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
       *
       * Organization owners can use this endpoint to delete a permission for a
       * fine-tuned model checkpoint.
       *
       * @example
       * ```ts
       * const permission =
       *   await client.fineTuning.checkpoints.permissions.delete(
       *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
       *     {
       *       fine_tuned_model_checkpoint:
       *         'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
       *     },
       *   );
       * ```
       */
      delete(permissionID, params, options) {
        const { fine_tuned_model_checkpoint } = params;
        return this._client.delete(
          path3`/fine_tuning/checkpoints/${fine_tuned_model_checkpoint}/permissions/${permissionID}`,
          options
        );
      }
    };
  },
});

// node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.mjs
var Checkpoints;
var init_checkpoints = __esm({
  'node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.mjs'() {
    init_resource();
    init_permissions();
    init_permissions();
    Checkpoints = class extends APIResource {
      constructor() {
        super(...arguments);
        this.permissions = new Permissions(this._client);
      }
    };
    Checkpoints.Permissions = Permissions;
  },
});

// node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs
var Checkpoints2;
var init_checkpoints2 = __esm({
  'node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs'() {
    init_resource();
    init_pagination();
    init_path();
    Checkpoints2 = class extends APIResource {
      /**
       * List checkpoints for a fine-tuning job.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const fineTuningJobCheckpoint of client.fineTuning.jobs.checkpoints.list(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * )) {
       *   // ...
       * }
       * ```
       */
      list(fineTuningJobID, query = {}, options) {
        return this._client.getAPIList(
          path3`/fine_tuning/jobs/${fineTuningJobID}/checkpoints`,
          CursorPage,
          { query, ...options }
        );
      }
    };
  },
});

// node_modules/openai/resources/fine-tuning/jobs/jobs.mjs
var Jobs;
var init_jobs = __esm({
  'node_modules/openai/resources/fine-tuning/jobs/jobs.mjs'() {
    init_resource();
    init_checkpoints2();
    init_checkpoints2();
    init_pagination();
    init_path();
    Jobs = class extends APIResource {
      constructor() {
        super(...arguments);
        this.checkpoints = new Checkpoints2(this._client);
      }
      /**
       * Creates a fine-tuning job which begins the process of creating a new model from
       * a given dataset.
       *
       * Response includes details of the enqueued job including job status and the name
       * of the fine-tuned models once complete.
       *
       * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
       *
       * @example
       * ```ts
       * const fineTuningJob = await client.fineTuning.jobs.create({
       *   model: 'gpt-4o-mini',
       *   training_file: 'file-abc123',
       * });
       * ```
       */
      create(body, options) {
        return this._client.post('/fine_tuning/jobs', { body, ...options });
      }
      /**
       * Get info about a fine-tuning job.
       *
       * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
       *
       * @example
       * ```ts
       * const fineTuningJob = await client.fineTuning.jobs.retrieve(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * );
       * ```
       */
      retrieve(fineTuningJobID, options) {
        return this._client.get(path3`/fine_tuning/jobs/${fineTuningJobID}`, options);
      }
      /**
       * List your organization's fine-tuning jobs
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const fineTuningJob of client.fineTuning.jobs.list()) {
       *   // ...
       * }
       * ```
       */
      list(query = {}, options) {
        return this._client.getAPIList('/fine_tuning/jobs', CursorPage, { query, ...options });
      }
      /**
       * Immediately cancel a fine-tune job.
       *
       * @example
       * ```ts
       * const fineTuningJob = await client.fineTuning.jobs.cancel(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * );
       * ```
       */
      cancel(fineTuningJobID, options) {
        return this._client.post(path3`/fine_tuning/jobs/${fineTuningJobID}/cancel`, options);
      }
      /**
       * Get status updates for a fine-tuning job.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const fineTuningJobEvent of client.fineTuning.jobs.listEvents(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * )) {
       *   // ...
       * }
       * ```
       */
      listEvents(fineTuningJobID, query = {}, options) {
        return this._client.getAPIList(
          path3`/fine_tuning/jobs/${fineTuningJobID}/events`,
          CursorPage,
          { query, ...options }
        );
      }
      /**
       * Pause a fine-tune job.
       *
       * @example
       * ```ts
       * const fineTuningJob = await client.fineTuning.jobs.pause(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * );
       * ```
       */
      pause(fineTuningJobID, options) {
        return this._client.post(path3`/fine_tuning/jobs/${fineTuningJobID}/pause`, options);
      }
      /**
       * Resume a fine-tune job.
       *
       * @example
       * ```ts
       * const fineTuningJob = await client.fineTuning.jobs.resume(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * );
       * ```
       */
      resume(fineTuningJobID, options) {
        return this._client.post(path3`/fine_tuning/jobs/${fineTuningJobID}/resume`, options);
      }
    };
    Jobs.Checkpoints = Checkpoints2;
  },
});

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning;
var init_fine_tuning = __esm({
  'node_modules/openai/resources/fine-tuning/fine-tuning.mjs'() {
    init_resource();
    init_methods();
    init_methods();
    init_alpha();
    init_alpha();
    init_checkpoints();
    init_checkpoints();
    init_jobs();
    init_jobs();
    FineTuning = class extends APIResource {
      constructor() {
        super(...arguments);
        this.methods = new Methods(this._client);
        this.jobs = new Jobs(this._client);
        this.checkpoints = new Checkpoints(this._client);
        this.alpha = new Alpha(this._client);
      }
    };
    FineTuning.Methods = Methods;
    FineTuning.Jobs = Jobs;
    FineTuning.Checkpoints = Checkpoints;
    FineTuning.Alpha = Alpha;
  },
});

// node_modules/openai/resources/graders/grader-models.mjs
var GraderModels;
var init_grader_models = __esm({
  'node_modules/openai/resources/graders/grader-models.mjs'() {
    init_resource();
    GraderModels = class extends APIResource {};
  },
});

// node_modules/openai/resources/graders/graders.mjs
var Graders2;
var init_graders2 = __esm({
  'node_modules/openai/resources/graders/graders.mjs'() {
    init_resource();
    init_grader_models();
    init_grader_models();
    Graders2 = class extends APIResource {
      constructor() {
        super(...arguments);
        this.graderModels = new GraderModels(this._client);
      }
    };
    Graders2.GraderModels = GraderModels;
  },
});

// node_modules/openai/resources/images.mjs
var Images;
var init_images = __esm({
  'node_modules/openai/resources/images.mjs'() {
    init_resource();
    init_uploads();
    Images = class extends APIResource {
      /**
       * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
       *
       * @example
       * ```ts
       * const imagesResponse = await client.images.createVariation({
       *   image: fs.createReadStream('otter.png'),
       * });
       * ```
       */
      createVariation(body, options) {
        return this._client.post(
          '/images/variations',
          multipartFormRequestOptions({ body, ...options }, this._client)
        );
      }
      edit(body, options) {
        return this._client.post(
          '/images/edits',
          multipartFormRequestOptions(
            { body, ...options, stream: body.stream ?? false },
            this._client
          )
        );
      }
      generate(body, options) {
        return this._client.post('/images/generations', {
          body,
          ...options,
          stream: body.stream ?? false,
        });
      }
    };
  },
});

// node_modules/openai/resources/models.mjs
var Models;
var init_models = __esm({
  'node_modules/openai/resources/models.mjs'() {
    init_resource();
    init_pagination();
    init_path();
    Models = class extends APIResource {
      /**
       * Retrieves a model instance, providing basic information about the model such as
       * the owner and permissioning.
       */
      retrieve(model, options) {
        return this._client.get(path3`/models/${model}`, options);
      }
      /**
       * Lists the currently available models, and provides basic information about each
       * one such as the owner and availability.
       */
      list(options) {
        return this._client.getAPIList('/models', Page, options);
      }
      /**
       * Delete a fine-tuned model. You must have the Owner role in your organization to
       * delete a model.
       */
      delete(model, options) {
        return this._client.delete(path3`/models/${model}`, options);
      }
    };
  },
});

// node_modules/openai/resources/moderations.mjs
var Moderations;
var init_moderations = __esm({
  'node_modules/openai/resources/moderations.mjs'() {
    init_resource();
    Moderations = class extends APIResource {
      /**
       * Classifies if text and/or image inputs are potentially harmful. Learn more in
       * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
       */
      create(body, options) {
        return this._client.post('/moderations', { body, ...options });
      }
    };
  },
});

// node_modules/openai/resources/realtime/calls.mjs
var Calls;
var init_calls = __esm({
  'node_modules/openai/resources/realtime/calls.mjs'() {
    init_resource();
    init_headers();
    init_path();
    Calls = class extends APIResource {
      /**
       * Accept an incoming SIP call and configure the realtime session that will handle
       * it.
       *
       * @example
       * ```ts
       * await client.realtime.calls.accept('call_id', {
       *   type: 'realtime',
       * });
       * ```
       */
      accept(callID, body, options) {
        return this._client.post(path3`/realtime/calls/${callID}/accept`, {
          body,
          ...options,
          headers: buildHeaders([{ Accept: '*/*' }, options?.headers]),
        });
      }
      /**
       * End an active Realtime API call, whether it was initiated over SIP or WebRTC.
       *
       * @example
       * ```ts
       * await client.realtime.calls.hangup('call_id');
       * ```
       */
      hangup(callID, options) {
        return this._client.post(path3`/realtime/calls/${callID}/hangup`, {
          ...options,
          headers: buildHeaders([{ Accept: '*/*' }, options?.headers]),
        });
      }
      /**
       * Transfer an active SIP call to a new destination using the SIP REFER verb.
       *
       * @example
       * ```ts
       * await client.realtime.calls.refer('call_id', {
       *   target_uri: 'tel:+14155550123',
       * });
       * ```
       */
      refer(callID, body, options) {
        return this._client.post(path3`/realtime/calls/${callID}/refer`, {
          body,
          ...options,
          headers: buildHeaders([{ Accept: '*/*' }, options?.headers]),
        });
      }
      /**
       * Decline an incoming SIP call by returning a SIP status code to the caller.
       *
       * @example
       * ```ts
       * await client.realtime.calls.reject('call_id');
       * ```
       */
      reject(callID, body = {}, options) {
        return this._client.post(path3`/realtime/calls/${callID}/reject`, {
          body,
          ...options,
          headers: buildHeaders([{ Accept: '*/*' }, options?.headers]),
        });
      }
    };
  },
});

// node_modules/openai/resources/realtime/client-secrets.mjs
var ClientSecrets;
var init_client_secrets = __esm({
  'node_modules/openai/resources/realtime/client-secrets.mjs'() {
    init_resource();
    ClientSecrets = class extends APIResource {
      /**
       * Create a Realtime client secret with an associated session configuration.
       *
       * @example
       * ```ts
       * const clientSecret =
       *   await client.realtime.clientSecrets.create();
       * ```
       */
      create(body, options) {
        return this._client.post('/realtime/client_secrets', { body, ...options });
      }
    };
  },
});

// node_modules/openai/resources/realtime/realtime.mjs
var Realtime2;
var init_realtime2 = __esm({
  'node_modules/openai/resources/realtime/realtime.mjs'() {
    init_resource();
    init_calls();
    init_calls();
    init_client_secrets();
    init_client_secrets();
    Realtime2 = class extends APIResource {
      constructor() {
        super(...arguments);
        this.clientSecrets = new ClientSecrets(this._client);
        this.calls = new Calls(this._client);
      }
    };
    Realtime2.ClientSecrets = ClientSecrets;
    Realtime2.Calls = Calls;
  },
});

// node_modules/openai/lib/ResponsesParser.mjs
function maybeParseResponse(response, params) {
  if (!params || !hasAutoParseableInput2(params)) {
    return {
      ...response,
      output_parsed: null,
      output: response.output.map((item) => {
        if (item.type === 'function_call') {
          return {
            ...item,
            parsed_arguments: null,
          };
        }
        if (item.type === 'message') {
          return {
            ...item,
            content: item.content.map((content) => ({
              ...content,
              parsed: null,
            })),
          };
        } else {
          return item;
        }
      }),
    };
  }
  return parseResponse(response, params);
}
function parseResponse(response, params) {
  const output = response.output.map((item) => {
    if (item.type === 'function_call') {
      return {
        ...item,
        parsed_arguments: parseToolCall2(params, item),
      };
    }
    if (item.type === 'message') {
      const content = item.content.map((content2) => {
        if (content2.type === 'output_text') {
          return {
            ...content2,
            parsed: parseTextFormat(params, content2.text),
          };
        }
        return content2;
      });
      return {
        ...item,
        content,
      };
    }
    return item;
  });
  const parsed = Object.assign({}, response, { output });
  if (!Object.getOwnPropertyDescriptor(response, 'output_text')) {
    addOutputText(parsed);
  }
  Object.defineProperty(parsed, 'output_parsed', {
    enumerable: true,
    get() {
      for (const output2 of parsed.output) {
        if (output2.type !== 'message') {
          continue;
        }
        for (const content of output2.content) {
          if (content.type === 'output_text' && content.parsed !== null) {
            return content.parsed;
          }
        }
      }
      return null;
    },
  });
  return parsed;
}
function parseTextFormat(params, content) {
  if (params.text?.format?.type !== 'json_schema') {
    return null;
  }
  if ('$parseRaw' in params.text?.format) {
    const text_format = params.text?.format;
    return text_format.$parseRaw(content);
  }
  return JSON.parse(content);
}
function hasAutoParseableInput2(params) {
  if (isAutoParsableResponseFormat(params.text?.format)) {
    return true;
  }
  return false;
}
function isAutoParsableTool2(tool) {
  return tool?.['$brand'] === 'auto-parseable-tool';
}
function getInputToolByName(input_tools, name3) {
  return input_tools.find((tool) => tool.type === 'function' && tool.name === name3);
}
function parseToolCall2(params, toolCall) {
  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
  return {
    ...toolCall,
    ...toolCall,
    parsed_arguments: isAutoParsableTool2(inputTool)
      ? inputTool.$parseRaw(toolCall.arguments)
      : inputTool?.strict
        ? JSON.parse(toolCall.arguments)
        : null,
  };
}
function addOutputText(rsp) {
  const texts = [];
  for (const output of rsp.output) {
    if (output.type !== 'message') {
      continue;
    }
    for (const content of output.content) {
      if (content.type === 'output_text') {
        texts.push(content.text);
      }
    }
  }
  rsp.output_text = texts.join('');
}
var init_ResponsesParser = __esm({
  'node_modules/openai/lib/ResponsesParser.mjs'() {
    init_error2();
    init_parser();
  },
});

// node_modules/openai/lib/responses/ResponseStream.mjs
function finalizeResponse(snapshot2, params) {
  return maybeParseResponse(snapshot2, params);
}
var _ResponseStream_instances,
  _ResponseStream_params,
  _ResponseStream_currentResponseSnapshot,
  _ResponseStream_finalResponse,
  _ResponseStream_beginRequest,
  _ResponseStream_addEvent,
  _ResponseStream_endRequest,
  _ResponseStream_accumulateResponse,
  ResponseStream;
var init_ResponseStream = __esm({
  'node_modules/openai/lib/responses/ResponseStream.mjs'() {
    init_tslib();
    init_error2();
    init_EventStream();
    init_ResponsesParser();
    ResponseStream = class _ResponseStream extends EventStream {
      constructor(params) {
        super();
        _ResponseStream_instances.add(this);
        _ResponseStream_params.set(this, void 0);
        _ResponseStream_currentResponseSnapshot.set(this, void 0);
        _ResponseStream_finalResponse.set(this, void 0);
        __classPrivateFieldSet(this, _ResponseStream_params, params, 'f');
      }
      static createResponse(client2, params, options) {
        const runner = new _ResponseStream(params);
        runner._run(() =>
          runner._createOrRetrieveResponse(client2, params, {
            ...options,
            headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },
          })
        );
        return runner;
      }
      async _createOrRetrieveResponse(client2, params, options) {
        const signal = options?.signal;
        if (signal) {
          if (signal.aborted) this.controller.abort();
          signal.addEventListener('abort', () => this.controller.abort());
        }
        __classPrivateFieldGet(
          this,
          _ResponseStream_instances,
          'm',
          _ResponseStream_beginRequest
        ).call(this);
        let stream4;
        let starting_after = null;
        if ('response_id' in params) {
          stream4 = await client2.responses.retrieve(
            params.response_id,
            { stream: true },
            { ...options, signal: this.controller.signal, stream: true }
          );
          starting_after = params.starting_after ?? null;
        } else {
          stream4 = await client2.responses.create(
            { ...params, stream: true },
            { ...options, signal: this.controller.signal }
          );
        }
        this._connected();
        for await (const event2 of stream4) {
          __classPrivateFieldGet(
            this,
            _ResponseStream_instances,
            'm',
            _ResponseStream_addEvent
          ).call(this, event2, starting_after);
        }
        if (stream4.controller.signal?.aborted) {
          throw new APIUserAbortError();
        }
        return __classPrivateFieldGet(
          this,
          _ResponseStream_instances,
          'm',
          _ResponseStream_endRequest
        ).call(this);
      }
      [((_ResponseStream_params = /* @__PURE__ */ new WeakMap()),
      (_ResponseStream_currentResponseSnapshot = /* @__PURE__ */ new WeakMap()),
      (_ResponseStream_finalResponse = /* @__PURE__ */ new WeakMap()),
      (_ResponseStream_instances = /* @__PURE__ */ new WeakSet()),
      (_ResponseStream_beginRequest = function _ResponseStream_beginRequest2() {
        if (this.ended) return;
        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, void 0, 'f');
      }),
      (_ResponseStream_addEvent = function _ResponseStream_addEvent2(event2, starting_after) {
        if (this.ended) return;
        const maybeEmit = (name3, event3) => {
          if (starting_after == null || event3.sequence_number > starting_after) {
            this._emit(name3, event3);
          }
        };
        const response = __classPrivateFieldGet(
          this,
          _ResponseStream_instances,
          'm',
          _ResponseStream_accumulateResponse
        ).call(this, event2);
        maybeEmit('event', event2);
        switch (event2.type) {
          case 'response.output_text.delta': {
            const output = response.output[event2.output_index];
            if (!output) {
              throw new OpenAIError(`missing output at index ${event2.output_index}`);
            }
            if (output.type === 'message') {
              const content = output.content[event2.content_index];
              if (!content) {
                throw new OpenAIError(`missing content at index ${event2.content_index}`);
              }
              if (content.type !== 'output_text') {
                throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
              }
              maybeEmit('response.output_text.delta', {
                ...event2,
                snapshot: content.text,
              });
            }
            break;
          }
          case 'response.function_call_arguments.delta': {
            const output = response.output[event2.output_index];
            if (!output) {
              throw new OpenAIError(`missing output at index ${event2.output_index}`);
            }
            if (output.type === 'function_call') {
              maybeEmit('response.function_call_arguments.delta', {
                ...event2,
                snapshot: output.arguments,
              });
            }
            break;
          }
          default:
            maybeEmit(event2.type, event2);
            break;
        }
      }),
      (_ResponseStream_endRequest = function _ResponseStream_endRequest2() {
        if (this.ended) {
          throw new OpenAIError(`stream has ended, this shouldn't happen`);
        }
        const snapshot2 = __classPrivateFieldGet(
          this,
          _ResponseStream_currentResponseSnapshot,
          'f'
        );
        if (!snapshot2) {
          throw new OpenAIError(`request ended without sending any events`);
        }
        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, void 0, 'f');
        const parsedResponse = finalizeResponse(
          snapshot2,
          __classPrivateFieldGet(this, _ResponseStream_params, 'f')
        );
        __classPrivateFieldSet(this, _ResponseStream_finalResponse, parsedResponse, 'f');
        return parsedResponse;
      }),
      (_ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse2(event2) {
        let snapshot2 = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, 'f');
        if (!snapshot2) {
          if (event2.type !== 'response.created') {
            throw new OpenAIError(
              `When snapshot hasn't been set yet, expected 'response.created' event, got ${event2.type}`
            );
          }
          snapshot2 = __classPrivateFieldSet(
            this,
            _ResponseStream_currentResponseSnapshot,
            event2.response,
            'f'
          );
          return snapshot2;
        }
        switch (event2.type) {
          case 'response.output_item.added': {
            snapshot2.output.push(event2.item);
            break;
          }
          case 'response.content_part.added': {
            const output = snapshot2.output[event2.output_index];
            if (!output) {
              throw new OpenAIError(`missing output at index ${event2.output_index}`);
            }
            const type = output.type;
            const part = event2.part;
            if (type === 'message' && part.type !== 'reasoning_text') {
              output.content.push(part);
            } else if (type === 'reasoning' && part.type === 'reasoning_text') {
              if (!output.content) {
                output.content = [];
              }
              output.content.push(part);
            }
            break;
          }
          case 'response.output_text.delta': {
            const output = snapshot2.output[event2.output_index];
            if (!output) {
              throw new OpenAIError(`missing output at index ${event2.output_index}`);
            }
            if (output.type === 'message') {
              const content = output.content[event2.content_index];
              if (!content) {
                throw new OpenAIError(`missing content at index ${event2.content_index}`);
              }
              if (content.type !== 'output_text') {
                throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
              }
              content.text += event2.delta;
            }
            break;
          }
          case 'response.function_call_arguments.delta': {
            const output = snapshot2.output[event2.output_index];
            if (!output) {
              throw new OpenAIError(`missing output at index ${event2.output_index}`);
            }
            if (output.type === 'function_call') {
              output.arguments += event2.delta;
            }
            break;
          }
          case 'response.reasoning_text.delta': {
            const output = snapshot2.output[event2.output_index];
            if (!output) {
              throw new OpenAIError(`missing output at index ${event2.output_index}`);
            }
            if (output.type === 'reasoning') {
              const content = output.content?.[event2.content_index];
              if (!content) {
                throw new OpenAIError(`missing content at index ${event2.content_index}`);
              }
              if (content.type !== 'reasoning_text') {
                throw new OpenAIError(
                  `expected content to be 'reasoning_text', got ${content.type}`
                );
              }
              content.text += event2.delta;
            }
            break;
          }
          case 'response.completed': {
            __classPrivateFieldSet(
              this,
              _ResponseStream_currentResponseSnapshot,
              event2.response,
              'f'
            );
            break;
          }
        }
        return snapshot2;
      }),
      Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on('event', (event2) => {
          const reader = readQueue.shift();
          if (reader) {
            reader.resolve(event2);
          } else {
            pushQueue.push(event2);
          }
        });
        this.on('end', () => {
          done = true;
          for (const reader of readQueue) {
            reader.resolve(void 0);
          }
          readQueue.length = 0;
        });
        this.on('abort', (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        this.on('error', (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        return {
          next: async () => {
            if (!pushQueue.length) {
              if (done) {
                return { value: void 0, done: true };
              }
              return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then(
                (event3) =>
                  event3 ? { value: event3, done: false } : { value: void 0, done: true }
              );
            }
            const event2 = pushQueue.shift();
            return { value: event2, done: false };
          },
          return: async () => {
            this.abort();
            return { value: void 0, done: true };
          },
        };
      }
      /**
       * @returns a promise that resolves with the final Response, or rejects
       * if an error occurred or the stream ended prematurely without producing a REsponse.
       */
      async finalResponse() {
        await this.done();
        const response = __classPrivateFieldGet(this, _ResponseStream_finalResponse, 'f');
        if (!response) throw new OpenAIError('stream ended without producing a ChatCompletion');
        return response;
      }
    };
  },
});

// node_modules/openai/resources/responses/input-items.mjs
var InputItems;
var init_input_items = __esm({
  'node_modules/openai/resources/responses/input-items.mjs'() {
    init_resource();
    init_pagination();
    init_path();
    InputItems = class extends APIResource {
      /**
       * Returns a list of input items for a given response.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const responseItem of client.responses.inputItems.list(
       *   'response_id',
       * )) {
       *   // ...
       * }
       * ```
       */
      list(responseID, query = {}, options) {
        return this._client.getAPIList(path3`/responses/${responseID}/input_items`, CursorPage, {
          query,
          ...options,
        });
      }
    };
  },
});

// node_modules/openai/resources/responses/responses.mjs
var Responses;
var init_responses = __esm({
  'node_modules/openai/resources/responses/responses.mjs'() {
    init_ResponsesParser();
    init_ResponseStream();
    init_resource();
    init_input_items();
    init_input_items();
    init_headers();
    init_path();
    Responses = class extends APIResource {
      constructor() {
        super(...arguments);
        this.inputItems = new InputItems(this._client);
      }
      create(body, options) {
        return this._client
          .post('/responses', { body, ...options, stream: body.stream ?? false })
          ._thenUnwrap((rsp) => {
            if ('object' in rsp && rsp.object === 'response') {
              addOutputText(rsp);
            }
            return rsp;
          });
      }
      retrieve(responseID, query = {}, options) {
        return this._client
          .get(path3`/responses/${responseID}`, {
            query,
            ...options,
            stream: query?.stream ?? false,
          })
          ._thenUnwrap((rsp) => {
            if ('object' in rsp && rsp.object === 'response') {
              addOutputText(rsp);
            }
            return rsp;
          });
      }
      /**
       * Deletes a model response with the given ID.
       *
       * @example
       * ```ts
       * await client.responses.delete(
       *   'resp_677efb5139a88190b512bc3fef8e535d',
       * );
       * ```
       */
      delete(responseID, options) {
        return this._client.delete(path3`/responses/${responseID}`, {
          ...options,
          headers: buildHeaders([{ Accept: '*/*' }, options?.headers]),
        });
      }
      parse(body, options) {
        return this._client.responses
          .create(body, options)
          ._thenUnwrap((response) => parseResponse(response, body));
      }
      /**
       * Creates a model response stream
       */
      stream(body, options) {
        return ResponseStream.createResponse(this._client, body, options);
      }
      /**
       * Cancels a model response with the given ID. Only responses created with the
       * `background` parameter set to `true` can be cancelled.
       * [Learn more](https://platform.openai.com/docs/guides/background).
       *
       * @example
       * ```ts
       * const response = await client.responses.cancel(
       *   'resp_677efb5139a88190b512bc3fef8e535d',
       * );
       * ```
       */
      cancel(responseID, options) {
        return this._client.post(path3`/responses/${responseID}/cancel`, options);
      }
    };
    Responses.InputItems = InputItems;
  },
});

// node_modules/openai/resources/uploads/parts.mjs
var Parts;
var init_parts = __esm({
  'node_modules/openai/resources/uploads/parts.mjs'() {
    init_resource();
    init_uploads();
    init_path();
    Parts = class extends APIResource {
      /**
       * Adds a
       * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
       * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
       * A Part represents a chunk of bytes from the file you are trying to upload.
       *
       * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
       * maximum of 8 GB.
       *
       * It is possible to add multiple Parts in parallel. You can decide the intended
       * order of the Parts when you
       * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
       */
      create(uploadID, body, options) {
        return this._client.post(
          path3`/uploads/${uploadID}/parts`,
          multipartFormRequestOptions({ body, ...options }, this._client)
        );
      }
    };
  },
});

// node_modules/openai/resources/uploads/uploads.mjs
var Uploads;
var init_uploads3 = __esm({
  'node_modules/openai/resources/uploads/uploads.mjs'() {
    init_resource();
    init_parts();
    init_parts();
    init_path();
    Uploads = class extends APIResource {
      constructor() {
        super(...arguments);
        this.parts = new Parts(this._client);
      }
      /**
       * Creates an intermediate
       * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
       * that you can add
       * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
       * Currently, an Upload can accept at most 8 GB in total and expires after an hour
       * after you create it.
       *
       * Once you complete the Upload, we will create a
       * [File](https://platform.openai.com/docs/api-reference/files/object) object that
       * contains all the parts you uploaded. This File is usable in the rest of our
       * platform as a regular File object.
       *
       * For certain `purpose` values, the correct `mime_type` must be specified. Please
       * refer to documentation for the
       * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
       *
       * For guidance on the proper filename extensions for each purpose, please follow
       * the documentation on
       * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
       */
      create(body, options) {
        return this._client.post('/uploads', { body, ...options });
      }
      /**
       * Cancels the Upload. No Parts may be added after an Upload is cancelled.
       */
      cancel(uploadID, options) {
        return this._client.post(path3`/uploads/${uploadID}/cancel`, options);
      }
      /**
       * Completes the
       * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
       *
       * Within the returned Upload object, there is a nested
       * [File](https://platform.openai.com/docs/api-reference/files/object) object that
       * is ready to use in the rest of the platform.
       *
       * You can specify the order of the Parts by passing in an ordered list of the Part
       * IDs.
       *
       * The number of bytes uploaded upon completion must match the number of bytes
       * initially specified when creating the Upload object. No Parts may be added after
       * an Upload is completed.
       */
      complete(uploadID, body, options) {
        return this._client.post(path3`/uploads/${uploadID}/complete`, { body, ...options });
      }
    };
    Uploads.Parts = Parts;
  },
});

// node_modules/openai/lib/Util.mjs
var allSettledWithThrow;
var init_Util = __esm({
  'node_modules/openai/lib/Util.mjs'() {
    allSettledWithThrow = async (promises) => {
      const results = await Promise.allSettled(promises);
      const rejected = results.filter((result) => result.status === 'rejected');
      if (rejected.length) {
        for (const result of rejected) {
          console.error(result.reason);
        }
        throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
      }
      const values = [];
      for (const result of results) {
        if (result.status === 'fulfilled') {
          values.push(result.value);
        }
      }
      return values;
    };
  },
});

// node_modules/openai/resources/vector-stores/file-batches.mjs
var FileBatches;
var init_file_batches = __esm({
  'node_modules/openai/resources/vector-stores/file-batches.mjs'() {
    init_resource();
    init_pagination();
    init_headers();
    init_sleep();
    init_Util();
    init_path();
    FileBatches = class extends APIResource {
      /**
       * Create a vector store file batch.
       */
      create(vectorStoreID, body, options) {
        return this._client.post(path3`/vector_stores/${vectorStoreID}/file_batches`, {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Retrieves a vector store file batch.
       */
      retrieve(batchID, params, options) {
        const { vector_store_id } = params;
        return this._client.get(path3`/vector_stores/${vector_store_id}/file_batches/${batchID}`, {
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Cancel a vector store file batch. This attempts to cancel the processing of
       * files in this batch as soon as possible.
       */
      cancel(batchID, params, options) {
        const { vector_store_id } = params;
        return this._client.post(
          path3`/vector_stores/${vector_store_id}/file_batches/${batchID}/cancel`,
          {
            ...options,
            headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
          }
        );
      }
      /**
       * Create a vector store batch and poll until all files have been processed.
       */
      async createAndPoll(vectorStoreId, body, options) {
        const batch = await this.create(vectorStoreId, body);
        return await this.poll(vectorStoreId, batch.id, options);
      }
      /**
       * Returns a list of vector store files in a batch.
       */
      listFiles(batchID, params, options) {
        const { vector_store_id, ...query } = params;
        return this._client.getAPIList(
          path3`/vector_stores/${vector_store_id}/file_batches/${batchID}/files`,
          CursorPage,
          {
            query,
            ...options,
            headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
          }
        );
      }
      /**
       * Wait for the given file batch to be processed.
       *
       * Note: this will return even if one of the files failed to process, you need to
       * check batch.file_counts.failed_count to handle this case.
       */
      async poll(vectorStoreID, batchID, options) {
        const headers = buildHeaders([
          options?.headers,
          {
            'X-Stainless-Poll-Helper': 'true',
            'X-Stainless-Custom-Poll-Interval': options?.pollIntervalMs?.toString() ?? void 0,
          },
        ]);
        while (true) {
          const { data: batch, response } = await this.retrieve(
            batchID,
            { vector_store_id: vectorStoreID },
            {
              ...options,
              headers,
            }
          ).withResponse();
          switch (batch.status) {
            case 'in_progress':
              let sleepInterval = 5e3;
              if (options?.pollIntervalMs) {
                sleepInterval = options.pollIntervalMs;
              } else {
                const headerInterval = response.headers.get('openai-poll-after-ms');
                if (headerInterval) {
                  const headerIntervalMs = parseInt(headerInterval);
                  if (!isNaN(headerIntervalMs)) {
                    sleepInterval = headerIntervalMs;
                  }
                }
              }
              await sleep(sleepInterval);
              break;
            case 'failed':
            case 'cancelled':
            case 'completed':
              return batch;
          }
        }
      }
      /**
       * Uploads the given files concurrently and then creates a vector store file batch.
       *
       * The concurrency limit is configurable using the `maxConcurrency` parameter.
       */
      async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
        if (files == null || files.length == 0) {
          throw new Error(
            `No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`
          );
        }
        const configuredConcurrency = options?.maxConcurrency ?? 5;
        const concurrencyLimit = Math.min(configuredConcurrency, files.length);
        const client2 = this._client;
        const fileIterator = files.values();
        const allFileIds = [...fileIds];
        async function processFiles(iterator2) {
          for (let item of iterator2) {
            const fileObj = await client2.files.create(
              { file: item, purpose: 'assistants' },
              options
            );
            allFileIds.push(fileObj.id);
          }
        }
        const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
        await allSettledWithThrow(workers);
        return await this.createAndPoll(vectorStoreId, {
          file_ids: allFileIds,
        });
      }
    };
  },
});

// node_modules/openai/resources/vector-stores/files.mjs
var Files3;
var init_files3 = __esm({
  'node_modules/openai/resources/vector-stores/files.mjs'() {
    init_resource();
    init_pagination();
    init_headers();
    init_utils7();
    init_path();
    Files3 = class extends APIResource {
      /**
       * Create a vector store file by attaching a
       * [File](https://platform.openai.com/docs/api-reference/files) to a
       * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
       */
      create(vectorStoreID, body, options) {
        return this._client.post(path3`/vector_stores/${vectorStoreID}/files`, {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Retrieves a vector store file.
       */
      retrieve(fileID, params, options) {
        const { vector_store_id } = params;
        return this._client.get(path3`/vector_stores/${vector_store_id}/files/${fileID}`, {
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Update attributes on a vector store file.
       */
      update(fileID, params, options) {
        const { vector_store_id, ...body } = params;
        return this._client.post(path3`/vector_stores/${vector_store_id}/files/${fileID}`, {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Returns a list of vector store files.
       */
      list(vectorStoreID, query = {}, options) {
        return this._client.getAPIList(path3`/vector_stores/${vectorStoreID}/files`, CursorPage, {
          query,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Delete a vector store file. This will remove the file from the vector store but
       * the file itself will not be deleted. To delete the file, use the
       * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
       * endpoint.
       */
      delete(fileID, params, options) {
        const { vector_store_id } = params;
        return this._client.delete(path3`/vector_stores/${vector_store_id}/files/${fileID}`, {
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Attach a file to the given vector store and wait for it to be processed.
       */
      async createAndPoll(vectorStoreId, body, options) {
        const file = await this.create(vectorStoreId, body, options);
        return await this.poll(vectorStoreId, file.id, options);
      }
      /**
       * Wait for the vector store file to finish processing.
       *
       * Note: this will return even if the file failed to process, you need to check
       * file.last_error and file.status to handle these cases
       */
      async poll(vectorStoreID, fileID, options) {
        const headers = buildHeaders([
          options?.headers,
          {
            'X-Stainless-Poll-Helper': 'true',
            'X-Stainless-Custom-Poll-Interval': options?.pollIntervalMs?.toString() ?? void 0,
          },
        ]);
        while (true) {
          const fileResponse = await this.retrieve(
            fileID,
            {
              vector_store_id: vectorStoreID,
            },
            { ...options, headers }
          ).withResponse();
          const file = fileResponse.data;
          switch (file.status) {
            case 'in_progress':
              let sleepInterval = 5e3;
              if (options?.pollIntervalMs) {
                sleepInterval = options.pollIntervalMs;
              } else {
                const headerInterval = fileResponse.response.headers.get('openai-poll-after-ms');
                if (headerInterval) {
                  const headerIntervalMs = parseInt(headerInterval);
                  if (!isNaN(headerIntervalMs)) {
                    sleepInterval = headerIntervalMs;
                  }
                }
              }
              await sleep(sleepInterval);
              break;
            case 'failed':
            case 'completed':
              return file;
          }
        }
      }
      /**
       * Upload a file to the `files` API and then attach it to the given vector store.
       *
       * Note the file will be asynchronously processed (you can use the alternative
       * polling helper method to wait for processing to complete).
       */
      async upload(vectorStoreId, file, options) {
        const fileInfo = await this._client.files.create({ file, purpose: 'assistants' }, options);
        return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
      }
      /**
       * Add a file to a vector store and poll until processing is complete.
       */
      async uploadAndPoll(vectorStoreId, file, options) {
        const fileInfo = await this.upload(vectorStoreId, file, options);
        return await this.poll(vectorStoreId, fileInfo.id, options);
      }
      /**
       * Retrieve the parsed contents of a vector store file.
       */
      content(fileID, params, options) {
        const { vector_store_id } = params;
        return this._client.getAPIList(
          path3`/vector_stores/${vector_store_id}/files/${fileID}/content`,
          Page,
          {
            ...options,
            headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
          }
        );
      }
    };
  },
});

// node_modules/openai/resources/vector-stores/vector-stores.mjs
var VectorStores;
var init_vector_stores = __esm({
  'node_modules/openai/resources/vector-stores/vector-stores.mjs'() {
    init_resource();
    init_file_batches();
    init_file_batches();
    init_files3();
    init_files3();
    init_pagination();
    init_headers();
    init_path();
    VectorStores = class extends APIResource {
      constructor() {
        super(...arguments);
        this.files = new Files3(this._client);
        this.fileBatches = new FileBatches(this._client);
      }
      /**
       * Create a vector store.
       */
      create(body, options) {
        return this._client.post('/vector_stores', {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Retrieves a vector store.
       */
      retrieve(vectorStoreID, options) {
        return this._client.get(path3`/vector_stores/${vectorStoreID}`, {
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Modifies a vector store.
       */
      update(vectorStoreID, body, options) {
        return this._client.post(path3`/vector_stores/${vectorStoreID}`, {
          body,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Returns a list of vector stores.
       */
      list(query = {}, options) {
        return this._client.getAPIList('/vector_stores', CursorPage, {
          query,
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Delete a vector store.
       */
      delete(vectorStoreID, options) {
        return this._client.delete(path3`/vector_stores/${vectorStoreID}`, {
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
      /**
       * Search a vector store for relevant chunks based on a query and file attributes
       * filter.
       */
      search(vectorStoreID, body, options) {
        return this._client.getAPIList(path3`/vector_stores/${vectorStoreID}/search`, Page, {
          body,
          method: 'post',
          ...options,
          headers: buildHeaders([{ 'OpenAI-Beta': 'assistants=v2' }, options?.headers]),
        });
      }
    };
    VectorStores.Files = Files3;
    VectorStores.FileBatches = FileBatches;
  },
});

// node_modules/openai/resources/videos.mjs
var Videos;
var init_videos = __esm({
  'node_modules/openai/resources/videos.mjs'() {
    init_resource();
    init_pagination();
    init_headers();
    init_uploads();
    init_path();
    Videos = class extends APIResource {
      /**
       * Create a video
       */
      create(body, options) {
        return this._client.post(
          '/videos',
          maybeMultipartFormRequestOptions({ body, ...options }, this._client)
        );
      }
      /**
       * Retrieve a video
       */
      retrieve(videoID, options) {
        return this._client.get(path3`/videos/${videoID}`, options);
      }
      /**
       * List videos
       */
      list(query = {}, options) {
        return this._client.getAPIList('/videos', ConversationCursorPage, { query, ...options });
      }
      /**
       * Delete a video
       */
      delete(videoID, options) {
        return this._client.delete(path3`/videos/${videoID}`, options);
      }
      /**
       * Download video content
       */
      downloadContent(videoID, query = {}, options) {
        return this._client.get(path3`/videos/${videoID}/content`, {
          query,
          ...options,
          headers: buildHeaders([{ Accept: 'application/binary' }, options?.headers]),
          __binaryResponse: true,
        });
      }
      /**
       * Create a video remix
       */
      remix(videoID, body, options) {
        return this._client.post(
          path3`/videos/${videoID}/remix`,
          maybeMultipartFormRequestOptions({ body, ...options }, this._client)
        );
      }
    };
  },
});

// node_modules/openai/resources/webhooks.mjs
var _Webhooks_instances, _Webhooks_validateSecret, _Webhooks_getRequiredHeader, Webhooks;
var init_webhooks = __esm({
  'node_modules/openai/resources/webhooks.mjs'() {
    init_tslib();
    init_error2();
    init_resource();
    init_headers();
    Webhooks = class extends APIResource {
      constructor() {
        super(...arguments);
        _Webhooks_instances.add(this);
      }
      /**
       * Validates that the given payload was sent by OpenAI and parses the payload.
       */
      async unwrap(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
        await this.verifySignature(payload, headers, secret, tolerance);
        return JSON.parse(payload);
      }
      /**
       * Validates whether or not the webhook payload was sent by OpenAI.
       *
       * An error will be raised if the webhook payload was not sent by OpenAI.
       *
       * @param payload - The webhook payload
       * @param headers - The webhook headers
       * @param secret - The webhook secret (optional, will use client secret if not provided)
       * @param tolerance - Maximum age of the webhook in seconds (default: 300 = 5 minutes)
       */
      async verifySignature(
        payload,
        headers,
        secret = this._client.webhookSecret,
        tolerance = 300
      ) {
        if (
          typeof crypto === 'undefined' ||
          typeof crypto.subtle.importKey !== 'function' ||
          typeof crypto.subtle.verify !== 'function'
        ) {
          throw new Error(
            'Webhook signature verification is only supported when the `crypto` global is defined'
          );
        }
        __classPrivateFieldGet(this, _Webhooks_instances, 'm', _Webhooks_validateSecret).call(
          this,
          secret
        );
        const headersObj = buildHeaders([headers]).values;
        const signatureHeader = __classPrivateFieldGet(
          this,
          _Webhooks_instances,
          'm',
          _Webhooks_getRequiredHeader
        ).call(this, headersObj, 'webhook-signature');
        const timestamp = __classPrivateFieldGet(
          this,
          _Webhooks_instances,
          'm',
          _Webhooks_getRequiredHeader
        ).call(this, headersObj, 'webhook-timestamp');
        const webhookId = __classPrivateFieldGet(
          this,
          _Webhooks_instances,
          'm',
          _Webhooks_getRequiredHeader
        ).call(this, headersObj, 'webhook-id');
        const timestampSeconds = parseInt(timestamp, 10);
        if (isNaN(timestampSeconds)) {
          throw new InvalidWebhookSignatureError('Invalid webhook timestamp format');
        }
        const nowSeconds2 = Math.floor(Date.now() / 1e3);
        if (nowSeconds2 - timestampSeconds > tolerance) {
          throw new InvalidWebhookSignatureError('Webhook timestamp is too old');
        }
        if (timestampSeconds > nowSeconds2 + tolerance) {
          throw new InvalidWebhookSignatureError('Webhook timestamp is too new');
        }
        const signatures = signatureHeader
          .split(' ')
          .map((part) => (part.startsWith('v1,') ? part.substring(3) : part));
        const decodedSecret = secret.startsWith('whsec_')
          ? Buffer.from(secret.replace('whsec_', ''), 'base64')
          : Buffer.from(secret, 'utf-8');
        const signedPayload = webhookId
          ? `${webhookId}.${timestamp}.${payload}`
          : `${timestamp}.${payload}`;
        const key2 = await crypto.subtle.importKey(
          'raw',
          decodedSecret,
          { name: 'HMAC', hash: 'SHA-256' },
          false,
          ['verify']
        );
        for (const signature of signatures) {
          try {
            const signatureBytes = Buffer.from(signature, 'base64');
            const isValid = await crypto.subtle.verify(
              'HMAC',
              key2,
              signatureBytes,
              new TextEncoder().encode(signedPayload)
            );
            if (isValid) {
              return;
            }
          } catch {
            continue;
          }
        }
        throw new InvalidWebhookSignatureError(
          'The given webhook signature does not match the expected signature'
        );
      }
    };
    ((_Webhooks_instances = /* @__PURE__ */ new WeakSet()),
      (_Webhooks_validateSecret = function _Webhooks_validateSecret2(secret) {
        if (typeof secret !== 'string' || secret.length === 0) {
          throw new Error(
            `The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function`
          );
        }
      }),
      (_Webhooks_getRequiredHeader = function _Webhooks_getRequiredHeader2(headers, name3) {
        if (!headers) {
          throw new Error(`Headers are required`);
        }
        const value = headers.get(name3);
        if (value === null || value === void 0) {
          throw new Error(`Missing required header: ${name3}`);
        }
        return value;
      }));
  },
});

// node_modules/openai/resources/index.mjs
var init_resources = __esm({
  'node_modules/openai/resources/index.mjs'() {
    init_chat2();
    init_shared3();
    init_audio();
    init_batches();
    init_beta();
    init_completions3();
    init_containers();
    init_conversations();
    init_embeddings();
    init_evals();
    init_files2();
    init_fine_tuning();
    init_graders2();
    init_images();
    init_models();
    init_moderations();
    init_realtime2();
    init_responses();
    init_uploads3();
    init_vector_stores();
    init_videos();
    init_webhooks();
  },
});

// node_modules/openai/client.mjs
var _OpenAI_instances, _a2, _OpenAI_encoder, _OpenAI_baseURLOverridden, OpenAI;
var init_client2 = __esm({
  'node_modules/openai/client.mjs'() {
    init_tslib();
    init_uuid();
    init_values();
    init_sleep();
    init_errors3();
    init_detect_platform();
    init_shims();
    init_request_options();
    init_qs();
    init_version2();
    init_error();
    init_pagination();
    init_uploads2();
    init_resources();
    init_api_promise();
    init_batches();
    init_completions3();
    init_embeddings();
    init_files2();
    init_images();
    init_models();
    init_moderations();
    init_videos();
    init_webhooks();
    init_audio();
    init_beta();
    init_chat();
    init_containers();
    init_conversations();
    init_evals();
    init_fine_tuning();
    init_graders2();
    init_realtime2();
    init_responses();
    init_uploads3();
    init_vector_stores();
    init_detect_platform();
    init_headers();
    init_env();
    init_log();
    init_values();
    OpenAI = class {
      /**
       * API Client for interfacing with the OpenAI API.
       *
       * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
       * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
       * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
       * @param {string | null | undefined} [opts.webhookSecret=process.env['OPENAI_WEBHOOK_SECRET'] ?? null]
       * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
       * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
       * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
       * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
       * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
       * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
       * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
       * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
       */
      constructor({
        baseURL = readEnv('OPENAI_BASE_URL'),
        apiKey = readEnv('OPENAI_API_KEY'),
        organization = readEnv('OPENAI_ORG_ID') ?? null,
        project = readEnv('OPENAI_PROJECT_ID') ?? null,
        webhookSecret = readEnv('OPENAI_WEBHOOK_SECRET') ?? null,
        ...opts
      } = {}) {
        _OpenAI_instances.add(this);
        _OpenAI_encoder.set(this, void 0);
        this.completions = new Completions2(this);
        this.chat = new Chat(this);
        this.embeddings = new Embeddings(this);
        this.files = new Files2(this);
        this.images = new Images(this);
        this.audio = new Audio(this);
        this.moderations = new Moderations(this);
        this.models = new Models(this);
        this.fineTuning = new FineTuning(this);
        this.graders = new Graders2(this);
        this.vectorStores = new VectorStores(this);
        this.webhooks = new Webhooks(this);
        this.beta = new Beta(this);
        this.batches = new Batches(this);
        this.uploads = new Uploads(this);
        this.responses = new Responses(this);
        this.realtime = new Realtime2(this);
        this.conversations = new Conversations(this);
        this.evals = new Evals(this);
        this.containers = new Containers(this);
        this.videos = new Videos(this);
        if (apiKey === void 0) {
          throw new OpenAIError(
            'Missing credentials. Please pass an `apiKey`, or set the `OPENAI_API_KEY` environment variable.'
          );
        }
        const options = {
          apiKey,
          organization,
          project,
          webhookSecret,
          ...opts,
          baseURL: baseURL || `https://api.openai.com/v1`,
        };
        if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
          throw new OpenAIError(
            "It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n"
          );
        }
        this.baseURL = options.baseURL;
        this.timeout = options.timeout ?? _a2.DEFAULT_TIMEOUT;
        this.logger = options.logger ?? console;
        const defaultLogLevel = 'warn';
        this.logLevel = defaultLogLevel;
        this.logLevel =
          parseLogLevel(options.logLevel, 'ClientOptions.logLevel', this) ??
          parseLogLevel(readEnv('OPENAI_LOG'), "process.env['OPENAI_LOG']", this) ??
          defaultLogLevel;
        this.fetchOptions = options.fetchOptions;
        this.maxRetries = options.maxRetries ?? 2;
        this.fetch = options.fetch ?? getDefaultFetch();
        __classPrivateFieldSet(this, _OpenAI_encoder, FallbackEncoder, 'f');
        this._options = options;
        this.apiKey = typeof apiKey === 'string' ? apiKey : 'Missing Key';
        this.organization = organization;
        this.project = project;
        this.webhookSecret = webhookSecret;
      }
      /**
       * Create a new client instance re-using the same options given to the current client with optional overriding.
       */
      withOptions(options) {
        const client2 = new this.constructor({
          ...this._options,
          baseURL: this.baseURL,
          maxRetries: this.maxRetries,
          timeout: this.timeout,
          logger: this.logger,
          logLevel: this.logLevel,
          fetch: this.fetch,
          fetchOptions: this.fetchOptions,
          apiKey: this.apiKey,
          organization: this.organization,
          project: this.project,
          webhookSecret: this.webhookSecret,
          ...options,
        });
        return client2;
      }
      defaultQuery() {
        return this._options.defaultQuery;
      }
      validateHeaders({ values, nulls }) {
        return;
      }
      async authHeaders(opts) {
        return buildHeaders([{ Authorization: `Bearer ${this.apiKey}` }]);
      }
      stringifyQuery(query) {
        return stringify3(query, { arrayFormat: 'brackets' });
      }
      getUserAgent() {
        return `${this.constructor.name}/JS ${VERSION3}`;
      }
      defaultIdempotencyKey() {
        return `stainless-node-retry-${uuid4()}`;
      }
      makeStatusError(status, error, message, headers) {
        return APIError.generate(status, error, message, headers);
      }
      async _callApiKey() {
        const apiKey = this._options.apiKey;
        if (typeof apiKey !== 'function') return false;
        let token;
        try {
          token = await apiKey();
        } catch (err) {
          if (err instanceof OpenAIError) throw err;
          throw new OpenAIError(
            `Failed to get token from 'apiKey' function: ${err.message}`,
            // @ts-ignore
            { cause: err }
          );
        }
        if (typeof token !== 'string' || !token) {
          throw new OpenAIError(
            `Expected 'apiKey' function argument to return a string but it returned ${token}`
          );
        }
        this.apiKey = token;
        return true;
      }
      buildURL(path5, query, defaultBaseURL) {
        const baseURL =
          (!__classPrivateFieldGet(this, _OpenAI_instances, 'm', _OpenAI_baseURLOverridden).call(
            this
          ) &&
            defaultBaseURL) ||
          this.baseURL;
        const url2 = isAbsoluteURL2(path5)
          ? new URL(path5)
          : new URL(
              baseURL + (baseURL.endsWith('/') && path5.startsWith('/') ? path5.slice(1) : path5)
            );
        const defaultQuery = this.defaultQuery();
        if (!isEmptyObj(defaultQuery)) {
          query = { ...defaultQuery, ...query };
        }
        if (typeof query === 'object' && query && !Array.isArray(query)) {
          url2.search = this.stringifyQuery(query);
        }
        return url2.toString();
      }
      /**
       * Used as a callback for mutating the given `FinalRequestOptions` object.
       */
      async prepareOptions(options) {
        await this._callApiKey();
      }
      /**
       * Used as a callback for mutating the given `RequestInit` object.
       *
       * This is useful for cases where you want to add certain headers based off of
       * the request properties, e.g. `method` or `url`.
       */
      async prepareRequest(request, { url: url2, options }) {}
      get(path5, opts) {
        return this.methodRequest('get', path5, opts);
      }
      post(path5, opts) {
        return this.methodRequest('post', path5, opts);
      }
      patch(path5, opts) {
        return this.methodRequest('patch', path5, opts);
      }
      put(path5, opts) {
        return this.methodRequest('put', path5, opts);
      }
      delete(path5, opts) {
        return this.methodRequest('delete', path5, opts);
      }
      methodRequest(method, path5, opts) {
        return this.request(
          Promise.resolve(opts).then((opts2) => {
            return { method, path: path5, ...opts2 };
          })
        );
      }
      request(options, remainingRetries = null) {
        return new APIPromise(this, this.makeRequest(options, remainingRetries, void 0));
      }
      async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
        const options = await optionsInput;
        const maxRetries = options.maxRetries ?? this.maxRetries;
        if (retriesRemaining == null) {
          retriesRemaining = maxRetries;
        }
        await this.prepareOptions(options);
        const {
          req,
          url: url2,
          timeout,
        } = await this.buildRequest(options, {
          retryCount: maxRetries - retriesRemaining,
        });
        await this.prepareRequest(req, { url: url2, options });
        const requestLogID =
          'log_' + ((Math.random() * (1 << 24)) | 0).toString(16).padStart(6, '0');
        const retryLogStr =
          retryOfRequestLogID === void 0 ? '' : `, retryOf: ${retryOfRequestLogID}`;
        const startTime = Date.now();
        loggerFor(this).debug(
          `[${requestLogID}] sending request`,
          formatRequestDetails({
            retryOfRequestLogID,
            method: options.method,
            url: url2,
            options,
            headers: req.headers,
          })
        );
        if (options.signal?.aborted) {
          throw new APIUserAbortError();
        }
        const controller = new AbortController();
        const response = await this.fetchWithTimeout(url2, req, timeout, controller).catch(
          castToError
        );
        const headersTime = Date.now();
        if (response instanceof globalThis.Error) {
          const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
          if (options.signal?.aborted) {
            throw new APIUserAbortError();
          }
          const isTimeout =
            isAbortError(response) ||
            /timed? ?out/i.test(
              String(response) + ('cause' in response ? String(response.cause) : '')
            );
          if (retriesRemaining) {
            loggerFor(this).info(
              `[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} - ${retryMessage}`
            );
            loggerFor(this).debug(
              `[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} (${retryMessage})`,
              formatRequestDetails({
                retryOfRequestLogID,
                url: url2,
                durationMs: headersTime - startTime,
                message: response.message,
              })
            );
            return this.retryRequest(
              options,
              retriesRemaining,
              retryOfRequestLogID ?? requestLogID
            );
          }
          loggerFor(this).info(
            `[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} - error; no more retries left`
          );
          loggerFor(this).debug(
            `[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} (error; no more retries left)`,
            formatRequestDetails({
              retryOfRequestLogID,
              url: url2,
              durationMs: headersTime - startTime,
              message: response.message,
            })
          );
          if (isTimeout) {
            throw new APIConnectionTimeoutError();
          }
          throw new APIConnectionError({ cause: response });
        }
        const specialHeaders = [...response.headers.entries()]
          .filter(([name3]) => name3 === 'x-request-id')
          .map(([name3, value]) => ', ' + name3 + ': ' + JSON.stringify(value))
          .join('');
        const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req.method} ${url2} ${response.ok ? 'succeeded' : 'failed'} with status ${response.status} in ${headersTime - startTime}ms`;
        if (!response.ok) {
          const shouldRetry = await this.shouldRetry(response);
          if (retriesRemaining && shouldRetry) {
            const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
            await CancelReadableStream(response.body);
            loggerFor(this).info(`${responseInfo} - ${retryMessage2}`);
            loggerFor(this).debug(
              `[${requestLogID}] response error (${retryMessage2})`,
              formatRequestDetails({
                retryOfRequestLogID,
                url: response.url,
                status: response.status,
                headers: response.headers,
                durationMs: headersTime - startTime,
              })
            );
            return this.retryRequest(
              options,
              retriesRemaining,
              retryOfRequestLogID ?? requestLogID,
              response.headers
            );
          }
          const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
          loggerFor(this).info(`${responseInfo} - ${retryMessage}`);
          const errText = await response.text().catch((err2) => castToError(err2).message);
          const errJSON = safeJSON(errText);
          const errMessage = errJSON ? void 0 : errText;
          loggerFor(this).debug(
            `[${requestLogID}] response error (${retryMessage})`,
            formatRequestDetails({
              retryOfRequestLogID,
              url: response.url,
              status: response.status,
              headers: response.headers,
              message: errMessage,
              durationMs: Date.now() - startTime,
            })
          );
          const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
          throw err;
        }
        loggerFor(this).info(responseInfo);
        loggerFor(this).debug(
          `[${requestLogID}] response start`,
          formatRequestDetails({
            retryOfRequestLogID,
            url: response.url,
            status: response.status,
            headers: response.headers,
            durationMs: headersTime - startTime,
          })
        );
        return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
      }
      getAPIList(path5, Page2, opts) {
        return this.requestAPIList(Page2, { method: 'get', path: path5, ...opts });
      }
      requestAPIList(Page2, options) {
        const request = this.makeRequest(options, null, void 0);
        return new PagePromise(this, request, Page2);
      }
      async fetchWithTimeout(url2, init2, ms, controller) {
        const { signal, method, ...options } = init2 || {};
        if (signal) signal.addEventListener('abort', () => controller.abort());
        const timeout = setTimeout(() => controller.abort(), ms);
        const isReadableBody =
          (globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream) ||
          (typeof options.body === 'object' &&
            options.body !== null &&
            Symbol.asyncIterator in options.body);
        const fetchOptions = {
          signal: controller.signal,
          ...(isReadableBody ? { duplex: 'half' } : {}),
          method: 'GET',
          ...options,
        };
        if (method) {
          fetchOptions.method = method.toUpperCase();
        }
        try {
          return await this.fetch.call(void 0, url2, fetchOptions);
        } finally {
          clearTimeout(timeout);
        }
      }
      async shouldRetry(response) {
        const shouldRetryHeader = response.headers.get('x-should-retry');
        if (shouldRetryHeader === 'true') return true;
        if (shouldRetryHeader === 'false') return false;
        if (response.status === 408) return true;
        if (response.status === 409) return true;
        if (response.status === 429) return true;
        if (response.status >= 500) return true;
        return false;
      }
      async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
        let timeoutMillis;
        const retryAfterMillisHeader = responseHeaders?.get('retry-after-ms');
        if (retryAfterMillisHeader) {
          const timeoutMs = parseFloat(retryAfterMillisHeader);
          if (!Number.isNaN(timeoutMs)) {
            timeoutMillis = timeoutMs;
          }
        }
        const retryAfterHeader = responseHeaders?.get('retry-after');
        if (retryAfterHeader && !timeoutMillis) {
          const timeoutSeconds = parseFloat(retryAfterHeader);
          if (!Number.isNaN(timeoutSeconds)) {
            timeoutMillis = timeoutSeconds * 1e3;
          } else {
            timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
          }
        }
        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
          const maxRetries = options.maxRetries ?? this.maxRetries;
          timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
        }
        await sleep(timeoutMillis);
        return this.makeRequest(options, retriesRemaining - 1, requestLogID);
      }
      calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
        const initialRetryDelay = 0.5;
        const maxRetryDelay = 8;
        const numRetries = maxRetries - retriesRemaining;
        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
        const jitter = 1 - Math.random() * 0.25;
        return sleepSeconds * jitter * 1e3;
      }
      async buildRequest(inputOptions, { retryCount = 0 } = {}) {
        const options = { ...inputOptions };
        const { method, path: path5, query, defaultBaseURL } = options;
        const url2 = this.buildURL(path5, query, defaultBaseURL);
        if ('timeout' in options) validatePositiveInteger('timeout', options.timeout);
        options.timeout = options.timeout ?? this.timeout;
        const { bodyHeaders, body } = this.buildBody({ options });
        const reqHeaders = await this.buildHeaders({
          options: inputOptions,
          method,
          bodyHeaders,
          retryCount,
        });
        const req = {
          method,
          headers: reqHeaders,
          ...(options.signal && { signal: options.signal }),
          ...(globalThis.ReadableStream &&
            body instanceof globalThis.ReadableStream && { duplex: 'half' }),
          ...(body && { body }),
          ...(this.fetchOptions ?? {}),
          ...(options.fetchOptions ?? {}),
        };
        return { req, url: url2, timeout: options.timeout };
      }
      async buildHeaders({ options, method, bodyHeaders, retryCount }) {
        let idempotencyHeaders = {};
        if (this.idempotencyHeader && method !== 'get') {
          if (!options.idempotencyKey) options.idempotencyKey = this.defaultIdempotencyKey();
          idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
        }
        const headers = buildHeaders([
          idempotencyHeaders,
          {
            Accept: 'application/json',
            'User-Agent': this.getUserAgent(),
            'X-Stainless-Retry-Count': String(retryCount),
            ...(options.timeout
              ? { 'X-Stainless-Timeout': String(Math.trunc(options.timeout / 1e3)) }
              : {}),
            ...getPlatformHeaders(),
            'OpenAI-Organization': this.organization,
            'OpenAI-Project': this.project,
          },
          await this.authHeaders(options),
          this._options.defaultHeaders,
          bodyHeaders,
          options.headers,
        ]);
        this.validateHeaders(headers);
        return headers.values;
      }
      buildBody({ options: { body, headers: rawHeaders } }) {
        if (!body) {
          return { bodyHeaders: void 0, body: void 0 };
        }
        const headers = buildHeaders([rawHeaders]);
        if (
          // Pass raw type verbatim
          ArrayBuffer.isView(body) ||
          body instanceof ArrayBuffer ||
          body instanceof DataView ||
          (typeof body === 'string' && // Preserve legacy string encoding behavior for now
            headers.values.has('content-type')) || // `Blob` is superset of `File`
          (globalThis.Blob && body instanceof globalThis.Blob) || // `FormData` -> `multipart/form-data`
          body instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
          body instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
          (globalThis.ReadableStream && body instanceof globalThis.ReadableStream)
        ) {
          return { bodyHeaders: void 0, body };
        } else if (
          typeof body === 'object' &&
          (Symbol.asyncIterator in body ||
            (Symbol.iterator in body && 'next' in body && typeof body.next === 'function'))
        ) {
          return { bodyHeaders: void 0, body: ReadableStreamFrom(body) };
        } else {
          return __classPrivateFieldGet(this, _OpenAI_encoder, 'f').call(this, { body, headers });
        }
      }
    };
    ((_a2 = OpenAI),
      (_OpenAI_encoder = /* @__PURE__ */ new WeakMap()),
      (_OpenAI_instances = /* @__PURE__ */ new WeakSet()),
      (_OpenAI_baseURLOverridden = function _OpenAI_baseURLOverridden2() {
        return this.baseURL !== 'https://api.openai.com/v1';
      }));
    OpenAI.OpenAI = _a2;
    OpenAI.DEFAULT_TIMEOUT = 6e5;
    OpenAI.OpenAIError = OpenAIError;
    OpenAI.APIError = APIError;
    OpenAI.APIConnectionError = APIConnectionError;
    OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
    OpenAI.APIUserAbortError = APIUserAbortError;
    OpenAI.NotFoundError = NotFoundError;
    OpenAI.ConflictError = ConflictError;
    OpenAI.RateLimitError = RateLimitError;
    OpenAI.BadRequestError = BadRequestError;
    OpenAI.AuthenticationError = AuthenticationError;
    OpenAI.InternalServerError = InternalServerError;
    OpenAI.PermissionDeniedError = PermissionDeniedError;
    OpenAI.UnprocessableEntityError = UnprocessableEntityError;
    OpenAI.InvalidWebhookSignatureError = InvalidWebhookSignatureError;
    OpenAI.toFile = toFile;
    OpenAI.Completions = Completions2;
    OpenAI.Chat = Chat;
    OpenAI.Embeddings = Embeddings;
    OpenAI.Files = Files2;
    OpenAI.Images = Images;
    OpenAI.Audio = Audio;
    OpenAI.Moderations = Moderations;
    OpenAI.Models = Models;
    OpenAI.FineTuning = FineTuning;
    OpenAI.Graders = Graders2;
    OpenAI.VectorStores = VectorStores;
    OpenAI.Webhooks = Webhooks;
    OpenAI.Beta = Beta;
    OpenAI.Batches = Batches;
    OpenAI.Uploads = Uploads;
    OpenAI.Responses = Responses;
    OpenAI.Realtime = Realtime2;
    OpenAI.Conversations = Conversations;
    OpenAI.Evals = Evals;
    OpenAI.Containers = Containers;
    OpenAI.Videos = Videos;
  },
});

// node_modules/openai/azure.mjs
var AzureOpenAI, _deployments_endpoints;
var init_azure = __esm({
  'node_modules/openai/azure.mjs'() {
    init_headers();
    init_error2();
    init_utils7();
    init_client2();
    AzureOpenAI = class extends OpenAI {
      /**
       * API Client for interfacing with the Azure OpenAI API.
       *
       * @param {string | undefined} [opts.apiVersion=process.env['OPENAI_API_VERSION'] ?? undefined]
       * @param {string | undefined} [opts.endpoint=process.env['AZURE_OPENAI_ENDPOINT'] ?? undefined] - Your Azure endpoint, including the resource, e.g. `https://example-resource.azure.openai.com/`
       * @param {string | undefined} [opts.apiKey=process.env['AZURE_OPENAI_API_KEY'] ?? undefined]
       * @param {string | undefined} opts.deployment - A model deployment, if given, sets the base client URL to include `/deployments/{deployment}`.
       * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
       * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL']] - Sets the base URL for the API, e.g. `https://example-resource.azure.openai.com/openai/`.
       * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
       * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
       * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
       * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
       * @param {Headers} opts.defaultHeaders - Default headers to include with every request to the API.
       * @param {DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
       * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
       */
      constructor({
        baseURL = readEnv('OPENAI_BASE_URL'),
        apiKey = readEnv('AZURE_OPENAI_API_KEY'),
        apiVersion = readEnv('OPENAI_API_VERSION'),
        endpoint,
        deployment,
        azureADTokenProvider,
        dangerouslyAllowBrowser,
        ...opts
      } = {}) {
        if (!apiVersion) {
          throw new OpenAIError(
            "The OPENAI_API_VERSION environment variable is missing or empty; either provide it, or instantiate the AzureOpenAI client with an apiVersion option, like new AzureOpenAI({ apiVersion: 'My API Version' })."
          );
        }
        if (typeof azureADTokenProvider === 'function') {
          dangerouslyAllowBrowser = true;
        }
        if (!azureADTokenProvider && !apiKey) {
          throw new OpenAIError(
            'Missing credentials. Please pass one of `apiKey` and `azureADTokenProvider`, or set the `AZURE_OPENAI_API_KEY` environment variable.'
          );
        }
        if (azureADTokenProvider && apiKey) {
          throw new OpenAIError(
            'The `apiKey` and `azureADTokenProvider` arguments are mutually exclusive; only one can be passed at a time.'
          );
        }
        opts.defaultQuery = { ...opts.defaultQuery, 'api-version': apiVersion };
        if (!baseURL) {
          if (!endpoint) {
            endpoint = process.env['AZURE_OPENAI_ENDPOINT'];
          }
          if (!endpoint) {
            throw new OpenAIError(
              'Must provide one of the `baseURL` or `endpoint` arguments, or the `AZURE_OPENAI_ENDPOINT` environment variable'
            );
          }
          baseURL = `${endpoint}/openai`;
        } else {
          if (endpoint) {
            throw new OpenAIError('baseURL and endpoint are mutually exclusive');
          }
        }
        super({
          apiKey: azureADTokenProvider ?? apiKey,
          baseURL,
          ...opts,
          ...(dangerouslyAllowBrowser !== void 0 ? { dangerouslyAllowBrowser } : {}),
        });
        this.apiVersion = '';
        this.apiVersion = apiVersion;
        this.deploymentName = deployment;
      }
      async buildRequest(options, props = {}) {
        if (
          _deployments_endpoints.has(options.path) &&
          options.method === 'post' &&
          options.body !== void 0
        ) {
          if (!isObj(options.body)) {
            throw new Error('Expected request body to be an object');
          }
          const model =
            this.deploymentName || options.body['model'] || options.__metadata?.['model'];
          if (model !== void 0 && !this.baseURL.includes('/deployments')) {
            options.path = `/deployments/${model}${options.path}`;
          }
        }
        return super.buildRequest(options, props);
      }
      async authHeaders(opts) {
        if (typeof this._options.apiKey === 'string') {
          return buildHeaders([{ 'api-key': this.apiKey }]);
        }
        return super.authHeaders(opts);
      }
    };
    _deployments_endpoints = /* @__PURE__ */ new Set([
      '/completions',
      '/chat/completions',
      '/embeddings',
      '/audio/transcriptions',
      '/audio/translations',
      '/audio/speech',
      '/images/generations',
      '/batches',
      '/images/edits',
    ]);
  },
});

// node_modules/openai/index.mjs
var openai_exports = {};
__export(openai_exports, {
  APIConnectionError: () => APIConnectionError,
  APIConnectionTimeoutError: () => APIConnectionTimeoutError,
  APIError: () => APIError,
  APIPromise: () => APIPromise,
  APIUserAbortError: () => APIUserAbortError,
  AuthenticationError: () => AuthenticationError,
  AzureOpenAI: () => AzureOpenAI,
  BadRequestError: () => BadRequestError,
  ConflictError: () => ConflictError,
  InternalServerError: () => InternalServerError,
  InvalidWebhookSignatureError: () => InvalidWebhookSignatureError,
  NotFoundError: () => NotFoundError,
  OpenAI: () => OpenAI,
  OpenAIError: () => OpenAIError,
  PagePromise: () => PagePromise,
  PermissionDeniedError: () => PermissionDeniedError,
  RateLimitError: () => RateLimitError,
  UnprocessableEntityError: () => UnprocessableEntityError,
  default: () => OpenAI,
  toFile: () => toFile,
});
var init_openai = __esm({
  'node_modules/openai/index.mjs'() {
    init_client2();
    init_uploads2();
    init_api_promise();
    init_client2();
    init_pagination();
    init_error();
    init_azure();
  },
});

// src/activation.ts
init_azureClient2();
import * as vscode8 from 'vscode';
import * as fs from 'fs';
import * as path4 from 'path';
import { randomUUID as randomUUID3 } from 'crypto';
init_provider2();

// src/timer.ts
var WorkItemTimer = class {
  onState;
  onInfo;
  onWarn;
  onError;
  now;
  persist;
  restorePersisted;
  autoResumeOnActivity;
  inactivityTimeoutSec;
  pomodoroEnabled;
  breakPrompt;
  _tickIntervalMs = 1e3;
  _inactivityCheckMs = 1e4;
  defaultElapsedLimitHours = 3.5;
  // hours
  _state;
  _ticker;
  _inactivityTicker;
  _lastActivity;
  _timeEntries = [];
  constructor(options = {}) {
    this.onState = options.onState || (() => {});
    this.onInfo = options.onInfo || (() => {});
    this.onWarn = options.onWarn || (() => {});
    this.onError = options.onError || (() => {});
    this.now = options.now || (() => Date.now());
    this.persist = options.persist || (() => {});
    this.restorePersisted = options.restorePersisted || (() => ({}));
    this.autoResumeOnActivity = options.autoResumeOnActivity ?? true;
    this.inactivityTimeoutSec = options.inactivityTimeoutSec ?? 300;
    this._inactivityCheckMs = options.inactivityCheckMs ?? 1e4;
    this.pomodoroEnabled = options.pomodoroEnabled ?? false;
    this.breakPrompt = options.breakPrompt || ((cb) => cb());
    this.defaultElapsedLimitHours = options.defaultElapsedLimitHours ?? 3.5;
    this._lastActivity = this.now();
  }
  loadFromPersisted() {
    const persisted = this.restorePersisted() || {};
    const state2 = persisted.state;
    const timeEntries = persisted.timeEntries;
    const persistedCap =
      persisted.defaultElapsedLimitHours ||
      (state2 && (state2.__defaultElapsedLimitHours ?? void 0));
    if (typeof persistedCap === 'number') this.defaultElapsedLimitHours = persistedCap;
    if (state2) {
      this._state = state2;
      if (!this._state.isPaused) {
        const elapsedMs = this._state.elapsedSeconds * 1e3;
        this._state.startTime = this.now() - elapsedMs;
      }
      this._timeEntries = timeEntries || [];
      this._startLoops();
      this.onInfo(`Restored timer for #${this._state.workItemId}: ${this._state.workItemTitle}`);
      this.onState(this.snapshot());
    }
  }
  snapshot() {
    return this._state ? { ...this._state } : void 0;
  }
  start(workItemId, workItemTitle) {
    if (this._state) {
      this.onWarn('Timer already running. Stop it first.');
      return false;
    }
    this._state = {
      workItemId,
      workItemTitle,
      startTime: this.now(),
      elapsedSeconds: 0,
      isPaused: false,
      isPomodoro: this.pomodoroEnabled,
      pomodoroCount: 0,
    };
    this._persist();
    this._startLoops();
    this.onInfo(`Timer started for #${workItemId}: ${workItemTitle}`);
    this.onState(this.snapshot());
    return true;
  }
  pause(manual = true) {
    if (!this._state || this._state.isPaused) {
      this.onInfo('No active timer to pause');
      return false;
    }
    this._applyElapsed();
    this._state.isPaused = true;
    this._state.pausedTime = this.now();
    if (!manual) this._state.pausedDueToInactivity = true;
    this._persist();
    this.onInfo('Timer paused');
    this.onState(this.snapshot());
    return true;
  }
  resume(fromActivity = false) {
    if (!this._state || !this._state.isPaused) {
      this.onInfo('No paused timer to resume');
      return false;
    }
    const anyState = this._state;
    if (anyState.pausedTime) {
      const pausedMs = Math.max(0, this.now() - anyState.pausedTime);
      const adj = Math.min(pausedMs, 24 * 60 * 60 * 1e3);
      this._state.startTime += adj;
    }
    this._state.isPaused = false;
    delete anyState.pausedTime;
    if (fromActivity) delete anyState.pausedDueToInactivity;
    this._persist();
    this.onInfo('Timer resumed');
    this.onState(this.snapshot());
    return true;
  }
  activityPing() {
    this._lastActivity = this.now();
    const anyState = this._state;
    if (
      this._state &&
      this._state.isPaused &&
      anyState.pausedDueToInactivity &&
      this.autoResumeOnActivity
    ) {
      this.resume(true);
      this.onInfo('Timer resumed due to activity');
    }
  }
  stop(addTimeEntryCallback) {
    if (!this._state) {
      this.onInfo('No timer running');
      return null;
    }
    this._applyElapsed();
    const totalSecRaw = this._state.elapsedSeconds;
    const capSec = Math.max(0, Math.floor(this.defaultElapsedLimitHours * 3600));
    let usedSec = totalSecRaw;
    let capApplied = false;
    if (capSec > 0 && totalSecRaw > capSec) {
      usedSec = capSec;
      capApplied = true;
    }
    const hours = parseFloat((usedSec / 3600).toFixed(2));
    const entry = {
      workItemId: this._state.workItemId,
      startTime: this._state.startTime,
      endTime: this._state.startTime + usedSec * 1e3,
      duration: usedSec,
    };
    this._timeEntries.push(entry);
    this._persist();
    const finishedId = this._state.workItemId;
    this._clearState();
    if (addTimeEntryCallback)
      Promise.resolve(addTimeEntryCallback(finishedId, hours)).catch((err) =>
        this.onError((err && err.message) || String(err))
      );
    if (capApplied) {
      this.onWarn(
        `Timer stopped. Elapsed time exceeded configured cap; recorded ${hours.toFixed(
          2
        )} hours (cap: ${this.defaultElapsedLimitHours.toFixed(2)}h).`
      );
    } else {
      this.onInfo(`Timer stopped. Total time: ${hours.toFixed(2)} hours.`);
    }
    return {
      ...entry,
      hoursDecimal: hours,
      capApplied,
      capLimitHours: this.defaultElapsedLimitHours,
    };
  }
  getTimeEntries() {
    return [...this._timeEntries];
  }
  timeReport(period) {
    const now = this.now();
    const nowDate = new Date(now);
    let from;
    switch (period) {
      case 'Today': {
        const d = new Date(nowDate);
        d.setHours(0, 0, 0, 0);
        from = d.getTime();
        break;
      }
      case 'This Week': {
        const d = new Date(nowDate);
        d.setDate(d.getDate() - d.getDay());
        d.setHours(0, 0, 0, 0);
        from = d.getTime();
        break;
      }
      case 'This Month': {
        const d = new Date(nowDate.getFullYear(), nowDate.getMonth(), 1);
        d.setHours(0, 0, 0, 0);
        from = d.getTime();
        break;
      }
      case 'All Time':
      default:
        from = 0;
        break;
    }
    const map = /* @__PURE__ */ new Map();
    for (const e of this._timeEntries) {
      const entryStart = e.startTime;
      const entryEnd = typeof e.endTime === 'number' ? e.endTime : e.startTime + e.duration * 1e3;
      const overlapStart = Math.max(entryStart, from);
      const overlapEnd = Math.min(entryEnd, now);
      const overlapMs = Math.max(0, overlapEnd - overlapStart);
      if (overlapMs <= 0) continue;
      if (!map.has(e.workItemId)) map.set(e.workItemId, { total: 0, entries: [] });
      const bucket = map.get(e.workItemId);
      bucket.total += overlapMs / 1e3;
      bucket.entries.push(e);
    }
    return { period, from, to: now, buckets: map };
  }
  _applyElapsed() {
    if (!this._state || this._state.isPaused) return;
    const deltaSec = Math.floor((this.now() - this._state.startTime) / 1e3);
    this._state.elapsedSeconds = Math.max(0, Math.min(deltaSec, 86400));
  }
  _tick() {
    if (this._state && !this._state.isPaused) {
      this._applyElapsed();
      if (this._state.isPomodoro) {
        const mins = this._state.elapsedSeconds / 60;
        if (mins >= 25 && Math.floor(mins) % 30 === 25) {
          this.breakPrompt(() => this.activityPing());
          this._state.pomodoroCount += 1;
        }
      }
      this.onState(this.snapshot());
      this._persist(false);
    }
  }
  _checkInactivity() {
    if (!this._state || this._state.isPaused) return;
    const idleSec = (this.now() - this._lastActivity) / 1e3;
    if (idleSec >= this.inactivityTimeoutSec) {
      this.pause(false);
      this.onWarn(`Timer paused after ${this.inactivityTimeoutSec} seconds of inactivity.`);
    }
  }
  _startLoops() {
    this._stopLoops();
    this._ticker = setInterval(() => this._tick(), this._tickIntervalMs);
    this._inactivityTicker = setInterval(() => this._checkInactivity(), this._inactivityCheckMs);
  }
  _stopLoops() {
    if (this._ticker) {
      clearInterval(this._ticker);
      this._ticker = void 0;
    }
    if (this._inactivityTicker) {
      clearInterval(this._inactivityTicker);
      this._inactivityTicker = void 0;
    }
  }
  _clearState() {
    this._stopLoops();
    this._state = void 0;
    this._persist();
    this.onState(void 0);
  }
  _persist(updateLastSave = true) {
    try {
      this.persist({
        state: this._state,
        timeEntries: this._timeEntries,
        updateLastSave,
        defaultElapsedLimitHours: this.defaultElapsedLimitHours,
      });
    } catch (e) {
      this.onError(e.message || e);
    }
  }
  // Allow updating the cap at runtime when settings change
  setDefaultElapsedLimitHours(hours) {
    if (typeof hours === 'number' && Number.isFinite(hours) && hours >= 0) {
      this.defaultElapsedLimitHours = hours;
      this.onInfo(`Default elapsed limit updated to ${hours} hours.`);
    }
  }
};

// src/sessionTelemetry.ts
import { randomUUID } from 'crypto';
import { execFile } from 'child_process';
import * as os from 'node:os';
import * as path2 from 'node:path';
import { promisify } from 'util';
import * as vscode2 from 'vscode';

// src/telemetryDatabase.ts
import * as path from 'node:path';
import * as vscode from 'vscode';
var TelemetryDatabase = class {
  constructor(context, options = {}) {
    this.context = context;
    this.options = options;
    this.ready = this.init();
  }
  db;
  sqlJs;
  ready;
  async persistSession(record) {
    await this.ready;
    if (!this.db) return;
    this.db.run(
      `INSERT OR REPLACE INTO session (sessionId, workItemId, workItemTitle, startedAt, stoppedAt, timerHours, capApplied, capLimitHours, baseline, finalSnapshot)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`.trim(),
      [
        record.sessionId,
        record.workItemId,
        record.workItemTitle,
        record.startedAt,
        record.stoppedAt,
        record.timerHours ?? null,
        record.capApplied ? 1 : 0,
        record.capLimitHours ?? null,
        record.baseline ? JSON.stringify(record.baseline) : null,
        record.finalSnapshot ? JSON.stringify(record.finalSnapshot) : null,
      ]
    );
    for (const event2 of record.events) {
      this.db.run(
        `INSERT OR REPLACE INTO event (id, sessionId, type, timestamp, payload) VALUES (?, ?, ?, ?, ?)`.trim(),
        [
          event2.id,
          record.sessionId,
          event2.type,
          event2.timestamp,
          event2.payload ? JSON.stringify(event2.payload) : null,
        ]
      );
    }
    await this.save();
  }
  async getSessions() {
    await this.ready;
    if (!this.db) return [];
    const stmt = this.db.prepare('SELECT * FROM session ORDER BY startedAt DESC');
    const sessions = [];
    try {
      while (stmt.step()) {
        const row = stmt.getAsObject();
        row.baseline = row.baseline ? JSON.parse(row.baseline) : void 0;
        row.finalSnapshot = row.finalSnapshot ? JSON.parse(row.finalSnapshot) : void 0;
        sessions.push(row);
      }
    } finally {
      stmt.free();
    }
    return sessions;
  }
  async init() {
    try {
      const sqlJsModule = await Promise.resolve().then(() => __toESM(require_sql_wasm()));
      const initSqlJs = sqlJsModule.default || sqlJsModule;
      this.sqlJs = await initSqlJs();
      const bytes = await this.loadFromDisk();
      this.db = this.sqlJs ? new this.sqlJs.Database(bytes ?? void 0) : void 0;
      this.createTables();
    } catch (error) {
      console.warn(
        '[TelemetryDatabase] Failed to initialize SQLite, disabling database features:',
        error
      );
      this.db = void 0;
      this.sqlJs = void 0;
    }
  }
  createTables() {
    if (!this.db) return;
    this.db.run(
      `CREATE TABLE IF NOT EXISTS session (
         sessionId TEXT PRIMARY KEY,
         workItemId INTEGER,
         workItemTitle TEXT,
         startedAt INTEGER,
         stoppedAt INTEGER,
         timerHours REAL,
         capApplied INTEGER,
         capLimitHours REAL,
         baseline TEXT,
         finalSnapshot TEXT
       );
       CREATE TABLE IF NOT EXISTS event (
         id TEXT PRIMARY KEY,
         sessionId TEXT,
         type TEXT,
         timestamp INTEGER,
         payload TEXT
       );`
    );
  }
  async save() {
    if (!this.db) return;
    const storageFile = await this.ensureStorageFile();
    if (!storageFile) return;
    const data = this.db.export();
    await vscode.workspace.fs.writeFile(storageFile, data);
  }
  async loadFromDisk() {
    const storageFile = await this.ensureStorageFile(false);
    if (!storageFile) return void 0;
    try {
      const bytes = await vscode.workspace.fs.readFile(storageFile);
      return bytes;
    } catch (error) {
      if (error.code === 'FileNotFound' || error?.name === 'EntryNotFound') {
        return void 0;
      }
      console.warn('[telemetryDatabase] Failed to read existing database', error);
      return void 0;
    }
  }
  async ensureStorageFile(createDir = true) {
    const target =
      this.options.storageFile ??
      vscode.Uri.joinPath(this.context.globalStorageUri, 'telemetry.sqlite');
    if (!target) return void 0;
    if (createDir) {
      const dir = vscode.Uri.file(path.dirname(target.fsPath));
      await vscode.workspace.fs.createDirectory(dir);
    }
    return target;
  }
};

// src/sessionTelemetry.ts
var execFileAsync = promisify(execFile);
var TELEMETRY_STORAGE_KEY = 'azureDevOpsIntegration.sessionTelemetry.lastRecord';
var CAPTURE_CONFIG_KEY = 'sessionTelemetry.enableCapture';
var STORAGE_MODE_CONFIG_KEY = 'sessionTelemetry.storageMode';
var SQLITE_PATH_CONFIG_KEY = 'sessionTelemetry.sqlitePath';
var GIT_STATUS_THROTTLE_MS = 4e3;
async function runGitCommand(repoPath, args) {
  try {
    const { stdout } = await execFileAsync('git', args, {
      cwd: repoPath,
      encoding: 'utf8',
      windowsHide: true,
    });
    return stdout.trim();
  } catch (error) {
    console.warn('[sessionTelemetry] git command failed', { args, error });
    return void 0;
  }
}
function asRelativePath(uri) {
  if (!uri) return void 0;
  const workspace6 = vscode2.workspace.getWorkspaceFolder(uri);
  if (workspace6) {
    return vscode2.workspace.asRelativePath(uri, false);
  }
  return uri.fsPath;
}
var SessionTelemetryManager = class {
  context;
  gitApi;
  activeSession;
  pendingGitPulse;
  telemetryDb;
  telemetryDbUri;
  constructor(context) {
    this.context = context;
  }
  get isActive() {
    return !!this.activeSession;
  }
  async ensureGitApi() {
    if (this.gitApi) return this.gitApi;
    try {
      const gitExt = vscode2.extensions.getExtension('vscode.git');
      if (!gitExt) return void 0;
      const api = gitExt.isActive
        ? gitExt.exports.getAPI?.(1)
        : (await gitExt.activate()).getAPI?.(1);
      this.gitApi = api;
      return api;
    } catch (error) {
      console.warn('[sessionTelemetry] Failed to acquire git API', error);
      return void 0;
    }
  }
  async startSession(args) {
    const config = vscode2.workspace.getConfiguration('azureDevOpsIntegration');
    const enabled = config.get(CAPTURE_CONFIG_KEY, true);
    if (!enabled) {
      this.disposeSession();
      return;
    }
    if (this.activeSession) {
      await this.finalizeSession({ reason: 'overlapping-start' });
    }
    const sessionId = randomUUID();
    const startedAt = Date.now();
    const repo = await this.getPrimaryRepository();
    const repoPath = repo?.rootUri?.fsPath ?? void 0;
    const baseline = repoPath ? await this.captureGitSnapshot(repo, repoPath) : void 0;
    const events = [];
    const disposables = [];
    if (repo && typeof repo.state?.onDidChange === 'function') {
      const repoListener = repo.state.onDidChange(() => this.queueGitPulse(repo, 'state-change'));
      disposables.push(repoListener);
    }
    const saveListener = vscode2.workspace.onDidSaveTextDocument((doc) => {
      if (!this.activeSession) return;
      const relative = asRelativePath(doc.uri);
      if (!relative) return;
      this.recordEvent('workspace:file-save', {
        file: relative,
        languageId: doc.languageId,
        byteLength: doc.getText().length,
      });
    });
    disposables.push(saveListener);
    this.activeSession = {
      sessionId,
      workItemId: args.workItemId,
      workItemTitle: args.workItemTitle,
      startedAt,
      repoPath,
      baseline,
      events,
      disposables,
      repo,
    };
    this.recordEvent('timer:start', {
      workItemId: args.workItemId,
      workItemTitle: args.workItemTitle,
      baseline,
    });
  }
  async handleTimerStop(entry) {
    await this.finalizeSession({ reason: 'timer-stop', entry });
  }
  disposeSession() {
    if (!this.activeSession) return;
    for (const d of this.activeSession.disposables) {
      try {
        d.dispose();
      } catch {}
    }
    this.activeSession = void 0;
    if (this.pendingGitPulse) {
      clearTimeout(this.pendingGitPulse);
      this.pendingGitPulse = void 0;
    }
  }
  recordEvent(type, payload) {
    if (!this.activeSession) return;
    const event2 = {
      id: randomUUID(),
      type,
      timestamp: Date.now(),
      payload,
    };
    this.activeSession.events.push(event2);
  }
  queueGitPulse(repo, reason) {
    if (!this.activeSession || !this.activeSession.repoPath) return;
    if (this.pendingGitPulse) return;
    this.pendingGitPulse = setTimeout(async () => {
      this.pendingGitPulse = void 0;
      const snapshot2 = await this.captureGitSnapshot(repo, this.activeSession?.repoPath, reason);
      if (snapshot2) {
        this.recordEvent('git:status', { reason, snapshot: snapshot2 });
      }
    }, GIT_STATUS_THROTTLE_MS);
  }
  async finalizeSession(options) {
    if (!this.activeSession) return;
    const session = this.activeSession;
    const repo = session.repo;
    const repoPath = session.repoPath;
    let finalSnapshot;
    if (repo && repoPath) {
      finalSnapshot = await this.captureGitSnapshot(repo, repoPath, options.reason);
      if (finalSnapshot) {
        this.recordEvent('git:status', {
          reason: `${options.reason}:final`,
          snapshot: finalSnapshot,
        });
      }
    }
    const stoppedAt = Date.now();
    if (options.entry) {
      this.recordEvent('timer:stop', {
        workItemId: options.entry.workItemId,
        duration: options.entry.duration,
        hoursDecimal: options.entry.hoursDecimal,
        startTime: options.entry.startTime,
        endTime: options.entry.endTime,
        capApplied: options.entry.capApplied,
        capLimitHours: options.entry.capLimitHours,
      });
    } else {
      this.recordEvent('timer:stop', { reason: options.reason });
    }
    const record = {
      sessionId: session.sessionId,
      workItemId: session.workItemId,
      workItemTitle: session.workItemTitle,
      startedAt: session.startedAt,
      stoppedAt,
      timerHours: options.entry?.hoursDecimal,
      capApplied: options.entry?.capApplied,
      capLimitHours: options.entry?.capLimitHours,
      baseline: session.baseline,
      finalSnapshot,
      events: [...session.events],
    };
    await this.persistRecord(record);
    this.disposeSession();
  }
  async persistRecord(record) {
    try {
      if (this.getStorageMode() === 'sqlite') {
        const db = await this.ensureTelemetryDb();
        if (db) {
          await db.persistSession(record);
          return;
        }
      }
      await this.context.workspaceState.update(TELEMETRY_STORAGE_KEY, record);
    } catch (error) {
      console.warn('[sessionTelemetry] Failed to persist session record', error);
      try {
        await this.context.workspaceState.update(TELEMETRY_STORAGE_KEY, record);
      } catch {}
    }
  }
  getStorageMode() {
    const config = vscode2.workspace.getConfiguration('azureDevOpsIntegration');
    const value = (config.get(STORAGE_MODE_CONFIG_KEY, 'sqlite') || '').toLowerCase();
    return value === 'workspacestate' ? 'workspaceState' : 'sqlite';
  }
  async ensureTelemetryDb() {
    const mode = this.getStorageMode();
    if (mode !== 'sqlite') {
      this.telemetryDb = void 0;
      this.telemetryDbUri = void 0;
      return void 0;
    }
    const sqliteUri = await this.resolveSqliteUri();
    if (!sqliteUri) return void 0;
    if (
      !this.telemetryDb ||
      !this.telemetryDbUri ||
      this.telemetryDbUri.fsPath !== sqliteUri.fsPath
    ) {
      try {
        this.telemetryDb = new TelemetryDatabase(this.context, { storageFile: sqliteUri });
        this.telemetryDbUri = sqliteUri;
      } catch (error) {
        console.warn(
          '[SessionTelemetry] Failed to create TelemetryDatabase, falling back to workspaceState:',
          error
        );
        const config = vscode2.workspace.getConfiguration('azureDevOpsIntegration');
        await config.update(
          STORAGE_MODE_CONFIG_KEY,
          'workspaceState',
          vscode2.ConfigurationTarget.Global
        );
        this.telemetryDb = void 0;
        this.telemetryDbUri = void 0;
        return void 0;
      }
    }
    return this.telemetryDb;
  }
  async resolveSqliteUri() {
    const config = vscode2.workspace.getConfiguration('azureDevOpsIntegration');
    const rawSetting = config.get(SQLITE_PATH_CONFIG_KEY, '')?.trim();
    if (!rawSetting) {
      return vscode2.Uri.joinPath(this.context.globalStorageUri, 'session-telemetry.sqlite');
    }
    const expanded = rawSetting.startsWith('~')
      ? path2.join(os.homedir(), rawSetting.slice(1))
      : rawSetting;
    const candidate = path2.isAbsolute(expanded)
      ? expanded
      : this.resolveRelativeSqlitePath(expanded);
    if (!candidate) return void 0;
    return vscode2.Uri.file(candidate);
  }
  resolveRelativeSqlitePath(relPath) {
    const workspaceFolder = vscode2.workspace.workspaceFolders?.[0]?.uri.fsPath;
    if (workspaceFolder) {
      return path2.join(workspaceFolder, relPath);
    }
    return path2.join(this.context.globalStorageUri.fsPath, relPath);
  }
  async getPrimaryRepository() {
    const api = await this.ensureGitApi();
    if (!api) return void 0;
    const repo = api.repositories?.[0];
    return repo;
  }
  async captureGitSnapshot(repo, repoPath, reason) {
    try {
      const head2 = repo?.state?.HEAD;
      const workingTree = Array.isArray(repo?.state?.workingTreeChanges)
        ? repo.state.workingTreeChanges
            .map((change) => asRelativePath(change.resourceUri || change.uri))
            .filter(Boolean)
        : [];
      const staged = Array.isArray(repo?.state?.indexChanges)
        ? repo.state.indexChanges
            .map((change) => asRelativePath(change.resourceUri || change.uri))
            .filter(Boolean)
        : [];
      const merge2 = Array.isArray(repo?.state?.mergeChanges)
        ? repo.state.mergeChanges
            .map((change) => asRelativePath(change.resourceUri || change.uri))
            .filter(Boolean)
        : [];
      const statusShort = await runGitCommand(repoPath, ['status', '--short']);
      const diffStat = await runGitCommand(repoPath, ['diff', '--stat']);
      const diffStatStaged = await runGitCommand(repoPath, ['diff', '--stat', '--cached']);
      return {
        branch: head2?.name,
        commit: head2?.commit,
        upstream: head2?.upstream?.name,
        ahead: head2?.ahead,
        behind: head2?.behind,
        workingTree,
        staged,
        merge: merge2,
        statusShort,
        diffStat,
        diffStatStaged,
      };
    } catch (error) {
      console.warn('[sessionTelemetry] captureGitSnapshot failed', { reason, error });
      return {};
    }
  }
};

// src/logging.ts
var LOG_BUFFER_MAX = 5e3;
var outputChannel;
var logBuffer = [];
function setOutputChannel(channel) {
  outputChannel = channel;
}
function getOutputChannel() {
  return outputChannel;
}
function logLine(text2) {
  try {
    outputChannel?.appendLine(text2);
  } catch {}
  try {
    logBuffer.push(text2);
    if (logBuffer.length > LOG_BUFFER_MAX) {
      logBuffer.splice(0, logBuffer.length - LOG_BUFFER_MAX);
    }
  } catch {}
}
function formatLogMeta(meta) {
  if (meta === void 0 || meta === null) return void 0;
  if (typeof meta === 'string') return meta;
  try {
    return JSON.stringify(meta);
  } catch {
    return '[unserializable meta]';
  }
}
function createScopedLogger(scope, shouldLogDebug2 = () => false) {
  const write = (level, message, meta) => {
    const metaText = formatLogMeta(meta);
    const suffix = metaText ? ` ${metaText}` : '';
    const line = `${/* @__PURE__ */ new Date().toISOString()} [${scope}] ${level} ${message}${suffix}`;
    logLine(line);
  };
  return {
    debug: (message, meta) => {
      if (!shouldLogDebug2()) return;
      write('DEBUG', message, meta);
    },
    info: (message, meta) => {
      if (!shouldLogDebug2()) return;
      write('INFO', message, meta);
    },
    warn: (message, meta) => {
      write('WARN', message, meta);
    },
    error: (message, meta) => {
      write('ERROR', message, meta);
    },
  };
}
function getLogBufferSnapshot() {
  return [...logBuffer];
}
function bridgeConsoleToOutputChannel() {
  const originalConsoleLog = console.log;
  const originalConsoleError = console.error;
  const originalConsoleWarn = console.warn;
  console.log = function (...args) {
    try {
      const message = args
        .map((arg) => {
          if (typeof arg === 'string') return arg;
          try {
            return JSON.stringify(arg);
          } catch {
            return String(arg);
          }
        })
        .join(' ');
      logLine(`[console.log] ${message}`);
    } catch {}
    return originalConsoleLog.apply(console, args);
  };
  console.error = function (...args) {
    try {
      const message = args
        .map((arg) => {
          if (typeof arg === 'string') return arg;
          if (arg instanceof Error)
            return `${arg.message}
${arg.stack}`;
          try {
            return JSON.stringify(arg);
          } catch {
            return String(arg);
          }
        })
        .join(' ');
      logLine(`[console.error] ${message}`);
    } catch {}
    return originalConsoleError.apply(console, args);
  };
  console.warn = function (...args) {
    try {
      const message = args
        .map((arg) => {
          if (typeof arg === 'string') return arg;
          try {
            return JSON.stringify(arg);
          } catch {
            return String(arg);
          }
        })
        .join(' ');
      logLine(`[console.warn] ${message}`);
    } catch {}
    return originalConsoleWarn.apply(console, args);
  };
}

// src/webviewMessaging.ts
function postToWebview({ panel: panel2, message, logger: logger4 }) {
  console.log('\u{1F50D} [POST_TO_WEBVIEW] DEPRECATED - Use direct store updates instead');
  console.log('\u{1F50D} [POST_TO_WEBVIEW] Called with:', {
    hasPanel: !!panel2,
    messageType: message?.type,
    messageSize: JSON.stringify(message).length,
  });
  if (!panel2) {
    console.log('\u{1F50D} [POST_TO_WEBVIEW] No panel available!');
    return;
  }
  try {
    logger4?.('[postToWebview] DEPRECATED - posting message', {
      type: message?.type,
      hasPanel: !!panel2,
    });
    console.log(
      '\u{1F50D} [POST_TO_WEBVIEW] DEPRECATED - Posting message to webview:',
      message?.type
    );
    panel2.webview.postMessage(message);
    console.log('\u{1F50D} [POST_TO_WEBVIEW] DEPRECATED - Message posted successfully!');
  } catch (err) {
    console.error('\u{1F50D} [POST_TO_WEBVIEW] Failed to post message:', err);
    console.warn('[azureDevOpsInt] Failed to post message to webview', err);
  }
}
function getConnectionLabel(connection) {
  if (connection.label && connection.label.trim()) return connection.label.trim();
  if (connection.project && connection.project.trim()) return connection.project.trim();
  return `${connection.organization}/${connection.project}`;
}
function postConnectionsUpdate({
  panel: panel2,
  connections: connections3,
  activeConnectionId: activeConnectionId3,
  logger: logger4,
}) {
  console.log('\u{1F50D} [UPDATE_CONNECTIONS_STORE] Directly updating webview store with:', {
    hasPanel: !!panel2,
    connectionsCount: connections3.length,
    activeConnectionId: activeConnectionId3,
  });
  if (!panel2) {
    console.log('\u{1F50D} [UPDATE_CONNECTIONS_STORE] No panel available!');
    return;
  }
  const entries = connections3.map((connection) => ({
    id: connection.id,
    name: getConnectionLabel(connection),
    // Changed from 'label' to 'name' to match webview interface
    label: getConnectionLabel(connection),
    // Keep label for backward compatibility
    organization: connection.organization,
    project: connection.project,
    authMethod: connection.authMethod,
    url: '',
    // Add required url field
    personalAccessToken: '',
    // Add required PAT field (empty for display)
  }));
  console.log(
    '\u{1F50D} [UPDATE_CONNECTIONS_STORE] Connection entries prepared:',
    entries.map((e) => ({
      id: e.id,
      label: e.label,
      organization: e.organization,
      project: e.project,
    }))
  );
  logger4?.('[postConnectionsUpdate] Directly updating webview store', {
    connectionCount: entries.length,
    activeConnectionId: activeConnectionId3,
    connectionLabels: entries.map((c) => c.label),
  });
  try {
    panel2.webview.postMessage({
      type: 'connections-update',
      connections: entries,
      activeConnectionId: activeConnectionId3,
    });
    console.log(
      '\u{1F50D} [UPDATE_CONNECTIONS_STORE] Connections update message sent successfully!'
    );
  } catch (err) {
    console.error('\u{1F50D} [UPDATE_CONNECTIONS_STORE] Failed to update store:', err);
    logger4?.('[postConnectionsUpdate] Failed to update webview store', { error: err });
  }
}

// src/fsm/functions/tabViewModelFunctions.ts
function deriveTabViewModel(context, rawConnectionId) {
  const normalizedId =
    normalizeConnectionId(rawConnectionId) ?? normalizeConnectionId(context.activeConnectionId);
  const connection = selectConnection(context.connections, normalizedId);
  const connectionId = connection?.id ?? normalizedId ?? null;
  const connectionState = connectionId ? context.connectionStates.get(connectionId) : void 0;
  return {
    connectionId,
    label: deriveConnectionLabel(connection, connectionId),
    organization: connection?.organization,
    project: connection?.project,
    authMethod: connection?.authMethod,
    isActive: Boolean(connectionId && context.activeConnectionId === connectionId),
    rawWorkItems: deriveRawWorkItems(context, connectionId),
    workItems: deriveWorkItems(context, connectionId),
    timer: deriveTimerViewModel(context),
    status: deriveStatus(context, connectionId, connectionState),
    authReminder: deriveAuthReminder(context.pendingAuthReminders, connectionId),
  };
}
function deriveTimerViewModel(context) {
  const timerActor = context.timerActor;
  if (!timerActor?.getSnapshot) {
    return { isActive: false, isRunning: false, workItemId: null, elapsed: 0 };
  }
  try {
    const snapshot2 = timerActor.getSnapshot();
    const snapshotContext = snapshot2?.context ?? {};
    const isRunning =
      typeof snapshot2?.matches === 'function'
        ? snapshot2.matches('running')
        : snapshot2?.value === 'running';
    return {
      isActive: Boolean(snapshot2),
      isRunning: Boolean(isRunning),
      workItemId: readNumeric(snapshotContext.workItemId),
      elapsed: readElapsed(snapshotContext.elapsed),
    };
  } catch {
    return { isActive: false, isRunning: false, workItemId: null, elapsed: 0 };
  }
}
function normalizeWorkItems(items) {
  return items
    .map((item) => normalizeWorkItem(item))
    .filter((item) => item !== null && item.id !== null);
}
function deriveWorkItems(context, connectionId) {
  return normalizeWorkItems(deriveRawWorkItems(context, connectionId));
}
function deriveRawWorkItems(context, connectionId) {
  if (!connectionId) {
    return [];
  }
  const pending2 = context.pendingWorkItems;
  if (!pending2 || !Array.isArray(pending2.workItems)) {
    return [];
  }
  const targetMatches =
    typeof pending2.connectionId === 'string' ? pending2.connectionId === connectionId : true;
  if (!targetMatches) {
    return [];
  }
  return pending2.workItems;
}
function deriveStatus(context, connectionId, connectionState) {
  if (!connectionId) {
    return { isLoading: false, lastError: null };
  }
  const pending2 = context.pendingWorkItems;
  const pendingMatches =
    pending2 && (!pending2.connectionId || pending2.connectionId === connectionId);
  const waitingForData = Boolean(
    pendingMatches && (!Array.isArray(pending2?.workItems) || pending2.workItems.length === 0)
  );
  const connectionReady = Boolean(connectionState?.client && connectionState?.provider);
  const lastError2 = context.lastError?.message ?? null;
  return {
    isLoading: !connectionReady || waitingForData,
    lastError: lastError2,
  };
}
function deriveAuthReminder(reminders, connectionId) {
  if (!connectionId || !reminders?.size) {
    return null;
  }
  const reminder = reminders.get(connectionId);
  if (!reminder) {
    return null;
  }
  return {
    reason: reminder.reason,
    detail: reminder.detail,
  };
}
function normalizeConnectionId(connectionId) {
  if (typeof connectionId !== 'string') {
    return null;
  }
  const trimmed = connectionId.trim();
  return trimmed.length > 0 ? trimmed : null;
}
function selectConnection(connections3, connectionId) {
  if (!connectionId || !Array.isArray(connections3)) {
    return void 0;
  }
  return connections3.find((connection) => connection.id === connectionId);
}
function deriveConnectionLabel(connection, connectionId) {
  if (connection?.project) {
    return connection.project;
  }
  if (connection?.id) {
    return connection.id;
  }
  return connectionId ?? 'unknown-connection';
}
function normalizeWorkItem(item) {
  if (!item || typeof item !== 'object') {
    return null;
  }
  const record = item;
  const id = readNumeric(record.id ?? record['System.Id']);
  if (id === null) {
    return null;
  }
  const fields = readRecord(record.fields);
  const title = readString(record.title ?? fields?.['System.Title']) ?? String(id);
  const type = readString(record.type ?? fields?.['System.WorkItemType']);
  const state2 = readString(record.state ?? fields?.['System.State']);
  const assignedTo = readAssignedTo(record.assignedTo, fields?.['System.AssignedTo']);
  return { id, title, type, state: state2, assignedTo };
}
function readNumeric(value) {
  if (typeof value === 'number' && Number.isFinite(value)) {
    return value;
  }
  if (typeof value === 'string') {
    const parsed = Number.parseInt(value, 10);
    return Number.isFinite(parsed) ? parsed : null;
  }
  return null;
}
function readElapsed(value) {
  const numeric = readNumeric(value);
  return numeric !== null ? numeric : 0;
}
function readString(value) {
  if (typeof value === 'string') {
    const trimmed = value.trim();
    return trimmed.length > 0 ? trimmed : void 0;
  }
  return void 0;
}
function readRecord(value) {
  return value && typeof value === 'object' ? value : void 0;
}
function readAssignedTo(fieldValue, fieldRecord) {
  if (typeof fieldValue === 'string') {
    return fieldValue;
  }
  if (fieldRecord && typeof fieldRecord === 'object') {
    const record = fieldRecord;
    const candidate = record.displayName ?? record.uniqueName;
    return readString(candidate);
  }
  return void 0;
}

// src/bridge/sharedContextBridge.ts
function createSharedContextBridge({ actor, logger: logger4, contextSelector }) {
  const applicationActor = actor;
  let currentWebview;
  let disposed = false;
  let lastSignature = '';
  const subscription = applicationActor.subscribe((state2) =>
    maybePostContext(state2, 'state-change')
  );
  function log2(message, meta) {
    try {
      logger4?.(message, meta);
    } catch (error) {
      console.warn('[SharedContextBridge] Logger failed', { message, meta, error });
    }
  }
  function buildPayload(context) {
    if (contextSelector) {
      return contextSelector(context);
    }
    const safeConnections = (context.connections || []).map((connection) => ({
      id: connection.id,
      label: connection.project || connection.id,
      organization: connection.organization,
      project: connection.project,
      authMethod: connection.authMethod,
      lastUsed: connectionStatesSafeTimestamp(context, connection.id),
    }));
    const normalizedWorkItems = normalizeWorkItems(
      Array.isArray(context.pendingWorkItems?.workItems) ? context.pendingWorkItems.workItems : []
    );
    const workItems = normalizedWorkItems.map(({ id, title, type, state: state2, assignedTo }) => ({
      id,
      title,
      type,
      state: state2,
      assignedTo,
    }));
    const timerSnapshot = deriveTimerViewModel(context);
    const tabView = deriveTabViewModel(context, context.activeConnectionId ?? null);
    const authReminders = Array.isArray(context.pendingAuthReminders)
      ? context.pendingAuthReminders
          .filter(
            (reminder) =>
              reminder?.status !== 'dismissed' &&
              typeof reminder?.connectionId === 'string' &&
              reminder.connectionId.trim().length > 0
          )
          .map((reminder) => ({
            connectionId: reminder.connectionId,
            reason: reminder?.reason ?? 'authFailed',
            detail: reminder?.detail,
          }))
      : context.pendingAuthReminders instanceof Map
        ? Array.from(context.pendingAuthReminders.entries())
            .filter(([, reminder]) => reminder?.status !== 'dismissed')
            .map(([connectionId, reminder]) => ({
              connectionId,
              reason: reminder?.reason ?? 'authFailed',
              detail: reminder?.detail,
            }))
        : [];
    const lastError2 = context.lastError
      ? {
          message: context.lastError.message,
          name: context.lastError.name,
        }
      : null;
    const isLoading = Boolean(
      context.pendingWorkItems?.workItems?.length && !context.pendingWorkItems?.connectionId
    );
    return {
      activeConnectionId: context.activeConnectionId ?? null,
      connections: safeConnections,
      workItems,
      timer: timerSnapshot,
      isLoading,
      authReminders,
      lastError: lastError2,
      tab: tabView,
    };
  }
  function connectionStatesSafeTimestamp(context, connectionId) {
    try {
      const rawState = context.connectionStates?.get(connectionId);
      if (!rawState) {
        return void 0;
      }
      const inferred = rawState.lastUsed;
      return typeof inferred === 'string' ? inferred : void 0;
    } catch (error) {
      log2('connectionStateTimestampExtractionFailed', {
        connectionId,
        error: serializeError(error),
      });
      return void 0;
    }
  }
  function maybePostContext(state2, reason) {
    if (!currentWebview || !state2) {
      return;
    }
    try {
      const payload = buildPayload(state2.context);
      const signature = JSON.stringify(payload);
      if (signature === lastSignature) {
        return;
      }
      lastSignature = signature;
      const message = {
        type: 'contextUpdate',
        context: payload,
        meta: {
          reason,
          state: state2.value,
        },
      };
      const maybeThenable = currentWebview.postMessage(message);
      if (typeof maybeThenable?.then === 'function') {
        maybeThenable.then(void 0, (error) => {
          log2('postMessageFailed', { error: serializeError(error) });
        });
      }
    } catch (error) {
      log2('contextSerializationFailed', { error: serializeError(error) });
    }
  }
  function synchronizeImmediately(reason) {
    const snapshot2 = applicationActor.getSnapshot?.();
    if (!snapshot2) {
      log2('snapshotUnavailable', { reason });
      return;
    }
    maybePostContext(snapshot2, reason);
  }
  function handleWebviewMessage(message) {
    if (!message || typeof message !== 'object') {
      return false;
    }
    const msg = message;
    if (msg.type === 'getContext') {
      synchronizeImmediately('explicit-request');
      return true;
    }
    return false;
  }
  return {
    attachWebview(webview) {
      currentWebview = webview;
      synchronizeImmediately('webview-attached');
    },
    detachWebview() {
      currentWebview = void 0;
    },
    handleWebviewMessage,
    sync() {
      synchronizeImmediately('manual-sync');
    },
    dispose() {
      if (disposed) {
        return;
      }
      disposed = true;
      try {
        subscription.unsubscribe();
      } catch (error) {
        log2('subscriptionDisposalFailed', { error: serializeError(error) });
      }
      currentWebview = void 0;
    },
  };
}
function serializeError(error) {
  if (error instanceof Error) {
    return {
      message: error.message,
      name: error.name,
      stack: error.stack,
    };
  }
  if (typeof error === 'object' && error) {
    return { ...error };
  }
  return { value: String(error) };
}

// src/activation.ts
init_cache();
init_performance();

// src/fsm/services/fsmSetupService.ts
init_xstate_esm();
import * as vscode3 from 'vscode';

// src/fsm/machines/setupMachine.ts
init_xstate_esm();
import { randomUUID as randomUUID2 } from 'crypto';
var parseWorkItemUrl = fromPromise(async ({ input }) => {
  const { url: url2 } = input;
  const devAzureMatch = url2.match(/https:\/\/dev\.azure\.com\/([^\/]+)\/([^\/]+)\/_workitems/);
  if (devAzureMatch) {
    return {
      organization: devAzureMatch[1],
      project: devAzureMatch[2],
      baseUrl: `https://dev.azure.com/${devAzureMatch[1]}`,
      apiBaseUrl: `https://dev.azure.com/${devAzureMatch[1]}`,
    };
  }
  const onPremMatch = url2.match(/https?:\/\/([^\/]+)\/([^\/]+)\/([^\/]+)\/_workitems/);
  if (onPremMatch) {
    const server = onPremMatch[1];
    const collection = onPremMatch[2];
    const project = onPremMatch[3];
    return {
      organization: collection,
      project,
      baseUrl: `https://${server}/${collection}`,
      apiBaseUrl: `https://${server}/${collection}`,
    };
  }
  throw new Error('Invalid work item URL format');
});
var testConnection = fromPromise(async ({ input }) => {
  const { organization, project, baseUrl, authMethod, patKey } = input;
  if (!organization || !project || !baseUrl) {
    throw new Error('Missing connection details');
  }
  if (authMethod === 'pat') {
    if (!patKey) {
      throw new Error('PAT token is required');
    }
    const testUrl = `${baseUrl}/_apis/projects/${project}?api-version=6.0`;
    const response = await fetch(testUrl, {
      headers: {
        Authorization: `Basic ${Buffer.from(`:${patKey}`).toString('base64')}`,
        Accept: 'application/json',
      },
    });
    if (!response.ok) {
      throw new Error(`Connection test failed: ${response.status} ${response.statusText}`);
    }
    return { success: true };
  } else if (authMethod === 'entra') {
    const { tenantId } = input;
    if (!tenantId) {
      throw new Error('Tenant ID is required for Entra ID authentication');
    }
    return { success: true };
  }
  throw new Error('Invalid authentication method');
});
var saveConnection = fromPromise(async ({ input }) => {
  const { context: setupContext, extensionContext } = input;
  const { organization, project, baseUrl, apiBaseUrl, authMethod, patKey, tenantId, identityName } =
    setupContext;
  if (!organization || !project || !baseUrl || !authMethod) {
    throw new Error('Missing required connection details');
  }
  const connectionId = randomUUID2();
  const connection = {
    id: connectionId,
    organization,
    project,
    baseUrl,
    apiBaseUrl: apiBaseUrl || baseUrl,
    authMethod,
    label: `${organization}/${project}`,
  };
  if (authMethod === 'entra') {
    if (tenantId && tenantId !== 'organizations') {
      connection.tenantId = tenantId;
    }
    if (identityName) {
      connection.identityName = identityName;
    }
  }
  const existingConnections = extensionContext.globalState.get('azureDevOpsInt.connections', []);
  const duplicate = existingConnections.find(
    (c) => c.organization === organization && c.project === project && c.baseUrl === baseUrl
  );
  if (duplicate) {
    throw new Error(`Connection to ${organization}/${project} already exists`);
  }
  const updatedConnections = [...existingConnections, connection];
  await extensionContext.globalState.update('azureDevOpsInt.connections', updatedConnections);
  if (authMethod === 'pat' && patKey) {
    await extensionContext.secrets.store(`azureDevOpsInt.pat.${connectionId}`, patKey);
  }
  return { connectionId };
});
var removeConnection = fromPromise(async ({ input }) => {
  const { connectionId, extensionContext } = input;
  const existingConnections = extensionContext.globalState.get('azureDevOpsInt.connections', []);
  const connectionToRemove = existingConnections.find((c) => c.id === connectionId);
  if (!connectionToRemove) {
    throw new Error('Connection not found');
  }
  const updatedConnections = existingConnections.filter((c) => c.id !== connectionId);
  await extensionContext.globalState.update('azureDevOpsInt.connections', updatedConnections);
  if (connectionToRemove.authMethod === 'pat') {
    try {
      await extensionContext.secrets.delete(`azureDevOpsInt.pat.${connectionId}`);
    } catch (error) {
      console.warn('Failed to delete PAT secret:', error);
    }
  }
  return { removedConnectionId: connectionId };
});
var setupMachine = createMachine({
  id: 'setup',
  initial: 'idle',
  types: {
    context: {},
    events: {},
  },
  context: {
    currentStep: 'url',
    existingConnections: [],
  },
  states: {
    idle: {
      on: {
        START: {
          target: 'checkingMode',
          actions: assign({
            skipInitialChoice: ({ event: event2 }) => event2.skipInitialChoice,
          }),
        },
      },
    },
    checkingMode: {
      always: [
        {
          guard: ({ context }) => context.skipInitialChoice === true,
          target: 'managingExisting',
        },
        {
          target: 'collectingUrl',
        },
      ],
    },
    collectingUrl: {
      entry: assign({
        currentStep: 'url',
      }),
      on: {
        URL_PROVIDED: {
          target: 'parsingUrl',
          actions: assign({
            workItemUrl: ({ event: event2 }) => event2.url,
          }),
        },
        MANAGE_EXISTING: {
          target: 'managingExisting',
        },
        CANCEL: {
          target: 'cancelled',
        },
      },
    },
    parsingUrl: {
      invoke: {
        src: parseWorkItemUrl,
        input: ({ context }) => ({ url: context.workItemUrl }),
        onDone: {
          target: 'selectingAuth',
          actions: assign({
            organization: ({ event: event2 }) => event2.output.organization,
            project: ({ event: event2 }) => event2.output.project,
            baseUrl: ({ event: event2 }) => event2.output.baseUrl,
            apiBaseUrl: ({ event: event2 }) => event2.output.apiBaseUrl,
          }),
        },
        onError: {
          target: 'urlError',
          actions: assign({
            error: ({ event: event2 }) =>
              (event2.error instanceof Error ? event2.error.message : String(event2.error)) ||
              'Failed to parse URL',
          }),
        },
      },
    },
    urlError: {
      on: {
        RETRY: {
          target: 'collectingUrl',
          actions: assign({
            error: void 0,
          }),
        },
        CANCEL: {
          target: 'cancelled',
        },
      },
    },
    selectingAuth: {
      entry: assign({
        currentStep: 'auth',
      }),
      on: {
        AUTH_METHOD_SELECTED: {
          target: 'collectingCredentials',
          actions: assign({
            authMethod: ({ event: event2 }) => event2.method,
          }),
        },
        BACK: {
          target: 'collectingUrl',
        },
        CANCEL: {
          target: 'cancelled',
        },
      },
    },
    collectingCredentials: {
      entry: assign({
        currentStep: 'credentials',
      }),
      on: {
        PAT_PROVIDED: {
          target: 'testingConnection',
          actions: assign({
            patKey: ({ event: event2 }) => event2.token,
          }),
        },
        ENTRA_CONFIG: {
          target: 'testingConnection',
          actions: assign({
            tenantId: ({ event: event2 }) => event2.tenantId,
            // Client ID is now hardcoded in connection machine
          }),
        },
        BACK: {
          target: 'selectingAuth',
        },
        CANCEL: {
          target: 'cancelled',
        },
      },
    },
    testingConnection: {
      entry: assign({
        currentStep: 'test',
      }),
      invoke: {
        src: testConnection,
        input: ({ context }) => context,
        onDone: {
          target: 'savingConnection',
        },
        onError: {
          target: 'connectionError',
          actions: assign({
            error: ({ event: event2 }) =>
              (event2.error instanceof Error ? event2.error.message : String(event2.error)) ||
              'Connection test failed',
          }),
        },
      },
    },
    connectionError: {
      on: {
        RETRY: {
          target: 'testingConnection',
          actions: assign({
            error: void 0,
          }),
        },
        BACK: {
          target: 'collectingCredentials',
        },
        CANCEL: {
          target: 'cancelled',
        },
      },
    },
    savingConnection: {
      invoke: {
        src: saveConnection,
        input: ({ context }) => ({ context, extensionContext: context.extensionContext }),
        onDone: {
          target: 'completed',
          actions: assign({
            connectionId: ({ event: event2 }) => event2.output.connectionId,
            currentStep: 'complete',
          }),
        },
        onError: {
          target: 'saveError',
          actions: assign({
            error: ({ event: event2 }) =>
              (event2.error instanceof Error ? event2.error.message : String(event2.error)) ||
              'Failed to save connection',
          }),
        },
      },
    },
    saveError: {
      on: {
        RETRY: {
          target: 'savingConnection',
          actions: assign({
            error: void 0,
          }),
        },
        CANCEL: {
          target: 'cancelled',
        },
      },
    },
    managingExisting: {
      on: {
        REMOVE_CONNECTION: {
          target: 'removingConnection',
          actions: assign({
            removedConnectionId: ({ event: event2 }) => event2.connectionId,
          }),
        },
        CANCEL: {
          target: 'cancelled',
        },
      },
    },
    removingConnection: {
      invoke: {
        src: removeConnection,
        input: ({ context }) => ({
          connectionId: context.removedConnectionId,
          extensionContext: context.extensionContext,
        }),
        onDone: {
          target: 'removed',
        },
        onError: {
          target: 'removeError',
          actions: assign({
            error: ({ event: event2 }) =>
              (event2.error instanceof Error ? event2.error.message : String(event2.error)) ||
              'Failed to remove connection',
          }),
        },
      },
    },
    removeError: {
      on: {
        RETRY: {
          target: 'removingConnection',
          actions: assign({
            error: void 0,
          }),
        },
        CANCEL: {
          target: 'cancelled',
        },
      },
    },
    completed: {
      type: 'final',
    },
    removed: {
      type: 'final',
    },
    cancelled: {
      type: 'final',
    },
  },
});

// src/fsm/services/fsmSetupService.ts
var FSMSetupService = class _FSMSetupService {
  context;
  constructor(context) {
    this.context = context;
  }
  async startSetup(options) {
    const actor = createActor(setupMachine, {
      input: {
        extensionContext: this.context,
        existingConnections: this.context.globalState.get('azureDevOpsInt.connections', []),
      },
    });
    actor.start();
    actor.send({ type: 'START', skipInitialChoice: options?.skipInitialChoice });
    return new Promise((resolve) => {
      actor.subscribe((state2) => {
        this.handleStateChange(state2, actor, resolve);
      });
    });
  }
  async handleStateChange(state2, actor, resolve) {
    const context = state2.context;
    switch (state2.value) {
      case 'collectingUrl':
        await this.showUrlInput(actor);
        break;
      case 'urlError':
        await this.showUrlError(context.error, actor);
        break;
      case 'selectingAuth':
        await this.showAuthMethodSelection(actor);
        break;
      case 'collectingCredentials':
        await this.showCredentialsInput(context, actor);
        break;
      case 'connectionError':
        await this.showConnectionError(context.error, actor);
        break;
      case 'saveError':
        await this.showSaveError(context.error, actor);
        break;
      case 'managingExisting':
        await this.showExistingConnections(context, actor);
        break;
      case 'removeError':
        await this.showRemoveError(context.error, actor);
        break;
      case 'completed':
        resolve({
          status: 'success',
          connectionId: context.connectionId,
        });
        break;
      case 'removed':
        resolve({
          status: 'removed',
          removedConnectionId: context.removedConnectionId,
        });
        break;
      case 'cancelled':
        resolve({ status: 'cancelled' });
        break;
      case 'testingConnection':
        vscode3.window.showInformationMessage('Testing connection...');
        break;
      case 'savingConnection':
        vscode3.window.showInformationMessage('Saving connection...');
        break;
      case 'removingConnection':
        vscode3.window.showInformationMessage('Removing connection...');
        break;
    }
  }
  async showUrlInput(actor) {
    const url2 = await vscode3.window.showInputBox({
      prompt: 'Enter an Azure DevOps work item URL to auto-configure your connection',
      placeHolder: 'https://dev.azure.com/myorg/myproject/_workitems/edit/123',
      validateInput: (value) => {
        if (!value) return 'URL is required';
        if (!value.includes('_workitems')) return 'Please provide a work item URL';
        return null;
      },
    });
    if (url2) {
      actor.send({ type: 'URL_PROVIDED', url: url2 });
    } else {
      const manageExisting = await vscode3.window.showQuickPick(
        ['Cancel', 'Manage Existing Connections'],
        { placeHolder: 'What would you like to do?' }
      );
      if (manageExisting === 'Manage Existing Connections') {
        actor.send({ type: 'MANAGE_EXISTING' });
      } else {
        actor.send({ type: 'CANCEL' });
      }
    }
  }
  async showUrlError(error, actor) {
    const action2 = await vscode3.window.showErrorMessage(
      `Invalid URL: ${error}`,
      'Try Again',
      'Cancel'
    );
    if (action2 === 'Try Again') {
      actor.send({ type: 'RETRY' });
    } else {
      actor.send({ type: 'CANCEL' });
    }
  }
  async showAuthMethodSelection(actor) {
    const authMethod = await vscode3.window.showQuickPick(
      [
        {
          label: 'Personal Access Token (PAT)',
          description: 'Use a Personal Access Token for authentication',
          detail: 'Recommended for most users. Generate a PAT from Azure DevOps settings.',
          value: 'pat',
        },
        {
          label: 'Microsoft Entra ID (OAuth)',
          description: 'Use your Microsoft account to sign in',
          detail: 'Enterprise authentication using your organizational account.',
          value: 'entra',
        },
      ],
      {
        placeHolder: 'Choose authentication method',
        matchOnDescription: true,
        matchOnDetail: true,
      }
    );
    if (authMethod) {
      actor.send({ type: 'AUTH_METHOD_SELECTED', method: authMethod.value });
    } else {
      actor.send({ type: 'CANCEL' });
    }
  }
  async showCredentialsInput(context, actor) {
    if (context.authMethod === 'pat') {
      await this.showPATInput(actor);
    } else if (context.authMethod === 'entra') {
      await this.showEntraConfig(actor);
    }
  }
  async showPATInput(actor) {
    const token = await vscode3.window.showInputBox({
      prompt: 'Enter your Personal Access Token',
      password: true,
      placeHolder: 'Your PAT from Azure DevOps',
      validateInput: (value) => {
        if (!value) return 'PAT is required';
        if (value.length < 20) return 'PAT seems too short';
        return null;
      },
    });
    if (token) {
      actor.send({ type: 'PAT_PROVIDED', token });
    } else {
      actor.send({ type: 'CANCEL' });
    }
  }
  async showEntraConfig(actor) {
    const tenantId = await vscode3.window.showInputBox({
      prompt: 'Enter your Tenant ID (Directory ID)',
      placeHolder: 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx',
      validateInput: (value) => {
        if (!value) return 'Tenant ID is required';
        if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {
          return 'Invalid Tenant ID format';
        }
        return null;
      },
    });
    if (!tenantId) {
      actor.send({ type: 'CANCEL' });
      return;
    }
    const clientId = await vscode3.window.showInputBox({
      prompt: 'Enter your Application (Client) ID',
      placeHolder: 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx',
      validateInput: (value) => {
        if (!value) return 'Client ID is required';
        if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {
          return 'Invalid Client ID format';
        }
        return null;
      },
    });
    if (clientId) {
      actor.send({ type: 'ENTRA_CONFIG', tenantId, clientId });
    } else {
      actor.send({ type: 'CANCEL' });
    }
  }
  async showConnectionError(error, actor) {
    const action2 = await vscode3.window.showErrorMessage(
      `Connection test failed: ${error}`,
      'Try Again',
      'Go Back',
      'Cancel'
    );
    switch (action2) {
      case 'Try Again':
        actor.send({ type: 'RETRY' });
        break;
      case 'Go Back':
        actor.send({ type: 'BACK' });
        break;
      default:
        actor.send({ type: 'CANCEL' });
        break;
    }
  }
  async showSaveError(error, actor) {
    const action2 = await vscode3.window.showErrorMessage(
      `Failed to save connection: ${error}`,
      'Try Again',
      'Cancel'
    );
    if (action2 === 'Try Again') {
      actor.send({ type: 'RETRY' });
    } else {
      actor.send({ type: 'CANCEL' });
    }
  }
  async showExistingConnections(context, actor) {
    const connections3 = this.context.globalState.get('azureDevOpsInt.connections', []);
    if (connections3.length === 0) {
      vscode3.window.showInformationMessage('No existing connections found.');
      actor.send({ type: 'CANCEL' });
      return;
    }
    const items = connections3.map((conn) => ({
      label: conn.label || `${conn.organization}/${conn.project}`,
      description: conn.authMethod === 'pat' ? 'Personal Access Token' : 'Microsoft Entra ID',
      detail: conn.baseUrl,
      connection: conn,
    }));
    items.push({
      label: '$(add) Add New Connection',
      description: 'Create a new Azure DevOps connection',
      detail: 'Set up a new connection to Azure DevOps',
      connection: null,
    });
    const selected = await vscode3.window.showQuickPick(items, {
      placeHolder: 'Select a connection to manage or add a new one',
      matchOnDescription: true,
      matchOnDetail: true,
    });
    if (!selected) {
      actor.send({ type: 'CANCEL' });
      return;
    }
    if (!selected.connection) {
      actor.send({ type: 'CANCEL' });
      const newSetup = new _FSMSetupService(this.context);
      await newSetup.startSetup();
      return;
    }
    const action2 = await vscode3.window.showQuickPick(
      [
        { label: 'Remove Connection', value: 'remove', description: 'Delete this connection' },
        {
          label: 'Test Connection',
          value: 'test',
          description: 'Test if this connection is working',
        },
      ],
      {
        placeHolder: `Manage connection: ${selected.label}`,
      }
    );
    if (action2?.value === 'remove') {
      const confirm = await vscode3.window.showWarningMessage(
        `Are you sure you want to remove the connection "${selected.label}"?`,
        { modal: true },
        'Yes, Remove'
      );
      if (confirm === 'Yes, Remove') {
        actor.send({ type: 'REMOVE_CONNECTION', connectionId: selected.connection.id });
      } else {
        actor.send({ type: 'CANCEL' });
      }
    } else if (action2?.value === 'test') {
      vscode3.window.showInformationMessage('Connection test not yet implemented in FSM setup');
      actor.send({ type: 'CANCEL' });
    } else {
      actor.send({ type: 'CANCEL' });
    }
  }
  async showRemoveError(error, actor) {
    const action2 = await vscode3.window.showErrorMessage(
      `Failed to remove connection: ${error}`,
      'Try Again',
      'Cancel'
    );
    if (action2 === 'Try Again') {
      actor.send({ type: 'RETRY' });
    } else {
      actor.send({ type: 'CANCEL' });
    }
  }
};

// src/fsm/commands/traceCommands.ts
init_FSMTracer();
init_FSMLogger();
import * as vscode5 from 'vscode';
function registerTraceCommands(context) {
  context.subscriptions.push(
    vscode5.commands.registerCommand('azureDevOpsInt.showFSMTraceStatus', async () => {
      await showTraceStatus();
    })
  );
  context.subscriptions.push(
    vscode5.commands.registerCommand('azureDevOpsInt.exportFSMTrace', async () => {
      await exportTrace();
    })
  );
  context.subscriptions.push(
    vscode5.commands.registerCommand('azureDevOpsInt.importFSMTrace', async () => {
      await importTrace();
    })
  );
  context.subscriptions.push(
    vscode5.commands.registerCommand('azureDevOpsInt.analyzeFSMTrace', async () => {
      await analyzeTrace();
    })
  );
  context.subscriptions.push(
    vscode5.commands.registerCommand('azureDevOpsInt.startFSMTraceSession', async () => {
      await startTraceSession2();
    })
  );
  context.subscriptions.push(
    vscode5.commands.registerCommand('azureDevOpsInt.stopFSMTraceSession', async () => {
      await stopTraceSession2();
    })
  );
  context.subscriptions.push(
    vscode5.commands.registerCommand('azureDevOpsInt.showFSMTraceTimeline', async () => {
      await showTraceTimeline();
    })
  );
  fsmLogger.info('MACHINE' /* MACHINE */, 'FSM trace commands registered');
}
async function showTraceStatus() {
  try {
    const stats = fsmTracer.getStats();
    const currentSession = fsmTracer.getCurrentSession();
    const statusItems = [
      `\u{1F4CA} **FSM Trace Status**`,
      ``,
      `**Current Session:**`,
      currentSession ? `- ID: \`${currentSession.id}\`` : `- No active session`,
      currentSession ? `- Description: ${currentSession.description}` : ``,
      currentSession ? `- Started: ${new Date(currentSession.startTime).toLocaleString()}` : ``,
      currentSession ? `- Events: ${currentSession.entries.length}` : ``,
      ``,
      `**Statistics:**`,
      `- Total Sessions: ${stats.sessionsCount}`,
      `- Total Events: ${stats.totalEntries}`,
      `- Instrumented Actors: ${stats.instrumentedActors}`,
      ``,
      `**Actions:**`,
      `- Export current trace for analysis`,
      `- Import trace file for replay`,
      `- Analyze performance patterns`,
      `- Start/stop trace sessions`,
    ];
    const panel2 = vscode5.window.createWebviewPanel(
      'fsmTraceStatus',
      'FSM Trace Status',
      vscode5.ViewColumn.One,
      { enableScripts: false }
    );
    panel2.webview.html = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <style>
          body { 
            font-family: var(--vscode-font-family); 
            color: var(--vscode-foreground);
            background: var(--vscode-editor-background);
            padding: 20px;
            line-height: 1.6;
          }
          code { 
            background: var(--vscode-textCodeBlock-background);
            padding: 2px 4px;
            border-radius: 3px;
          }
          pre {
            background: var(--vscode-textCodeBlock-background);
            padding: 10px;
            border-radius: 3px;
            overflow-x: auto;
          }
        </style>
      </head>
      <body>
        ${statusItems
          .map((item) => {
            if (item.startsWith('- ')) {
              return `<p style="margin-left: 20px;">${item}</p>`;
            } else if (item.startsWith('**') && item.endsWith('**')) {
              return `<h3>${item.slice(2, -2)}</h3>`;
            } else if (item.includes('`')) {
              return `<p>${item.replace(/\`([^`]+)\`/g, '<code>$1</code>')}</p>`;
            } else {
              return item ? `<p>${item}</p>` : '<br>';
            }
          })
          .join('')}
      </body>
      </html>
    `;
  } catch (error) {
    vscode5.window.showErrorMessage(`Failed to show trace status: ${error}`);
    fsmLogger.error('MACHINE' /* MACHINE */, 'Failed to show trace status', void 0, { error });
  }
}
async function exportTrace() {
  try {
    const traceData = exportCurrentTrace();
    if (!traceData) {
      vscode5.window.showWarningMessage('No active trace session to export');
      return;
    }
    const uri = await vscode5.window.showSaveDialog({
      defaultUri: vscode5.Uri.file(`fsm-trace-${Date.now()}.json`),
      filters: {
        'FSM Trace Files': ['json'],
        'All Files': ['*'],
      },
    });
    if (uri) {
      await vscode5.workspace.fs.writeFile(uri, Buffer.from(traceData, 'utf8'));
      vscode5.window.showInformationMessage(`FSM trace exported to: ${uri.fsPath}`);
      const analyze = await vscode5.window.showInformationMessage(
        'Trace exported successfully. Would you like to analyze it now?',
        'Yes',
        'No'
      );
      if (analyze === 'Yes') {
        await analyzeTrace();
      }
    }
  } catch (error) {
    vscode5.window.showErrorMessage(`Failed to export trace: ${error}`);
    fsmLogger.error('MACHINE' /* MACHINE */, 'Failed to export trace', void 0, { error });
  }
}
async function importTrace() {
  try {
    const uris = await vscode5.window.showOpenDialog({
      canSelectFiles: true,
      canSelectMany: false,
      filters: {
        'FSM Trace Files': ['json'],
        'All Files': ['*'],
      },
    });
    if (uris && uris.length > 0) {
      const content = await vscode5.workspace.fs.readFile(uris[0]);
      const traceData = Buffer.from(content).toString('utf8');
      const sessionId = fsmTracer.importSession(traceData);
      vscode5.window.showInformationMessage(`FSM trace imported: ${sessionId}`);
      const analyze = await vscode5.window.showInformationMessage(
        'Trace imported successfully. Would you like to analyze it?',
        'Yes',
        'No'
      );
      if (analyze === 'Yes') {
        const analysis = fsmTracer.analyzeSession(sessionId);
        await showAnalysisResults(analysis, sessionId);
      }
    }
  } catch (error) {
    vscode5.window.showErrorMessage(`Failed to import trace: ${error}`);
    fsmLogger.error('MACHINE' /* MACHINE */, 'Failed to import trace', void 0, { error });
  }
}
async function analyzeTrace() {
  try {
    const analysis = analyzeCurrentTrace();
    if (!analysis) {
      vscode5.window.showWarningMessage('No active trace session to analyze');
      return;
    }
    const currentSession = fsmTracer.getCurrentSession();
    await showAnalysisResults(analysis, currentSession?.id || 'current');
  } catch (error) {
    vscode5.window.showErrorMessage(`Failed to analyze trace: ${error}`);
    fsmLogger.error('MACHINE' /* MACHINE */, 'Failed to analyze trace', void 0, { error });
  }
}
async function showAnalysisResults(analysis, sessionId) {
  const panel2 = vscode5.window.createWebviewPanel(
    'fsmTraceAnalysis',
    `FSM Trace Analysis - ${sessionId}`,
    vscode5.ViewColumn.One,
    { enableScripts: false }
  );
  const durationMs = analysis.summary.duration;
  const durationFormatted =
    durationMs > 6e4
      ? `${Math.round(durationMs / 6e4)} minutes`
      : `${Math.round(durationMs / 1e3)} seconds`;
  panel2.webview.html = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="UTF-8">
      <style>
        body { 
          font-family: var(--vscode-font-family); 
          color: var(--vscode-foreground);
          background: var(--vscode-editor-background);
          padding: 20px;
          line-height: 1.6;
        }
        .metric { 
          background: var(--vscode-textCodeBlock-background);
          padding: 10px;
          margin: 10px 0;
          border-radius: 5px;
          display: inline-block;
          min-width: 200px;
        }
        .metric-value { 
          font-size: 1.5em; 
          font-weight: bold; 
          color: var(--vscode-charts-blue);
        }
        .section {
          margin: 20px 0;
          padding: 10px;
          border-left: 3px solid var(--vscode-charts-blue);
          background: var(--vscode-editor-lineHighlightBackground);
        }
        .event-freq, .transitions {
          background: var(--vscode-textCodeBlock-background);
          padding: 10px;
          border-radius: 3px;
          margin: 10px 0;
        }
        .slow-transition {
          color: var(--vscode-charts-red);
          font-weight: bold;
        }
      </style>
    </head>
    <body>
      <h1>\u{1F50D} FSM Trace Analysis</h1>
      <p><strong>Session:</strong> <code>${sessionId}</code></p>
      
      <div class="section">
        <h2>\u{1F4CA} Summary</h2>
        <div class="metric">
          <div>Duration</div>
          <div class="metric-value">${durationFormatted}</div>
        </div>
        <div class="metric">
          <div>Total Events</div>
          <div class="metric-value">${analysis.summary.totalEvents}</div>
        </div>
        <div class="metric">
          <div>Unique States</div>
          <div class="metric-value">${analysis.summary.uniqueStates}</div>
        </div>
        <div class="metric">
          <div>Errors</div>
          <div class="metric-value" style="color: ${analysis.summary.errors > 0 ? 'var(--vscode-charts-red)' : 'var(--vscode-charts-green)'}">
            ${analysis.summary.errors}
          </div>
        </div>
      </div>

      <div class="section">
        <h2>\u{1F4C8} Event Frequency</h2>
        <div class="event-freq">
          ${Object.entries(analysis.eventFrequency)
            .sort(([, a], [, b]) => b - a)
            .map(([event2, count]) => `<div>${event2}: <strong>${count}</strong></div>`)
            .join('')}
        </div>
      </div>

      <div class="section">
        <h2>\u{1F504} State Transitions</h2>
        <div class="transitions">
          ${Object.entries(analysis.stateTransitions)
            .map(
              ([from, toStates]) =>
                `<div><strong>${from}</strong> \u2192 ${toStates.join(', ')}</div>`
            )
            .join('')}
        </div>
      </div>

      <div class="section">
        <h2>\u26A1 Performance</h2>
        <div class="metric">
          <div>Avg Transition Time</div>
          <div class="metric-value">${Math.round(analysis.performance.avgTransitionTime)}ms</div>
        </div>
        
        <h3>\u{1F40C} Slowest Transitions</h3>
        <div class="transitions">
          ${analysis.performance.slowestTransitions
            .slice(0, 5)
            .map(
              (t) =>
                `<div class="slow-transition">${t.from} \u2192 ${t.to} (${t.event}): ${t.duration}ms</div>`
            )
            .join('')}
        </div>
      </div>

      <div class="section">
        <h2>\u{1F4A1} Insights</h2>
        <ul>
          ${analysis.summary.errors > 0 ? `<li>\u26A0\uFE0F Found ${analysis.summary.errors} errors - investigate error patterns</li>` : ''}
          ${analysis.performance.avgTransitionTime > 100 ? `<li>\u{1F40C} Average transition time is high (${Math.round(analysis.performance.avgTransitionTime)}ms) - check for performance bottlenecks</li>` : ''}
          ${analysis.summary.uniqueStates > 20 ? `<li>\u{1F504} High number of unique states (${analysis.summary.uniqueStates}) - consider state machine simplification</li>` : ''}
          ${Object.keys(analysis.eventFrequency).length > 10 ? `<li>\u{1F4E2} Many event types (${Object.keys(analysis.eventFrequency).length}) - review event design</li>` : ''}
          <li>\u2705 Use this data to optimize FSM performance and reliability</li>
        </ul>
      </div>
    </body>
    </html>
  `;
}
async function startTraceSession2() {
  try {
    const description = await vscode5.window.showInputBox({
      prompt: 'Enter a description for the new trace session',
      value: 'Manual trace session',
    });
    if (description !== void 0) {
      const sessionId = fsmTracer.startNewSession(description);
      vscode5.window.showInformationMessage(`Started new FSM trace session: ${sessionId}`);
    }
  } catch (error) {
    vscode5.window.showErrorMessage(`Failed to start trace session: ${error}`);
    fsmLogger.error('MACHINE' /* MACHINE */, 'Failed to start trace session', void 0, { error });
  }
}
async function stopTraceSession2() {
  try {
    const currentSession = fsmTracer.getCurrentSession();
    if (!currentSession) {
      vscode5.window.showWarningMessage('No active trace session to stop');
      return;
    }
    fsmTracer.stopCurrentSession();
    const action2 = await vscode5.window.showInformationMessage(
      `Stopped trace session: ${currentSession.id}`,
      'Analyze',
      'Export',
      'Close'
    );
    if (action2 === 'Analyze') {
      await analyzeTrace();
    } else if (action2 === 'Export') {
      await exportTrace();
    }
  } catch (error) {
    vscode5.window.showErrorMessage(`Failed to stop trace session: ${error}`);
    fsmLogger.error('MACHINE' /* MACHINE */, 'Failed to stop trace session', void 0, { error });
  }
}
async function showTraceTimeline() {
  try {
    const currentSession = fsmTracer.getCurrentSession();
    if (!currentSession) {
      vscode5.window.showWarningMessage('No active trace session');
      return;
    }
    const panel2 = vscode5.window.createWebviewPanel(
      'fsmTraceTimeline',
      `FSM Trace Timeline - ${currentSession.id}`,
      vscode5.ViewColumn.One,
      { enableScripts: true }
    );
    const recentEntries = currentSession.entries.slice(-100);
    const timelineData = recentEntries.map((entry) => ({
      timestamp: new Date(entry.timestamp).toLocaleTimeString(),
      event: entry.eventType,
      fromState: entry.fromState,
      toState: entry.toState,
      component: entry.component,
      duration: entry.duration || 0,
      hasError: !!entry.error,
    }));
    panel2.webview.html = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <style>
          body { 
            font-family: var(--vscode-font-family); 
            color: var(--vscode-foreground);
            background: var(--vscode-editor-background);
            padding: 20px;
          }
          .timeline-item {
            padding: 10px;
            margin: 5px 0;
            border-left: 3px solid var(--vscode-charts-blue);
            background: var(--vscode-editor-lineHighlightBackground);
            border-radius: 3px;
          }
          .timeline-item.error {
            border-color: var(--vscode-charts-red);
            background: var(--vscode-inputValidation-errorBackground);
          }
          .timestamp {
            font-size: 0.9em;
            color: var(--vscode-descriptionForeground);
          }
          .event-type {
            font-weight: bold;
            color: var(--vscode-charts-blue);
          }
          .state-transition {
            font-family: monospace;
            background: var(--vscode-textCodeBlock-background);
            padding: 2px 4px;
            border-radius: 3px;
          }
        </style>
      </head>
      <body>
        <h1>\u23F1\uFE0F FSM Trace Timeline</h1>
        <p><strong>Session:</strong> <code>${currentSession.id}</code></p>
        <p><strong>Showing:</strong> Last ${recentEntries.length} events</p>
        <hr>
        
        ${timelineData
          .map(
            (item) => `
          <div class="timeline-item ${item.hasError ? 'error' : ''}">
            <div class="timestamp">${item.timestamp}</div>
            <div>
              <span class="event-type">${item.event}</span>
              <span style="margin-left: 10px; color: var(--vscode-descriptionForeground);">[${item.component}]</span>
            </div>
            <div class="state-transition">${item.fromState} \u2192 ${item.toState}</div>
          </div>
        `
          )
          .join('')}
      </body>
      </html>
    `;
  } catch (error) {
    vscode5.window.showErrorMessage(`Failed to show trace timeline: ${error}`);
    fsmLogger.error('MACHINE' /* MACHINE */, 'Failed to show trace timeline', void 0, { error });
  }
}

// src/activation.ts
init_extensionHostBridge();
function getApplicationActor() {
  return getApplicationStoreActor();
}
function dispatchApplicationEvent(event2) {
  sendApplicationStoreEvent(event2);
}
var STATE_TIMER = 'azureDevOpsInt.timer.state';
var STATE_TIME_ENTRIES = 'azureDevOpsInt.timer.entries';
var STATE_LAST_SAVE = 'azureDevOpsInt.timer.lastSave';
var STATE_TIMER_CONNECTION = 'azureDevOpsInt.timer.connection';
var CONFIG_NS = 'azureDevOpsIntegration';
var LEGACY_CONFIG_NS = 'azureDevOps';
var CONNECTIONS_CONFIG_KEY = 'connections';
var ACTIVE_CONNECTION_STATE_KEY = 'azureDevOpsInt.activeConnectionId';
var panel;
var provider;
var timer;
var sessionTelemetry;
var client;
var statusBarItem;
var authStatusBarItem;
var PAT_KEY = 'azureDevOpsInt.pat';
var OPENAI_SECRET_KEY = 'azureDevOpsInt.openai.apiKey';
var viewProviderRegistered = false;
var initialRefreshedConnections = /* @__PURE__ */ new Set();
var connections2 = [];
var connectionStates2 = /* @__PURE__ */ new Map();
var activeConnectionId2;
var tokenRefreshInterval;
var gcInterval;
var isDeactivating2 = false;
var rejectionHandler;
var sharedContextBridge;
function safeCommandHandler(handler) {
  return (...args) => {
    if (isDeactivating2) {
      console.log('[Command] Ignoring command execution during deactivation');
      return;
    }
    try {
      const result = handler(...args);
      if (result && typeof result.catch === 'function') {
        result.catch((error) => {
          if (!isDeactivating2) {
            console.error('[Command] Unhandled command error:', error);
          }
        });
      }
    } catch (error) {
      if (!isDeactivating2) {
        console.error('[Command] Synchronous command error:', error);
      }
    }
  };
}
async function ensureSharedContextBridge(context) {
  if (!sharedContextBridge) {
    if (!getApplicationStoreActor()) {
      await Promise.resolve().then(() => (init_applicationStore(), applicationStore_exports));
    }
    const actor = getApplicationStoreActor();
    if (!actor) {
      throw new Error('Application store actor not available');
    }
    sharedContextBridge = createSharedContextBridge({
      actor,
      logger: (message, meta) => {
        verbose(`[context-bridge] ${message}`, meta);
      },
    });
    context.subscriptions.push(sharedContextBridge);
    context.subscriptions.push(
      new vscode8.Disposable(() => {
        sharedContextBridge = void 0;
      })
    );
  }
  return sharedContextBridge;
}
var timerConnectionInfo = {};
var DEFAULT_QUERY2 = 'My Activity';
var activeQueryByConnection = /* @__PURE__ */ new Map();
var branchStateByConnection = /* @__PURE__ */ new Map();
var repositoryCacheByConnection = /* @__PURE__ */ new Map();
var buildCacheByKey = /* @__PURE__ */ new Map();
var buildRefreshTimers = /* @__PURE__ */ new Map();
var cachedGitApi;
var BRANCH_REFRESH_INTERVAL_MS = 30 * 1e3;
var REPOSITORY_CACHE_TTL_MS = 5 * 60 * 1e3;
var BUILD_CACHE_TTL_MS = 20 * 1e3;
function clearConnectionCaches(connectionId) {
  branchStateByConnection.delete(connectionId);
  repositoryCacheByConnection.delete(connectionId);
  for (const key2 of Array.from(buildCacheByKey.keys())) {
    if (key2.startsWith(`${connectionId}|`)) {
      buildCacheByKey.delete(key2);
    }
  }
  const timer2 = buildRefreshTimers.get(connectionId);
  if (timer2) {
    try {
      clearTimeout(timer2);
    } catch {}
    buildRefreshTimers.delete(connectionId);
  }
}
var AUTH_REMINDER_SNOOZE_MS = 30 * 60 * 1e3;
var nextAuthConnectionIndex = 0;
function getPendingAuthReminderMap() {
  const actor = getApplicationActor();
  if (!actor || typeof actor.getSnapshot !== 'function') {
    return /* @__PURE__ */ new Map();
  }
  try {
    const snapshot2 = actor.getSnapshot();
    const raw = snapshot2?.context?.pendingAuthReminders;
    if (raw instanceof Map) {
      return raw;
    }
    if (Array.isArray(raw)) {
      const normalizedEntries = raw
        .filter((reminder) => {
          if (!reminder) return false;
          const connectionId =
            typeof reminder.connectionId === 'string' ? reminder.connectionId.trim() : '';
          return connectionId.length > 0;
        })
        .map((reminder) => {
          const connectionId = reminder.connectionId.trim();
          const normalized = {
            connectionId,
            status: reminder.status === 'dismissed' ? 'dismissed' : 'pending',
            reason: typeof reminder.reason === 'string' ? reminder.reason : 'authFailed',
            detail: typeof reminder.detail === 'string' ? reminder.detail : void 0,
            label: typeof reminder.label === 'string' ? reminder.label : void 0,
            message: typeof reminder.message === 'string' ? reminder.message : void 0,
            authMethod:
              reminder.authMethod === 'entra'
                ? 'entra'
                : reminder.authMethod === 'pat'
                  ? 'pat'
                  : void 0,
            snoozeUntil: typeof reminder.snoozeUntil === 'number' ? reminder.snoozeUntil : void 0,
          };
          return [connectionId, normalized];
        });
      return new Map(normalizedEntries);
    }
  } catch {}
  return /* @__PURE__ */ new Map();
}
var INTERACTIVE_REAUTH_THROTTLE_MS = 5 * 60 * 1e3;
function describeConnection(connection) {
  if (connection.label && connection.label.trim().length > 0) {
    return connection.label;
  }
  const parts = [];
  if (connection.organization) parts.push(connection.organization);
  if (connection.project) parts.push(connection.project);
  if (parts.length > 0) {
    return parts.join('/');
  }
  return connection.id;
}
function shouldLogDebug() {
  try {
    return !!getConfig().get('debugLogging');
  } catch {
    return false;
  }
}
function sendToWebview(message) {
  Promise.resolve()
    .then(() => (init_FSMLogger(), FSMLogger_exports))
    .then(({ fsmLogger: fsmLogger2, FSMComponent: FSMComponent2 }) => {
      fsmLogger2.debug(
        FSMComponent2.WEBVIEW,
        `Sending to webview: ${message?.type || 'unknown'}`,
        {
          component: FSMComponent2.WEBVIEW,
          event: 'MESSAGE_TO_WEBVIEW',
        },
        { messageType: message?.type }
      );
    })
    .catch((error) => {
      console.error(
        '\u274C [AzureDevOpsInt][FSM] Failed to import FSM logger for webview message:',
        error
      );
    });
  if (message?.type === 'workItemsLoaded') {
    dispatchApplicationEvent({
      type: 'WORK_ITEMS_LOADED',
      workItems: message.items || [],
      connectionId: message.connectionId,
      query: message.query,
      kanbanView: message.kanbanView || false,
      types: message.types || [],
    });
  } else if (message?.type === 'queryChanged') {
    Promise.resolve()
      .then(() => (init_FSMLogger(), FSMLogger_exports))
      .then(({ fsmLogger: fsmLogger2, FSMComponent: FSMComponent2 }) => {
        fsmLogger2.info(
          FSMComponent2.DATA,
          'Query changed in webview',
          {
            component: FSMComponent2.DATA,
            connectionId: message.connectionId,
            event: 'QUERY_CHANGED',
          },
          { query: message.query }
        );
      })
      .catch((error) => {
        console.error(
          '\u274C [AzureDevOpsInt][FSM] Failed to import FSM logger for query change:',
          error
        );
      });
    if (panel?.webview) {
      panel.webview.postMessage(message);
    } else {
      console.warn('\u{1F534} [FSM Integration] No panel available for queryChanged message');
    }
  } else {
    console.warn(
      '[FSM Integration] DEPRECATED: Ignoring sendToWebview call for message type:',
      message?.type
    );
    console.warn('[FSM Integration] Use FSM events or direct store updates instead');
  }
}
function sendWorkItemsSnapshot(options) {
  const branchContext = options.connectionId
    ? (branchStateByConnection.get(options.connectionId)?.context ?? null)
    : null;
  const enrichedWorkItems = (options.items || []).map((item) => ({
    ...item,
    connectionId: options.connectionId,
    branchContext,
  }));
  dispatchApplicationEvent({
    type: 'WORK_ITEMS_LOADED',
    workItems: enrichedWorkItems,
    connectionId: options.connectionId,
    query: options.query,
    kanbanView: options.kanbanView || false,
    types: options.types || [],
  });
}
async function updateAuthStatusBar() {
  if (!authStatusBarItem) return;
  if (!activeConnectionId2) {
    clearAuthReminder(activeConnectionId2);
    authStatusBarItem.hide();
    return;
  }
  const state2 = connectionStates2.get(activeConnectionId2);
  if (!state2 || state2.authMethod !== 'entra') {
    clearAuthReminder(activeConnectionId2);
    authStatusBarItem.hide();
    return;
  }
  authStatusBarItem.command = {
    title: 'Sign in with Microsoft Entra',
    command: 'azureDevOpsInt.signInWithEntra',
    arguments: [activeConnectionId2],
  };
  try {
    const connectionLabel = describeConnection(state2.config);
    authStatusBarItem.text = '$(warning) Entra Auth Not Available';
    authStatusBarItem.tooltip = `FSM authentication implementation needed for ${connectionLabel}`;
    authStatusBarItem.backgroundColor = new vscode8.ThemeColor('statusBarItem.warningBackground');
    authStatusBarItem.show();
  } catch (error) {
    console.error('[updateAuthStatusBar] Error updating auth status:', error);
    authStatusBarItem.hide();
  }
}
function notifyConnectionsList() {
  postConnectionsUpdate({
    panel,
    connections: connections2,
    activeConnectionId: activeConnectionId2,
    logger: verbose,
  });
  const actor = getApplicationActor();
  if (!actor) {
    return;
  }
  actor.send({
    type: 'CONNECTIONS_LOADED',
    connections: connections2.slice(),
  });
  if (activeConnectionId2) {
    actor.send({
      type: 'CONNECTION_SELECTED',
      connectionId: activeConnectionId2,
    });
  }
}
function clearAuthReminder(connectionId) {
  if (!connectionId) return;
  const actor = getApplicationActor();
  if (!actor) return;
  actor.send({ type: 'AUTH_REMINDER_CLEARED', connectionId });
  if (getPendingAuthReminderMap().size === 0) {
    nextAuthConnectionIndex = 0;
  }
}
function getPendingAuthConnectionIds() {
  const ordered = [];
  const pendingAuthReminders2 = getPendingAuthReminderMap();
  for (const connection of connections2) {
    const reminder = pendingAuthReminders2.get(connection.id);
    if (reminder?.status === 'pending') {
      ordered.push(connection.id);
    }
  }
  for (const [connectionId, reminder] of pendingAuthReminders2.entries()) {
    if (reminder?.status === 'pending' && !ordered.includes(connectionId)) {
      ordered.push(connectionId);
    }
  }
  return ordered;
}
async function cycleAuthSignIn(context) {
  const pendingIds = getPendingAuthConnectionIds();
  if (pendingIds.length === 0) {
    if (activeConnectionId2) {
      await signInWithEntra(context, activeConnectionId2);
    } else {
      await signInWithEntra(context);
    }
    return;
  }
  if (nextAuthConnectionIndex >= pendingIds.length) {
    nextAuthConnectionIndex = 0;
  }
  const targetId = pendingIds[nextAuthConnectionIndex];
  nextAuthConnectionIndex = (nextAuthConnectionIndex + 1) % pendingIds.length;
  clearAuthReminder(targetId);
  await signInWithEntra(context, targetId, { showSuccessMessage: true });
}
function ensureAuthReminder(connectionId, reason, options = {}) {
  const state2 = connectionStates2.get(connectionId);
  if (!state2) return;
  const now = Date.now();
  const pendingAuthReminders2 = getPendingAuthReminderMap();
  const existing = pendingAuthReminders2.get(connectionId);
  if (existing) {
    if (existing.status === 'pending') {
      return;
    }
    if (existing.status === 'dismissed') {
      if (existing.snoozeUntil && existing.snoozeUntil > now) {
        return;
      }
    }
  }
  const label = describeConnection(state2.config);
  let message;
  switch (reason) {
    case 'refreshFailed':
      message = `Microsoft Entra sign-in required for ${label}: token refresh failed.`;
      break;
    case 'authFailed':
      message = `Microsoft Entra sign-in required for ${label}.`;
      break;
    default:
      message = `Microsoft Entra access expired for ${label}.`;
      break;
  }
  const baseDetails = [];
  if (options.detail) baseDetails.push(options.detail.trim());
  const webviewDetails = [
    ...baseDetails,
    'Use Sign In here or select the authentication status bar item to reconnect.',
  ];
  const reminderState = {
    connectionId,
    status: 'pending',
    reason,
    detail: webviewDetails.join('\n\n'),
    message,
    label,
    authMethod: state2.config.authMethod ?? 'pat',
  };
  const actor = getApplicationActor();
  if (!actor) return;
  actor.send({ type: 'AUTH_REMINDER_SET', connectionId, reminder: reminderState });
}
function triggerAuthReminderSignIn(connectionId, reason, options = {}) {
  const state2 = connectionStates2.get(connectionId);
  if (!state2) return;
  const detail = options.detail;
  const startInteractive = options.startInteractive === true;
  if (!startInteractive) {
    ensureAuthReminder(connectionId, reason, detail ? { detail } : {});
    return;
  }
  if ((state2.authMethod ?? 'pat') !== 'entra') {
    ensureAuthReminder(connectionId, reason, detail ? { detail } : {});
    return;
  }
  const now = Date.now();
  if (state2.reauthInProgress) {
    return;
  }
  if (
    !options.force &&
    state2.lastInteractiveAuthAt &&
    now - state2.lastInteractiveAuthAt < INTERACTIVE_REAUTH_THROTTLE_MS
  ) {
    return;
  }
  state2.reauthInProgress = true;
  state2.lastInteractiveAuthAt = now;
  state2.accessToken = void 0;
  state2.refreshFailureCount = 0;
  state2.refreshBackoffUntil = void 0;
  const context = extensionContextRef2;
  (async () => {
    try {
      if (context) {
        await signInWithEntra(context, connectionId, {
          showSuccessMessage: false,
          forceInteractive: true,
        });
      } else {
        await vscode8.commands.executeCommand('azureDevOpsInt.signInWithEntra', connectionId);
      }
    } catch (error) {
      console.error('[triggerAuthReminderSignIn] Interactive Entra sign-in failed', error);
      ensureAuthReminder(connectionId, reason, detail ? { detail } : {});
    } finally {
      state2.reauthInProgress = false;
    }
  })().catch((error) => {
    console.error('[triggerAuthReminderSignIn] Unexpected Entra sign-in error', error);
    state2.reauthInProgress = false;
    ensureAuthReminder(connectionId, reason, detail ? { detail } : {});
  });
}
function normalizeQuery(value) {
  if (typeof value !== 'string') return void 0;
  const trimmed = value.trim();
  return trimmed.length > 0 ? trimmed : void 0;
}
function getStoredQueryForConnection(connectionId, fallback2) {
  const resolved = fallback2 ?? getDefaultQuery(getConfig());
  const base = resolved && resolved.trim().length > 0 ? resolved : DEFAULT_QUERY2;
  if (!connectionId) {
    return base;
  }
  const stored = activeQueryByConnection.get(connectionId);
  if (stored && stored.trim().length > 0) {
    return stored;
  }
  activeQueryByConnection.set(connectionId, base);
  return base;
}
function setStoredQueryForConnection(connectionId, query) {
  const resolvedDefault = getDefaultQuery(getConfig());
  const normalized = normalizeQuery(query) ?? resolvedDefault ?? DEFAULT_QUERY2;
  activeQueryByConnection.set(connectionId, normalized);
  return normalized;
}
function getQueryForProvider(targetProvider, connectionId) {
  const cfg = getConfig();
  const fallback2 = getDefaultQuery(cfg);
  const providerConnectionId = connectionId
    ? connectionId
    : typeof targetProvider?.getConnectionId === 'function'
      ? targetProvider.getConnectionId()
      : void 0;
  return getStoredQueryForConnection(providerConnectionId, fallback2);
}
function setTimerConnectionFrom(connection) {
  if (connection) {
    timerConnectionInfo = {
      id: connection.id,
      label: getConnectionLabel(connection),
      organization: connection.organization,
      project: connection.project,
    };
  } else {
    timerConnectionInfo = {};
  }
}
function getActiveTimerConnectionLabel() {
  if (timerConnectionInfo.label) return timerConnectionInfo.label;
  if (timerConnectionInfo.id) {
    const match = connections2.find((c) => c.id === timerConnectionInfo.id);
    if (match) return getConnectionLabel(match);
  }
  if (timerConnectionInfo.organization && timerConnectionInfo.project) {
    return `${timerConnectionInfo.organization}/${timerConnectionInfo.project}`;
  }
  return void 0;
}
function getClientForConnectionInfo(info) {
  if (info?.id) {
    const state2 = connectionStates2.get(info.id);
    if (state2?.client) return state2.client;
    if (info.id === activeConnectionId2 && client) return client;
  }
  return client;
}
function sanitizeConnection(raw) {
  if (!raw || typeof raw !== 'object') return null;
  const organization = String(raw.organization || '').trim();
  const project = String(raw.project || '').trim();
  if (!organization || !project) return null;
  const idValue = typeof raw.id === 'string' && raw.id.trim() ? raw.id.trim() : randomUUID3();
  const labelValue = typeof raw.label === 'string' && raw.label.trim() ? raw.label.trim() : void 0;
  const teamValue = typeof raw.team === 'string' && raw.team.trim() ? raw.team.trim() : void 0;
  const patKeyValue =
    typeof raw.patKey === 'string' && raw.patKey.trim() ? raw.patKey.trim() : void 0;
  const baseUrlValue =
    typeof raw.baseUrl === 'string' && raw.baseUrl.trim() ? raw.baseUrl.trim() : void 0;
  const tenantIdValue =
    typeof raw.tenantId === 'string' && raw.tenantId.trim() ? raw.tenantId.trim() : void 0;
  let authMethodValue;
  const authMethodRaw =
    typeof raw.authMethod === 'string' && raw.authMethod.trim()
      ? raw.authMethod.trim().toLowerCase()
      : void 0;
  if (authMethodRaw === 'entra' || authMethodRaw === 'pat') {
    authMethodValue = authMethodRaw;
  } else if (tenantIdValue) {
    authMethodValue = 'entra';
  }
  return {
    id: idValue,
    organization,
    project,
    label: labelValue,
    team: teamValue,
    authMethod: authMethodValue,
    patKey: patKeyValue,
    baseUrl: baseUrlValue,
    tenantId: tenantIdValue,
  };
}
async function loadConnectionsFromConfig(context) {
  const settings = getConfig();
  const rawConnections = settings.get(CONNECTIONS_CONFIG_KEY) ?? [];
  const normalized = [];
  let needsSave = false;
  for (const entry of rawConnections) {
    const sanitized = sanitizeConnection(entry);
    if (sanitized) {
      const rawId = typeof entry?.id === 'string' ? entry.id.trim() : '';
      if (!rawId) {
        needsSave = true;
      }
      if (!sanitized.patKey && sanitized.authMethod !== 'entra') {
        sanitized.patKey = `azureDevOpsInt.pat.${sanitized.id}`;
        needsSave = true;
      }
      if (!sanitized.baseUrl) {
        sanitized.baseUrl = `https://dev.azure.com/${sanitized.organization}`;
        needsSave = true;
      }
      if (
        !sanitized.apiBaseUrl &&
        sanitized.baseUrl &&
        sanitized.organization &&
        sanitized.project
      ) {
        try {
          const lowerBase = sanitized.baseUrl.toLowerCase();
          if (lowerBase.includes('dev.azure.com')) {
            sanitized.apiBaseUrl = `${sanitized.baseUrl.replace(/\/$/, '')}/${sanitized.organization}/${sanitized.project}/_apis`;
          } else if (lowerBase.includes('visualstudio.com')) {
            sanitized.apiBaseUrl = `${sanitized.baseUrl.replace(/\/$/, '')}/${sanitized.project}/_apis`;
          } else {
            sanitized.apiBaseUrl = `${sanitized.baseUrl.replace(/\/$/, '')}/${sanitized.organization}/${sanitized.project}/_apis`;
          }
          verbose('[connections] Migrated apiBaseUrl for connection', {
            id: sanitized.id,
            apiBaseUrl: sanitized.apiBaseUrl,
          });
          needsSave = true;
        } catch (e) {
          console.warn(
            '[connections] Failed to migrate apiBaseUrl for connection',
            sanitized.id,
            e
          );
        }
      }
      normalized.push(sanitized);
    }
  }
  if (normalized.length === 0) {
    const legacyOrg = String(settings.get('organization') || '').trim();
    const legacyProject = String(settings.get('project') || '').trim();
    if (legacyOrg && legacyProject) {
      const legacyTeam = String(settings.get('team') || '').trim();
      normalized.push({
        id: randomUUID3(),
        organization: legacyOrg,
        project: legacyProject,
        team: legacyTeam || void 0,
      });
      await settings.update(CONNECTIONS_CONFIG_KEY, normalized, vscode8.ConfigurationTarget.Global);
    }
  }
  connections2 = normalized;
  if (needsSave) {
    try {
      const settings2 = getConfig();
      await settings2.update(
        CONNECTIONS_CONFIG_KEY,
        normalized.map((entry) => ({ ...entry })),
        vscode8.ConfigurationTarget.Global
      );
      verbose('[connections] Saved migrated connections');
    } catch (e) {
      console.warn('[connections] Failed to save migrated connections', e);
    }
  }
  if (connections2.length > 0) {
    try {
      await migrateGlobalPATToConnections(context, connections2);
    } catch (e) {
      console.warn('[azureDevOpsInt] migrateGlobalPATToConnections failed', e);
    }
  }
  verbose('[connections] Loaded connections from config', {
    count: connections2.length,
    ids: connections2.map((c) => c.id),
  });
  const validIds = new Set(normalized.map((item) => item.id));
  for (const [id, state2] of connectionStates2.entries()) {
    if (!validIds.has(id)) {
      connectionStates2.delete(id);
      initialRefreshedConnections.delete(id);
      clearConnectionCaches(id);
    } else {
      const updated = normalized.find((item) => item.id === id);
      if (updated) state2.config = updated;
    }
  }
  for (const key2 of Array.from(activeQueryByConnection.keys())) {
    if (!validIds.has(key2)) {
      activeQueryByConnection.delete(key2);
    }
  }
  if (connections2.length === 0) {
    activeConnectionId2 = void 0;
    await context.globalState.update(ACTIVE_CONNECTION_STATE_KEY, void 0);
  } else {
    let storedActive = context.globalState.get(ACTIVE_CONNECTION_STATE_KEY);
    if (!storedActive || !validIds.has(storedActive)) {
      storedActive = connections2[0].id;
      await context.globalState.update(ACTIVE_CONNECTION_STATE_KEY, storedActive);
    }
    activeConnectionId2 = storedActive;
  }
  notifyConnectionsList();
  return connections2;
}
async function saveConnectionsToConfig(context, nextConnections) {
  const settings = getConfig();
  connections2 = nextConnections;
  const serialized = nextConnections.map((entry) => ({ ...entry }));
  await settings.update(CONNECTIONS_CONFIG_KEY, serialized, vscode8.ConfigurationTarget.Global);
  const validIds = new Set(nextConnections.map((item) => item.id));
  for (const [id, state2] of connectionStates2.entries()) {
    if (!validIds.has(id)) {
      connectionStates2.delete(id);
      initialRefreshedConnections.delete(id);
      clearConnectionCaches(id);
    } else {
      const updated = nextConnections.find((item) => item.id === id);
      if (updated) state2.config = updated;
    }
  }
  if (activeConnectionId2 && !validIds.has(activeConnectionId2)) {
    activeConnectionId2 = nextConnections[0]?.id;
    await context.globalState.update(ACTIVE_CONNECTION_STATE_KEY, activeConnectionId2);
  }
  notifyConnectionsList();
}
async function ensureConnectionsInitialized(context) {
  if (connections2.length === 0) await loadConnectionsFromConfig(context);
  return connections2;
}
async function ensureActiveConnection(context, connectionId, options = {}) {
  await ensureConnectionsInitialized(context);
  const targetId = connectionId ?? activeConnectionId2 ?? connections2[0]?.id;
  verbose('[ensureActiveConnection] evaluating target', {
    requested: connectionId,
    activeConnectionId: activeConnectionId2,
    resolved: targetId,
    connectionCount: connections2.length,
  });
  if (!targetId) {
    if (options.notify !== false) notifyConnectionsList();
    await vscode8.commands.executeCommand('setContext', 'azureDevOpsInt.connected', false);
    provider = void 0;
    client = void 0;
    return void 0;
  }
  if (targetId !== activeConnectionId2) {
    activeConnectionId2 = targetId;
    await context.globalState.update(ACTIVE_CONNECTION_STATE_KEY, targetId);
    if (options.notify !== false) notifyConnectionsList();
  }
  const connection = connections2.find((item) => item.id === targetId);
  if (!connection) {
    console.warn('[azureDevOpsInt] Connection not found for id', targetId);
    return void 0;
  }
  verbose('[ensureActiveConnection] using connection', {
    id: connection.id,
    organization: connection.organization,
    project: connection.project,
    baseUrl: connection.baseUrl,
    apiBaseUrl: connection.apiBaseUrl,
    // Add this to see if it's set
    authMethod: connection.authMethod || 'pat',
    hasIdentityName: !!connection.identityName,
    identityName: connection.identityName,
    // Show for debugging on-prem identity
  });
  let state2 = connectionStates2.get(targetId);
  if (!state2) {
    state2 = { id: targetId, config: connection, authMethod: connection.authMethod || 'pat' };
    connectionStates2.set(targetId, state2);
  } else {
    state2.config = connection;
    state2.authMethod = connection.authMethod || 'pat';
  }
  const settings = getConfig();
  const authMethod = connection.authMethod || 'pat';
  let credential;
  if (authMethod === 'entra') {
    verbose(
      '[ensureActiveConnection] Entra ID authentication not available - FSM implementation needed',
      { id: targetId }
    );
    state2.client = void 0;
    state2.provider = void 0;
    await vscode8.commands.executeCommand('setContext', 'azureDevOpsInt.connected', false);
    return state2;
  } else {
    verbose('[ensureActiveConnection] using PAT authentication', { id: targetId });
    const pat = await getSecretPAT2(context, targetId);
    if (!pat) {
      verbose('[ensureActiveConnection] missing PAT, cannot create client');
      provider = void 0;
      client = void 0;
      state2.client = void 0;
      state2.provider = void 0;
      await vscode8.commands.executeCommand('setContext', 'azureDevOpsInt.connected', false);
      return state2;
    }
    state2.pat = pat;
    credential = pat;
  }
  const ratePerSecond = Math.max(1, Math.min(50, settings.get('apiRatePerSecond') ?? 5));
  const burst = Math.max(1, Math.min(100, settings.get('apiBurst') ?? 10));
  const team = connection.team || settings.get('team') || void 0;
  const providerLogger = createScopedLogger(`provider:${connection.id}`, shouldLogDebug);
  const needsNewClient =
    !state2.client ||
    (authMethod === 'pat' && state2.pat !== credential) ||
    (authMethod === 'entra' && state2.accessToken !== credential) ||
    state2.client.organization !== connection.organization ||
    state2.client.project !== connection.project ||
    state2.client.team !== team;
  if (needsNewClient) {
    verbose('[ensureActiveConnection] creating new client', {
      id: connection.id,
      organization: connection.organization,
      project: connection.project,
      team,
      baseUrl: connection.baseUrl,
      authMethod,
    });
    verbose('[ensureActiveConnection] creating client with options', {
      hasIdentityName: !!connection.identityName,
      identityName: connection.identityName,
      baseUrl: connection.baseUrl,
    });
    state2.client = new AzureDevOpsIntClient(
      connection.organization,
      connection.project,
      credential,
      {
        ratePerSecond,
        burst,
        team,
        baseUrl: connection.baseUrl,
        apiBaseUrl: connection.apiBaseUrl,
        // Pass manual API URL override if provided
        authType: /* @__PURE__ */ (() => {
          const method = authMethod;
          return method === 'entra' ? 'bearer' : 'pat';
        })(),
        identityName: connection.identityName,
        // Pass through for on-prem identity fallback
        onAuthFailure: (error) => {
          state2.accessToken = void 0;
          const detail = error?.message ? `Details: ${error.message}` : void 0;
          const shouldStartInteractive = (state2.authMethod ?? 'pat') === 'entra';
          triggerAuthReminderSignIn(state2.id, 'authFailed', {
            detail,
            force: true,
            startInteractive: shouldStartInteractive,
          });
        },
      }
    );
    if (state2.provider) state2.provider.updateClient(state2.client);
  }
  const activeClient = state2.client;
  if (!activeClient) {
    provider = void 0;
    client = void 0;
    await vscode8.commands.executeCommand('setContext', 'azureDevOpsInt.connected', false);
    return state2;
  }
  if (!state2.provider) {
    verbose('[ensureActiveConnection] creating provider', {
      id: state2.id,
    });
    state2.provider = new WorkItemsProvider(
      state2.id,
      activeClient,
      (msg) => forwardProviderMessage2(state2.id, msg),
      {
        logger: providerLogger,
        transformWorkItems: (payload) => enrichWorkItemsForConnection(state2, payload),
      }
    );
  } else {
    state2.provider.setPostMessage((msg) => forwardProviderMessage2(state2.id, msg));
    state2.provider.setLogger(providerLogger);
    state2.provider.setTransformWorkItems((payload) =>
      enrichWorkItemsForConnection(state2, payload)
    );
  }
  verbose('[ensureActiveConnection] provider ready', {
    id: state2.id,
    hasClient: !!state2.client,
  });
  client = activeClient;
  provider = state2.provider;
  await vscode8.commands.executeCommand('setContext', 'azureDevOpsInt.connected', true);
  await updateAuthStatusBar();
  if (options.refresh !== false && provider) {
    const fallbackQuery = getDefaultQuery(settings);
    const selectedQuery = getStoredQueryForConnection(state2.id, fallbackQuery);
    if (!initialRefreshedConnections.has(state2.id)) {
      initialRefreshedConnections.add(state2.id);
    }
    verbose('[ensureActiveConnection] triggering provider refresh', {
      id: state2.id,
      query: selectedQuery,
    });
    provider.refresh(selectedQuery);
  }
  const hadReminder = getPendingAuthReminderMap().has(state2.id);
  clearAuthReminder(state2.id);
  if ((state2.authMethod ?? 'pat') === 'entra' || hadReminder) {
    dispatchApplicationEvent({ type: 'AUTHENTICATION_SUCCESS', connectionId: state2.id });
  }
  return state2;
}
function ensureTimer(context) {
  if (timer) return timer;
  const config = getConfig();
  let pomodoroBreakTimeout;
  timer = new WorkItemTimer({
    autoResumeOnActivity: config.get('autoResumeOnActivity') ?? true,
    inactivityTimeoutSec: config.get('timerInactivityTimeout') ?? 300,
    defaultElapsedLimitHours: config.get('defaultElapsedLimitHours') ?? 3.5,
    pomodoroEnabled: config.get('pomodoroEnabled') ?? false,
    breakPrompt: () => {
      const snap = timer?.snapshot?.();
      if (!snap || snap.isPaused) return;
      vscode8.window
        .showInformationMessage(
          'Time for a Pomodoro break?',
          { modal: true },
          'Start 5\u2011min break',
          'Skip'
        )
        .then((choice) => {
          if (!choice || choice === 'Skip') return;
          try {
            timer?.pause();
          } catch {}
          if (pomodoroBreakTimeout) {
            try {
              clearTimeout(pomodoroBreakTimeout);
            } catch {}
            pomodoroBreakTimeout = void 0;
          }
          pomodoroBreakTimeout = setTimeout(
            () => {
              try {
                timer?.resume();
              } catch {}
              pomodoroBreakTimeout = void 0;
            },
            5 * 60 * 1e3
          );
        })
        .then(
          () => {},
          (error) => {
            console.error('\u274C [TIMER] Failed to show Pomodoro break dialog:', error);
          }
        );
    },
    persist: (data) => persistTimer(context, data),
    restorePersisted: () => restoreTimer(context),
    onState: (s) => {
      sendToWebview({
        type: 'timerUpdate',
        timer: s,
        connectionId: timerConnectionInfo.id,
        connectionLabel: timerConnectionInfo.label,
        connectionOrganization: timerConnectionInfo.organization,
        connectionProject: timerConnectionInfo.project,
      });
      updateTimerContext(s);
    },
    onInfo: (m) => verbose('[timer]', m),
    onWarn: (m) => console.warn('[timer]', m),
    onError: (m) => console.error('[timer]', m),
  });
  timer.loadFromPersisted();
  return timer;
}
var extensionContextRef2;
var cachedExtensionVersion;
var openAiClient;
var selfTestPending;
function isVSCodeTestRun() {
  try {
    return (process.argv || []).some(
      (a) =>
        typeof a === 'string' &&
        (a.includes('--extensionTestsPath') || a.includes('integration-tests'))
    );
  } catch {
    return false;
  }
}
var IS_SMOKE = process.env.VSCODE_INTEGRATION_SMOKE === '1' || isVSCodeTestRun();
function getConfig() {
  return vscode8.workspace.getConfiguration(CONFIG_NS);
}
function hasConfigOverride(metadata) {
  if (!metadata) return false;
  const overrideValues = [
    metadata.globalValue,
    metadata.workspaceValue,
    metadata.workspaceFolderValue,
    metadata.globalLanguageValue,
    metadata.workspaceLanguageValue,
    metadata.workspaceFolderLanguageValue,
  ];
  return overrideValues.some((value) => value !== void 0);
}
function resolveDefaultQuery(_config) {
  const getValue = (key2) => {
    try {
      const raw = _config?.get(key2);
      if (typeof raw !== 'string') return void 0;
      const trimmed = raw.trim();
      return trimmed.length > 0 ? trimmed : void 0;
    } catch {
      return void 0;
    }
  };
  const explicitDefault = getValue('defaultQuery');
  if (explicitDefault) return explicitDefault;
  const workItemQuery = getValue('workItemQuery');
  if (workItemQuery) {
    const inspectFn =
      typeof _config?.inspect === 'function' ? _config.inspect.bind(_config) : void 0;
    if (!inspectFn) return workItemQuery;
    try {
      const metadata = inspectFn('workItemQuery');
      if (hasConfigOverride(metadata)) return workItemQuery;
    } catch {
      return workItemQuery;
    }
  }
  return DEFAULT_QUERY2;
}
function getDefaultQuery(config) {
  const target = config ?? getConfig();
  return resolveDefaultQuery(target);
}
function getExtensionVersion(context) {
  if (cachedExtensionVersion) return cachedExtensionVersion;
  try {
    const pkgPath = path4.join(context.extensionPath, 'package.json');
    const pkgRaw = fs.readFileSync(pkgPath, 'utf8');
    const pkg = JSON.parse(pkgRaw);
    cachedExtensionVersion = String(pkg.version || 'dev');
  } catch {
    cachedExtensionVersion = 'dev';
  }
  return cachedExtensionVersion;
}
async function migrateLegacyConfigIfNeeded() {
  try {
    const legacy = vscode8.workspace.getConfiguration(LEGACY_CONFIG_NS);
    const target = getConfig();
    const legacyOrg = legacy.get('organization');
    const legacyProj = legacy.get('project');
    if (legacyOrg && !target.get('organization'))
      await target.update('organization', legacyOrg, vscode8.ConfigurationTarget.Global);
    if (legacyProj && !target.get('project'))
      await target.update('project', legacyProj, vscode8.ConfigurationTarget.Global);
  } catch (e) {
    console.warn('[azureDevOpsInt] migrateLegacyConfigIfNeeded failed', e);
  }
}
async function applyStartupPatches(context) {
  try {
    const patchState = context.globalState;
    const PATCH_VERSION_KEY = 'azureDevOpsInt.appliedPatches';
    const appliedPatches = patchState.get(PATCH_VERSION_KEY, []);
    if (!appliedPatches.includes('1.0.0-clientid-removal')) {
      await applyClientIdRemovalPatch();
      appliedPatches.push('1.0.0-clientid-removal');
      await patchState.update(PATCH_VERSION_KEY, appliedPatches);
      console.log('[azureDevOpsInt] Applied patch: 1.0.0-clientid-removal');
    }
  } catch (error) {
    console.warn('[azureDevOpsInt] Failed to apply startup patches:', error);
  }
}
async function applyClientIdRemovalPatch() {
  try {
    const config = vscode8.workspace.getConfiguration('azureDevOpsIntegration');
    const connections3 = config.get('connections', []);
    let patchedCount = 0;
    const patchedConnections = connections3.map((conn) => {
      if ('clientId' in conn) {
        patchedCount++;
        const { clientId, ...connWithoutClientId } = conn;
        return connWithoutClientId;
      }
      return conn;
    });
    if (patchedCount > 0) {
      await config.update('connections', patchedConnections, vscode8.ConfigurationTarget.Global);
      console.log(
        `[azureDevOpsInt] Startup patch: Removed clientId from ${patchedCount} connection(s)`
      );
    }
  } catch (error) {
    console.warn('[azureDevOpsInt] Client ID removal patch failed:', error);
    throw error;
  }
}
async function activate(context) {
  rejectionHandler = (reason, promise) => {
    const isFromOurExtension =
      reason &&
      typeof reason === 'object' &&
      'stack' in reason &&
      typeof reason.stack === 'string' &&
      (reason.stack.includes('azuredevops-integration-extension') ||
        reason.stack.includes('azureDevOpsInt') ||
        reason.stack.includes('activation.ts') ||
        reason.stack.includes('src\\fsm\\') ||
        reason.stack.includes('src/fsm/'));
    if (!isFromOurExtension) {
      return;
    }
    if (reason && typeof reason === 'object') {
      const isCancellation =
        ('name' in reason && reason.name === 'Canceled') ||
        ('message' in reason && reason.message === 'Canceled') ||
        (reason.toString && reason.toString().includes('Canceled')) ||
        ('stack' in reason &&
          typeof reason.stack === 'string' &&
          reason.stack.includes('Canceled'));
      if (isCancellation) {
        verbose('[azureDevOpsInt] Promise cancelled during shutdown (normal)');
        return;
      }
    }
    console.error('[azureDevOpsInt] Unhandled Promise Rejection:', reason);
    console.error('[azureDevOpsInt] Promise:', promise);
  };
  process.on('unhandledRejection', rejectionHandler);
  process.on('uncaughtException', (error) => {
    console.error('[azureDevOpsInt] Uncaught Exception:', error);
  });
  extensionContextRef2 = context;
  setExtensionContextRef(context);
  await applyStartupPatches(context);
  if (IS_SMOKE) {
    try {
      vscode8.commands.executeCommand('setContext', 'azureDevOpsInt.connected', false).then(
        () => {},
        () => {}
      );
    } catch {}
    return void 0;
  }
  const cfg = getConfig();
  if (cfg.get('debugLogging')) {
    const channel =
      getOutputChannel() ?? vscode8.window.createOutputChannel('Azure DevOps Integration');
    setOutputChannel(channel);
    logLine('[activate] Debug logging enabled');
    bridgeConsoleToOutputChannel();
  }
  statusBarItem = vscode8.window.createStatusBarItem(
    'azureDevOpsInt.timer',
    vscode8.StatusBarAlignment.Left,
    100
  );
  statusBarItem.command = 'azureDevOpsInt.stopTimer';
  context.subscriptions.push(statusBarItem);
  authStatusBarItem = vscode8.window.createStatusBarItem(
    'azureDevOpsInt.authStatus',
    vscode8.StatusBarAlignment.Left,
    99
  );
  authStatusBarItem.command = 'azureDevOpsInt.signInWithEntra';
  context.subscriptions.push(authStatusBarItem);
  authStatusBarItem.hide();
  const authenticationProviderOptions = {
    supportsMultipleAccounts: true,
    supportsAccountManagement: true,
  };
  if (!viewProviderRegistered) {
    verbose('[azureDevOpsInt] Registering webview view provider: azureDevOpsWorkItems');
    context.subscriptions.push(
      vscode8.window.registerWebviewViewProvider(
        'azureDevOpsWorkItems',
        new AzureDevOpsIntViewProvider(context),
        { webviewOptions: { retainContextWhenHidden: true } }
      )
    );
    viewProviderRegistered = true;
  }
  registerTraceCommands(context);
  Promise.resolve()
    .then(() => (init_quickDebugCommands(), quickDebugCommands_exports))
    .then(({ registerQuickDebugCommands: registerQuickDebugCommands2 }) => {
      registerQuickDebugCommands2(context);
      verbose('[ACTIVATION] Quick debug commands registered');
    })
    .catch((error) => {
      console.error('\u274C [ACTIVATION] Failed to import quick debug commands:', error);
    });
  Promise.resolve()
    .then(() => (init_outputChannelReader(), outputChannelReader_exports))
    .then(({ registerOutputChannelReader: registerOutputChannelReader2 }) => {
      registerOutputChannelReader2(context);
      verbose('[ACTIVATION] Output channel reader registered for automated debugging');
    })
    .catch((error) => {
      console.error('\u274C [ACTIVATION] Failed to import output channel reader:', error);
    });
  verbose('[ACTIVATION] Starting FSM tracing session automatically...');
  Promise.resolve()
    .then(() => (init_FSMTracer(), FSMTracer_exports))
    .then(({ startTraceSession: startTraceSession3, fsmTracer: fsmTracer2 }) => {
      try {
        const sessionId = startTraceSession3('Extension Activation - Auto Debug Session');
        verbose(`[ACTIVATION] FSM tracing started: ${sessionId}`);
        Promise.resolve()
          .then(() => (init_FSMLogger(), FSMLogger_exports))
          .then(({ fsmLogger: fsmLogger2, FSMComponent: FSMComponent2 }) => {
            fsmLogger2.showOutputChannel();
            verbose('[ACTIVATION] FSM Output Channel opened for debugging visibility');
            fsmLogger2.info(FSMComponent2.APPLICATION, 'Extension activation started', {
              component: FSMComponent2.APPLICATION,
              event: 'ACTIVATE',
              state: 'activating',
            });
          })
          .catch((error) => {
            console.error('\u274C [ACTIVATION] Failed to import FSM logger for activation:', error);
          });
      } catch (error) {
        console.error('\u274C [ACTIVATION] Failed to start FSM tracing:', error);
      }
    })
    .catch((error) => {
      console.error('\u274C [ACTIVATION] Failed to import FSM tracing modules:', error);
    });
  context.subscriptions.push(
    vscode8.commands.registerCommand(
      'azureDevOpsInt.setup',
      safeCommandHandler(() => {
        return setupConnection(context);
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.setOpenAIApiKey',
      safeCommandHandler(() => {
        return setOpenAIApiKey(context);
      })
    ),
    vscode8.commands.registerCommand('azureDevOpsInt.openLogs', () => {
      (async () => {
        try {
          let channel = getOutputChannel();
          if (!channel) {
            channel = vscode8.window.createOutputChannel('Azure DevOps Integration');
            setOutputChannel(channel);
            logLine('[logs] Output channel created on demand');
          }
          channel.show(true);
          const currentConfig = getConfig();
          if (!currentConfig.get('debugLogging')) {
            const pick = await vscode8.window.showInformationMessage(
              'Verbose logging is currently disabled. Enable it to capture more diagnostics?',
              'Enable',
              'Skip'
            );
            if (pick === 'Enable') {
              await currentConfig.update('debugLogging', true, vscode8.ConfigurationTarget.Global);
              logLine('[logs] Debug logging enabled');
            }
          }
        } catch (e) {
          vscode8.window.showErrorMessage('Failed to open logs: ' + (e?.message || String(e)));
        }
      })().catch((err) => console.error('[azureDevOpsInt.openLogs] Error:', err));
    }),
    vscode8.commands.registerCommand('azureDevOpsInt.copyLogsToClipboard', () => {
      (async () => {
        try {
          const version4 = extensionContextRef2 ? getExtensionVersion(extensionContextRef2) : 'dev';
          const buffer = getLogBufferSnapshot();
          const header = `Azure DevOps Integration Logs
Version: ${version4}
Timestamp: ${/* @__PURE__ */ new Date().toISOString()}
Lines: ${buffer.length}
---
`;
          const body = buffer.join('\n');
          const text2 = header + body + (body.endsWith('\n') ? '' : '\n');
          await vscode8.env.clipboard.writeText(text2);
          vscode8.window.showInformationMessage('Copied extension logs to clipboard.');
        } catch (e) {
          vscode8.window.showErrorMessage(
            'Failed to copy logs to clipboard: ' + (e?.message || String(e))
          );
        }
      })().catch((err) => console.error('[azureDevOpsInt.copyLogsToClipboard] Error:', err));
    }),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.diagnoseWorkItems',
      safeCommandHandler(async () => {
        try {
          await diagnoseWorkItemsIssue(context);
        } catch (e) {
          vscode8.window.showErrorMessage('Diagnostic failed: ' + (e?.message || String(e)));
        }
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.openLogsFolder',
      safeCommandHandler(async () => {
        try {
          await vscode8.commands.executeCommand('workbench.action.openLogsFolder');
        } catch {
          try {
            await vscode8.env.openExternal(vscode8.env.logUri ?? vscode8.Uri.file(''));
          } catch (e) {
            vscode8.window.showErrorMessage(
              'Failed to open logs folder: ' + (e?.message || String(e))
            );
          }
        }
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.focusWorkItemsView',
      safeCommandHandler(() => revealWorkItemsView())
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.setDefaultElapsedLimit',
      safeCommandHandler(async () => {
        try {
          const cfg2 = getConfig();
          const prev = cfg2.get('defaultElapsedLimitHours') ?? 3.5;
          const input = await vscode8.window.showInputBox({
            prompt: 'Default elapsed hours to cap long-running timers (e.g. 3.5)',
            value: String(prev),
            validateInput: (v) => {
              const n = Number(v);
              if (isNaN(n) || !isFinite(n) || n < 0) return 'Enter a non-negative number';
              return null;
            },
          });
          if (typeof input === 'undefined') return;
          const val = Number(input);
          await cfg2.update('defaultElapsedLimitHours', val, vscode8.ConfigurationTarget.Global);
          vscode8.window.showInformationMessage(`Default elapsed cap updated to ${val} hours.`);
          if (timer && typeof timer.setDefaultElapsedLimitHours === 'function') {
            try {
              timer.setDefaultElapsedLimitHours(val);
            } catch (e) {
              console.warn(
                '[azureDevOpsInt] Failed to propagate defaultElapsedLimitHours to running timer',
                e
              );
            }
          }
        } catch (err) {
          console.error('Failed to update default elapsed cap', err);
          vscode8.window.showErrorMessage(
            'Failed to update default elapsed cap: ' + (err?.message || String(err))
          );
        }
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.showWorkItems',
      safeCommandHandler(() => revealWorkItemsView())
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.refreshWorkItems',
      safeCommandHandler(async () => {
        const connectionSpecificQuery = activeConnectionId2
          ? getStoredQueryForConnection(activeConnectionId2)
          : getDefaultQuery();
        verbose('[command] refreshWorkItems invoked', {
          hasProvider: !!provider,
          query: connectionSpecificQuery,
          activeConnectionId: activeConnectionId2,
        });
        if (!provider && extensionContextRef2) {
          verbose('[command] refreshWorkItems no provider; attempting ensureActiveConnection');
          try {
            await ensureActiveConnection(extensionContextRef2, activeConnectionId2, {
              refresh: false,
            });
          } catch (e) {
            verbose('[command] ensureActiveConnection failed in refreshWorkItems', e?.message || e);
          }
        }
        provider?.refresh(connectionSpecificQuery);
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.createWorkItem',
      safeCommandHandler(() => {
        return quickCreateWorkItem();
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.startTimer',
      safeCommandHandler(() => {
        return startTimerInteractive();
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.pauseTimer',
      safeCommandHandler(() => {
        timer?.pause();
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.resumeTimer',
      safeCommandHandler(() => {
        timer?.resume();
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.stopTimer',
      safeCommandHandler(async () => {
        if (!timer) {
          vscode8.window.showInformationMessage('No active timer to stop.');
          return;
        }
        const timerConnectionSnapshot = { ...timerConnectionInfo };
        setTimerConnectionFrom(void 0);
        const stopped = timer.stop();
        updateTimerContext(void 0);
        if (stopped) {
          await handleTimerStopAndOfferUpdate(stopped, {
            offerCopilot: false,
            connection: timerConnectionSnapshot,
          });
        }
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.showTimeReport',
      safeCommandHandler(() => showTimeReport())
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.createBranch',
      safeCommandHandler(() => createBranchFromWorkItem())
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.createPullRequest',
      safeCommandHandler(() => createPullRequestInteractive())
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.showPullRequests',
      safeCommandHandler(() => showMyPullRequests())
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.showBuildStatus',
      safeCommandHandler(() => showBuildStatus())
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.toggleKanbanView',
      safeCommandHandler(() => toggleKanbanView())
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.selectTeam',
      safeCommandHandler(() => selectTeam())
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.resetPreferredRepositories',
      safeCommandHandler(() => resetPreferredRepositories())
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.selfTestWebview',
      safeCommandHandler(() => selfTestWebview())
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.signInWithEntra',
      safeCommandHandler((target) => {
        return signInWithEntra(context, typeof target === 'string' ? target : target?.id);
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.signOutEntra',
      safeCommandHandler((target) => {
        return signOutEntra(context, typeof target === 'string' ? target : target?.id);
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.convertConnectionToEntra',
      safeCommandHandler(() => convertConnectionToEntra(context))
    ),
    vscode8.commands.registerCommand('azureDevOpsInt.clearFilter', () => {
      sendToWebview({ type: 'clearFilters' });
    }),
    vscode8.commands.registerCommand('azureDevOpsInt.focusSearch', () => {
      sendToWebview({ type: 'focusSearch' });
    }),
    vscode8.commands.registerCommand('azureDevOpsInt.showPerformanceDashboard', () => {
      showPerformanceDashboard();
    }),
    vscode8.commands.registerCommand('azureDevOpsInt.clearPerformanceData', () => {
      performanceMonitor.clear();
      vscode8.window.showInformationMessage('Performance data cleared successfully');
    }),
    vscode8.commands.registerCommand('azureDevOpsInt.forceGC', () => {
      forceGarbageCollection();
    }),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.bulkAssign',
      safeCommandHandler(() => {
        bulkAssignWorkItems();
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.bulkMove',
      safeCommandHandler(() => {
        bulkMoveWorkItems();
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.bulkAddTags',
      safeCommandHandler(() => {
        bulkAddTags();
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.bulkDelete',
      safeCommandHandler(() => {
        bulkDeleteWorkItems();
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.exportFilters',
      safeCommandHandler(() => {
        exportFiltersToFile();
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.importFilters',
      safeCommandHandler(() => {
        importFiltersFromFile();
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.manageFilters',
      safeCommandHandler(() => {
        manageSavedFilters();
      })
    ),
    vscode8.commands.registerCommand(
      'azureDevOpsInt.showQueryBuilder',
      safeCommandHandler(() => {
        showQueryBuilder();
      })
    )
  );
  startCacheCleanup();
  performanceMonitor.setEnabled(true);
  gcInterval = setInterval(() => {
    MemoryOptimizer.forceGCIfNeeded();
  }, 6e4);
  if (!IS_SMOKE) {
    migrateLegacyConfigIfNeeded().finally(() => silentInit(context));
  } else {
    try {
      vscode8.commands.executeCommand('setContext', 'azureDevOpsInt.connected', false).then(
        () => {},
        () => {}
      );
    } catch {}
  }
  context.subscriptions.push(
    vscode8.workspace.onDidChangeConfiguration((e) => {
      (async () => {
        if (
          e.affectsConfiguration(`${CONFIG_NS}.connections`) ||
          e.affectsConfiguration(`${CONFIG_NS}.organization`) ||
          e.affectsConfiguration(`${CONFIG_NS}.project`) ||
          e.affectsConfiguration(`${CONFIG_NS}.personalAccessToken`)
        ) {
          try {
            vscode8.commands.registerCommand(
              'azureDevOpsInt.signInWithEntraCycle',
              safeCommandHandler(() => {
                return cycleAuthSignIn(context);
              })
            );
            await migrateLegacyPAT(context);
          } catch {}
          if (e.affectsConfiguration(`${CONFIG_NS}.connections`)) {
            connections2.length = 0;
            await loadConnectionsFromConfig(context);
            notifyConnectionsList();
          }
          client = void 0;
          provider = void 0;
          await silentInit(context);
          try {
            await vscode8.commands.executeCommand('azureDevOpsInt.refreshWorkItems');
          } catch {}
        }
      })().catch((err) => console.error('[onDidChangeConfiguration] Error:', err));
    })
  );
  verbose('[TokenRefresh] Legacy token refresh disabled - FSM handles authentication');
  verbose('[TokenRefresh] Legacy initial token check disabled - FSM handles authentication');
}
function deactivate() {
  console.log('[azureDevOpsInt] Extension deactivating...');
  isDeactivating2 = true;
  try {
    if (rejectionHandler) {
      process.removeListener('unhandledRejection', rejectionHandler);
      rejectionHandler = void 0;
    }
    stopCacheCleanup();
    performanceMonitor.setEnabled(false);
    if (tokenRefreshInterval) {
      clearInterval(tokenRefreshInterval);
      tokenRefreshInterval = void 0;
    }
    if (gcInterval) {
      clearInterval(gcInterval);
      gcInterval = void 0;
    }
    if (timer) {
      timer.stop();
    }
    try {
      vscode8.commands.executeCommand('setContext', 'azureDevOpsInt.connected', false).then(
        () => {},
        () => {}
      );
      vscode8.commands.executeCommand('setContext', 'azureDevOpsInt.timerActive', false).then(
        () => {},
        () => {}
      );
      vscode8.commands.executeCommand('setContext', 'azureDevOpsInt.timerRunning', false).then(
        () => {},
        () => {}
      );
      vscode8.commands.executeCommand('setContext', 'azureDevOpsInt.timerPaused', false).then(
        () => {},
        () => {}
      );
    } catch {}
    console.log('[azureDevOpsInt] Extension deactivated successfully');
  } catch (error) {
    console.error('[azureDevOpsInt] Error during deactivation:', error);
  }
}
var AzureDevOpsIntViewProvider = class {
  ctx;
  constructor(context) {
    this.ctx = context;
  }
  async resolveWebviewView(webviewView) {
    if (IS_SMOKE) {
      try {
        vscode8.commands.executeCommand('setContext', 'azureDevOpsInt.connected', false).then(
          () => {},
          () => {}
        );
      } catch {}
      return void 0;
    }
    console.log(
      '[azureDevOpsInt] \u{1F50D} resolveWebviewView invoked for view:',
      webviewView.viewType
    );
    console.log('[azureDevOpsInt] \u{1F50D} Webview visibility:', webviewView.visible);
    console.log(
      '[azureDevOpsInt] \u{1F50D} Extension context URI:',
      this.ctx.extensionUri.toString()
    );
    panel = webviewView;
    const webview = webviewView.webview;
    const contextBridge = await ensureSharedContextBridge(this.ctx);
    contextBridge.attachWebview(webview);
    contextBridge.sync();
    console.log('[azureDevOpsInt] \u{1F50D} Setting webview options...');
    console.log('\u{1F4FA} [WEBVIEW] Webview panel created and assigned');
    Promise.resolve()
      .then(() => (init_FSMLogger(), FSMLogger_exports))
      .then(({ fsmLogger: fsmLogger2, FSMComponent: FSMComponent2 }) => {
        fsmLogger2.info(
          FSMComponent2.WEBVIEW,
          'Webview panel created',
          {
            component: FSMComponent2.WEBVIEW,
            event: 'PANEL_CREATED',
          },
          {
            viewType: webviewView.viewType,
            visible: webviewView.visible,
          }
        );
      })
      .catch((error) => {
        console.error(
          '\u274C [AzureDevOpsInt][FSM] Failed to import FSM logger for webview panel creation:',
          error
        );
      });
    const mediaPath = vscode8.Uri.joinPath(this.ctx.extensionUri, 'media', 'webview');
    console.log('[azureDevOpsInt] \u{1F50D} Media path for local resources:', mediaPath.toString());
    webview.options = {
      enableScripts: true,
      localResourceRoots: [mediaPath],
    };
    console.log('[azureDevOpsInt] \u{1F50D} Webview options set successfully');
    const nonce = getNonce();
    console.log('[azureDevOpsInt] \u{1F50D} Generated nonce for webview:', nonce);
    webview.onDidReceiveMessage((msg) => {
      console.log(
        '[azureDevOpsInt] \u{1F50D} Received message from webview:',
        msg?.type || 'unknown'
      );
      if (contextBridge.handleWebviewMessage(msg)) {
        return;
      }
      void handleLegacyMessage(msg);
    });
    webviewView.onDidDispose(() => {
      contextBridge.detachWebview();
    });
    console.log('[azureDevOpsInt] \u{1F50D} Building webview HTML...');
    const html2 = buildMinimalWebviewHtml(this.ctx, webview, nonce);
    console.log('[azureDevOpsInt] \u{1F50D} HTML length:', html2.length);
    console.log(
      '[azureDevOpsInt] \u{1F50D} HTML preview (first 500 chars):',
      html2.substring(0, 500)
    );
    webview.html = html2;
    console.log('[azureDevOpsInt] \u{1F50D} Webview HTML set successfully');
    webviewView.onDidChangeVisibility(() => {
      console.log('[azureDevOpsInt] \u{1F50D} Webview visibility changed to:', webviewView.visible);
    });
    if (!IS_SMOKE) {
      console.log('[azureDevOpsInt] \u{1F50D} Initializing domain objects...');
      initDomainObjects(this.ctx).catch((err) =>
        console.error('[azureDevOpsInt] Failed to initialize domain objects', err)
      );
    } else {
      console.log('[azureDevOpsInt] \u{1F50D} SMOKE mode - sending minimal snapshot');
      const initialQuery = getStoredQueryForConnection(
        activeConnectionId2,
        getDefaultQuery(getConfig())
      );
      sendWorkItemsSnapshot({
        connectionId: activeConnectionId2,
        items: [],
        kanbanView: false,
        types: [],
        query: initialQuery,
      });
      sendToWebview({
        type: 'queryChanged',
        query: initialQuery,
        connectionId: activeConnectionId2,
        description: `SMOKE mode query for connection ${activeConnectionId2}`,
      });
    }
  }
};
async function initDomainObjects(context) {
  verbose('[initDomainObjects] start');
  const config = getConfig();
  sessionTelemetry = sessionTelemetry ?? new SessionTelemetryManager(context);
  await ensureConnectionsInitialized(context);
  const state2 = await ensureActiveConnection(context, activeConnectionId2, { refresh: false });
  verbose('[initDomainObjects] ensured active connection', {
    hasState: !!state2,
    connectionId: state2?.id,
    hasProvider: !!state2?.provider,
  });
  const timerInstance = ensureTimer(context);
  const snapshot2 = timerInstance.snapshot?.();
  if (snapshot2) {
    sendToWebview({
      type: 'timerUpdate',
      timer: snapshot2,
      connectionId: timerConnectionInfo.id,
      connectionLabel: timerConnectionInfo.label,
      connectionOrganization: timerConnectionInfo.organization,
      connectionProject: timerConnectionInfo.project,
    });
    updateTimerContext(snapshot2);
  }
  notifyConnectionsList();
  if (panel && state2?.provider) {
    const selectedQuery = getStoredQueryForConnection(state2.id, getDefaultQuery(config));
    sendToWebview({
      type: 'queryChanged',
      query: selectedQuery,
      connectionId: state2.id,
      description: `Initial query for connection ${state2.id}`,
    });
    if (!initialRefreshedConnections.has(state2.id)) {
      initialRefreshedConnections.add(state2.id);
    }
    verbose('[initDomainObjects] panel ready, refreshing provider', {
      id: state2.id,
      query: selectedQuery,
    });
    state2.provider.refresh(selectedQuery);
  } else if (panel && !state2?.provider) {
    verbose('[initDomainObjects] panel ready but provider missing, sending empty payload');
    sendWorkItemsSnapshot({
      connectionId: activeConnectionId2,
      items: [],
      kanbanView: false,
      types: [],
      query: getStoredQueryForConnection(activeConnectionId2, getDefaultQuery(config)),
    });
  }
}
async function handleLegacyMessage(msg) {
  verbose('[webview->ext]', JSON.stringify(msg));
  Promise.resolve()
    .then(() => (init_FSMLogger(), FSMLogger_exports))
    .then(({ fsmLogger: fsmLogger2, FSMComponent: FSMComponent2 }) => {
      fsmLogger2.debug(
        FSMComponent2.WEBVIEW,
        `Webview message: ${msg?.type || 'unknown'}`,
        {
          component: FSMComponent2.WEBVIEW,
          event: msg?.type || 'UNKNOWN_MESSAGE',
        },
        msg
      );
    })
    .catch((error) => {
      console.error(
        '\u274C [AzureDevOpsInt][FSM] Failed to import FSM logger for webview message:',
        error
      );
    });
  if (msg?.type === 'editWorkItemInEditor') {
    const id = typeof msg.workItemId === 'number' ? msg.workItemId : void 0;
    if (typeof id === 'number' && provider) {
      editWorkItemInEditor(id);
    }
    return void 0;
  }
  if (msg?.type === 'bulkAssign') {
    await bulkAssignWorkItems();
    return void 0;
  }
  if (msg?.type === 'bulkMove') {
    await bulkMoveWorkItems();
    return;
  }
  if (msg?.type === 'bulkAddTags') {
    await bulkAddTags();
    return;
  }
  if (msg?.type === 'bulkDelete') {
    await bulkDeleteWorkItems();
    return;
  }
  switch (msg?.type) {
    case 'authReminderAction': {
      Promise.resolve()
        .then(() => (init_FSMLogger(), FSMLogger_exports))
        .then(({ fsmLogger: fsmLogger2, FSMComponent: FSMComponent2 }) => {
          fsmLogger2.info(
            FSMComponent2.AUTH,
            'Authentication reminder action received',
            {
              component: FSMComponent2.AUTH,
              connectionId: msg.connectionId,
              event: 'AUTH_REMINDER_ACTION',
            },
            { action: msg.action }
          );
        })
        .catch((error) => {
          console.error(
            '\u274C [AzureDevOpsInt][FSM] Failed to import FSM logger for auth reminder action:',
            error
          );
        });
      const connectionId = typeof msg.connectionId === 'string' ? msg.connectionId.trim() : '';
      if (!connectionId) {
        console.warn('\u{1F534} [webview->ext] authReminderAction: missing connectionId');
        break;
      }
      const action2 = typeof msg.action === 'string' ? msg.action : '';
      if (!action2) {
        console.warn('\u{1F534} [webview->ext] authReminderAction: missing action');
        break;
      }
      if (action2 === 'signIn') {
        clearAuthReminder(connectionId);
        triggerAuthReminderSignIn(connectionId, 'authFailed', {
          force: true,
          startInteractive: true,
        });
        break;
      }
      if (action2 === 'dismiss') {
        const actor = getApplicationActor();
        if (!actor) {
          break;
        }
        const pendingReminders = getPendingAuthReminderMap();
        const existingReminder = pendingReminders.get(connectionId);
        const snoozeUntil = Date.now() + AUTH_REMINDER_SNOOZE_MS;
        if (existingReminder) {
          actor.send({ type: 'AUTH_REMINDER_DISMISSED', connectionId, snoozeUntil });
        } else {
          actor.send({
            type: 'AUTH_REMINDER_SET',
            connectionId,
            reminder: {
              connectionId,
              status: 'dismissed',
              reason: 'authFailed',
              snoozeUntil,
            },
          });
        }
        break;
      }
      console.warn('\u{1F534} [webview->ext] Unknown authReminderAction action:', action2);
      break;
    }
    case 'requireAuthentication': {
      Promise.resolve()
        .then(() => (init_FSMLogger(), FSMLogger_exports))
        .then(({ fsmLogger: fsmLogger2, FSMComponent: FSMComponent2 }) => {
          fsmLogger2.info(FSMComponent2.AUTH, 'Manual authentication required', {
            component: FSMComponent2.AUTH,
            connectionId: msg.connectionId,
            event: 'REQUIRE_AUTHENTICATION',
          });
        })
        .catch((error) => {
          console.error(
            '\u274C [AzureDevOpsInt][FSM] Failed to import FSM logger for require authentication:',
            error
          );
        });
      const connectionId = typeof msg.connectionId === 'string' ? msg.connectionId.trim() : '';
      if (!connectionId) {
        console.warn('\u{1F534} [webview->ext] requireAuthentication: missing connectionId');
        break;
      }
      console.log(
        '\u{1F510} [webview->ext] Manual authentication required for connection:',
        connectionId
      );
      const connectionState = connectionStates2.get(connectionId);
      if (connectionState?.reauthInProgress) {
        console.log('\u23F3 [webview->ext] Authentication already in progress for:', connectionId);
        break;
      }
      try {
        const { getConnectionFSMManager: getConnectionFSMManager2 } = await Promise.resolve().then(
          () => (init_ConnectionFSMManager(), ConnectionFSMManager_exports)
        );
        const fsmManager = getConnectionFSMManager2();
        if (connectionState?.config) {
          if (connectionState) {
            connectionState.reauthInProgress = true;
          }
          fsmManager.setEnabled(true);
          const result = await fsmManager.connectToConnection(connectionState.config, {
            refresh: true,
            interactive: true,
          });
          if (result.success) {
            console.log('\u2705 [webview->ext] FSM authentication successful for:', connectionId);
          } else {
            console.warn(
              '\u26A0\uFE0F [webview->ext] FSM authentication failed, falling back to legacy:',
              result.error
            );
            throw new Error(result.error || 'FSM authentication failed');
          }
        } else {
          console.warn(
            '\u26A0\uFE0F [webview->ext] No connection config found for FSM authentication'
          );
          throw new Error('No connection config available');
        }
      } catch (error) {
        console.error('\u274C [webview->ext] Failed to trigger FSM authentication:', error);
        triggerAuthReminderSignIn(connectionId, 'authFailed', {
          force: true,
          startInteractive: true,
        });
      } finally {
        if (connectionState) {
          connectionState.reauthInProgress = false;
        }
      }
      break;
    }
    case 'webviewReady': {
      if (panel) {
        notifyConnectionsList();
        const workItems = provider?.getWorkItems() || [];
        console.log('[azureDevOpsInt] Sending workItemsLoaded with', workItems.length, 'items');
        if (workItems.length > 0) {
          console.log('[azureDevOpsInt] First work item:', JSON.stringify(workItems[0], null, 2));
        }
        const snapshotQuery = getQueryForProvider(provider, activeConnectionId2);
        sendWorkItemsSnapshot({
          connectionId: activeConnectionId2,
          items: workItems,
          kanbanView: false,
          provider,
          query: snapshotQuery,
        });
        const snap = timer?.snapshot?.();
        if (snap)
          sendToWebview({
            type: 'timerUpdate',
            timer: snap,
            connectionId: timerConnectionInfo.id,
            connectionLabel: timerConnectionInfo.label,
            connectionOrganization: timerConnectionInfo.organization,
            connectionProject: timerConnectionInfo.project,
          });
        const uiPrefs = extensionContextRef2?.globalState.get(
          'azureDevOpsIntegration.uiPreferences',
          {
            kanbanView: false,
            filterText: '',
            typeFilter: '',
            stateFilter: 'all',
            sortKey: 'updated-desc',
          }
        );
        sendToWebview({ type: 'uiPreferences', preferences: uiPrefs });
        if (selfTestPending) {
          sendToWebview({ type: 'selfTestPing', nonce: selfTestPending.nonce });
        }
      }
      break;
    }
    case 'selfTestAck':
    case 'selfTestPong': {
      if (selfTestPending && msg.nonce === selfTestPending.nonce) {
        clearTimeout(selfTestPending.timeout);
        selfTestPending.resolve({ ok: true, details: msg.signature || 'ack' });
        selfTestPending = void 0;
        vscode8.window.showInformationMessage(
          `Webview self-test succeeded: ${msg.signature || 'ack'}`
        );
      }
      break;
    }
    case 'webviewRuntimeError': {
      const msgTxt = `[webviewRuntimeError] ${msg.message || 'Unknown error'}${msg.stack ? '\n' + msg.stack : ''}`;
      console.error(msgTxt);
      logLine(msgTxt);
      if (getConfig().get('debugLogging')) {
        vscode8.window.showErrorMessage(`Webview runtime error: ${msg.message || 'Unknown'}`);
      }
      break;
    }
    case 'refresh': {
      verbose('[webview] refresh requested', {
        hasProvider: !!provider,
        cachedCount:
          provider && typeof provider.getWorkItems === 'function'
            ? (provider.getWorkItems() || []).length
            : 0,
      });
      if (!provider && extensionContextRef2) {
        verbose('[webview] refresh no provider; ensuring connection');
        try {
          await ensureActiveConnection(extensionContextRef2, activeConnectionId2, {
            refresh: false,
          });
        } catch (e) {
          verbose('[webview] ensureActiveConnection failed in refresh', e?.message || e);
        }
      }
      const refreshQuery = getQueryForProvider(provider, activeConnectionId2);
      provider?.refresh(refreshQuery);
      break;
    }
    case 'getWorkItems': {
      verbose('Work items requested from webview');
      const cfg = getConfig();
      const requestedConnectionId =
        typeof msg.connectionId === 'string' ? msg.connectionId.trim() : '';
      const fallbackQuery = getDefaultQuery(cfg);
      const incomingQuery = normalizeQuery(msg.query);
      const targetConnectionId = requestedConnectionId || activeConnectionId2 || void 0;
      let resolvedQuery = fallbackQuery;
      if (targetConnectionId) {
        resolvedQuery = incomingQuery
          ? setStoredQueryForConnection(targetConnectionId, incomingQuery)
          : getStoredQueryForConnection(targetConnectionId, fallbackQuery);
      } else if (incomingQuery) {
        resolvedQuery = incomingQuery;
      }
      let currentProvider = provider;
      verbose('[getWorkItems] current state', {
        hasProvider: !!currentProvider,
        cachedCount:
          currentProvider && typeof currentProvider.getWorkItems === 'function'
            ? (currentProvider.getWorkItems() || []).length
            : 0,
        activeConnectionId: activeConnectionId2,
        requestedConnectionId,
        resolvedQuery,
      });
      if (!currentProvider && extensionContextRef2) {
        verbose('No provider available; attempting to ensure active connection');
        try {
          await ensureActiveConnection(extensionContextRef2, targetConnectionId, {
            refresh: false,
          });
        } catch (e) {
          verbose('ensureActiveConnection failed during getWorkItems request', e?.message || e);
        }
        currentProvider = provider;
      }
      const responseConnectionId = targetConnectionId ?? activeConnectionId2;
      if (!targetConnectionId && responseConnectionId) {
        resolvedQuery = incomingQuery
          ? setStoredQueryForConnection(responseConnectionId, incomingQuery)
          : getStoredQueryForConnection(responseConnectionId, fallbackQuery);
      }
      const workItems =
        currentProvider && typeof currentProvider.getWorkItems === 'function'
          ? currentProvider.getWorkItems() || []
          : [];
      verbose('[getWorkItems] responding with cached items', {
        count: workItems.length,
        connectionId: responseConnectionId,
      });
      sendWorkItemsSnapshot({
        connectionId: responseConnectionId,
        items: workItems,
        provider: currentProvider,
        query: resolvedQuery,
      });
      if (currentProvider && workItems.length === 0) {
        verbose('Provider returned zero cached work items; triggering refresh', {
          query: resolvedQuery,
        });
        try {
          currentProvider.refresh(resolvedQuery);
        } catch (e) {
          verbose('Provider refresh failed after empty cache response', e?.message || e);
        }
      }
      break;
    }
    case 'setQuery': {
      const connectionIdRaw = typeof msg.connectionId === 'string' ? msg.connectionId.trim() : '';
      const targetId = connectionIdRaw || activeConnectionId2 || '';
      console.log('[azureDevOpsInt] \u{1F50D} Query update requested:', {
        messageConnectionId: connectionIdRaw,
        resolvedTargetId: targetId,
        activeConnectionId: activeConnectionId2,
        newQuery: msg.query,
      });
      if (!targetId) {
        verbose('[setQuery] no connection id resolved; skipping');
        break;
      }
      const storedQuery = setStoredQueryForConnection(
        targetId,
        typeof msg.query === 'string' ? msg.query : void 0
      );
      const state2 = connectionStates2.get(targetId);
      const targetProvider =
        state2?.provider ?? (targetId === activeConnectionId2 ? provider : void 0);
      console.log('[azureDevOpsInt] \u{1F50D} Query updated:', {
        connectionId: targetId,
        storedQuery,
        hasProvider: !!targetProvider,
        isActiveConnection: targetId === activeConnectionId2,
      });
      verbose('[setQuery] applied new query', {
        connectionId: targetId,
        query: storedQuery,
        hasProvider: !!targetProvider,
      });
      targetProvider?.refresh(storedQuery);
      break;
    }
    case 'switchConnection':
    case 'setActiveConnection': {
      const targetId = typeof msg.connectionId === 'string' ? msg.connectionId.trim() : '';
      console.log('[azureDevOpsInt] \u{1F504} Connection switch requested:', {
        targetId,
        currentActiveConnectionId: activeConnectionId2,
        messageType: msg.type,
      });
      if (!targetId) {
        verbose('[setActiveConnection] missing connectionId in message');
        break;
      }
      if (!extensionContextRef2) {
        verbose('[setActiveConnection] missing extension context');
        break;
      }
      try {
        const state2 = await ensureActiveConnection(extensionContextRef2, targetId, {
          refresh: false,
        });
        const activeProvider = state2?.provider;
        const cfg = getConfig();
        const selectedQuery = getStoredQueryForConnection(targetId, getDefaultQuery(cfg));
        console.log('[azureDevOpsInt] \u{1F504} Connection switched successfully:', {
          newActiveConnectionId: activeConnectionId2,
          targetId,
          selectedQuery,
          hasProvider: !!activeProvider,
        });
        sendToWebview({
          type: 'queryChanged',
          query: selectedQuery,
          connectionId: targetId,
          description: `Query for connection ${targetId}`,
        });
        const cachedItems =
          activeProvider && typeof activeProvider.getWorkItems === 'function'
            ? activeProvider.getWorkItems() || []
            : [];
        sendWorkItemsSnapshot({
          connectionId: targetId,
          items: cachedItems,
          kanbanView: false,
          provider: activeProvider,
          query: selectedQuery,
        });
        if (activeProvider && cachedItems.length === 0) {
          activeProvider.refresh(selectedQuery);
        } else if (activeProvider && cachedItems.length > 0) {
          setTimeout(() => {
            try {
              activeProvider.refresh(selectedQuery);
            } catch (e) {
              verbose('[setActiveConnection] refresh after cached post failed', e?.message || e);
            }
          }, 0);
        } else if (!activeProvider) {
          sendWorkItemsSnapshot({
            connectionId: targetId,
            items: [],
            kanbanView: false,
            types: [],
            query: selectedQuery,
          });
        }
      } catch (e) {
        console.error('[setActiveConnection] failed', e);
        vscode8.window.showErrorMessage(
          'Failed to switch Azure DevOps project: ' + (e?.message || String(e))
        );
      }
      break;
    }
    case 'moveWorkItem': {
      const id =
        typeof msg.id === 'number'
          ? msg.id
          : typeof msg.workItemId === 'number'
            ? msg.workItemId
            : void 0;
      const target = typeof msg.target === 'string' ? msg.target : void 0;
      const targetState = typeof msg.targetState === 'string' ? msg.targetState : void 0;
      if (!id || (!target && !targetState)) {
        panel?.webview.postMessage({
          type: 'moveWorkItemResult',
          id,
          success: false,
          error: 'Missing id or target state',
        });
        break;
      }
      try {
        if (!client || !provider) throw new Error('Not connected');
        const map = {
          todo: 'To Do',
          new: 'New',
          approved: 'Approved',
          committed: 'Committed',
          active: 'Active',
          inprogress: 'In Progress',
          review: 'Review',
          resolved: 'Resolved',
          done: 'Done',
          closed: 'Closed',
          removed: 'Removed',
        };
        let desired =
          (targetState && String(targetState)) || (target ? map[target] : void 0) || 'Active';
        const current = provider.getWorkItems().find((w) => Number(w.id) === Number(id));
        const wiType = current?.fields?.['System.WorkItemType'];
        if (wiType) {
          try {
            const states = await client.getWorkItemTypeStates(String(wiType));
            const match = desired
              ? states.find((s) => s.toLowerCase() === String(desired).toLowerCase())
              : void 0;
            if (!match) {
              const synonyms = {
                'To Do': ['New', 'Proposed', 'Approved'],
                Active: ['Committed'],
                'In Progress': ['Doing'],
                Review: ['Code Review', 'Testing', 'QA'],
                Resolved: ['Fixed'],
                Done: ['Closed', 'Completed'],
                Removed: ['Cut', 'Abandoned'],
              };
              const cand = Object.entries(synonyms).find(
                ([k]) => k.toLowerCase() === desired.toLowerCase()
              );
              if (cand) desired = cand[0];
            } else desired = match;
            if (!states.some((s) => s.toLowerCase() === desired.toLowerCase())) {
              throw new Error(`State '${desired}' not valid for type ${wiType}`);
            }
          } catch (stateErr) {
            verbose('State validation warning ' + (stateErr?.message || String(stateErr)));
          }
        }
        await client.updateWorkItem(id, [
          { op: 'add', path: '/fields/System.State', value: desired },
        ]);
        const postUpdateQuery = getQueryForProvider(provider, activeConnectionId2);
        provider.refresh(postUpdateQuery);
        panel?.webview.postMessage({
          type: 'moveWorkItemResult',
          id,
          success: true,
          newState: desired,
        });
      } catch (e) {
        console.error('Failed to move work item', e);
        panel?.webview.postMessage({
          type: 'moveWorkItemResult',
          id,
          success: false,
          error: e?.message || String(e),
        });
      }
      break;
    }
    case 'viewWorkItem': {
      const id = typeof msg.workItemId === 'number' ? msg.workItemId : void 0;
      if (typeof id === 'number' && provider) {
        const baseUrl = provider.client?.getBrowserUrl?.('') || '';
        if (baseUrl) {
          const workItemUrl = `${baseUrl}/_workitems/edit/${id}`;
          vscode8.env.openExternal(vscode8.Uri.parse(workItemUrl));
        }
      }
      break;
    }
    case 'startTimer': {
      const id =
        typeof msg.workItemId === 'number'
          ? msg.workItemId
          : typeof msg.id === 'number'
            ? msg.id
            : void 0;
      if (typeof id !== 'number') break;
      const activeState = timer?.snapshot?.();
      if (activeState) {
        const runningConnectionLabel = getActiveTimerConnectionLabel();
        const message = runningConnectionLabel
          ? `A timer is already running for ${runningConnectionLabel}. Stop it before starting another.`
          : 'A timer is already running. Stop it before starting another.';
        vscode8.window.showInformationMessage(message);
        break;
      }
      const wi = provider
        ?.getWorkItems()
        .find((w) => w.id === id || w.fields?.['System.Id'] === id);
      if (!wi) break;
      const connection = activeConnectionId2
        ? connections2.find((c) => c.id === activeConnectionId2)
        : void 0;
      const previousInfo = { ...timerConnectionInfo };
      setTimerConnectionFrom(connection);
      const started = timer?.start(
        Number(wi.id || wi.fields?.['System.Id']),
        wi.fields?.['System.Title'] || `#${id}`
      );
      if (!started) timerConnectionInfo = previousInfo;
      break;
    }
    case 'pauseTimer':
      timer?.pause();
      break;
    case 'resumeTimer':
      timer?.resume();
      break;
    case 'stopTimer': {
      const timerConnectionSnapshot = { ...timerConnectionInfo };
      setTimerConnectionFrom(void 0);
      const stopped = timer?.stop();
      updateTimerContext(void 0);
      if (stopped) {
        try {
          await handleTimerStopAndOfferUpdate(stopped, { connection: timerConnectionSnapshot });
        } catch (e) {
          console.error('Error applying timer updates', e);
          vscode8.window.showErrorMessage(
            'Failed to process timer update: ' + (e?.message || String(e))
          );
        }
      }
      break;
    }
    case 'showStopTimerOptions': {
      const timerConnectionSnapshot = { ...timerConnectionInfo };
      setTimerConnectionFrom(void 0);
      const stopped = timer?.stop();
      updateTimerContext(void 0);
      if (stopped) {
        try {
          await handleTimerStopAndOfferUpdate(stopped, {
            offerCopilot: false,
            connection: timerConnectionSnapshot,
          });
        } catch (e) {
          console.error('Error applying timer updates', e);
          vscode8.window.showErrorMessage(
            'Failed to process timer update: ' + (e?.message || String(e))
          );
        }
      }
      break;
    }
    case 'activity':
      verbose('Activity ping received');
      timer?.activityPing();
      break;
    case 'webviewConsole': {
      const lvl = msg.level || 'log';
      const text2 = `[webviewConsole][${lvl}] ${(msg.args || []).join(' ')}`;
      if (lvl === 'error') console.error(text2);
      else if (lvl === 'warn') console.warn(text2);
      else console.log(text2);
      logLine(text2);
      break;
    }
    case 'preImportDescriptor': {
      const text2 = `[preImportDescriptor] ${JSON.stringify(msg.snapshot)}`;
      console.log(text2);
      logLine(text2);
      break;
    }
    case 'generateCopilotPrompt': {
      const id = typeof msg.workItemId === 'number' ? msg.workItemId : void 0;
      if (!id) {
        vscode8.window.showWarningMessage('No work item specified for Copilot prompt generation.');
        break;
      }
      const timerSnapshot = timer?.snapshot?.();
      try {
        await produceWorkItemSummary({
          workItemId: id,
          draftSummary: typeof msg.draftSummary === 'string' ? msg.draftSummary : void 0,
          entrySeed: entrySeedFromMessage(msg, id),
          reason: 'manualPrompt',
          stillRunningTimer:
            !!timerSnapshot &&
            Number(timerSnapshot.workItemId) === Number(id) &&
            !timerSnapshot.isPaused,
        });
      } catch (e) {
        console.error('Failed to create Copilot prompt', e);
        vscode8.window.showErrorMessage(
          'Failed to generate Copilot prompt: ' + (e?.message || String(e))
        );
      }
      break;
    }
    case 'submitComposeComment': {
      const workItemId = typeof msg.workItemId === 'number' ? msg.workItemId : void 0;
      const comment2 = typeof msg.comment === 'string' ? msg.comment.trim() : '';
      const mode = typeof msg.mode === 'string' ? msg.mode : 'addComment';
      const timerData = msg.timerData;
      const connectionInfo = msg.connectionInfo;
      if (!workItemId) {
        vscode8.window.showWarningMessage('No work item specified for comment.');
        sendToWebview({
          type: 'composeCommentResult',
          workItemId: 0,
          success: false,
          error: 'No work item specified',
        });
        break;
      }
      try {
        let targetClient = client;
        if (mode === 'timerStop' && connectionInfo) {
          targetClient = getClientForConnectionInfo(connectionInfo);
        }
        if (!targetClient) {
          throw new Error('Client not initialized');
        }
        if (mode === 'timerStop' && timerData) {
          const wi = await targetClient.getWorkItemById(workItemId);
          if (!wi) throw new Error('Work item not found');
          const currCompleted =
            Number(wi.fields?.['Microsoft.VSTS.Scheduling.CompletedWork'] || 0) || 0;
          const currRemaining =
            Number(wi.fields?.['Microsoft.VSTS.Scheduling.RemainingWork'] || 0) || 0;
          const hours = Number(timerData.hoursDecimal || timerData.duration / 3600 || 0);
          const finalCompleted = Number((currCompleted + hours).toFixed(2));
          const finalRemaining = Number(Math.max(0, currRemaining - hours).toFixed(2));
          const patch = [
            {
              op: 'add',
              path: '/fields/Microsoft.VSTS.Scheduling.CompletedWork',
              value: finalCompleted,
            },
            {
              op: 'add',
              path: '/fields/Microsoft.VSTS.Scheduling.RemainingWork',
              value: finalRemaining,
            },
          ];
          await targetClient.updateWorkItem(workItemId, patch);
          if (comment2 && comment2.trim()) {
            await targetClient.addWorkItemComment(
              workItemId,
              `Time tracked: ${hours.toFixed(2)} hours. ${comment2}`
            );
          }
          sendToWebview({
            type: 'composeCommentResult',
            workItemId,
            success: true,
            mode,
            hours,
          });
          vscode8.window.showInformationMessage(
            `Work item #${workItemId} updated: Completed ${finalCompleted}h, Remaining ${finalRemaining}h.`
          );
        } else {
          await targetClient.addWorkItemComment(workItemId, comment2);
          sendToWebview({
            type: 'composeCommentResult',
            workItemId,
            success: true,
            mode,
          });
          vscode8.window.showInformationMessage(`Comment added to work item #${workItemId}.`);
        }
      } catch (err) {
        console.error('Failed to submit compose comment', err);
        vscode8.window.showErrorMessage(
          `Failed to ${mode === 'timerStop' ? 'apply timer update' : 'add comment'}: ` +
            (err?.message || String(err))
        );
        sendToWebview({
          type: 'composeCommentResult',
          workItemId,
          success: false,
          error: err?.message || String(err),
          mode,
        });
      }
      break;
    }
    case 'stopAndApply': {
      const comment2 = typeof msg.comment === 'string' ? msg.comment : '';
      const stopped = timer?.stop(async (finishedId, hoursDecimal) => {
        try {
          const wi = await client?.getWorkItemById(finishedId);
          if (!wi) return;
          const currCompleted =
            Number(wi.fields?.['Microsoft.VSTS.Scheduling.CompletedWork'] || 0) || 0;
          const currRemaining =
            Number(wi.fields?.['Microsoft.VSTS.Scheduling.RemainingWork'] || 0) || 0;
          const finalCompleted = Number((currCompleted + hoursDecimal).toFixed(2));
          const finalRemaining = Number(Math.max(0, currRemaining - hoursDecimal).toFixed(2));
          const patch = [
            {
              op: 'add',
              path: '/fields/Microsoft.VSTS.Scheduling.CompletedWork',
              value: finalCompleted,
            },
            {
              op: 'add',
              path: '/fields/Microsoft.VSTS.Scheduling.RemainingWork',
              value: finalRemaining,
            },
          ];
          if (!client) throw new Error('Client not initialized');
          await client.updateWorkItem(finishedId, patch);
          if (comment2 && comment2.trim()) {
            if (!client) throw new Error('Client not initialized');
          }
          await client.addWorkItemComment(
            finishedId,
            `Time tracked: ${hoursDecimal.toFixed(2)} hours. ${comment2}`
          );
          panel?.webview.postMessage({
            type: 'stopAndApplyResult',
            workItemId: finishedId,
            hours: hoursDecimal,
          });
          vscode8.window.showInformationMessage(
            `Work item #${finishedId} updated: Completed ${finalCompleted}h, Remaining ${finalRemaining}h.`
          );
        } catch (err) {
          console.error('stopAndApply failed', err);
          vscode8.window.showErrorMessage(
            'Failed to apply time entry: ' + (err?.message || String(err))
          );
        }
      });
      if (!stopped) vscode8.window.showInformationMessage('No active timer to stop.');
      updateTimerContext(void 0);
      break;
    }
    case 'addComment': {
      const workItemId = typeof msg.workItemId === 'number' ? msg.workItemId : void 0;
      let comment2 = typeof msg.comment === 'string' ? msg.comment.trim() : void 0;
      if (!workItemId) {
        vscode8.window.showWarningMessage('No work item specified for comment.');
        break;
      }
      if (comment2 && comment2.length > 0) {
        try {
          if (!client) throw new Error('Client not initialized');
          await client.addWorkItemComment(workItemId, comment2);
          vscode8.window.showInformationMessage(`Comment added to work item #${workItemId}.`);
          sendToWebview({ type: 'addCommentResult', workItemId, success: true });
        } catch (err) {
          console.error('Failed to add comment', err);
          vscode8.window.showErrorMessage(
            'Failed to add comment: ' + (err?.message || String(err))
          );
          sendToWebview({
            type: 'addCommentResult',
            workItemId,
            success: false,
            error: err?.message || String(err),
          });
        }
        break;
      }
      sendToWebview({
        type: 'showComposeComment',
        workItemId,
        mode: 'addComment',
      });
      break;
    }
    case 'uiPreferenceChanged': {
      if (extensionContextRef2 && msg.preferences) {
        await extensionContextRef2.globalState.update(
          'azureDevOpsIntegration.uiPreferences',
          msg.preferences
        );
      }
      break;
    }
    case 'ready': {
      console.log('\u2705 [webview->ext] Webview ready message received');
      if (panel && activeConnectionId2) {
        const currentQuery = getStoredQueryForConnection(activeConnectionId2);
        console.log('\u{1F4E4} [webview->ext] Sending initial query to webview:', {
          connectionId: activeConnectionId2,
          query: currentQuery,
        });
        sendToWebview({
          type: 'queryChanged',
          query: currentQuery,
          connectionId: activeConnectionId2,
          description: `Initial query for connection ${activeConnectionId2}`,
        });
      }
      break;
    }
    default:
      console.warn('Unknown webview message', msg);
      verbose('Unknown message type');
  }
}
async function selfTestWebview() {
  try {
    const attempt = async () => {
      if (!panel) revealWorkItemsView();
      if (!panel) {
        await new Promise((r) => setTimeout(r, 250));
      }
      if (!panel) throw new Error('Webview panel not available');
      if (selfTestPending) throw new Error('A self-test is already running');
      const nonce = getNonce();
      const promise = new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          if (selfTestPending) {
            selfTestPending = void 0;
            reject(new Error('Self-test timeout waiting for ack'));
          }
        }, 4e3);
        selfTestPending = { nonce, resolve, reject, timeout };
      });
      sendToWebview({ type: 'selfTestPing', nonce });
      return promise;
    };
    const result = await attempt();
    verbose('[selfTest] success', result.details);
  } catch (e) {
    verbose('[selfTest] failed', e?.message || e);
    vscode8.window.showErrorMessage(`Webview self-test failed: ${e?.message || e}`);
  }
}
async function migrateGlobalPATToConnections(context, conns) {
  try {
    const global2 = await context.secrets.get(PAT_KEY);
    if (!global2) return;
    for (const c of conns) {
      if (!c.patKey) continue;
      try {
        const existing = await context.secrets.get(c.patKey);
        if (!existing) {
          await context.secrets.store(c.patKey, global2);
          console.log(`[azureDevOpsInt] Migrated global PAT into connection ${c.id}`);
        }
      } catch (e) {
        console.warn(`[azureDevOpsInt] Failed migrating PAT to connection ${c.id}`, e);
      }
    }
    try {
      await context.secrets.delete(PAT_KEY);
      console.log('[azureDevOpsInt] Deleted global PAT after migrating to connections');
    } catch (e) {
      console.warn('[azureDevOpsInt] Failed to delete global PAT after migration', e);
    }
  } catch (e) {
    console.warn('[azureDevOpsInt] migrateGlobalPATToConnections failed', e);
  }
}
async function getSecretPAT2(context, connectionId) {
  if (connectionId) {
    const connection = connections2.find((conn) => conn.id === connectionId);
    if (connection?.patKey) {
      return context.secrets.get(connection.patKey);
    }
  }
  return void 0;
}
function persistTimer(context, data) {
  if (data.updateLastSave) context.globalState.update(STATE_LAST_SAVE, Date.now());
  const stateToPersist = data.state
    ? {
        ...data.state,
        __defaultElapsedLimitHours: data.defaultElapsedLimitHours,
        __connectionId: timerConnectionInfo.id,
        __connectionLabel: timerConnectionInfo.label,
        __connectionOrganization: timerConnectionInfo.organization,
        __connectionProject: timerConnectionInfo.project,
      }
    : void 0;
  context.globalState.update(STATE_TIMER, stateToPersist);
  context.globalState.update(STATE_TIME_ENTRIES, data.timeEntries);
  context.globalState.update(
    STATE_TIMER_CONNECTION,
    timerConnectionInfo.id ? { ...timerConnectionInfo } : void 0
  );
}
function restoreTimer(context) {
  const persistedState = context.globalState.get(STATE_TIMER);
  const persistedConnection = context.globalState.get(STATE_TIMER_CONNECTION);
  const embedded = persistedState
    ? {
        id: persistedState.__connectionId,
        label: persistedState.__connectionLabel,
        organization: persistedState.__connectionOrganization,
        project: persistedState.__connectionProject,
      }
    : {};
  const restored = {
    id: embedded.id ?? persistedConnection?.id,
    label: embedded.label ?? persistedConnection?.label,
    organization: embedded.organization ?? persistedConnection?.organization,
    project: embedded.project ?? persistedConnection?.project,
  };
  timerConnectionInfo =
    restored.id || restored.label || restored.organization || restored.project ? restored : {};
  if (persistedState) {
    delete persistedState.__connectionId;
    delete persistedState.__connectionLabel;
    delete persistedState.__connectionOrganization;
    delete persistedState.__connectionProject;
  }
  return {
    state: persistedState,
    timeEntries: context.globalState.get(STATE_TIME_ENTRIES) || [],
    defaultElapsedLimitHours: persistedState?.__defaultElapsedLimitHours,
  };
}
function buildMinimalWebviewHtml(context, webview, nonce) {
  const htmlPath = path4.join(context.extensionPath, 'media', 'webview', 'svelte.html');
  console.log('[azureDevOpsInt] \u{1F50D} buildMinimalWebviewHtml: Starting HTML generation');
  console.log('[azureDevOpsInt] \u{1F50D} Extension path:', context.extensionPath);
  console.log('[azureDevOpsInt] \u{1F50D} Extension URI:', context.extensionUri.toString());
  console.log('[azureDevOpsInt] \u{1F50D} HTML path:', htmlPath);
  console.log('[azureDevOpsInt] \u{1F50D} Nonce:', nonce);
  let html2;
  try {
    console.log('[azureDevOpsInt] \u{1F50D} Attempting to read HTML file...');
    html2 = fs.readFileSync(htmlPath, 'utf8');
    console.log('[azureDevOpsInt] \u{1F50D} Successfully read HTML file, length:', html2.length);
    console.log(
      '[azureDevOpsInt] \u{1F50D} HTML content preview (first 200 chars):',
      html2.substring(0, 200)
    );
  } catch (error) {
    console.error('[azureDevOpsInt] \u{1F50D} Failed to read HTML file:', error);
    console.error('[azureDevOpsInt] \u{1F50D} HTML file path:', htmlPath);
    console.error('[azureDevOpsInt] \u{1F50D} HTML file exists:', fs.existsSync(htmlPath));
    return `<!DOCTYPE html><html><head><title>Error</title></head><body><h1>Failed to load webview</h1></body></html>`;
  }
  const mediaRoot = vscode8.Uri.joinPath(context.extensionUri, 'media', 'webview');
  const version4 = getExtensionVersion(context);
  const scriptUri = webview.asWebviewUri(vscode8.Uri.joinPath(mediaRoot, 'reactive-main.js'));
  const scriptUriWithVersion = scriptUri.with({ query: `v=${encodeURIComponent(version4)}` });
  const scriptUriStr = scriptUriWithVersion.toString();
  console.log('[azureDevOpsInt] \u{1F50D} Media root URI:', mediaRoot.toString());
  console.log('[azureDevOpsInt] \u{1F50D} Extension version:', version4);
  console.log('[azureDevOpsInt] \u{1F50D} Script URI (before version):', scriptUri.toString());
  console.log('[azureDevOpsInt] \u{1F50D} Script URI (with version):', scriptUriStr);
  const scriptFsPath = path4.join(context.extensionPath, 'media', 'webview', 'reactive-main.js');
  console.log('[azureDevOpsInt] \u{1F50D} Script file path:', scriptFsPath);
  console.log('[azureDevOpsInt] \u{1F50D} Script file exists:', fs.existsSync(scriptFsPath));
  let cssLinkTag = '';
  try {
    const cssFsPath = path4.join(context.extensionPath, 'media', 'webview', 'reactive-main.css');
    console.log('[azureDevOpsInt] \u{1F50D} CSS file path:', cssFsPath);
    console.log('[azureDevOpsInt] \u{1F50D} CSS file exists:', fs.existsSync(cssFsPath));
    if (fs.existsSync(cssFsPath)) {
      const cssUri = webview
        .asWebviewUri(vscode8.Uri.joinPath(mediaRoot, 'reactive-main.css'))
        .with({ query: `v=${encodeURIComponent(version4)}` })
        .toString();
      cssLinkTag = `<link rel="stylesheet" href="${cssUri}" />`;
      console.log('[azureDevOpsInt] \u{1F50D} CSS link tag:', cssLinkTag);
    } else {
      console.log('[azureDevOpsInt] \u{1F50D} CSS file not found, skipping CSS injection');
    }
  } catch (cssError) {
    console.error('[azureDevOpsInt] \u{1F50D} CSS injection error:', cssError);
  }
  const csp = `default-src 'none'; img-src ${webview.cspSource} data:; style-src ${webview.cspSource} 'unsafe-inline'; script-src 'nonce-${nonce}' ${webview.cspSource}`;
  console.log('[azureDevOpsInt] \u{1F50D} CSP:', csp);
  const consoleBridge = `(function(){try{var vs=window.vscode||acquireVsCodeApi();['log','warn','error'].forEach(function(m){var orig=console[m];console[m]=function(){try{vs.postMessage({type:'webviewConsole', level:m, args:Array.from(arguments).map(a=>{try{return a&&a.stack?String(a.stack):typeof a==='object'?JSON.stringify(a):String(a);}catch{return String(a);}})});}catch{};return orig.apply(console,arguments);};});console.log('[webview] Azure DevOps Integration v${version4}');}catch(e){/* ignore */}})();`;
  console.log('[azureDevOpsInt] \u{1F50D} Starting HTML transformations...');
  const originalHtml = html2;
  html2 = html2.replace(
    '<meta charset="UTF-8">',
    `<meta charset="UTF-8"><meta http-equiv="Content-Security-Policy" content="${csp}">`
  );
  console.log('[azureDevOpsInt] \u{1F50D} CSP replacement done, changed:', originalHtml !== html2);
  const beforeScriptReplace = html2;
  html2 = html2.replace('./reactive-main.js', scriptUriStr);
  console.log(
    '[azureDevOpsInt] \u{1F50D} Script source replacement done, changed:',
    beforeScriptReplace !== html2
  );
  if (cssLinkTag) {
    const beforeCssReplace = html2;
    html2 = html2.replace(
      '</head>',
      `${cssLinkTag}
</head>`
    );
    console.log(
      '[azureDevOpsInt] \u{1F50D} CSS injection done, changed:',
      beforeCssReplace !== html2
    );
  }
  const beforeFinalReplace = html2;
  html2 = html2.replace(
    '<script type="module" crossorigin src="./reactive-main.js"></script>',
    `<script nonce="${nonce}">(function(){try{if(!window.vscode){window.vscode=acquireVsCodeApi();}}catch(e){console.error('[webview] acquireVsCodeApi failed',e);}})();</script><script nonce="${nonce}">${consoleBridge}</script><script type="module" nonce="${nonce}" src="${scriptUriStr}"></script>`
  );
  console.log(
    '[azureDevOpsInt] \u{1F50D} Final script replacement done, changed:',
    beforeFinalReplace !== html2
  );
  console.log('[azureDevOpsInt] \u{1F50D} Final HTML length:', html2.length);
  console.log(
    '[azureDevOpsInt] \u{1F50D} Final HTML preview (last 200 chars):',
    html2.substring(html2.length - 200)
  );
  return html2;
}
function getNonce() {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let v = '';
  for (let i = 0; i < 16; i++) v += chars.charAt(Math.floor(Math.random() * chars.length));
  return v;
}
async function setupConnection(context) {
  await ensureConnectionsInitialized(context);
  await migrateLegacyPAT(context);
  const hasExistingConnections = connections2.length > 0;
  let action2;
  if (!hasExistingConnections) {
    action2 = 'add';
  } else {
    const canSwitch = connections2.length > 1;
    const hasPatConnections = connections2.some(
      (connection) => !connection.authMethod || connection.authMethod === 'pat'
    );
    const hasEntraConnections = connections2.some(
      (connection) => connection.authMethod === 'entra'
    );
    const quickPickItems = [];
    quickPickItems.push(
      {
        label: 'Add new project\u2026',
        description: 'Connect to another organization/project',
        action: 'add',
      },
      {
        label: 'Manage existing project\u2026',
        description: 'Edit, replace, or remove an existing project',
        action: 'manage',
      },
      {
        label: 'Remove project\u2026',
        description: 'Disconnect an existing project',
        action: 'remove',
      }
    );
    if (canSwitch) {
      quickPickItems.push({
        label: 'Switch active project\u2026',
        description: 'Choose which project the sidebar uses by default',
        action: 'switch',
      });
    }
    quickPickItems.push({
      label: 'Sign in with Microsoft Entra ID\u2026',
      description: 'Authenticate a connection using Entra ID',
      action: 'entraSignIn',
    });
    if (hasEntraConnections) {
      quickPickItems.push({
        label: 'Sign out from Microsoft Entra ID\u2026',
        description: 'Remove cached tokens for an Entra-enabled connection',
        action: 'entraSignOut',
      });
    }
    if (hasPatConnections) {
      quickPickItems.push({
        label: 'Convert a PAT connection to Entra ID\u2026',
        description: 'Upgrade authentication for an existing PAT project',
        action: 'convertToEntra',
      });
    }
    const pick = await vscode8.window.showQuickPick(quickPickItems, {
      placeHolder: 'Manage Azure DevOps projects',
      ignoreFocusOut: true,
    });
    action2 = pick?.action;
  }
  if (!action2) {
    return;
  }
  if (action2 === 'add') {
    const setupService = new FSMSetupService(context);
    const result = await setupService.startSetup();
    if (result.status === 'success') {
      await ensureConnectionsInitialized(context);
      ensureTimer(context);
      if (result.connectionId) {
        const newConnection = connections2.find((c) => c.id === result.connectionId);
        if (newConnection) {
          activeConnectionId2 = result.connectionId;
          await context.globalState.update(ACTIVE_CONNECTION_STATE_KEY, activeConnectionId2);
          vscode8.window.showInformationMessage(
            `Connection "${newConnection.label || `${newConnection.organization}/${newConnection.project}`}" added and activated successfully.`
          );
        }
      }
    }
  } else if (action2 === 'manage') {
    const setupService = new FSMSetupService(context);
    const result = await setupService.startSetup({ skipInitialChoice: true });
    if (result.status === 'success') {
      await ensureConnectionsInitialized(context);
      ensureTimer(context);
      if (result.connectionId) {
        const updatedConnection = connections2.find((c) => c.id === result.connectionId);
        if (updatedConnection) {
          vscode8.window.showInformationMessage(
            `Project "${updatedConnection.label || `${updatedConnection.organization}/${updatedConnection.project}`}" updated successfully.`
          );
        }
      }
    }
  } else if (action2 === 'remove') {
    const removed = await promptRemoveConnection(context);
    if (removed) {
      ensureTimer(context);
    }
  } else if (action2 === 'switch') {
    const switched = await promptSwitchActiveConnection(context);
    if (switched) {
      ensureTimer(context);
    }
  } else if (action2 === 'entraSignIn') {
    await signInWithEntra(context);
  } else if (action2 === 'entraSignOut') {
    await signOutEntra(context);
  } else if (action2 === 'convertToEntra') {
    await convertConnectionToEntra(context);
  }
}
async function signInWithEntra(context, targetConnectionId, options = {}) {
  await ensureConnectionsInitialized(context);
  if (connections2.length === 0) {
    vscode8.window.showInformationMessage(
      'No connections configured. Please add a connection first.'
    );
    return;
  }
  let connection;
  if (targetConnectionId) {
    connection = connections2.find((conn) => conn.id === targetConnectionId);
    if (!connection) {
      vscode8.window.showWarningMessage('Selected connection is no longer available.');
      return void 0;
    }
  } else {
    const entraEligible = connections2.filter((conn) => conn.authMethod === 'entra');
    if (entraEligible.length === 0) {
      vscode8.window.showInformationMessage(
        'No connections configured for Microsoft Entra ID. Convert or add a connection first.'
      );
      return;
    }
    if (entraEligible.length === 1) {
      connection = entraEligible[0];
    } else {
      const connectionItems = entraEligible.map((conn) => ({
        label: conn.label || `${conn.organization}/${conn.project}`,
        description: conn.authMethod === 'entra' ? '(Entra ID)' : '(PAT)',
        detail: `Organization: ${conn.organization}, Project: ${conn.project}`,
        connection: conn,
      }));
      const selected = await vscode8.window.showQuickPick(connectionItems, {
        placeHolder: 'Select a connection to sign in with Microsoft Entra ID',
        ignoreFocusOut: true,
      });
      if (!selected) {
        return void 0;
      }
      connection = selected.connection;
    }
  }
  if (!connection) {
    return;
  }
  const connectionLabel = describeConnection(connection);
  const statusMsg = vscode8.window.setStatusBarMessage(
    `\u{1F510} Starting Entra ID authentication...`,
    5e3
  );
  try {
    console.log(
      `\u{1F510} [signInWithEntra] Starting FSM-based Entra authentication for ${connection.id}`
    );
    const { getConnectionFSMManager: getConnectionFSMManager2 } = await Promise.resolve().then(
      () => (init_ConnectionFSMManager(), ConnectionFSMManager_exports)
    );
    const fsmManager = getConnectionFSMManager2();
    fsmManager.setEnabled(true);
    const connectionState = connectionStates2.get(connection.id);
    if (connectionState) {
      connectionState.authMethod = 'entra';
    }
    const updatedConnection = {
      ...connection,
      authMethod: 'entra',
    };
    const result = await fsmManager.connectToConnection(updatedConnection, {
      refresh: true,
      interactive: options.forceInteractive || true,
    });
    if (result.success) {
      statusMsg.dispose();
      console.log(`\u2705 [signInWithEntra] Entra authentication successful for ${connection.id}`);
      if (options.showSuccessMessage) {
        vscode8.window.showInformationMessage(
          `Successfully signed in to ${connectionLabel} with Microsoft Entra ID.`
        );
      }
    } else {
      statusMsg.dispose();
      throw new Error(result.error || 'Entra authentication failed');
    }
  } catch (error) {
    statusMsg.dispose();
    console.error(`\u274C [signInWithEntra] Failed to authenticate with Entra ID:`, error);
    vscode8.window.showErrorMessage(
      `Failed to sign in to ${connectionLabel} with Microsoft Entra ID: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
async function signOutEntra(context, targetConnectionId, options = {}) {
  await ensureConnectionsInitialized(context);
  const entraConnections = connections2.filter((conn) => conn.authMethod === 'entra');
  if (entraConnections.length === 0) {
    vscode8.window.showInformationMessage('No Entra ID connections found.');
    return;
  }
  let connection;
  if (targetConnectionId) {
    connection = entraConnections.find((conn) => conn.id === targetConnectionId);
    if (!connection) {
      vscode8.window.showWarningMessage('Selected connection is no longer available.');
      return;
    }
  } else {
    const connectionItems = entraConnections.map((conn) => ({
      label: conn.label || `${conn.organization}/${conn.project}`,
      description: '(Entra ID)',
      detail: `Organization: ${conn.organization}, Project: ${conn.project}`,
      connection: conn,
    }));
    const selected = await vscode8.window.showQuickPick(connectionItems, {
      placeHolder: 'Select a connection to sign out from',
      ignoreFocusOut: true,
    });
    if (!selected) {
      return;
    }
    connection = selected.connection;
  }
  if (!connection) {
    return;
  }
  const state2 = connectionStates2.get(connection.id);
  try {
    await context.secrets.delete(`entra_refresh_token_${connection.id}`);
    await context.secrets.delete(`entra_access_token_${connection.id}`);
    if (state2) {
      state2.accessToken = void 0;
    }
    if (options.showSuccessMessage !== false) {
      vscode8.window.showInformationMessage(
        `Successfully signed out from "${connection.label || connection.organization}".`
      );
    }
    clearAuthReminder(connection.id);
    if (connection.id === activeConnectionId2) {
      provider = void 0;
      client = void 0;
      await vscode8.commands.executeCommand('setContext', 'azureDevOpsInt.connected', false);
    }
  } catch (error) {
    console.error('[azureDevOpsInt] Sign out failed:', error);
    vscode8.window.showErrorMessage(`Sign out failed: ${error.message}`);
  }
}
async function convertConnectionToEntra(context) {
  await ensureConnectionsInitialized(context);
  const patConnections = connections2.filter(
    (conn) => !conn.authMethod || conn.authMethod === 'pat'
  );
  if (patConnections.length === 0) {
    vscode8.window.showInformationMessage('No PAT-based connections to convert.');
    return;
  }
  const connectionItems = patConnections.map((conn) => ({
    label: conn.label || `${conn.organization}/${conn.project}`,
    description: '(PAT)',
    detail: `Organization: ${conn.organization}, Project: ${conn.project}`,
    connection: conn,
  }));
  const selected = await vscode8.window.showQuickPick(connectionItems, {
    placeHolder: 'Select a connection to convert to Entra ID',
    ignoreFocusOut: true,
  });
  if (!selected) {
    return;
  }
  const connection = selected.connection;
  const confirm = await vscode8.window.showWarningMessage(
    `This will convert "${connection.label || connection.organization}" to use Microsoft Entra ID authentication instead of a Personal Access Token. The PAT will be removed. Continue?`,
    'Yes, Convert',
    'Cancel'
  );
  if (confirm !== 'Yes, Convert') {
    return;
  }
  const settings = getConfig();
  const defaultClientId =
    settings.get('entra.defaultClientId') || '872cd9fa-d31f-45e0-9eab-6e460a02d1f1';
  const defaultTenantId = settings.get('entra.defaultTenantId') || 'organizations';
  vscode8.window.showInformationMessage(
    `Entra ID authentication conversion is not yet implemented in the FSM architecture. Please use PAT authentication for now.`
  );
  console.log(
    '[azureDevOpsInt] Entra ID conversion requested but not yet implemented in FSM architecture'
  );
  return;
}
async function promptSwitchActiveConnection(context) {
  await ensureConnectionsInitialized(context);
  if (connections2.length === 0) {
    vscode8.window.showInformationMessage('No project connections configured yet.');
    return false;
  }
  if (connections2.length === 1) {
    vscode8.window.showInformationMessage(
      `Only ${getConnectionLabel(connections2[0])} is configured. Add another project to switch.`
    );
    return false;
  }
  const items = connections2.map((connection) => {
    const description = connection.team
      ? `${connection.organization}/${connection.project} \u2022 ${connection.team}`
      : `${connection.organization}/${connection.project}`;
    const labelBase = getConnectionLabel(connection);
    const label = connection.id === activeConnectionId2 ? `$(check) ${labelBase}` : labelBase;
    const detail =
      connection.authMethod === 'entra' ? 'Microsoft Entra ID' : 'Personal Access Token';
    return {
      label,
      description,
      detail,
      connection,
    };
  });
  const pick = await vscode8.window.showQuickPick(items, {
    placeHolder: 'Select the connection to make active',
    ignoreFocusOut: true,
  });
  if (!pick) {
    return false;
  }
  if (pick.connection.id === activeConnectionId2) {
    vscode8.window.showInformationMessage(
      `${getConnectionLabel(pick.connection)} is already the active connection.`
    );
    return false;
  }
  await ensureActiveConnection(context, pick.connection.id, { refresh: true });
  await updateAuthStatusBar();
  vscode8.window.showInformationMessage(
    `Switched active project to ${getConnectionLabel(pick.connection)}.`
  );
  return true;
}
async function promptRemoveConnection(context) {
  if (connections2.length === 0) {
    vscode8.window.showInformationMessage('There are no saved connections to remove.');
    return false;
  }
  const items = connections2.map((connection) => {
    const description = connection.team
      ? `${connection.organization}/${connection.project} \u2022 ${connection.team}`
      : `${connection.organization}/${connection.project}`;
    return {
      label: getConnectionLabel(connection),
      description,
      connection,
    };
  });
  const pick = await vscode8.window.showQuickPick(items, {
    placeHolder: 'Select a project connection to remove',
    ignoreFocusOut: true,
  });
  if (!pick) return false;
  const confirm = await vscode8.window.showWarningMessage(
    `Remove connection ${pick.label}?`,
    { modal: true },
    'Remove'
  );
  if (confirm !== 'Remove') return false;
  const currentActive = activeConnectionId2;
  const remaining = connections2.filter((connection) => connection.id !== pick.connection.id);
  await saveConnectionsToConfig(context, remaining);
  const nextActiveId = pick.connection.id === currentActive ? remaining[0]?.id : currentActive;
  await ensureActiveConnection(context, nextActiveId, { refresh: true });
  if (remaining.length === 0) {
    vscode8.window.showInformationMessage(
      'Removed last connection. Run Azure DevOps: Setup Connection to add another project.'
    );
  } else {
    vscode8.window.showInformationMessage(`Removed connection ${pick.label}.`);
  }
  return true;
}
async function silentInit(context) {
  if (IS_SMOKE) return;
  await migrateLegacyPAT(context);
  await ensureConnectionsInitialized(context);
  verbose('[silentInit] initialized connections', {
    connectionCount: connections2.length,
    activeConnectionId: activeConnectionId2,
  });
  const state2 = await ensureActiveConnection(context, activeConnectionId2, { refresh: false });
  verbose('[silentInit] ensureActiveConnection returned', {
    hasState: !!state2,
    stateId: state2?.id,
    hasProvider: !!state2?.provider,
  });
  ensureTimer(context);
  if (panel && state2?.provider) {
    const cfg = getConfig();
    const selectedQuery = getStoredQueryForConnection(state2.id, getDefaultQuery(cfg));
    if (!initialRefreshedConnections.has(state2.id)) {
      initialRefreshedConnections.add(state2.id);
    }
    verbose('[silentInit] panel present, refreshing provider', {
      id: state2.id,
      query: selectedQuery,
    });
    state2.provider.refresh(selectedQuery);
  }
}
async function migrateLegacyPAT(context) {
  const NEW_KEY = PAT_KEY;
  const legacySecretKeys = [
    'azureDevOps.pat',
    'azureDevOpsIntegration.pat',
    'azureDevOpsIntegration.personalAccessToken',
  ];
  const legacyGlobalKeys = [
    NEW_KEY,
    'azureDevOpsIntegration.personalAccessToken',
    'azureDevOpsIntegration.pat',
  ];
  let stored = String((await context.secrets.get(NEW_KEY)) || '').trim();
  const storeIfMissing = async (candidate, source2, cleanup) => {
    if (stored) return;
    const value = String(candidate || '').trim();
    if (!value) return;
    try {
      await context.secrets.store(NEW_KEY, value);
      stored = value;
      if (cleanup) {
        try {
          await cleanup();
        } catch {}
      }
      console.log(`[azureDevOpsInt] Migrated PAT (${source2})`);
    } catch (e) {
      console.error(`Failed migrating PAT (${source2})`, e);
    }
  };
  for (const key2 of legacyGlobalKeys) {
    const value = context.globalState.get(key2);
    await storeIfMissing(value, `globalState ${key2}`, async () => {
      if (key2) await context.globalState.update(key2, void 0);
    });
  }
  for (const key2 of legacySecretKeys) {
    const value = await context.secrets.get(key2);
    await storeIfMissing(value || void 0, `secret ${key2}`, async () => {
      if (key2 !== NEW_KEY) await context.secrets.delete(key2);
    });
  }
  try {
    const cfg = getConfig();
    const configKeys = ['personalAccessToken', 'pat'];
    for (const key2 of configKeys) {
      const value = cfg.get(key2);
      await storeIfMissing(value, `settings ${key2}`, async () => {
        await cfg.update(key2, '', vscode8.ConfigurationTarget.Global);
      });
    }
  } catch (e) {
    console.warn('[azureDevOpsInt] migrate PAT from settings failed', e);
  }
}
function revealWorkItemsView() {
  if (IS_SMOKE) {
    verbose('Skipping revealWorkItemsView in smoke mode');
    return;
  }
  vscode8.commands.executeCommand('workbench.view.extension.azureDevOpsIntegration').then(
    () => {},
    () => {}
  );
  setTimeout(() => {
    try {
      vscode8.commands.executeCommand('azureDevOpsWorkItems.focus').then(
        () => {},
        () => {}
      );
      verbose('Focused Work Items view');
    } catch {}
  }, 0);
  verbose('Revealed Azure DevOps container');
}
async function quickCreateWorkItem() {
  if (!client || !provider) {
    vscode8.window.showWarningMessage(
      'Connect to Azure DevOps first (Azure DevOps: Setup Connection).'
    );
    return;
  }
  const cfg = getConfig();
  const defaultType = cfg.get('defaultWorkItemType') || 'Task';
  const typeOptions =
    typeof provider.getWorkItemTypeOptions === 'function' ? provider.getWorkItemTypeOptions() : [];
  let chosenType = defaultType;
  if (Array.isArray(typeOptions) && typeOptions.length > 0) {
    const quickPickType = await vscode8.window.showQuickPick(
      typeOptions.map((label) => ({ label, picked: label === defaultType })),
      {
        placeHolder: 'Select work item type',
        ignoreFocusOut: true,
      }
    );
    if (!quickPickType) return;
    chosenType = quickPickType.label;
  }
  const title = await vscode8.window.showInputBox({
    prompt: `New ${chosenType} title`,
    ignoreFocusOut: true,
  });
  if (!title) return;
  const workItems = typeof provider.getWorkItems === 'function' ? provider.getWorkItems() : [];
  const dedupe = (values) => {
    const seen = /* @__PURE__ */ new Set();
    const result = [];
    for (const value of values) {
      const trimmed = typeof value === 'string' ? value.trim() : '';
      if (!trimmed) continue;
      if (seen.has(trimmed)) continue;
      seen.add(trimmed);
      result.push(trimmed);
    }
    return result.sort((a, b) => a.localeCompare(b));
  };
  const areaPathCache = dedupe(workItems.map((w) => w.fields?.['System.AreaPath']));
  const iterationPathCache = dedupe(workItems.map((w) => w.fields?.['System.IterationPath']));
  const lastAreaPath = extensionContextRef2?.globalState.get('azureDevOpsInt.lastAreaPath');
  if (lastAreaPath && !areaPathCache.includes(lastAreaPath)) areaPathCache.unshift(lastAreaPath);
  const lastIterationPath = extensionContextRef2?.globalState.get(
    'azureDevOpsInt.lastIterationPath'
  );
  if (lastIterationPath && !iterationPathCache.includes(lastIterationPath))
    iterationPathCache.unshift(lastIterationPath);
  const areaPath = await promptForAreaPath(areaPathCache);
  if (!areaPath) return;
  const iterationPath = await promptForIterationPath(iterationPathCache);
  if (iterationPath === void 0) {
    return;
  }
  const extraFields = {};
  if (areaPath) extraFields['System.AreaPath'] = areaPath;
  if (iterationPath) extraFields['System.IterationPath'] = iterationPath;
  const descriptionInput = await vscode8.window.showInputBox({
    prompt: `Description for the new ${chosenType} (optional)`,
    ignoreFocusOut: true,
    placeHolder: 'Leave blank to skip adding a description',
    value: '',
  });
  const description = descriptionInput?.trim() ? descriptionInput.trim() : void 0;
  try {
    const created = await provider.createWorkItem(
      chosenType,
      title.trim(),
      description,
      void 0,
      extraFields
    );
    if (extensionContextRef2) {
      await extensionContextRef2.globalState.update('azureDevOpsInt.lastAreaPath', areaPath);
      await extensionContextRef2.globalState.update(
        'azureDevOpsInt.lastIterationPath',
        iterationPath || null
      );
    }
    vscode8.window.showInformationMessage(`Created work item #${created.id}`);
  } catch (e) {
    vscode8.window.showErrorMessage(`Failed to create: ${e.message || e}`);
  }
}
async function promptForAreaPath(candidates) {
  const hasCandidates = Array.isArray(candidates) && candidates.length > 0;
  if (!hasCandidates) {
    const manual = await vscode8.window.showInputBox({
      prompt: 'Area path for new work item (required)',
      ignoreFocusOut: true,
    });
    return manual?.trim();
  }
  const pickItems = candidates.map((label, index2) => ({
    label,
    picked: index2 === 0,
  }));
  pickItems.push({
    label: 'Enter custom area path\u2026',
    description: 'Specify a different area path',
    alwaysShow: true,
  });
  const selection = await vscode8.window.showQuickPick(pickItems, {
    placeHolder: 'Select Area Path for the new work item',
    ignoreFocusOut: true,
  });
  if (!selection) return void 0;
  if (selection.label === 'Enter custom area path\u2026') {
    const manual = await vscode8.window.showInputBox({
      prompt: 'Custom area path',
      ignoreFocusOut: true,
      value: candidates[0] ?? '',
    });
    return manual?.trim() || void 0;
  }
  return selection.label.trim();
}
async function promptForIterationPath(candidates) {
  const skipLabel = 'Use default iteration (skip)';
  const customLabel = 'Enter custom iteration path\u2026';
  if (!Array.isArray(candidates) || candidates.length === 0) {
    const manual = await vscode8.window.showInputBox({
      prompt: 'Iteration path for the new work item (optional)',
      placeHolder: 'Leave blank to use default iteration',
      ignoreFocusOut: true,
    });
    if (manual === void 0) return void 0;
    const trimmed = manual.trim();
    return trimmed.length > 0 ? trimmed : '';
  }
  const items = [
    { label: skipLabel, description: 'Let Azure DevOps use the default iteration' },
    ...candidates.map((label, index2) => ({ label, picked: index2 === 0 })),
    { label: customLabel, description: 'Specify a different iteration path', alwaysShow: true },
  ];
  const selection = await vscode8.window.showQuickPick(items, {
    placeHolder: 'Select Iteration Path (optional)',
    ignoreFocusOut: true,
  });
  if (!selection) return void 0;
  if (selection.label === skipLabel) return '';
  if (selection.label === customLabel) {
    const manual = await vscode8.window.showInputBox({
      prompt: 'Custom iteration path (optional)',
      placeHolder: 'Leave blank to use default',
      ignoreFocusOut: true,
      value: candidates[0] ?? '',
    });
    if (manual === void 0) return void 0;
    const trimmed = manual.trim();
    return trimmed.length > 0 ? trimmed : '';
  }
  return selection.label.trim();
}
async function selectTeam() {
  try {
    if (!client) {
      vscode8.window.showWarningMessage('Connect to Azure DevOps first (Setup Connection).');
      return;
    }
    const teams = await client.getTeams?.();
    if (!Array.isArray(teams) || teams.length === 0) {
      vscode8.window.showInformationMessage('No teams found for this project.');
      return;
    }
    const picks = teams.map((t) => ({ label: t.name, description: t.id }));
    const chosen = await vscode8.window.showQuickPick(picks, {
      placeHolder: 'Select your Team for sprint queries',
    });
    if (!chosen) return;
    const cfg = getConfig();
    await cfg.update('team', chosen.label, vscode8.ConfigurationTarget.Global);
    vscode8.window.showInformationMessage(
      `Team set to "${chosen.label}". 'Current Sprint' will use this team context.`
    );
    const org = String(cfg.get('organization') || '');
    const project = String(cfg.get('project') || '');
    const pat = extensionContextRef2 ? await getSecretPAT2(extensionContextRef2) : void 0;
    if (org && project && pat) {
      try {
        const rate = Math.max(1, Math.min(50, cfg.get('apiRatePerSecond') ?? 5));
        const burst = Math.max(1, Math.min(100, cfg.get('apiBurst') ?? 10));
        client = new AzureDevOpsIntClient(org, project, pat, {
          ratePerSecond: rate,
          burst,
          team: chosen.label,
        });
        provider = client
          ? new WorkItemsProvider(
              'default',
              client,
              (m) => postToWebview({ panel, message: m, logger: verbose }),
              {}
            )
          : provider;
        const connectionSpecificQuery = activeConnectionId2
          ? getStoredQueryForConnection(activeConnectionId2)
          : getDefaultQuery(cfg);
        console.log(
          '\u{1F504} [Query Debug] selectTeam - refreshing with connection-specific query:',
          {
            activeConnectionId: activeConnectionId2,
            connectionSpecificQuery,
            globalDefault: getDefaultQuery(cfg),
          }
        );
        provider?.refresh(connectionSpecificQuery);
      } catch {}
    }
  } catch (e) {
    vscode8.window.showErrorMessage(`Failed to select team: ${e?.message || e}`);
  }
}
async function resetPreferredRepositories() {
  const cfg = getConfig();
  try {
    await cfg.update('preferredRepositoryIds', [], vscode8.ConfigurationTarget.Global);
    vscode8.window.showInformationMessage(
      'Preferred repositories cleared. You will be prompted next time you create a PR.'
    );
  } catch (e) {
    vscode8.window.showErrorMessage(`Failed to clear preferred repositories: ${e?.message || e}`);
  }
}
function toggleKanbanView() {
  if (!panel) {
    revealWorkItemsView();
    return;
  }
  sendToWebview({ type: 'toggleKanbanView' });
}
async function editWorkItemInEditor(workItemId) {
  if (!client || !provider) {
    vscode8.window.showWarningMessage(
      'Connect to Azure DevOps first (Azure DevOps: Setup Connection).'
    );
    return;
  }
  try {
    const workItems = provider.getWorkItems();
    const workItem = workItems.find(
      (w) => w.id === workItemId || w.fields?.['System.Id'] === workItemId
    );
    if (!workItem) {
      vscode8.window.showErrorMessage(`Work item #${workItemId} not found in current list.`);
      return;
    }
    const currentTitle = workItem.fields?.['System.Title'] || '';
    const currentDescription = workItem.fields?.['System.Description'] || '';
    const currentState = workItem.fields?.['System.State'] || '';
    const currentType = workItem.fields?.['System.WorkItemType'] || '';
    const newTitle = await vscode8.window.showInputBox({
      prompt: `Edit title for ${currentType} #${workItemId}`,
      value: currentTitle,
      placeHolder: 'Work item title',
    });
    if (newTitle === void 0) return;
    const newDescription = await vscode8.window.showInputBox({
      prompt: `Edit description for ${currentType} #${workItemId}`,
      value: currentDescription,
      placeHolder: 'Work item description (optional)',
    });
    if (newDescription === void 0) return;
    let stateOptions;
    try {
      const validStates = await client.getWorkItemTypeStates(currentType);
      if (validStates.length > 0) {
        stateOptions = validStates.map((state2) => ({
          label: state2,
          description: `${state2} state`,
        }));
        if (!validStates.includes(currentState) && currentState) {
          stateOptions.unshift({
            label: currentState,
            description: `Current: ${currentState} state`,
          });
        }
      } else {
        stateOptions = [
          { label: 'New', description: 'New work item' },
          { label: 'Active', description: 'Work in progress' },
          { label: 'Resolved', description: 'Work completed' },
          { label: 'Closed', description: 'Work verified and closed' },
          { label: 'Removed', description: 'Work item removed' },
        ];
      }
    } catch (e) {
      console.error('Failed to fetch valid states, using fallback:', e);
      stateOptions = [
        { label: 'New', description: 'New work item' },
        { label: 'Active', description: 'Work in progress' },
        { label: 'Resolved', description: 'Work completed' },
        { label: 'Closed', description: 'Work verified and closed' },
        { label: 'Removed', description: 'Work item removed' },
      ];
      const fallbackStates = stateOptions.map((opt) => opt.label);
      if (!fallbackStates.includes(currentState) && currentState) {
        stateOptions.unshift({
          label: currentState,
          description: `Current: ${currentState} state`,
        });
      }
    }
    const selectedState = await vscode8.window.showQuickPick(stateOptions, {
      placeHolder: `Current state: ${currentState}. Select new state:`,
    });
    if (!selectedState) return;
    const newState = selectedState.label;
    const patchOps = [];
    if (newTitle !== currentTitle) {
      patchOps.push({
        op: 'replace',
        path: '/fields/System.Title',
        value: newTitle,
      });
    }
    if (newDescription !== currentDescription) {
      patchOps.push({
        op: 'replace',
        path: '/fields/System.Description',
        value: newDescription,
      });
    }
    if (newState !== currentState) {
      patchOps.push({
        op: 'replace',
        path: '/fields/System.State',
        value: newState,
      });
    }
    if (patchOps.length > 0) {
      await client.updateWorkItem(workItemId, patchOps);
      vscode8.window.showInformationMessage(`Updated work item #${workItemId}`);
      const refreshQuery = getQueryForProvider(provider, activeConnectionId2);
      provider.refresh(refreshQuery);
    } else {
      vscode8.window.showInformationMessage('No changes made.');
    }
  } catch (e) {
    vscode8.window.showErrorMessage(`Failed to edit work item: ${e.message || e}`);
  }
}
async function startTimerInteractive() {
  if (!provider || !timer) {
    vscode8.window.showWarningMessage('Provider not ready yet');
    return;
  }
  if (timer.snapshot()) {
    const runningConnectionLabel = getActiveTimerConnectionLabel();
    vscode8.window.showInformationMessage(
      runningConnectionLabel
        ? `A timer is already running for ${runningConnectionLabel}. Stop it before starting another.`
        : 'A timer is already running. Stop it before starting another.'
    );
    return;
  }
  const items = provider.getWorkItems();
  if (items.length === 0) {
    const refreshQuery = getQueryForProvider(provider, activeConnectionId2);
    await provider.refresh(refreshQuery);
  }
  const pick = await vscode8.window.showQuickPick(
    provider.getWorkItems().map((w) => ({
      label: w.fields?.['System.Title'] || `#${w.id}`,
      description: `#${w.id}`,
      wi: w,
    })),
    { placeHolder: 'Select work item to start/stop timer' }
  );
  if (!pick) return;
  const wi = pick.wi;
  const connection = activeConnectionId2
    ? connections2.find((c) => c.id === activeConnectionId2)
    : void 0;
  const previousInfo = { ...timerConnectionInfo };
  setTimerConnectionFrom(connection);
  const started = timer.start(
    Number(wi.id || wi.fields?.['System.Id']),
    wi.fields?.['System.Title'] || `#${wi.id}`
  );
  if (!started) timerConnectionInfo = previousInfo;
}
function showTimeReport() {
  if (!timer) {
    vscode8.window.showInformationMessage('No timer data yet.');
    return;
  }
  const periods = ['Today', 'This Week', 'This Month', 'All Time'];
  vscode8.window.showQuickPick(periods, { placeHolder: 'Select report period' }).then((p) => {
    if (!p || !timer) return;
    const report = timer.timeReport(p);
    const lines = [];
    report.buckets.forEach((val, key2) => {
      const hrs = (val.total / 3600).toFixed(2);
      lines.push(`#${key2}: ${hrs}h`);
    });
    if (lines.length === 0) lines.push('No time entries in period');
    vscode8.window.showInformationMessage(`${p} Time:
${lines.join('\n')}`);
  });
}
function showPerformanceDashboard() {
  try {
    const report = performanceMonitor.getPerformanceReport();
    const { stats, cacheStats, memoryUsage, recommendations } = report;
    const formatMemory = (bytes) => (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    const dashboard = [
      '=== Performance Dashboard ===\n',
      '\u{1F4CA} Operation Statistics:',
      `  Total Operations: ${stats.totalOperations}`,
      `  Average Duration: ${stats.averageDuration.toFixed(2)}ms`,
      `  Min Duration: ${stats.minDuration.toFixed(2)}ms`,
      `  Max Duration: ${stats.maxDuration.toFixed(2)}ms`,
      `  Error Rate: ${(stats.errorRate * 100).toFixed(1)}%`,
      `  Cache Hit Rate: ${(stats.cacheHitRate * 100).toFixed(1)}%
`,
      '\u{1F4BE} Memory Usage:',
      `  Current Heap: ${formatMemory(memoryUsage.heapUsed)}`,
      `  Total Heap: ${formatMemory(memoryUsage.heapTotal)}`,
      `  Peak Usage: ${formatMemory(stats.memoryUsage.peak)}`,
      `  RSS: ${formatMemory(memoryUsage.rss)}
`,
      '\u{1F5C4}\uFE0F Cache Statistics:',
      `  Work Items Cached: ${cacheStats.workItems?.topKeys?.length || 0}`,
      `  API Calls Cached: ${cacheStats.api?.topKeys?.length || 0}`,
      `  Total Memory: ${formatMemory(cacheStats.totalMemoryUsage)}
`,
    ];
    if (recommendations.length > 0) {
      dashboard.push('\u{1F4A1} Recommendations:');
      recommendations.forEach((rec) => dashboard.push(`  \u2022 ${rec}`));
    } else {
      dashboard.push('\u2705 Performance looks good!');
    }
    vscode8.window.showInformationMessage(dashboard.join('\n'), { modal: true });
  } catch (error) {
    vscode8.window.showErrorMessage(
      `Failed to show performance dashboard: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }
}
function forceGarbageCollection() {
  try {
    if (global.gc) {
      const before = process.memoryUsage();
      global.gc();
      const after = process.memoryUsage();
      const freed = (before.heapUsed - after.heapUsed) / (1024 * 1024);
      vscode8.window.showInformationMessage(
        `Garbage collection completed. Freed ${freed.toFixed(2)} MB of memory.`
      );
    } else {
      vscode8.window.showWarningMessage(
        'Garbage collection is not exposed. To enable, start VS Code with --expose-gc flag.'
      );
    }
  } catch (error) {
    vscode8.window.showErrorMessage(
      `Failed to force garbage collection: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }
}
async function bulkAssignWorkItems() {
  try {
    if (!client) {
      vscode8.window.showErrorMessage('No active Azure DevOps connection');
      return;
    }
    const selectedIds = await requestSelectedWorkItems();
    if (!selectedIds || selectedIds.length === 0) {
      vscode8.window.showWarningMessage(
        'No work items selected. Use Ctrl+Click to select multiple items.'
      );
      return;
    }
    const assignee = await vscode8.window.showInputBox({
      prompt: `Assign ${selectedIds.length} work item(s) to:`,
      placeHolder: 'Enter display name or email',
      ignoreFocusOut: true,
    });
    if (!assignee) return;
    const confirm = await vscode8.window.showWarningMessage(
      `Assign ${selectedIds.length} work item(s) to "${assignee}"?`,
      { modal: true },
      'Yes',
      'No'
    );
    if (confirm !== 'Yes') return;
    await vscode8.window.withProgress(
      {
        location: vscode8.ProgressLocation.Notification,
        title: 'Bulk Assign',
        cancellable: false,
      },
      async (progress) => {
        let completed = 0;
        const errors = [];
        for (const id of selectedIds) {
          try {
            await client.updateWorkItem(id, [
              {
                op: 'add',
                path: '/fields/System.AssignedTo',
                value: assignee,
              },
            ]);
            completed++;
            progress.report({
              increment: 100 / selectedIds.length,
              message: `${completed}/${selectedIds.length} completed`,
            });
          } catch (error) {
            errors.push(`#${id}: ${error.message || 'Failed'}`);
          }
        }
        if (errors.length > 0) {
          vscode8.window.showWarningMessage(
            `Bulk assign completed with ${errors.length} error(s). Check Output Channel for details.`
          );
          errors.forEach((err) => logLine(`[bulkAssign] ${err}`));
        } else {
          vscode8.window.showInformationMessage(
            `Successfully assigned ${completed} work item(s) to ${assignee}`
          );
        }
        const refreshQuery = getQueryForProvider(provider, activeConnectionId2);
        provider?.refresh(refreshQuery);
      }
    );
  } catch (error) {
    vscode8.window.showErrorMessage(`Bulk assign failed: ${error.message || 'Unknown error'}`);
  }
}
async function bulkMoveWorkItems() {
  try {
    if (!client) {
      vscode8.window.showErrorMessage('No active Azure DevOps connection');
      return;
    }
    const selectedIds = await requestSelectedWorkItems();
    if (!selectedIds || selectedIds.length === 0) {
      vscode8.window.showWarningMessage(
        'No work items selected. Use Ctrl+Click to select multiple items.'
      );
      return;
    }
    const states = ['New', 'Active', 'Resolved', 'Closed', 'Removed'];
    const selectedState = await vscode8.window.showQuickPick(states, {
      placeHolder: `Move ${selectedIds.length} work item(s) to state:`,
      ignoreFocusOut: true,
    });
    if (!selectedState) return;
    const confirm = await vscode8.window.showWarningMessage(
      `Move ${selectedIds.length} work item(s) to "${selectedState}"?`,
      { modal: true },
      'Yes',
      'No'
    );
    if (confirm !== 'Yes') return;
    await vscode8.window.withProgress(
      {
        location: vscode8.ProgressLocation.Notification,
        title: 'Bulk Move',
        cancellable: false,
      },
      async (progress) => {
        let completed = 0;
        const errors = [];
        for (const id of selectedIds) {
          try {
            await client.updateWorkItem(id, [
              {
                op: 'replace',
                path: '/fields/System.State',
                value: selectedState,
              },
            ]);
            completed++;
            progress.report({
              increment: 100 / selectedIds.length,
              message: `${completed}/${selectedIds.length} completed`,
            });
          } catch (error) {
            errors.push(`#${id}: ${error.message || 'Failed'}`);
          }
        }
        if (errors.length > 0) {
          vscode8.window.showWarningMessage(
            `Bulk move completed with ${errors.length} error(s). Check Output Channel for details.`
          );
          errors.forEach((err) => logLine(`[bulkMove] ${err}`));
        } else {
          vscode8.window.showInformationMessage(
            `Successfully moved ${completed} work item(s) to ${selectedState}`
          );
        }
        const refreshQuery = getQueryForProvider(provider, activeConnectionId2);
        provider?.refresh(refreshQuery);
      }
    );
  } catch (error) {
    vscode8.window.showErrorMessage(`Bulk move failed: ${error.message || 'Unknown error'}`);
  }
}
async function bulkAddTags() {
  try {
    if (!client) {
      vscode8.window.showErrorMessage('No active Azure DevOps connection');
      return;
    }
    const selectedIds = await requestSelectedWorkItems();
    if (!selectedIds || selectedIds.length === 0) {
      vscode8.window.showWarningMessage(
        'No work items selected. Use Ctrl+Click to select multiple items.'
      );
      return;
    }
    const tagsInput = await vscode8.window.showInputBox({
      prompt: `Add tags to ${selectedIds.length} work item(s):`,
      placeHolder: 'Enter tags separated by semicolons (e.g., bug; high-priority; customer)',
      ignoreFocusOut: true,
    });
    if (!tagsInput) return;
    const newTags = tagsInput
      .split(';')
      .map((t) => t.trim())
      .filter((t) => t);
    if (newTags.length === 0) {
      vscode8.window.showWarningMessage('No valid tags entered');
      return;
    }
    const confirm = await vscode8.window.showWarningMessage(
      `Add tag(s) "${newTags.join('; ')}" to ${selectedIds.length} work item(s)?`,
      { modal: true },
      'Yes',
      'No'
    );
    if (confirm !== 'Yes') return;
    await vscode8.window.withProgress(
      {
        location: vscode8.ProgressLocation.Notification,
        title: 'Bulk Add Tags',
        cancellable: false,
      },
      async (progress) => {
        let completed = 0;
        const errors = [];
        for (const id of selectedIds) {
          try {
            const workItem = await client.getWorkItemById(id);
            const existingTags = workItem?.fields?.['System.Tags'] || '';
            const existingTagArray = existingTags
              .split(';')
              .map((t) => t.trim())
              .filter((t) => t);
            const mergedTags = Array.from(
              /* @__PURE__ */ new Set([...existingTagArray, ...newTags])
            );
            await client.updateWorkItem(id, [
              {
                op: 'add',
                path: '/fields/System.Tags',
                value: mergedTags.join('; '),
              },
            ]);
            completed++;
            progress.report({
              increment: 100 / selectedIds.length,
              message: `${completed}/${selectedIds.length} completed`,
            });
          } catch (error) {
            errors.push(`#${id}: ${error.message || 'Failed'}`);
          }
        }
        if (errors.length > 0) {
          vscode8.window.showWarningMessage(
            `Bulk add tags completed with ${errors.length} error(s). Check Output Channel for details.`
          );
          errors.forEach((err) => logLine(`[bulkAddTags] ${err}`));
        } else {
          vscode8.window.showInformationMessage(
            `Successfully added tags to ${completed} work item(s)`
          );
        }
        const refreshQuery = getQueryForProvider(provider, activeConnectionId2);
        provider?.refresh(refreshQuery);
      }
    );
  } catch (error) {
    vscode8.window.showErrorMessage(`Bulk add tags failed: ${error.message || 'Unknown error'}`);
  }
}
async function bulkDeleteWorkItems() {
  try {
    if (!client) {
      vscode8.window.showErrorMessage('No active Azure DevOps connection');
      return;
    }
    const selectedIds = await requestSelectedWorkItems();
    if (!selectedIds || selectedIds.length === 0) {
      vscode8.window.showWarningMessage(
        'No work items selected. Use Ctrl+Click to select multiple items.'
      );
      return;
    }
    const confirm1 = await vscode8.window.showWarningMessage(
      `\u26A0\uFE0F DELETE ${selectedIds.length} work item(s)? This action cannot be undone!`,
      { modal: true },
      'Delete',
      'Cancel'
    );
    if (confirm1 !== 'Delete') return;
    const confirm2 = await vscode8.window.showWarningMessage(
      `Are you absolutely sure? Type 'DELETE' to confirm deletion of ${selectedIds.length} work item(s).`,
      { modal: true },
      'I understand, delete them',
      'Cancel'
    );
    if (confirm2 !== 'I understand, delete them') return;
    await vscode8.window.withProgress(
      {
        location: vscode8.ProgressLocation.Notification,
        title: 'Bulk Delete',
        cancellable: false,
      },
      async (progress) => {
        let completed = 0;
        const errors = [];
        for (const id of selectedIds) {
          try {
            await client.updateWorkItem(id, [
              {
                op: 'replace',
                path: '/fields/System.State',
                value: 'Removed',
              },
            ]);
            completed++;
            progress.report({
              increment: 100 / selectedIds.length,
              message: `${completed}/${selectedIds.length} completed`,
            });
          } catch (error) {
            errors.push(`#${id}: ${error.message || 'Failed'}`);
          }
        }
        if (errors.length > 0) {
          vscode8.window.showWarningMessage(
            `Bulk delete completed with ${errors.length} error(s). Check Output Channel for details.`
          );
          errors.forEach((err) => logLine(`[bulkDelete] ${err}`));
        } else {
          vscode8.window.showInformationMessage(`Successfully removed ${completed} work item(s)`);
        }
        const refreshQuery = getQueryForProvider(provider, activeConnectionId2);
        provider?.refresh(refreshQuery);
      }
    );
  } catch (error) {
    vscode8.window.showErrorMessage(`Bulk delete failed: ${error.message || 'Unknown error'}`);
  }
}
async function requestSelectedWorkItems() {
  return new Promise((resolve) => {
    const timeout = setTimeout(() => {
      resolve(null);
    }, 5e3);
    const handler = (msg) => {
      if (msg?.type === 'selectedWorkItems') {
        clearTimeout(timeout);
        const ids = Array.isArray(msg.ids)
          ? msg.ids.map((id) => Number(id)).filter((id) => id > 0)
          : [];
        resolve(ids);
      }
    };
    if (panel) {
      panel.webview.onDidReceiveMessage(handler);
      sendToWebview({ type: 'requestSelection' });
    } else {
      clearTimeout(timeout);
      resolve(null);
    }
  });
}
async function exportFiltersToFile() {
  try {
    const config = getConfig();
    const filterData = {
      version: '1.0',
      exported: /* @__PURE__ */ new Date().toISOString(),
      filters: {
        workItemQuery: config.get('workItemQuery'),
        showCompletedWorkItems: config.get('showCompletedWorkItems'),
        defaultWorkItemType: config.get('defaultWorkItemType'),
      },
    };
    const uri = await vscode8.window.showSaveDialog({
      defaultUri: vscode8.Uri.file('azuredevops-filters.json'),
      filters: {
        'JSON Files': ['json'],
        'All Files': ['*'],
      },
    });
    if (!uri) return;
    const fs2 = await import('fs/promises');
    await fs2.writeFile(uri.fsPath, JSON.stringify(filterData, null, 2), 'utf8');
    vscode8.window.showInformationMessage(`Filters exported to ${uri.fsPath}`);
  } catch (error) {
    vscode8.window.showErrorMessage(
      `Failed to export filters: ${error.message || 'Unknown error'}`
    );
  }
}
async function importFiltersFromFile() {
  try {
    const uris = await vscode8.window.showOpenDialog({
      canSelectMany: false,
      filters: {
        'JSON Files': ['json'],
        'All Files': ['*'],
      },
    });
    if (!uris || uris.length === 0) return;
    const fs2 = await import('fs/promises');
    const content = await fs2.readFile(uris[0].fsPath, 'utf8');
    const filterData = JSON.parse(content);
    if (!filterData.version || !filterData.filters) {
      throw new Error('Invalid filter file format');
    }
    const confirm = await vscode8.window.showWarningMessage(
      `Import filters from ${uris[0].fsPath}? This will overwrite your current filter settings.`,
      { modal: true },
      'Import',
      'Cancel'
    );
    if (confirm !== 'Import') return;
    const config = getConfig();
    const filters = filterData.filters;
    if (filters.workItemQuery) {
      await config.update(
        'workItemQuery',
        filters.workItemQuery,
        vscode8.ConfigurationTarget.Global
      );
    }
    if (typeof filters.showCompletedWorkItems === 'boolean') {
      await config.update(
        'showCompletedWorkItems',
        filters.showCompletedWorkItems,
        vscode8.ConfigurationTarget.Global
      );
    }
    if (filters.defaultWorkItemType) {
      await config.update(
        'defaultWorkItemType',
        filters.defaultWorkItemType,
        vscode8.ConfigurationTarget.Global
      );
    }
    vscode8.window.showInformationMessage('Filters imported successfully');
    const refreshQuery = getQueryForProvider(provider, activeConnectionId2);
    provider?.refresh(refreshQuery);
  } catch (error) {
    vscode8.window.showErrorMessage(
      `Failed to import filters: ${error.message || 'Unknown error'}`
    );
  }
}
async function manageSavedFilters() {
  try {
    const SAVED_FILTERS_KEY = 'azureDevOpsInt.savedFilters';
    const savedFilters = extensionContextRef2?.globalState.get(SAVED_FILTERS_KEY) || [];
    const actions2 = [
      { label: '$(add) Save Current Query', value: 'save' },
      { label: '$(list-unordered) Load Saved Query', value: 'load' },
      { label: '$(trash) Delete Saved Query', value: 'delete' },
      { label: '$(list-flat) List All Saved Queries', value: 'list' },
    ];
    const action2 = await vscode8.window.showQuickPick(actions2, {
      placeHolder: `Manage Saved Filters (${savedFilters.length} saved)`,
      ignoreFocusOut: true,
    });
    if (!action2) return;
    switch (action2.value) {
      case 'save': {
        const name3 = await vscode8.window.showInputBox({
          prompt: 'Enter a name for this filter',
          placeHolder: 'e.g., "My Active Bugs", "Sprint Tasks"',
          ignoreFocusOut: true,
        });
        if (!name3) return;
        const config = getConfig();
        const currentQuery = config.get('workItemQuery') || '';
        const description = await vscode8.window.showInputBox({
          prompt: 'Enter a description (optional)',
          placeHolder: 'Describe what this filter shows',
          ignoreFocusOut: true,
        });
        const newFilter = { name: name3, query: currentQuery, description: description || void 0 };
        const updated = [...savedFilters, newFilter];
        await extensionContextRef2?.globalState.update(SAVED_FILTERS_KEY, updated);
        vscode8.window.showInformationMessage(`Filter "${name3}" saved successfully`);
        break;
      }
      case 'load': {
        if (savedFilters.length === 0) {
          vscode8.window.showInformationMessage('No saved filters. Save one first!');
          return;
        }
        const filterItems = savedFilters.map((f) => ({
          label: f.name,
          description: f.description,
          detail: f.query,
          filter: f,
        }));
        const selected = await vscode8.window.showQuickPick(filterItems, {
          placeHolder: 'Select a filter to load',
          ignoreFocusOut: true,
        });
        if (!selected) return;
        const config = getConfig();
        await config.update(
          'workItemQuery',
          selected.filter.query,
          vscode8.ConfigurationTarget.Global
        );
        vscode8.window.showInformationMessage(`Filter "${selected.filter.name}" loaded`);
        const refreshQuery = getQueryForProvider(provider, activeConnectionId2);
        provider?.refresh(refreshQuery);
        break;
      }
      case 'delete': {
        if (savedFilters.length === 0) {
          vscode8.window.showInformationMessage('No saved filters to delete');
          return;
        }
        const filterItems = savedFilters.map((f, index2) => ({
          label: f.name,
          description: f.description,
          index: index2,
        }));
        const selected = await vscode8.window.showQuickPick(filterItems, {
          placeHolder: 'Select a filter to delete',
          ignoreFocusOut: true,
        });
        if (!selected) return;
        const confirm = await vscode8.window.showWarningMessage(
          `Delete filter "${selected.label}"?`,
          'Delete',
          'Cancel'
        );
        if (confirm === 'Delete') {
          const updated = savedFilters.filter((_, i) => i !== selected.index);
          await extensionContextRef2?.globalState.update(SAVED_FILTERS_KEY, updated);
          vscode8.window.showInformationMessage(`Filter "${selected.label}" deleted`);
        }
        break;
      }
      case 'list': {
        if (savedFilters.length === 0) {
          vscode8.window.showInformationMessage('No saved filters yet');
          return;
        }
        const list = savedFilters
          .map((f, i) => `${i + 1}. ${f.name}${f.description ? ` - ${f.description}` : ''}`)
          .join('\n');
        vscode8.window.showInformationMessage(
          `Saved Filters (${savedFilters.length}):

${list}`,
          {
            modal: true,
          }
        );
        break;
      }
    }
  } catch (error) {
    vscode8.window.showErrorMessage(
      `Filter management failed: ${error.message || 'Unknown error'}`
    );
  }
}
async function showQueryBuilder() {
  try {
    const config = getConfig();
    const currentQuery = config.get('workItemQuery') || '';
    const buildAction = await vscode8.window.showQuickPick(
      [
        { label: '$(edit) Edit Current Query', value: 'edit' },
        { label: '$(sparkle) Build from Template', value: 'template' },
        { label: '$(info) View Query Help', value: 'help' },
      ],
      {
        placeHolder: 'Query Builder',
        ignoreFocusOut: true,
      }
    );
    if (!buildAction) return;
    switch (buildAction.value) {
      case 'edit': {
        const newQuery = await vscode8.window.showInputBox({
          prompt: 'Edit WIQL Query',
          value: currentQuery,
          placeHolder: 'SELECT [System.Id], [System.Title] FROM WorkItems WHERE...',
          ignoreFocusOut: true,
          validateInput: (value) => {
            if (!value.trim()) return 'Query cannot be empty';
            if (!value.toUpperCase().includes('SELECT')) return 'Query must include SELECT';
            if (!value.toUpperCase().includes('FROM')) return 'Query must include FROM';
            return null;
          },
        });
        if (!newQuery) return;
        await config.update('workItemQuery', newQuery, vscode8.ConfigurationTarget.Global);
        vscode8.window.showInformationMessage('Query updated successfully');
        const refreshQuery = getQueryForProvider(provider, activeConnectionId2);
        provider?.refresh(refreshQuery);
        break;
      }
      case 'template': {
        const templates = [
          {
            label: 'My Work Items',
            detail: 'Items assigned to me',
            query:
              "SELECT [System.Id], [System.Title], [System.State], [System.AssignedTo], [System.WorkItemType] FROM WorkItems WHERE [System.TeamProject] = @project AND [System.AssignedTo] = @Me AND [System.State] <> 'Closed' ORDER BY [System.ChangedDate] DESC",
          },
          {
            label: 'Recently Changed',
            detail: 'Items changed in last 7 days',
            query:
              'SELECT [System.Id], [System.Title], [System.State], [System.AssignedTo], [System.WorkItemType] FROM WorkItems WHERE [System.TeamProject] = @project AND [System.ChangedDate] >= @Today-7 ORDER BY [System.ChangedDate] DESC',
          },
          {
            label: 'Active Bugs',
            detail: 'All active bugs in project',
            query:
              "SELECT [System.Id], [System.Title], [System.State], [System.AssignedTo] FROM WorkItems WHERE [System.TeamProject] = @project AND [System.WorkItemType] = 'Bug' AND [System.State] = 'Active' ORDER BY [Microsoft.VSTS.Common.Priority] ASC",
          },
          {
            label: 'Current Sprint',
            detail: 'Items in current iteration',
            query:
              'SELECT [System.Id], [System.Title], [System.State], [System.AssignedTo], [System.WorkItemType] FROM WorkItems WHERE [System.TeamProject] = @project AND [System.IterationPath] = @CurrentIteration ORDER BY [Microsoft.VSTS.Common.Priority] ASC',
          },
          {
            label: 'Unassigned Items',
            detail: 'Items with no assignee',
            query:
              "SELECT [System.Id], [System.Title], [System.State], [System.WorkItemType] FROM WorkItems WHERE [System.TeamProject] = @project AND [System.AssignedTo] = '' AND [System.State] <> 'Closed' ORDER BY [System.CreatedDate] DESC",
          },
        ];
        const selected = await vscode8.window.showQuickPick(templates, {
          placeHolder: 'Select a query template',
          ignoreFocusOut: true,
        });
        if (!selected) return;
        await config.update('workItemQuery', selected.query, vscode8.ConfigurationTarget.Global);
        vscode8.window.showInformationMessage(`Query set to: ${selected.label}`);
        const refreshQuery = getQueryForProvider(provider, activeConnectionId2);
        provider?.refresh(refreshQuery);
        break;
      }
      case 'help': {
        const helpText = [
          '=== WIQL Query Builder Help ===\n',
          '\u{1F4DD} Basic Structure:',
          'SELECT [fields] FROM WorkItems WHERE [conditions] ORDER BY [field]\n',
          '\u{1F50D} Common Fields:',
          '  [System.Id] - Work Item ID',
          '  [System.Title] - Title',
          '  [System.State] - Current state',
          '  [System.AssignedTo] - Assigned user',
          '  [System.WorkItemType] - Type (Bug, Task, etc.)',
          '  [System.CreatedDate] - Creation date',
          '  [System.ChangedDate] - Last modified date',
          '  [System.Tags] - Tags\n',
          '\u26A1 Macros:',
          '  @Me - Current user',
          "  @Today - Today's date",
          '  @Project - Current project',
          '  @CurrentIteration - Current sprint\n',
          '\u{1F3AF} Example:',
          'SELECT [System.Id], [System.Title]',
          'FROM WorkItems',
          'WHERE [System.AssignedTo] = @Me',
          "AND [System.State] <> 'Closed'",
          'ORDER BY [System.ChangedDate] DESC',
        ].join('\n');
        vscode8.window.showInformationMessage(helpText, { modal: true });
        break;
      }
    }
  } catch (error) {
    vscode8.window.showErrorMessage(`Query builder failed: ${error.message || 'Unknown error'}`);
  }
}
function updateTimerContext(s) {
  const running = !!s && !s.isPaused;
  const paused = !!s && s.isPaused;
  if (!isDeactivating2) {
    vscode8.commands.executeCommand('setContext', 'azureDevOpsInt.timerActive', !!s).then(
      () => {},
      () => {}
    );
    vscode8.commands.executeCommand('setContext', 'azureDevOpsInt.timerRunning', running).then(
      () => {},
      () => {}
    );
    vscode8.commands.executeCommand('setContext', 'azureDevOpsInt.timerPaused', paused).then(
      () => {},
      () => {}
    );
  }
  if (statusBarItem) {
    if (s) {
      const connectionLabel = getActiveTimerConnectionLabel();
      const sec = s.elapsedSeconds || 0;
      const h = Math.floor(sec / 3600)
        .toString()
        .padStart(2, '0');
      const m = Math.floor((sec % 3600) / 60)
        .toString()
        .padStart(2, '0');
      const mini = `${h}:${m}`;
      statusBarItem.text = `$(watch) ${mini} #${s.workItemId}${s.isPaused ? ' (Paused)' : ''}`;
      const tooltipLines = [`Azure DevOps Timer for #${s.workItemId}`];
      if (connectionLabel) tooltipLines.push(`Project: ${connectionLabel}`);
      statusBarItem.tooltip = tooltipLines.join('\n');
      statusBarItem.show();
    } else {
      statusBarItem.hide();
    }
  }
}
function verbose(msg, extra) {
  try {
    if (!getOutputChannel()) return;
    if (extra !== void 0) {
      logLine(
        `${/* @__PURE__ */ new Date().toISOString()} ${msg} ${typeof extra === 'string' ? extra : JSON.stringify(extra)}`
      );
    } else {
      logLine(`${/* @__PURE__ */ new Date().toISOString()} ${msg}`);
    }
  } catch {}
}
async function getGitApi() {
  if (cachedGitApi) return cachedGitApi;
  try {
    const gitExt = vscode8.extensions.getExtension('vscode.git');
    if (!gitExt) return void 0;
    const exports = gitExt.isActive ? gitExt.exports : await gitExt.activate();
    const api = exports?.getAPI?.(1);
    cachedGitApi = api;
    return api;
  } catch (error) {
    console.warn('[azureDevOpsInt] Failed to acquire git API', error);
    return void 0;
  }
}
function normalizeBranchRef(ref) {
  if (!ref) return null;
  const trimmed = String(ref).trim();
  if (!trimmed) return null;
  if (trimmed.startsWith('refs/')) {
    const short = trimmed.startsWith('refs/heads/') ? trimmed.slice('refs/heads/'.length) : trimmed;
    return { full: trimmed, short };
  }
  return { full: `refs/heads/${trimmed}`, short: trimmed };
}
function parseBranchArtifactLink(url2) {
  if (!url2 || typeof url2 !== 'string') return null;
  const prefix = 'vstfs:///Git/Ref/';
  if (!url2.startsWith(prefix)) return null;
  try {
    const remainder = url2.slice(prefix.length);
    const parts = remainder.split('%2F');
    if (parts.length < 3) return null;
    const projectId = decodeURIComponent(parts[0]);
    const repositoryId = decodeURIComponent(parts[1]);
    const encodedRef = parts.slice(2).join('%2F');
    const rawRef = decodeURIComponent(encodedRef);
    let refName = rawRef;
    let shortName;
    if (refName.startsWith('GB')) {
      shortName = refName.slice(2);
      if (shortName.startsWith('refs/')) {
        refName = shortName;
        shortName = refName.replace(/^refs\/heads\//, '');
      } else {
        refName = `refs/heads/${shortName}`;
      }
    } else if (refName.startsWith('GT')) {
      shortName = refName.slice(2);
      refName = `refs/tags/${shortName}`;
    } else if (refName.startsWith('refs/')) {
      shortName = refName.replace(/^refs\/heads\//, '');
    }
    return { projectId, repositoryId, refName, shortName };
  } catch (error) {
    console.warn('[azureDevOpsInt] Failed to parse branch artifact link', { url: url2, error });
    return null;
  }
}
function normalizeRepositoryName(name3) {
  if (!name3) return void 0;
  const trimmed = name3.trim().replace(/\.git$/i, '');
  return trimmed.length > 0 ? trimmed : void 0;
}
function parseAzureRemote(remoteUrl) {
  if (!remoteUrl) return void 0;
  try {
    if (/^https?:/i.test(remoteUrl)) {
      const url2 = new URL(remoteUrl);
      const segments = url2.pathname.split('/').filter(Boolean);
      const gitIndex = segments.findIndex((segment) => segment.toLowerCase() === '_git');
      if (gitIndex >= 0 && segments.length > gitIndex + 1) {
        return {
          organization: segments[0],
          project: segments[1],
          repositoryName: normalizeRepositoryName(segments[gitIndex + 1]),
        };
      }
      if (segments.length >= 3) {
        return {
          organization: segments[0],
          project: segments[1],
          repositoryName: normalizeRepositoryName(segments[segments.length - 1]),
        };
      }
    } else if (remoteUrl.includes('ssh.dev.azure.com')) {
      const marker = 'ssh.dev.azure.com:v3/';
      const idx = remoteUrl.indexOf(marker);
      if (idx >= 0) {
        const parts = remoteUrl
          .slice(idx + marker.length)
          .split(/[\\/]/)
          .filter(Boolean);
        if (parts.length >= 3) {
          return {
            organization: parts[0],
            project: parts[1],
            repositoryName: normalizeRepositoryName(parts[2]),
          };
        }
      }
    } else if (remoteUrl.includes('vs-ssh.visualstudio.com')) {
      const marker = 'vs-ssh.visualstudio.com:';
      const idx = remoteUrl.indexOf(marker);
      if (idx >= 0) {
        const after = remoteUrl.slice(idx + marker.length).replace(/^v[23]\//i, '');
        const parts = after.split(/[\\/]/).filter(Boolean);
        if (parts.length >= 3) {
          return {
            organization: parts[0],
            project: parts[1],
            repositoryName: normalizeRepositoryName(parts[2]),
          };
        }
      }
    }
  } catch (error) {
    console.warn('[azureDevOpsInt] Failed to parse Azure remote URL', { remoteUrl, error });
  }
  return void 0;
}
async function getAzureRepositoryByName(connectionId, client2, repoName) {
  if (!repoName) return null;
  const normalized = repoName.trim().toLowerCase();
  if (!normalized) return null;
  const cached = repositoryCacheByConnection.get(connectionId);
  const now = Date.now();
  let repos = null;
  if (cached && now - cached.fetchedAt < REPOSITORY_CACHE_TTL_MS) {
    repos = cached.repos;
  } else {
    try {
      const fetched = await client2.getRepositories();
      if (Array.isArray(fetched)) {
        repos = fetched;
        repositoryCacheByConnection.set(connectionId, { fetchedAt: now, repos: fetched });
      }
    } catch (error) {
      console.warn('[azureDevOpsInt] Failed to fetch repositories', error);
      return null;
    }
  }
  if (!Array.isArray(repos)) return null;
  return (
    repos.find((r) => typeof r?.name === 'string' && r.name.trim().toLowerCase() === normalized) ||
    repos.find((r) => typeof r?.id === 'string' && r.id.trim().toLowerCase() === normalized) ||
    null
  );
}
async function resolveBranchContext(state2) {
  const api = await getGitApi();
  if (!api) return null;
  const repo = Array.isArray(api.repositories) ? api.repositories[0] : void 0;
  if (!repo) return null;
  const head2 = repo.state?.HEAD;
  const normalized = normalizeBranchRef(head2?.name || head2?.upstream?.name);
  if (!normalized) return null;
  const remotes = Array.isArray(repo.state?.remotes) ? repo.state.remotes : [];
  const remote = remotes.find((r) => !r?.isReadOnly && (r?.pushUrl || r?.fetchUrl)) || remotes[0];
  const remoteUrl = remote?.pushUrl || remote?.fetchUrl;
  const parsedRemote = parseAzureRemote(remoteUrl);
  let repositoryId = void 0;
  let repositoryName = parsedRemote?.repositoryName;
  if (repositoryName && state2.client) {
    const repoMeta = await getAzureRepositoryByName(state2.id, state2.client, repositoryName);
    if (repoMeta) {
      if (typeof repoMeta.id === 'string') repositoryId = repoMeta.id;
      if (typeof repoMeta.name === 'string' && repoMeta.name.trim().length > 0) {
        repositoryName = repoMeta.name.trim();
      }
    }
  }
  return {
    branchName: normalized.short,
    branchRef: normalized.full,
    repositoryId,
    repositoryName,
    remoteUrl,
    lastUpdated: Date.now(),
  };
}
async function getBuildsForBranch(connectionId, client2, branchRef, repositoryId) {
  const key2 = `${connectionId}|${repositoryId ?? 'any'}|${branchRef}`;
  const cached = buildCacheByKey.get(key2);
  const now = Date.now();
  if (cached && now - cached.fetchedAt < BUILD_CACHE_TTL_MS) {
    return cached.builds;
  }
  try {
    const builds = await client2.getRecentBuilds({
      top: 5,
      branchName: branchRef,
      repositoryId,
    });
    if (Array.isArray(builds)) {
      buildCacheByKey.set(key2, { fetchedAt: now, builds });
      return builds;
    }
  } catch (error) {
    console.warn('[azureDevOpsInt] Failed to fetch builds for branch', {
      branchRef,
      repositoryId,
      error,
    });
  }
  buildCacheByKey.set(key2, { fetchedAt: now, builds: [] });
  return [];
}
var FINISHED_BUILD_STATUSES = /* @__PURE__ */ new Set(['completed', 'postponed']);
var FINISHED_BUILD_RESULTS = /* @__PURE__ */ new Set([
  'succeeded',
  'failed',
  'canceled',
  'cancelled',
  'partiallysucceeded',
]);
function isBuildActive(summary) {
  if (!summary) return false;
  const status = typeof summary.status === 'string' ? summary.status.toLowerCase() : '';
  if (status) {
    return !FINISHED_BUILD_STATUSES.has(status);
  }
  const result = typeof summary.result === 'string' ? summary.result.toLowerCase() : '';
  if (!result) return true;
  return !FINISHED_BUILD_RESULTS.has(result);
}
function findBestBranchMatch(relations, targetBranchRef, targetBranchName, targetRepositoryId) {
  if (!Array.isArray(relations) || relations.length === 0) return null;
  let best = null;
  for (const relation of relations) {
    const parsed = parseBranchArtifactLink(relation.url);
    if (!parsed) continue;
    const normalized = normalizeBranchRef(parsed.refName || relation.refName);
    const relationRef = normalized?.full?.toLowerCase();
    const relationShort = (normalized?.short || parsed.shortName || '').toLowerCase();
    const desiredRef = targetBranchRef.toLowerCase();
    const desiredShort = targetBranchName.toLowerCase();
    const refMatches = !!relationRef && relationRef === desiredRef;
    const nameMatches = relationShort === desiredShort && desiredShort.length > 0;
    if (!refMatches && !nameMatches) continue;
    const repoMatch =
      targetRepositoryId && parsed.repositoryId
        ? parsed.repositoryId.toLowerCase() === targetRepositoryId.toLowerCase()
        : !targetRepositoryId;
    let score = 0;
    let confidence = 'name';
    if (refMatches) {
      score += 2;
      confidence = repoMatch ? 'exact' : 'refOnly';
    } else if (nameMatches) {
      score += 1;
      confidence = 'name';
    }
    if (repoMatch) score += 1;
    if (!best || score > best.score) {
      const result = {
        relation,
        parsed: {
          projectId: parsed.projectId,
          repositoryId: parsed.repositoryId,
          refName: normalized?.full || parsed.refName,
          shortName: normalized?.short || parsed.shortName,
        },
        confidence,
      };
      best = { score, result };
    }
  }
  return best?.result ?? null;
}
async function enrichWorkItemsForConnection(state2, payload) {
  const sourceItems = Array.isArray(payload.items) ? payload.items : [];
  const client2 = state2.client;
  if (!client2 || sourceItems.length === 0) {
    branchStateByConnection.set(state2.id, {
      context: null,
      hasActiveBuild: false,
      lastUpdated: Date.now(),
    });
    return [...sourceItems];
  }
  const branchContext = await resolveBranchContext(state2);
  if (!branchContext) {
    branchStateByConnection.set(state2.id, {
      context: null,
      hasActiveBuild: false,
      lastUpdated: Date.now(),
    });
    return sourceItems.map((item) => {
      const clone = { ...item };
      if (clone.branchMetadata) delete clone.branchMetadata;
      if (Array.isArray(item.relations)) {
        clone.relations = item.relations.map((rel) => ({ ...rel }));
      }
      return clone;
    });
  }
  const normalizedContext = normalizeBranchRef(branchContext.branchRef || branchContext.branchName);
  if (!normalizedContext) {
    branchStateByConnection.set(state2.id, {
      context: null,
      hasActiveBuild: false,
      lastUpdated: Date.now(),
    });
    return sourceItems;
  }
  const matchedItems = [];
  const unmatchedItems = [];
  const matches2 = [];
  for (const original of sourceItems) {
    const clone = { ...original };
    const relations = Array.isArray(original.relations)
      ? original.relations.map((rel) => {
          const relClone = { ...rel };
          const parsed = parseBranchArtifactLink(rel.url);
          if (parsed) {
            relClone.repositoryId = parsed.repositoryId;
            relClone.projectId = parsed.projectId;
            relClone.refName = parsed.refName;
          }
          return relClone;
        })
      : [];
    if (relations.length > 0) {
      clone.relations = relations;
    }
    const match = findBestBranchMatch(
      relations,
      normalizedContext.full,
      normalizedContext.short,
      branchContext.repositoryId
    );
    if (match) {
      const repositoryIdForMatch = match.parsed.repositoryId ?? branchContext.repositoryId;
      const metadata = {
        isCurrentBranch: true,
        branchName: normalizedContext.short,
        refName: normalizedContext.full,
        repositoryId: repositoryIdForMatch,
        repositoryName: branchContext.repositoryName,
        matchConfidence: match.confidence,
        link: { ...match.relation },
        hasActiveBuild: false,
        lastUpdated: /* @__PURE__ */ new Date().toISOString(),
      };
      clone.branchMetadata = metadata;
      matches2.push({ item: clone, repositoryId: repositoryIdForMatch, parsed: match.parsed });
      matchedItems.push(clone);
    } else {
      if (clone.branchMetadata) delete clone.branchMetadata;
      unmatchedItems.push(clone);
    }
  }
  let hasActiveBuild = false;
  let resolvedRepositoryId = branchContext.repositoryId ?? matches2[0]?.repositoryId;
  if (matches2.length > 0) {
    const buildInfoByRepo = /* @__PURE__ */ new Map();
    const repoKeys = /* @__PURE__ */ new Set();
    for (const entry of matches2) {
      repoKeys.add(entry.repositoryId ?? '__default__');
    }
    for (const repoKey of repoKeys) {
      const resolvedRepoId = repoKey === '__default__' ? branchContext.repositoryId : repoKey;
      const builds = await getBuildsForBranch(
        state2.id,
        client2,
        normalizedContext.full,
        resolvedRepoId
      );
      const latest = Array.isArray(builds) && builds.length > 0 ? builds[0] : void 0;
      const active = isBuildActive(latest);
      if (active) hasActiveBuild = true;
      buildInfoByRepo.set(repoKey, { build: latest, hasActive: active });
    }
    for (const entry of matches2) {
      const info = buildInfoByRepo.get(entry.repositoryId ?? '__default__');
      if (info && entry.item.branchMetadata) {
        entry.item.branchMetadata.build = info.build;
        entry.item.branchMetadata.hasActiveBuild = info.hasActive;
        entry.item.branchMetadata.lastUpdated = /* @__PURE__ */ new Date().toISOString();
      }
    }
  }
  let resolvedRepositoryName = branchContext.repositoryName;
  if (!resolvedRepositoryName && resolvedRepositoryId && state2.client) {
    const repoMeta = await getAzureRepositoryByName(state2.id, state2.client, resolvedRepositoryId);
    if (repoMeta?.name && typeof repoMeta.name === 'string') {
      resolvedRepositoryName = repoMeta.name.trim();
    }
  }
  if (resolvedRepositoryName) {
    for (const entry of matches2) {
      if (entry.item.branchMetadata) {
        entry.item.branchMetadata.repositoryName = resolvedRepositoryName;
      }
    }
  }
  if (resolvedRepositoryId) {
    for (const entry of matches2) {
      if (entry.item.branchMetadata && !entry.item.branchMetadata.repositoryId) {
        entry.item.branchMetadata.repositoryId = resolvedRepositoryId;
      }
    }
  }
  const sortedItems = [...matchedItems, ...unmatchedItems];
  resolvedRepositoryId = branchContext.repositoryId ?? resolvedRepositoryId;
  branchStateByConnection.set(state2.id, {
    context: {
      ...branchContext,
      branchName: normalizedContext.short,
      branchRef: normalizedContext.full,
      repositoryId: resolvedRepositoryId,
      repositoryName: resolvedRepositoryName ?? branchContext.repositoryName,
    },
    hasActiveBuild,
    lastUpdated: Date.now(),
  });
  return sortedItems;
}
function updateBuildRefreshTimer(connectionId, shouldPoll) {
  const existing = buildRefreshTimers.get(connectionId);
  if (shouldPoll) {
    if (existing) return;
    const state2 = connectionStates2.get(connectionId);
    const providerInstance = state2?.provider;
    if (!providerInstance) return;
    const timer2 = setTimeout(() => {
      buildRefreshTimers.delete(connectionId);
      Promise.resolve(providerInstance.refresh()).catch((error) =>
        console.warn('[azureDevOpsInt] Build polling refresh failed', error)
      );
    }, BRANCH_REFRESH_INTERVAL_MS);
    buildRefreshTimers.set(connectionId, timer2);
  } else if (existing) {
    try {
      clearTimeout(existing);
    } catch {}
    buildRefreshTimers.delete(connectionId);
  }
}
function forwardProviderMessage2(connectionId, message) {
  if (message?.type === 'workItemsLoaded') {
    const enrichment = branchStateByConnection.get(connectionId);
    const merged = {
      ...message,
      connectionId,
      branchContext: enrichment?.context ?? null,
    };
    postToWebview({ panel, message: merged, logger: verbose });
    updateBuildRefreshTimer(connectionId, !!enrichment?.hasActiveBuild);
    return;
  }
  const tagged = { ...message, connectionId };
  postToWebview({ panel, message: tagged, logger: verbose });
}
async function createBranchFromWorkItem() {
  const gitExt = vscode8.extensions.getExtension('vscode.git');
  if (!gitExt) {
    vscode8.window.showErrorMessage('Git extension not available.');
    return;
  }
  const api = gitExt.isActive ? gitExt.exports.getAPI(1) : (await gitExt.activate()).getAPI(1);
  const repo = api.repositories?.[0];
  if (!repo) {
    vscode8.window.showWarningMessage('No git repository open.');
    return;
  }
  if (!provider) {
    vscode8.window.showWarningMessage('Work items not loaded yet.');
    return;
  }
  const pick = await vscode8.window.showQuickPick(
    provider.getWorkItems().map((w) => ({
      label: w.fields?.['System.Title'] || `#${w.id}`,
      description: `#${w.id}`,
      wi: w,
    })),
    { placeHolder: 'Select work item for branch' }
  );
  if (!pick) return;
  const wi = pick.wi;
  const id = wi.id || wi.fields?.['System.Id'];
  const rawTitle =
    (wi.fields?.['System.Title'] || '')
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '')
      .slice(0, 40) || `wi-${id}`;
  const branchName = await vscode8.window.showInputBox({
    prompt: 'Branch name',
    value: `feature/wi-${id}-${rawTitle}`,
  });
  if (!branchName) return;
  try {
    await repo.createBranch(branchName, true);
    vscode8.window.showInformationMessage(`Created and switched to ${branchName}`);
    const autoStart = getConfig().get('autoStartTimerOnBranch');
    if (autoStart && timer && !timer.snapshot()) {
      const connection = activeConnectionId2
        ? connections2.find((c) => c.id === activeConnectionId2)
        : void 0;
      const previousInfo = { ...timerConnectionInfo };
      setTimerConnectionFrom(connection);
      const started = timer.start(Number(id), wi.fields?.['System.Title'] || `#${id}`);
      if (!started) timerConnectionInfo = previousInfo;
    }
  } catch (e) {
    vscode8.window.showErrorMessage(`Branch creation failed: ${e.message || e}`);
  }
}
async function createPullRequestInteractive() {
  if (!client) {
    vscode8.window.showWarningMessage('Connect first.');
    return;
  }
  const repos = await client.getRepositories();
  if (!Array.isArray(repos) || repos.length === 0) {
    vscode8.window.showWarningMessage('No repositories found via REST API.');
    return;
  }
  const cfg = getConfig();
  let preferred = (cfg.get('preferredRepositoryIds') || []).filter(Boolean);
  if (!preferred.length) {
    const picks = await vscode8.window.showQuickPick(
      repos.map((r) => ({ label: r.name, description: r.id, picked: false })),
      { placeHolder: 'Select default repositories for PR creation', canPickMany: true }
    );
    if (!picks || picks.length === 0) {
      vscode8.window.showInformationMessage('No repositories selected.');
      return;
    }
    preferred = picks.map((p) => p.description).filter(Boolean);
    try {
      await cfg.update('preferredRepositoryIds', preferred, vscode8.ConfigurationTarget.Global);
    } catch (e) {
      console.warn('[azureDevOpsInt] Failed to persist preferredRepositoryIds', e);
    }
  }
  const repoMap = new Map((repos || []).map((r) => [r.id, r]));
  const validPreferred = preferred.filter((id) => repoMap.has(id));
  if (!validPreferred.length) {
    vscode8.window.showWarningMessage(
      'Your saved repositories are not found in this project. Please reselect.'
    );
    const picks = await vscode8.window.showQuickPick(
      repos.map((r) => ({ label: r.name, description: r.id, picked: false })),
      { placeHolder: 'Select default repositories for PR creation', canPickMany: true }
    );
    if (!picks || picks.length === 0) return;
    const newIds = picks.map((p) => p.description).filter(Boolean);
    await cfg.update('preferredRepositoryIds', newIds, vscode8.ConfigurationTarget.Global);
  }
  const candidateRepos = (cfg.get('preferredRepositoryIds') || [])
    .filter((id) => repoMap.has(id))
    .map((id) => repoMap.get(id));
  let repoPick;
  if (candidateRepos.length === 1) {
    const r = candidateRepos[0];
    repoPick = { label: r.name, description: r.id };
  } else {
    repoPick = await vscode8.window.showQuickPick(
      candidateRepos.map((r) => ({ label: r.name, description: r.id })),
      { placeHolder: 'Select repository for this PR' }
    );
    if (!repoPick) return;
  }
  const source2 = await vscode8.window.showInputBox({
    prompt: 'Source branch (e.g. refs/heads/feature/x)',
    value: 'refs/heads/',
  });
  if (!source2) return;
  const target = await vscode8.window.showInputBox({
    prompt: 'Target branch',
    value: 'refs/heads/main',
  });
  if (!target) return;
  const title = await vscode8.window.showInputBox({ prompt: 'Pull Request title' });
  if (!title) return;
  try {
    const pr = await client.createPullRequest(repoPick.description, source2, target, title);
    vscode8.window.showInformationMessage(`PR created: ${pr.pullRequestId}`);
  } catch (e) {
    vscode8.window.showErrorMessage(`Failed to create PR: ${e.message || e}`);
  }
}
async function showMyPullRequests() {
  if (!client) {
    vscode8.window.showWarningMessage('Connect first.');
    return;
  }
  const prs = await client.getMyPullRequestsAcrossRepos?.('active');
  if (!Array.isArray(prs) || prs.length === 0) {
    vscode8.window.showInformationMessage('No active pull requests.');
    return;
  }
  const pick = await vscode8.window.showQuickPick(
    prs.map((pr) => ({
      label: pr.title,
      description: `#${pr.pullRequestId ?? pr.id} ${pr.sourceRefName?.split('/').pop()} -> ${pr.targetRefName?.split('/').pop()}`,
      detail: pr.webUrl,
    })),
    { placeHolder: 'Open PR in browser' }
  );
  if (!pick) return;
  if (pick.detail) {
    vscode8.env.openExternal(vscode8.Uri.parse(pick.detail));
  }
}
async function showBuildStatus() {
  if (!client) {
    vscode8.window.showWarningMessage('Connect first.');
    return;
  }
  vscode8.window.showInformationMessage('Build status feature not implemented yet.');
}
function __setTestContext(ctx) {
  if (ctx.provider !== void 0) provider = ctx.provider;
  if (ctx.panel !== void 0) panel = ctx.panel;
  if (ctx.timer !== void 0) timer = ctx.timer;
  if (ctx.client !== void 0) client = ctx.client;
  if (ctx.statusBarItem !== void 0) statusBarItem = ctx.statusBarItem;
  if (ctx.outputChannel !== void 0) setOutputChannel(ctx.outputChannel);
}
async function setOpenAIApiKey(context) {
  const current = await context.secrets.get(OPENAI_SECRET_KEY);
  const actions2 = [
    { label: current ? 'Update API key' : 'Set API key', action: 'set' },
    {
      label: 'Clear stored key',
      action: 'clear',
      description: current ? void 0 : 'No key stored',
    },
  ];
  const choice = await vscode8.window.showQuickPick(actions2, {
    placeHolder: current
      ? 'Update or clear the stored OpenAI API key'
      : 'Store an OpenAI API key for summaries',
    ignoreFocusOut: true,
  });
  if (!choice) return;
  if (choice.action === 'set') {
    const input = await vscode8.window.showInputBox({
      prompt: 'Enter your OpenAI API key',
      password: true,
      ignoreFocusOut: true,
      placeHolder: 'sk-...',
    });
    if (!input) return;
    await context.secrets.store(OPENAI_SECRET_KEY, input.trim());
    resetOpenAiClient();
    vscode8.window.showInformationMessage('OpenAI API key saved.');
    if (getSummaryProvider() !== 'openai') {
      const enable = await vscode8.window.showInformationMessage(
        'Would you like to switch the work summary provider to OpenAI?',
        'Yes',
        'Not now'
      );
      if (enable === 'Yes') {
        await getConfig().update('summaryProvider', 'openai', vscode8.ConfigurationTarget.Global);
      }
    }
    return;
  }
  if (!current) {
    vscode8.window.showInformationMessage('No OpenAI API key is stored.');
    return;
  }
  await context.secrets.delete(OPENAI_SECRET_KEY);
  resetOpenAiClient();
  vscode8.window.showInformationMessage('OpenAI API key cleared.');
}
function getSummaryProvider() {
  try {
    const value = (getConfig().get('summaryProvider') || 'builtin').toLowerCase();
    return value === 'openai' ? 'openai' : 'builtin';
  } catch {
    return 'builtin';
  }
}
function resetOpenAiClient() {
  openAiClient = void 0;
}
async function getOpenAIApiKey(context) {
  return context.secrets.get(OPENAI_SECRET_KEY);
}
async function ensureOpenAiClient(context) {
  if (openAiClient) return openAiClient;
  const apiKey = (await getOpenAIApiKey(context))?.trim();
  if (!apiKey) {
    throw new Error(
      'OpenAI API key not set. Use \u201CAzure DevOps: Set OpenAI API Key\u201D to store one.'
    );
  }
  const module = await Promise.resolve().then(() => (init_openai(), openai_exports));
  const OpenAIConstructor = module.default ?? module.OpenAI;
  if (typeof OpenAIConstructor !== 'function') {
    throw new Error('Failed to initialize OpenAI client.');
  }
  openAiClient = new OpenAIConstructor({ apiKey });
  return openAiClient;
}
function normalizeSummaryEntrySeed(workItemId, seed) {
  const snapshot2 = timer?.snapshot?.();
  const matchesSnapshot = snapshot2 && Number(snapshot2.workItemId) === Number(workItemId);
  const startTime = seed?.startTime ?? (matchesSnapshot ? snapshot2?.startTime : void 0);
  const endTime = seed?.endTime ?? (startTime ? Date.now() : void 0);
  const rawDuration =
    typeof seed?.duration === 'number'
      ? seed.duration
      : matchesSnapshot && typeof snapshot2?.elapsedSeconds === 'number'
        ? snapshot2.elapsedSeconds
        : void 0;
  const hoursDecimal =
    typeof seed?.hoursDecimal === 'number'
      ? seed.hoursDecimal
      : typeof rawDuration === 'number'
        ? rawDuration > 1e3
          ? rawDuration / 36e5
          : rawDuration / 3600
        : void 0;
  return {
    workItemId,
    startTime,
    endTime,
    duration: rawDuration,
    hoursDecimal,
    capApplied: seed?.capApplied,
    capLimitHours: seed?.capLimitHours,
  };
}
function entrySeedFromMessage(message, workItemId) {
  if (!message || typeof message !== 'object') return void 0;
  const seed = {};
  let hasValue = false;
  if (typeof message.startTime === 'number') {
    seed.startTime = message.startTime;
    hasValue = true;
  }
  if (typeof message.endTime === 'number') {
    seed.endTime = message.endTime;
    hasValue = true;
  }
  if (typeof message.hoursDecimal === 'number') {
    seed.hoursDecimal = message.hoursDecimal;
    hasValue = true;
  }
  if (typeof message.duration === 'number') {
    seed.duration = message.duration;
    hasValue = true;
  }
  if (typeof message.capApplied === 'boolean') {
    seed.capApplied = message.capApplied;
    hasValue = true;
  }
  if (typeof message.capLimitHours === 'number') {
    seed.capLimitHours = message.capLimitHours;
    hasValue = true;
  }
  if (!hasValue) return void 0;
  return { ...seed, workItemId };
}
function toPlainText(value, maxLength = 2e3) {
  if (!value || typeof value !== 'string') return '';
  const text2 = value
    .replace(/<style[\s\S]*?<\/style>/gi, ' ')
    .replace(/<script[\s\S]*?<\/script>/gi, ' ')
    .replace(/<[^>]+>/g, ' ')
    .replace(/&nbsp;/gi, ' ')
    .replace(/&amp;/gi, '&')
    .replace(/&lt;/gi, '<')
    .replace(/&gt;/gi, '>')
    .replace(/&quot;/gi, '"')
    .replace(/&#39;/gi, "'")
    .replace(/\s+/g, ' ')
    .trim();
  if (text2.length <= maxLength) return text2;
  return `${text2.slice(0, maxLength).trimEnd()}\u2026`;
}
function buildOpenAiPrompt(workItem, seed, draftSummary) {
  const fields = workItem?.fields || {};
  const title = fields['System.Title'] || `#${workItem?.id}`;
  const type = fields['System.WorkItemType'] || 'Work Item';
  const state2 = fields['System.State'] || 'Unknown';
  const assignedTo = fields['System.AssignedTo'];
  const description = toPlainText(fields['System.Description']);
  const tags = toPlainText(fields['System.Tags'] || '')
    .split(';')
    .map((t) => t.trim())
    .filter(Boolean);
  const start = seed?.startTime ? new Date(seed.startTime).toISOString() : void 0;
  const end = seed?.endTime ? new Date(seed.endTime).toISOString() : void 0;
  const hours =
    typeof seed?.hoursDecimal === 'number'
      ? seed.hoursDecimal
      : typeof seed?.duration === 'number'
        ? seed.duration / 3600
        : void 0;
  const notes = toPlainText(draftSummary || '', 1e3);
  const lines = [];
  lines.push('You are helping summarize Azure DevOps work.');
  lines.push(
    'Write a concise 1-2 sentence summary suitable as a work item comment. Mention progress, impact, and next steps if relevant.'
  );
  lines.push('Avoid hedging language, keep it factual.');
  lines.push('\nContext:');
  lines.push(`- Work item: #${workItem?.id} | ${type} | ${title}`);
  lines.push(`- Current state: ${state2}`);
  if (assignedTo)
    lines.push(
      `- Assigned to: ${typeof assignedTo === 'string' ? assignedTo : assignedTo.displayName || assignedTo.uniqueName || 'Unknown'}`
    );
  if (typeof hours === 'number') lines.push(`- Time spent: ${hours.toFixed(2)} hours`);
  if (start) lines.push(`- Start time: ${start}`);
  if (end) lines.push(`- End time: ${end}`);
  if (tags.length) lines.push(`- Tags: ${tags.join(', ')}`);
  if (description) {
    lines.push('\nWork item details:');
    lines.push(description);
  }
  if (notes) {
    lines.push('\nUser notes:');
    lines.push(notes);
  }
  lines.push('\nRespond with only the summary sentences.');
  return lines.join('\n');
}
async function generateOpenAiSummary(options) {
  if (!extensionContextRef2) {
    throw new Error('Extension context unavailable.');
  }
  const client2 = await ensureOpenAiClient(extensionContextRef2);
  const prompt = buildOpenAiPrompt(options.workItem, options.seed, options.draftSummary);
  const response = await client2.responses.create({
    model: options.model,
    input: prompt,
    temperature: 0.2,
    max_output_tokens: 320,
  });
  const text2 = response?.output_text;
  if (!text2 || typeof text2 !== 'string' || !text2.trim()) {
    throw new Error('OpenAI returned an empty summary.');
  }
  return text2.trim();
}
async function produceWorkItemSummary(options) {
  if (!client) throw new Error('Client not initialized');
  const workItem = await client.getWorkItemById(options.workItemId);
  if (!workItem) throw new Error(`Work item #${options.workItemId} not found.`);
  const seed = normalizeSummaryEntrySeed(options.workItemId, options.entrySeed);
  const provider2 = options.providerOverride ?? getSummaryProvider();
  if (provider2 === 'openai') {
    try {
      const model = getConfig().get('openAiModel') || 'gpt-4o-mini';
      const summary = await generateOpenAiSummary({
        workItem,
        seed,
        draftSummary: options.draftSummary,
        model,
      });
      await vscode8.env.clipboard.writeText(summary);
      panel?.webview.postMessage({
        type: 'copilotPromptCopied',
        workItemId: options.workItemId,
        provider: 'openai',
        summary,
      });
      const message2 = options.stillRunningTimer
        ? 'Generated an OpenAI summary and copied it to the clipboard while the timer continues running.'
        : 'Generated an OpenAI summary and copied it to the clipboard.';
      vscode8.window.showInformationMessage(message2);
      return { provider: 'openai', content: summary };
    } catch (err) {
      console.error('OpenAI summary generation failed', err);
      vscode8.window.showErrorMessage(
        err instanceof Error && err.message
          ? err.message
          : 'Failed to generate OpenAI summary. Falling back to Copilot prompt.'
      );
      return produceWorkItemSummary({ ...options, providerOverride: 'builtin' });
    }
  }
  const prompt = buildCopilotPrompt(seed || { workItemId: options.workItemId }, workItem);
  await vscode8.env.clipboard.writeText(prompt);
  panel?.webview.postMessage({
    type: 'copilotPromptCopied',
    workItemId: options.workItemId,
    provider: 'builtin',
    prompt,
  });
  const message = options.stillRunningTimer
    ? 'Copilot prompt copied to clipboard. The timer is still running.'
    : 'Copilot prompt copied to clipboard. Open Copilot chat and paste to generate a summary.';
  vscode8.window.showInformationMessage(message);
  return { provider: 'builtin', content: prompt };
}
async function handleTimerStopAndOfferUpdate(entry, options) {
  if (!entry) return;
  const connectionInfo = options?.connection ?? timerConnectionInfo;
  if (panel?.webview) {
    revealWorkItemsView();
    sendToWebview({
      type: 'showComposeComment',
      workItemId: entry.workItemId,
      mode: 'timerStop',
      timerData: entry,
      connectionInfo,
    });
    return;
  }
  const clientForTimer = getClientForConnectionInfo(connectionInfo);
  if (!clientForTimer) {
    vscode8.window.showWarningMessage(
      'Timer stopped but no Azure DevOps client is available for the associated project. Connect and try again.'
    );
    return;
  }
  const id = Number(entry.workItemId);
  let workItem;
  try {
    workItem = await clientForTimer.getWorkItemById(id);
  } catch (err) {
    console.error('Failed to load work item for timer stop', err);
    vscode8.window.showErrorMessage('Failed to load work item: ' + (err?.message || String(err)));
    return;
  }
  if (!workItem) {
    vscode8.window.showErrorMessage(`Work item #${id} not found.`);
    return;
  }
  const fields = workItem.fields || {};
  const title = fields['System.Title'] || `#${id}`;
  const currCompleted = Number(fields['Microsoft.VSTS.Scheduling.CompletedWork'] || 0) || 0;
  const currRemaining = Number(fields['Microsoft.VSTS.Scheduling.RemainingWork'] || 0) || 0;
  const hours = Number(entry.hoursDecimal || entry.duration / 3600 || 0);
  const suggestedCompleted = Number((currCompleted + hours).toFixed(2));
  const suggestedRemaining = Number(Math.max(0, currRemaining - hours).toFixed(2));
  const initialOptions = ['Apply', 'Edit'];
  if (options?.offerCopilot !== false) {
    initialOptions.push('Generate Copilot prompt');
  }
  let promptMsg = `Add ${hours.toFixed(
    2
  )}h to Completed (${currCompleted} \u2192 ${suggestedCompleted}) and subtract from Remaining (${currRemaining} \u2192 ${suggestedRemaining}) for ${title}?`;
  if (entry.capApplied) {
    promptMsg += `

Note: the timer elapsed exceeded the configured cap of ${entry.capLimitHours} hours and the recorded duration was limited to ${hours.toFixed(2)}h.`;
  }
  let action2 = await vscode8.window.showInformationMessage(
    promptMsg,
    { modal: true },
    ...initialOptions
  );
  if (!action2) return;
  let comment2 = generateAutoSummary(entry, workItem);
  if (action2 === 'Generate Copilot prompt') {
    try {
      const previousClient = client;
      try {
        client = clientForTimer;
        const result = await produceWorkItemSummary({
          workItemId: id,
          draftSummary: comment2,
          entrySeed: entry,
          reason: 'timerStop',
        });
        if (result.provider === 'openai' && result.content) {
          comment2 = result.content;
        }
      } finally {
        client = previousClient;
      }
    } catch (err) {
      console.error('Failed to generate summary prompt', err);
      vscode8.window.showErrorMessage(
        'Failed to generate summary prompt: ' + (err?.message || String(err))
      );
    }
    action2 = await vscode8.window.showInformationMessage(
      `After generating the summary in Copilot, choose how to proceed for work item #${id}.`,
      { modal: true },
      'Apply',
      'Edit'
    );
    if (!action2) return;
  }
  let finalCompleted = suggestedCompleted;
  let finalRemaining = suggestedRemaining;
  if (action2 === 'Edit') {
    const c = await vscode8.window.showInputBox({
      prompt: 'Completed work (hours)',
      value: String(suggestedCompleted),
      ignoreFocusOut: true,
    });
    if (!c) return;
    finalCompleted = Number(c);
    const r = await vscode8.window.showInputBox({
      prompt: 'Remaining work (hours)',
      value: String(suggestedRemaining),
      ignoreFocusOut: true,
    });
    if (!r) return;
    finalRemaining = Number(r);
    const edited = await vscode8.window.showInputBox({
      prompt: 'Summary comment (will be added to the work item)',
      value: comment2,
      ignoreFocusOut: true,
    });
    if (edited !== void 0) comment2 = edited;
  } else {
    const edited = await vscode8.window.showInputBox({
      prompt: 'Summary comment (optional)',
      value: comment2,
      ignoreFocusOut: true,
    });
    if (edited !== void 0) comment2 = edited;
  }
  const patch = [
    { op: 'add', path: '/fields/Microsoft.VSTS.Scheduling.CompletedWork', value: finalCompleted },
    { op: 'add', path: '/fields/Microsoft.VSTS.Scheduling.RemainingWork', value: finalRemaining },
  ];
  try {
    await clientForTimer.updateWorkItem(id, patch);
    if (comment2 && comment2.trim()) {
      await clientForTimer.addWorkItemComment(
        id,
        `Time tracked: ${hours.toFixed(2)} hours. ${comment2}`
      );
    }
    vscode8.window.showInformationMessage(
      `Work item #${id} updated: Completed ${finalCompleted}h, Remaining ${finalRemaining}h.`
    );
  } catch (err) {
    console.error('Failed to update work item', err);
    vscode8.window.showErrorMessage('Failed to update work item: ' + (err?.message || String(err)));
  }
}
function generateAutoSummary(entry, workItem) {
  try {
    const title = workItem?.fields?.['System.Title'] || `#${entry.workItemId}`;
    const start = entry.startTime ? new Date(entry.startTime).toLocaleString() : '';
    const end = entry.endTime ? new Date(entry.endTime).toLocaleString() : '';
    const hrs = Number(entry.hoursDecimal || 0).toFixed(2);
    return `Auto-summary: Worked ${hrs}h on "${title}" (${start} \u2192 ${end}).`;
  } catch {
    return `Worked ${Number(entry.hoursDecimal || 0).toFixed(2)}h on work item #${entry.workItemId}.`;
  }
}
function buildCopilotPrompt(entry, workItem) {
  const title = workItem?.fields?.['System.Title'] || `#${entry.workItemId}`;
  const start = entry.startTime ? new Date(entry.startTime).toLocaleString() : '';
  const end = entry.endTime ? new Date(entry.endTime).toLocaleString() : '';
  const hrs = Number(entry.hoursDecimal || entry.duration / 3600 || 0).toFixed(2);
  return `You are my assistant. Summarize the work I performed on work item #${entry.workItemId} entitled "${title}" between ${start} and ${end} (total ${hrs} hours). Produce a concise 1-2 sentence summary suitable as a comment on the work item that highlights the outcome, key changes, and suggested next steps.`;
}
async function diagnoseWorkItemsIssue(context) {
  const outputChannel2 =
    getOutputChannel() || vscode8.window.createOutputChannel('Azure DevOps Integration');
  outputChannel2.show(true);
  logLine('[DIAGNOSIS] Starting work items diagnostic...');
  try {
    await ensureConnectionsInitialized(context);
    if (connections2.length === 0) {
      logLine('[DIAGNOSIS] \u274C No connections configured');
      vscode8.window.showErrorMessage(
        'No Azure DevOps connections found. Please run the Setup Wizard first.'
      );
      return;
    }
    logLine(`[DIAGNOSIS] Found ${connections2.length} connection(s)`);
    connections2.forEach((conn, i) => {
      logLine(`[DIAGNOSIS]   ${i + 1}. ${conn.organization}/${conn.project} (ID: ${conn.id})`);
    });
    const state2 = await ensureActiveConnection(context, activeConnectionId2, { refresh: false });
    if (!state2) {
      logLine('[DIAGNOSIS] \u274C Failed to establish active connection');
      vscode8.window.showErrorMessage('Failed to establish connection to Azure DevOps');
      return;
    }
    logLine(
      `[DIAGNOSIS] \u2705 Active connection: ${state2.config.organization}/${state2.config.project}`
    );
    if (!state2.client) {
      logLine('[DIAGNOSIS] \u274C No client available - check PAT configuration');
      vscode8.window.showErrorMessage(
        'No Azure DevOps client available. Check your Personal Access Token.'
      );
      return;
    }
    logLine('[DIAGNOSIS] Testing authentication...');
    try {
      const userId = await state2.client.getAuthenticatedUserId();
      logLine(`[DIAGNOSIS] \u2705 Authentication successful. User ID: ${userId || 'unknown'}`);
    } catch (error) {
      logLine(`[DIAGNOSIS] \u274C Authentication failed: ${error.message}`);
      vscode8.window.showErrorMessage('Authentication failed. Check your Personal Access Token.');
      return;
    }
    logLine('[DIAGNOSIS] Testing simple work item query...');
    try {
      const simpleQuery =
        'SELECT [System.Id], [System.Title] FROM WorkItems ORDER BY [System.Id] DESC';
      const simpleResults = await state2.client.runWIQL(simpleQuery);
      logLine(`[DIAGNOSIS] \u2705 Simple query returned ${simpleResults.length} work items`);
      if (simpleResults.length === 0) {
        logLine('[DIAGNOSIS] \u26A0\uFE0F  Project has no work items at all');
        vscode8.window.showWarningMessage(
          'This project appears to have no work items. Try creating a work item first.'
        );
        return;
      } else {
        const sample = simpleResults[0];
        logLine(
          `[DIAGNOSIS]     Sample: #${sample.id} - ${sample.fields?.['System.Title'] || 'No title'}`
        );
      }
    } catch (error) {
      logLine(`[DIAGNOSIS] \u274C Simple query failed: ${error.message}`);
      vscode8.window.showErrorMessage('Failed to query work items. Check your PAT permissions.');
      return;
    }
    const testQueries = [
      { name: 'My Activity', query: 'My Activity' },
      { name: 'All Active', query: 'All Active' },
      { name: 'Assigned to me', query: 'Assigned to me' },
    ];
    for (const test2 of testQueries) {
      logLine(`[DIAGNOSIS] Testing "${test2.name}" query...`);
      try {
        const results = await state2.client.getWorkItems(test2.query);
        logLine(`[DIAGNOSIS] \u2705 "${test2.name}" returned ${results.length} work items`);
        if (results.length > 0) {
          const sample = results[0];
          logLine(
            `[DIAGNOSIS]     Sample: #${sample.id} - ${sample.fields?.['System.Title'] || 'No title'}`
          );
        }
      } catch (error) {
        logLine(`[DIAGNOSIS] \u274C "${test2.name}" failed: ${error.message}`);
      }
    }
    logLine('[DIAGNOSIS] Testing work item types...');
    try {
      const workItemTypes = await state2.client.getWorkItemTypes();
      logLine(`[DIAGNOSIS] \u2705 Found ${workItemTypes.length} work item types:`);
      workItemTypes.slice(0, 5).forEach((type) => {
        logLine(`[DIAGNOSIS]     - ${type.name || type}`);
      });
    } catch (error) {
      logLine(`[DIAGNOSIS] \u274C Failed to get work item types: ${error.message}`);
    }
    if (provider) {
      const cachedItems = provider.getWorkItems();
      logLine(`[DIAGNOSIS] \u2705 Provider has ${cachedItems.length} cached work items`);
      if (cachedItems.length === 0) {
        logLine('[DIAGNOSIS] \u26A0\uFE0F  Provider cache is empty - this is likely the issue');
        logLine('[DIAGNOSIS] Triggering manual refresh...');
        const defaultQuery = getDefaultQuery(getConfig());
        await provider.refresh(defaultQuery);
        await new Promise((resolve) => setTimeout(resolve, 2e3));
        const refreshedItems = provider.getWorkItems();
        logLine(`[DIAGNOSIS] After refresh: ${refreshedItems.length} work items`);
        if (refreshedItems.length > 0) {
          logLine('[DIAGNOSIS] \u2705 Refresh successful! Work items should now appear in the UI.');
          vscode8.window.showInformationMessage(
            'Diagnostic completed successfully. Work items should now be visible.'
          );
        } else {
          logLine(
            '[DIAGNOSIS] \u274C Refresh returned no items. This may be normal if you have no work items matching the default query.'
          );
          vscode8.window.showWarningMessage(
            'No work items match the current query. Try changing the query or creating work items.'
          );
        }
      } else {
        logLine('[DIAGNOSIS] \u2705 Provider cache has items - they should be visible in the UI');
        vscode8.window.showInformationMessage(
          'Diagnostic completed. Work items are cached and should be visible.'
        );
      }
    } else {
      logLine('[DIAGNOSIS] \u274C No provider available');
      vscode8.window.showErrorMessage(
        'No work items provider available. Try reloading the window.'
      );
    }
    logLine('[DIAGNOSIS] Diagnostic completed. Check the log above for details.');
  } catch (error) {
    logLine(`[DIAGNOSIS] \u274C Diagnostic failed: ${error.message}`);
    vscode8.window.showErrorMessage(`Diagnostic failed: ${error.message}`);
  }
}
function registerAllCommands(context) {
  console.log('[registerAllCommands] Commands are already registered in the activate function');
}
function getLoadedConnections() {
  return connections2;
}
function getActiveConnectionId() {
  return activeConnectionId2 ?? null;
}
setRegisterAllCommands(registerAllCommands);
setForwardProviderMessage(forwardProviderMessage2);
setGetSecretPAT(getSecretPAT2);
setLoadedConnectionsReader(() => connections2);
setActiveConnectionIdReader(() => activeConnectionId2 ?? null);
export {
  __setTestContext,
  activate,
  buildMinimalWebviewHtml,
  deactivate,
  extensionContextRef2 as extensionContextRef,
  forwardProviderMessage2 as forwardProviderMessage,
  getActiveConnectionId,
  getLoadedConnections,
  getSecretPAT2 as getSecretPAT,
  handleLegacyMessage,
  handleLegacyMessage as handleMessage,
  migrateLegacyConfigIfNeeded,
  migrateLegacyPAT,
  persistTimer,
  registerAllCommands,
  resolveDefaultQuery,
  restoreTimer,
  selfTestWebview,
};
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

partysocket/dist/index.js:
  (*!
   * Reconnecting WebSocket
   * by Pedro Ladaria <pedro.ladaria@gmail.com>
   * https://github.com/pladaria/reconnecting-websocket
   * License MIT
   *)

@azure/msal-node/dist/cache/serializer/Serializer.mjs:
@azure/msal-node/dist/cache/serializer/Deserializer.mjs:
@azure/msal-node/dist/internals.mjs:
@azure/msal-node/dist/utils/Constants.mjs:
@azure/msal-node/dist/utils/NetworkUtils.mjs:
@azure/msal-node/dist/network/HttpClient.mjs:
@azure/msal-node/dist/error/ManagedIdentityErrorCodes.mjs:
@azure/msal-node/dist/error/ManagedIdentityError.mjs:
@azure/msal-node/dist/config/ManagedIdentityId.mjs:
@azure/msal-node/dist/error/NodeAuthError.mjs:
@azure/msal-node/dist/config/Configuration.mjs:
@azure/msal-node/dist/crypto/GuidGenerator.mjs:
@azure/msal-node/dist/utils/EncodingUtils.mjs:
@azure/msal-node/dist/crypto/HashUtils.mjs:
@azure/msal-node/dist/crypto/PkceGenerator.mjs:
@azure/msal-node/dist/crypto/CryptoProvider.mjs:
@azure/msal-node/dist/cache/CacheHelpers.mjs:
@azure/msal-node/dist/cache/NodeStorage.mjs:
@azure/msal-node/dist/cache/TokenCache.mjs:
@azure/msal-node/dist/client/ClientAssertion.mjs:
@azure/msal-node/dist/packageMetadata.mjs:
@azure/msal-node/dist/client/UsernamePasswordClient.mjs:
@azure/msal-node/dist/protocol/Authorize.mjs:
@azure/msal-node/dist/client/ClientApplication.mjs:
@azure/msal-node/dist/network/LoopbackClient.mjs:
@azure/msal-node/dist/client/DeviceCodeClient.mjs:
@azure/msal-node/dist/client/PublicClientApplication.mjs:
@azure/msal-node/dist/client/ClientCredentialClient.mjs:
@azure/msal-node/dist/client/OnBehalfOfClient.mjs:
@azure/msal-node/dist/client/ConfidentialClientApplication.mjs:
@azure/msal-node/dist/utils/TimeUtils.mjs:
@azure/msal-node/dist/network/HttpClientWithRetries.mjs:
@azure/msal-node/dist/client/ManagedIdentitySources/BaseManagedIdentitySource.mjs:
@azure/msal-node/dist/retry/LinearRetryStrategy.mjs:
@azure/msal-node/dist/retry/DefaultManagedIdentityRetryPolicy.mjs:
@azure/msal-node/dist/config/ManagedIdentityRequestParameters.mjs:
@azure/msal-node/dist/client/ManagedIdentitySources/AppService.mjs:
@azure/msal-node/dist/client/ManagedIdentitySources/AzureArc.mjs:
@azure/msal-node/dist/client/ManagedIdentitySources/CloudShell.mjs:
@azure/msal-node/dist/retry/ExponentialRetryStrategy.mjs:
@azure/msal-node/dist/retry/ImdsRetryPolicy.mjs:
@azure/msal-node/dist/client/ManagedIdentitySources/Imds.mjs:
@azure/msal-node/dist/client/ManagedIdentitySources/ServiceFabric.mjs:
@azure/msal-node/dist/client/ManagedIdentitySources/MachineLearning.mjs:
@azure/msal-node/dist/client/ManagedIdentityClient.mjs:
@azure/msal-node/dist/client/ManagedIdentityApplication.mjs:
@azure/msal-node/dist/cache/distributed/DistributedCachePlugin.mjs:
@azure/msal-node/dist/index.mjs:
  (*! @azure/msal-node v3.8.0 2025-09-24 *)

@azure/msal-common/dist/utils/Constants.mjs:
@azure/msal-common/dist/error/AuthErrorCodes.mjs:
@azure/msal-common/dist/error/AuthError.mjs:
@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs:
@azure/msal-common/dist/error/ClientAuthError.mjs:
@azure/msal-common/dist/crypto/ICrypto.mjs:
@azure/msal-common/dist/logger/Logger.mjs:
@azure/msal-common/dist/packageMetadata.mjs:
@azure/msal-common/dist/authority/AuthorityOptions.mjs:
@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs:
@azure/msal-common/dist/error/ClientConfigurationError.mjs:
@azure/msal-common/dist/utils/StringUtils.mjs:
@azure/msal-common/dist/request/ScopeSet.mjs:
@azure/msal-common/dist/account/AccountInfo.mjs:
@azure/msal-common/dist/account/AuthToken.mjs:
@azure/msal-common/dist/utils/UrlUtils.mjs:
@azure/msal-common/dist/url/UrlString.mjs:
@azure/msal-common/dist/authority/AuthorityMetadata.mjs:
@azure/msal-common/dist/error/CacheErrorCodes.mjs:
@azure/msal-common/dist/error/CacheError.mjs:
@azure/msal-common/dist/cache/CacheManager.mjs:
@azure/msal-common/dist/authority/ProtocolMode.mjs:
@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs:
@azure/msal-common/dist/telemetry/performance/StubPerformanceClient.mjs:
@azure/msal-common/dist/config/ClientConfiguration.mjs:
@azure/msal-common/dist/account/CcsCredential.mjs:
@azure/msal-common/dist/account/ClientInfo.mjs:
@azure/msal-common/dist/constants/AADServerParamKeys.mjs:
@azure/msal-common/dist/request/RequestParameterBuilder.mjs:
@azure/msal-common/dist/authority/AuthorityType.mjs:
@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs:
@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs:
@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs:
@azure/msal-common/dist/utils/FunctionWrappers.mjs:
@azure/msal-common/dist/authority/RegionDiscovery.mjs:
@azure/msal-common/dist/utils/TimeUtils.mjs:
@azure/msal-common/dist/cache/utils/CacheHelpers.mjs:
@azure/msal-common/dist/authority/Authority.mjs:
@azure/msal-common/dist/authority/AuthorityFactory.mjs:
@azure/msal-common/dist/error/ServerError.mjs:
@azure/msal-common/dist/network/RequestThumbprint.mjs:
@azure/msal-common/dist/network/ThrottlingUtils.mjs:
@azure/msal-common/dist/error/NetworkError.mjs:
@azure/msal-common/dist/client/BaseClient.mjs:
@azure/msal-common/dist/account/TokenClaims.mjs:
@azure/msal-common/dist/cache/entities/AccountEntity.mjs:
@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs:
@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs:
@azure/msal-common/dist/utils/ProtocolUtils.mjs:
@azure/msal-common/dist/crypto/PopTokenGenerator.mjs:
@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs:
@azure/msal-common/dist/response/ResponseHandler.mjs:
@azure/msal-common/dist/utils/ClientAssertionUtils.mjs:
@azure/msal-common/dist/client/AuthorizationCodeClient.mjs:
@azure/msal-common/dist/client/RefreshTokenClient.mjs:
@azure/msal-common/dist/client/SilentFlowClient.mjs:
@azure/msal-common/dist/protocol/Authorize.mjs:
@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs:
@azure/msal-common/dist/index-node.mjs:
@azure/msal-common/dist/index.mjs:
  (*! @azure/msal-common v15.13.0 2025-09-24 *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/

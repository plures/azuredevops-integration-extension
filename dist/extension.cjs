"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name3 in all3)
    __defProp(target, name3, { get: all3[name3], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/logging.ts
function setOutputChannel(channel) {
  outputChannel = channel;
}
function getOutputChannel() {
  return outputChannel;
}
function logLine(text2) {
  try {
    outputChannel?.appendLine(text2);
  } catch {
  }
  try {
    logBuffer.push(text2);
    if (logBuffer.length > LOG_BUFFER_MAX) {
      logBuffer.splice(0, logBuffer.length - LOG_BUFFER_MAX);
    }
  } catch {
  }
}
function getLogBufferSnapshot() {
  return [...logBuffer];
}
function bridgeConsoleToOutputChannel() {
  const originalConsoleLog = console.log;
  const originalConsoleError = console.error;
  const originalConsoleWarn = console.warn;
  console.log = function(...args) {
    try {
      const message = args.map((arg) => {
        if (typeof arg === "string") return arg;
        try {
          return JSON.stringify(arg);
        } catch {
          return String(arg);
        }
      }).join(" ");
      logLine(`[console.log] ${message}`);
    } catch {
    }
    return originalConsoleLog.apply(console, args);
  };
  console.error = function(...args) {
    try {
      const message = args.map((arg) => {
        if (typeof arg === "string") return arg;
        if (arg instanceof Error) return `${arg.message}
${arg.stack}`;
        try {
          return JSON.stringify(arg);
        } catch {
          return String(arg);
        }
      }).join(" ");
      logLine(`[console.error] ${message}`);
    } catch {
    }
    return originalConsoleError.apply(console, args);
  };
  console.warn = function(...args) {
    try {
      const message = args.map((arg) => {
        if (typeof arg === "string") return arg;
        try {
          return JSON.stringify(arg);
        } catch {
          return String(arg);
        }
      }).join(" ");
      logLine(`[console.warn] ${message}`);
    } catch {
    }
    return originalConsoleWarn.apply(console, args);
  };
}
var LOG_BUFFER_MAX, outputChannel, logBuffer;
var init_logging = __esm({
  "src/logging.ts"() {
    "use strict";
    LOG_BUFFER_MAX = 5e3;
    logBuffer = [];
  }
});

// src/logging/StandardizedAutomaticLogger.ts
var StandardizedAutomaticLogger, standardizedLogger;
var init_StandardizedAutomaticLogger = __esm({
  "src/logging/StandardizedAutomaticLogger.ts"() {
    "use strict";
    init_logging();
    StandardizedAutomaticLogger = class _StandardizedAutomaticLogger {
      static instance;
      sessionId;
      entries = [];
      maxEntries = 1e4;
      constructor() {
        this.sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(7)}`;
      }
      static getInstance() {
        if (!_StandardizedAutomaticLogger.instance) {
          _StandardizedAutomaticLogger.instance = new _StandardizedAutomaticLogger();
        }
        return _StandardizedAutomaticLogger.instance;
      }
      /**
       * Format log message according to standard:
       * [azuredevops-integration-extension][{runtime}][{flowName}][{componentName}][{functionName}] {message}
       */
      formatMessage(context, message) {
        const prefix = "[azuredevops-integration-extension]";
        const runtime = `[${context.runtime}]`;
        const flow = `[${context.flowName}]`;
        const component2 = `[${context.componentName}]`;
        const functionPart = context.functionName ? `[${context.functionName}]` : "";
        return `${prefix}${runtime}${flow}${component2}${functionPart} ${message}`;
      }
      /**
       * Format metadata for logging
       */
      formatMeta(meta) {
        if (!meta || Object.keys(meta).length === 0) return "";
        try {
          return ` ${JSON.stringify(meta)}`;
        } catch {
          return " [unserializable meta]";
        }
      }
      /**
       * Determine runtime context automatically
       */
      detectRuntime() {
        if (typeof window !== "undefined" && typeof window.acquireVsCodeApi === "function") {
          return "webview";
        }
        if (typeof process !== "undefined" && process?.versions?.node) {
          return "ext";
        }
        return "ext";
      }
      /**
       * Core logging method
       */
      log(flowName, componentName, functionName, level, message, meta) {
        const runtime = this.detectRuntime();
        const context = {
          runtime,
          flowName,
          componentName,
          functionName
        };
        const entry = {
          context,
          level,
          message,
          meta,
          timestamp: Date.now(),
          sessionId: this.sessionId
        };
        this.entries.push(entry);
        if (this.entries.length > this.maxEntries) {
          this.entries = this.entries.slice(-this.maxEntries);
        }
        const formattedMessage = this.formatMessage(context, message);
        const metaText = this.formatMeta(meta);
        const fullMessage = `${formattedMessage}${metaText}`;
        logLine(fullMessage);
        switch (level) {
          case "error":
            console.error(fullMessage);
            break;
          case "warn":
            console.warn(fullMessage);
            break;
          case "debug":
            console.debug(fullMessage);
            break;
          default:
            console.log(fullMessage);
        }
      }
      /**
       * Convenience methods for each log level
       */
      debug(flowName, componentName, functionName, message, meta) {
        this.log(flowName, componentName, functionName, "debug", message, meta);
      }
      info(flowName, componentName, functionName, message, meta) {
        this.log(flowName, componentName, functionName, "info", message, meta);
      }
      warn(flowName, componentName, functionName, message, meta) {
        this.log(flowName, componentName, functionName, "warn", message, meta);
      }
      error(flowName, componentName, functionName, message, meta) {
        this.log(flowName, componentName, functionName, "error", message, meta);
      }
      /**
       * Get all log entries (for replay/export)
       */
      getEntries(filter2) {
        let entries = [...this.entries];
        if (filter2?.flowName) {
          entries = entries.filter((e) => e.context.flowName === filter2.flowName);
        }
        if (filter2?.componentName) {
          entries = entries.filter((e) => e.context.componentName === filter2.componentName);
        }
        if (filter2?.level) {
          entries = entries.filter((e) => e.level === filter2.level);
        }
        return entries;
      }
      /**
       * Export session for replay
       */
      exportSession() {
        return [...this.entries];
      }
      /**
       * Clear all entries
       */
      clear() {
        this.entries = [];
      }
      /**
       * Get session ID
       */
      getSessionId() {
        return this.sessionId;
      }
    };
    standardizedLogger = StandardizedAutomaticLogger.getInstance();
  }
});

// src/logging/unifiedLogger.ts
function shouldLogDebug() {
  try {
    if (vscode?.workspace?.getConfiguration) {
      const config = vscode.workspace.getConfiguration("azureDevOpsIntegration");
      return Boolean(config.get("debugLogging"));
    }
    if (typeof process !== "undefined" && process?.env?.AZDO_INT_DEBUG === "1") return true;
    return false;
  } catch {
    return false;
  }
}
function writeLog(level, message, options) {
  const scope = options?.scope || "application";
  const meta = options?.meta ? typeof options.meta === "object" ? options.meta : { meta: options.meta } : void 0;
  standardizedLogger.log("application", scope, void 0, level, message, meta);
}
function createLogger(scope) {
  const wrap = (options) => {
    if (!options) return { scope };
    if ("meta" in options) return { scope, ...options };
    return { scope, meta: options };
  };
  return {
    debug: (message, options) => log.debug(message, wrap(options)),
    info: (message, options) => log.info(message, wrap(options)),
    warn: (message, options) => log.warn(message, wrap(options)),
    error: (message, options) => log.error(message, wrap(options))
  };
}
var vscode, log;
var init_unifiedLogger = __esm({
  "src/logging/unifiedLogger.ts"() {
    "use strict";
    init_StandardizedAutomaticLogger();
    void (async () => {
      try {
        if (typeof process !== "undefined" && process?.versions?.node) {
          const vscodeModule = await import("vscode");
          vscode = vscodeModule;
        }
      } catch {
        vscode = void 0;
      }
    })();
    log = {
      debug: (message, options) => {
        if (!shouldLogDebug()) return;
        writeLog("debug", message, options);
      },
      info: (message, options) => {
        writeLog("info", message, options);
      },
      warn: (message, options) => {
        writeLog("warn", message, options);
      },
      error: (message, options) => {
        writeLog("error", message, options);
      }
    };
  }
});

// src/services/connection/branchEnrichment.ts
function getGitCacheKey(connectionId, repositoryId, branchRef) {
  return `${connectionId}|${repositoryId ?? "any"}|${branchRef ?? "unknown"}`;
}
function clearConnectionCaches(connectionId) {
  branchStateByConnection.delete(connectionId);
  repositoryCacheByConnection.delete(connectionId);
  for (const key2 of Array.from(buildCacheByKey.keys())) {
    if (key2.startsWith(`${connectionId}|`)) {
      buildCacheByKey.delete(key2);
    }
  }
  const timer = buildRefreshTimers.get(connectionId);
  if (timer) {
    try {
      clearTimeout(timer);
    } catch {
    }
    buildRefreshTimers.delete(connectionId);
  }
}
function updateBuildRefreshTimer(connectionId, provider2, shouldPoll) {
  const existing = buildRefreshTimers.get(connectionId);
  if (!shouldPoll) {
    if (existing) {
      try {
        clearTimeout(existing);
      } catch {
      }
      buildRefreshTimers.delete(connectionId);
    }
    return;
  }
  if (existing || !provider2) {
    return;
  }
  const timer = setTimeout(() => {
    buildRefreshTimers.delete(connectionId);
    Promise.resolve(provider2.refresh()).catch((error) => {
      logger.warn("Build polling refresh failed", { meta: error });
    }).then(() => {
    });
  }, BRANCH_REFRESH_INTERVAL_MS);
  buildRefreshTimers.set(connectionId, timer);
}
async function getGitApi() {
  if (cachedGitApi) {
    return cachedGitApi;
  }
  try {
    const gitExt = vscode2.extensions.getExtension("vscode.git");
    if (!gitExt) {
      return void 0;
    }
    const exports2 = gitExt.isActive ? gitExt.exports : await gitExt.activate();
    const api = exports2?.getAPI?.(1);
    cachedGitApi = api;
    return api;
  } catch (error) {
    logger.warn("Failed to acquire git API", { meta: error });
    return void 0;
  }
}
function normalizeRepositoryName(name3) {
  if (!name3) {
    return void 0;
  }
  const trimmed = name3.trim().replace(/\.git$/i, "");
  return trimmed.length > 0 ? trimmed : void 0;
}
function parseAzureRemote(remoteUrl) {
  if (!remoteUrl) {
    return void 0;
  }
  try {
    if (/^https?:/i.test(remoteUrl)) {
      const url2 = new URL(remoteUrl);
      const segments = url2.pathname.split("/").filter(Boolean);
      const gitIndex = segments.findIndex((segment) => segment.toLowerCase() === "_git");
      if (gitIndex >= 0 && segments.length > gitIndex + 1) {
        return {
          organization: segments[0],
          project: segments[1],
          repositoryName: normalizeRepositoryName(segments[gitIndex + 1])
        };
      }
      if (segments.length >= 3) {
        return {
          organization: segments[0],
          project: segments[1],
          repositoryName: normalizeRepositoryName(segments[segments.length - 1])
        };
      }
    } else if (remoteUrl.includes("ssh.dev.azure.com")) {
      const marker = "ssh.dev.azure.com:v3/";
      const idx = remoteUrl.indexOf(marker);
      if (idx >= 0) {
        const parts = remoteUrl.slice(idx + marker.length).split(/[\\/]/).filter(Boolean);
        if (parts.length >= 3) {
          return {
            organization: parts[0],
            project: parts[1],
            repositoryName: normalizeRepositoryName(parts[2])
          };
        }
      }
    } else if (remoteUrl.includes("vs-ssh.visualstudio.com")) {
      const marker = "vs-ssh.visualstudio.com:";
      const idx = remoteUrl.indexOf(marker);
      if (idx >= 0) {
        const after = remoteUrl.slice(idx + marker.length).replace(/^v[23]\//i, "");
        const parts = after.split(/[\\/]/).filter(Boolean);
        if (parts.length >= 3) {
          return {
            organization: parts[0],
            project: parts[1],
            repositoryName: normalizeRepositoryName(parts[2])
          };
        }
      }
    }
  } catch (error) {
    logger.warn("Failed to parse Azure remote URL", { meta: { remoteUrl, error } });
  }
  return void 0;
}
function normalizeBranchRef(ref) {
  if (!ref) {
    return null;
  }
  const trimmed = String(ref).trim();
  if (!trimmed) {
    return null;
  }
  if (trimmed.startsWith("refs/")) {
    const short = trimmed.startsWith("refs/heads/") ? trimmed.slice("refs/heads/".length) : trimmed;
    return { full: trimmed, short };
  }
  return { full: `refs/heads/${trimmed}`, short: trimmed };
}
function parseBranchArtifactLink(url2) {
  if (!url2 || typeof url2 !== "string") {
    return null;
  }
  const prefix = "vstfs:///Git/Ref/";
  if (!url2.startsWith(prefix)) {
    return null;
  }
  try {
    const remainder = url2.slice(prefix.length);
    const parts = remainder.split("%2F");
    if (parts.length < 3) {
      return null;
    }
    const projectId = decodeURIComponent(parts[0]);
    const repositoryId = decodeURIComponent(parts[1]);
    const encodedRef = parts.slice(2).join("%2F");
    const rawRef = decodeURIComponent(encodedRef);
    let refName = rawRef;
    let shortName;
    if (refName.startsWith("GB")) {
      shortName = refName.slice(2);
      if (shortName.startsWith("refs/")) {
        refName = shortName;
        shortName = refName.replace(/^refs\/heads\//, "");
      } else {
        refName = `refs/heads/${shortName}`;
      }
    } else if (refName.startsWith("GT")) {
      shortName = refName.slice(2);
      refName = `refs/tags/${shortName}`;
    } else if (refName.startsWith("refs/")) {
      shortName = refName.replace(/^refs\/heads\//, "");
    }
    return { projectId, repositoryId, refName, shortName };
  } catch (error) {
    logger.warn("Failed to parse branch artifact link", { meta: { url: url2, error } });
    return null;
  }
}
async function getAzureRepositoryByName(connectionId, client2, repoName) {
  if (!repoName) {
    return null;
  }
  const normalized = repoName.trim().toLowerCase();
  if (!normalized) {
    return null;
  }
  const cached = repositoryCacheByConnection.get(connectionId);
  const now = Date.now();
  let repos = null;
  if (cached && now - cached.fetchedAt < REPOSITORY_CACHE_TTL_MS) {
    repos = cached.repos;
  } else {
    try {
      const fetched = await client2.getRepositories();
      if (Array.isArray(fetched)) {
        repos = fetched;
        repositoryCacheByConnection.set(connectionId, { fetchedAt: now, repos: fetched });
      }
    } catch (error) {
      logger.warn("Failed to fetch repositories", { meta: error });
      return null;
    }
  }
  if (!Array.isArray(repos)) {
    return null;
  }
  return repos.find(
    (r) => typeof r?.name === "string" && r.name.trim().toLowerCase() === normalized
  ) || repos.find((r) => typeof r?.id === "string" && r.id.trim().toLowerCase() === normalized) || null;
}
async function resolveBranchContext(source2) {
  const api = await getGitApi();
  if (!api) {
    return null;
  }
  const repo = Array.isArray(api.repositories) ? api.repositories[0] : void 0;
  if (!repo) {
    return null;
  }
  const head2 = repo.state?.HEAD;
  const normalized = normalizeBranchRef(head2?.name || head2?.upstream?.name);
  if (!normalized) {
    return null;
  }
  const remotes = Array.isArray(repo.state?.remotes) ? repo.state.remotes : [];
  const remote = remotes.find((r) => !r?.isReadOnly && (r?.pushUrl || r?.fetchUrl)) || remotes[0];
  const remoteUrl = remote?.pushUrl || remote?.fetchUrl;
  const parsedRemote = parseAzureRemote(remoteUrl);
  let repositoryId;
  let repositoryName = parsedRemote?.repositoryName;
  if (repositoryName && source2.client) {
    const repoMeta = await getAzureRepositoryByName(source2.id, source2.client, repositoryName);
    if (repoMeta) {
      if (typeof repoMeta.id === "string") {
        repositoryId = repoMeta.id;
      }
      if (typeof repoMeta.name === "string" && repoMeta.name.trim().length > 0) {
        repositoryName = repoMeta.name.trim();
      }
    }
  }
  return {
    branchName: normalized.short,
    branchRef: normalized.full,
    repositoryId,
    repositoryName,
    remoteUrl,
    lastUpdated: Date.now()
  };
}
async function getBuildsForBranch(connectionId, client2, branchRef, repositoryId) {
  const key2 = getGitCacheKey(connectionId, repositoryId, branchRef);
  const cached = buildCacheByKey.get(key2);
  const now = Date.now();
  if (cached && now - cached.fetchedAt < BUILD_CACHE_TTL_MS) {
    return cached.builds;
  }
  try {
    const builds = await client2.getRecentBuilds({
      top: 5,
      branchName: branchRef,
      repositoryId
    });
    if (Array.isArray(builds)) {
      buildCacheByKey.set(key2, { fetchedAt: now, builds });
      return builds;
    }
  } catch (error) {
    logger.warn("Failed to fetch builds for branch", { meta: error });
  }
  buildCacheByKey.set(key2, { fetchedAt: now, builds: [] });
  return [];
}
function isBuildActive(summary) {
  if (!summary) {
    return false;
  }
  const status = typeof summary.status === "string" ? summary.status.toLowerCase() : "";
  if (status) {
    return !FINISHED_BUILD_STATUSES.has(status);
  }
  const result = typeof summary.result === "string" ? summary.result.toLowerCase() : "";
  if (!result) {
    return true;
  }
  return !FINISHED_BUILD_RESULTS.has(result);
}
function findBestBranchMatch(relations, targetBranchRef, targetBranchName, targetRepositoryId) {
  if (!Array.isArray(relations) || relations.length === 0) {
    return null;
  }
  let best = null;
  for (const relation of relations) {
    const parsed = parseBranchArtifactLink(relation.url);
    if (!parsed) {
      continue;
    }
    const normalized = normalizeBranchRef(parsed.refName || relation.refName);
    const relationRef = normalized?.full?.toLowerCase();
    const relationShort = (normalized?.short || parsed.shortName || "").toLowerCase();
    const desiredRef = targetBranchRef.toLowerCase();
    const desiredShort = targetBranchName.toLowerCase();
    const refMatches = !!relationRef && relationRef === desiredRef;
    const nameMatches = relationShort === desiredShort && desiredShort.length > 0;
    if (!refMatches && !nameMatches) {
      continue;
    }
    const repoMatch = targetRepositoryId && parsed.repositoryId ? parsed.repositoryId.toLowerCase() === targetRepositoryId.toLowerCase() : !targetRepositoryId;
    let score = 0;
    let confidence = "name";
    if (refMatches) {
      score += 2;
      confidence = repoMatch ? "exact" : "refOnly";
    } else if (nameMatches) {
      score += 1;
      confidence = "name";
    }
    if (repoMatch) {
      score += 1;
    }
    if (!best || score > best.score) {
      const result = {
        relation,
        parsed: {
          projectId: parsed.projectId,
          repositoryId: parsed.repositoryId,
          refName: normalized?.full || parsed.refName,
          shortName: normalized?.short || parsed.shortName
        },
        confidence
      };
      best = { score, result };
    }
  }
  return best?.result ?? null;
}
async function enrichWorkItemsForConnection(source2, payload) {
  const sourceItems = Array.isArray(payload.items) ? payload.items : [];
  const client2 = source2.client;
  if (!client2 || sourceItems.length === 0) {
    branchStateByConnection.set(source2.id, {
      context: null,
      hasActiveBuild: false,
      lastUpdated: Date.now()
    });
    return [...sourceItems];
  }
  const branchContext = await resolveBranchContext(source2);
  if (!branchContext) {
    branchStateByConnection.set(source2.id, {
      context: null,
      hasActiveBuild: false,
      lastUpdated: Date.now()
    });
    return sourceItems.map((item) => {
      const clone = { ...item };
      if (clone.branchMetadata) {
        delete clone.branchMetadata;
      }
      if (Array.isArray(item.relations)) {
        clone.relations = item.relations.map((rel) => ({ ...rel }));
      }
      return clone;
    });
  }
  const normalizedContext = normalizeBranchRef(branchContext.branchRef || branchContext.branchName);
  if (!normalizedContext) {
    branchStateByConnection.set(source2.id, {
      context: null,
      hasActiveBuild: false,
      lastUpdated: Date.now()
    });
    return sourceItems;
  }
  const matchedItems = [];
  const unmatchedItems = [];
  const matches = [];
  for (const original of sourceItems) {
    const clone = { ...original };
    const relations = Array.isArray(original.relations) ? original.relations.map((rel) => {
      const relClone = { ...rel };
      const parsed = parseBranchArtifactLink(rel.url);
      if (parsed) {
        relClone.repositoryId = parsed.repositoryId;
        relClone.projectId = parsed.projectId;
        relClone.refName = parsed.refName;
      }
      return relClone;
    }) : [];
    if (relations.length > 0) {
      clone.relations = relations;
    }
    const match = findBestBranchMatch(
      relations,
      normalizedContext.full,
      normalizedContext.short,
      branchContext.repositoryId
    );
    if (match) {
      const repositoryIdForMatch = match.parsed.repositoryId ?? branchContext.repositoryId;
      const metadata = {
        isCurrentBranch: true,
        branchName: normalizedContext.short,
        refName: normalizedContext.full,
        repositoryId: repositoryIdForMatch,
        repositoryName: branchContext.repositoryName,
        matchConfidence: match.confidence,
        link: { ...match.relation },
        hasActiveBuild: false,
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
      };
      clone.branchMetadata = metadata;
      matches.push({ item: clone, repositoryId: repositoryIdForMatch, parsed: match.parsed });
      matchedItems.push(clone);
    } else {
      if (clone.branchMetadata) {
        delete clone.branchMetadata;
      }
      unmatchedItems.push(clone);
    }
  }
  let hasActiveBuild = false;
  let resolvedRepositoryId = branchContext.repositoryId ?? matches[0]?.repositoryId;
  if (matches.length > 0) {
    const buildInfoByRepo = /* @__PURE__ */ new Map();
    const repoKeys = /* @__PURE__ */ new Set();
    for (const entry of matches) {
      repoKeys.add(entry.repositoryId ?? "__default__");
    }
    for (const repoKey of repoKeys) {
      const resolvedRepoId = repoKey === "__default__" ? branchContext.repositoryId : repoKey;
      const builds = await getBuildsForBranch(
        source2.id,
        client2,
        normalizedContext.full,
        resolvedRepoId
      );
      const latest = Array.isArray(builds) && builds.length > 0 ? builds[0] : void 0;
      const active = isBuildActive(latest);
      if (active) {
        hasActiveBuild = true;
      }
      buildInfoByRepo.set(repoKey, { build: latest, hasActive: active });
    }
    for (const entry of matches) {
      const info = buildInfoByRepo.get(entry.repositoryId ?? "__default__");
      if (info && entry.item.branchMetadata) {
        entry.item.branchMetadata.build = info.build;
        entry.item.branchMetadata.hasActiveBuild = info.hasActive;
        entry.item.branchMetadata.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
      }
    }
  }
  let resolvedRepositoryName = branchContext.repositoryName;
  if (!resolvedRepositoryName && resolvedRepositoryId && source2.client) {
    const repoMeta = await getAzureRepositoryByName(source2.id, source2.client, resolvedRepositoryId);
    if (repoMeta?.name && typeof repoMeta.name === "string") {
      resolvedRepositoryName = repoMeta.name.trim();
    }
  }
  if (resolvedRepositoryName) {
    for (const entry of matches) {
      if (entry.item.branchMetadata) {
        entry.item.branchMetadata.repositoryName = resolvedRepositoryName;
      }
    }
  }
  if (resolvedRepositoryId) {
    for (const entry of matches) {
      if (entry.item.branchMetadata && !entry.item.branchMetadata.repositoryId) {
        entry.item.branchMetadata.repositoryId = resolvedRepositoryId;
      }
    }
  }
  const sortedItems = [...matchedItems, ...unmatchedItems];
  resolvedRepositoryId = branchContext.repositoryId ?? resolvedRepositoryId;
  branchStateByConnection.set(source2.id, {
    context: {
      ...branchContext,
      branchName: normalizedContext.short,
      branchRef: normalizedContext.full,
      repositoryId: resolvedRepositoryId,
      repositoryName: resolvedRepositoryName ?? branchContext.repositoryName
    },
    hasActiveBuild,
    lastUpdated: Date.now()
  });
  return sortedItems;
}
var vscode2, logger, branchStateByConnection, repositoryCacheByConnection, buildCacheByKey, buildRefreshTimers, cachedGitApi, BRANCH_REFRESH_INTERVAL_MS, REPOSITORY_CACHE_TTL_MS, BUILD_CACHE_TTL_MS, FINISHED_BUILD_STATUSES, FINISHED_BUILD_RESULTS;
var init_branchEnrichment = __esm({
  "src/services/connection/branchEnrichment.ts"() {
    "use strict";
    vscode2 = __toESM(require("vscode"), 1);
    init_unifiedLogger();
    logger = createLogger("branch-enrichment");
    branchStateByConnection = /* @__PURE__ */ new Map();
    repositoryCacheByConnection = /* @__PURE__ */ new Map();
    buildCacheByKey = /* @__PURE__ */ new Map();
    buildRefreshTimers = /* @__PURE__ */ new Map();
    BRANCH_REFRESH_INTERVAL_MS = 30 * 1e3;
    REPOSITORY_CACHE_TTL_MS = 5 * 60 * 1e3;
    BUILD_CACHE_TTL_MS = 20 * 1e3;
    FINISHED_BUILD_STATUSES = /* @__PURE__ */ new Set(["completed", "postponed"]);
    FINISHED_BUILD_RESULTS = /* @__PURE__ */ new Set([
      "succeeded",
      "failed",
      "canceled",
      "cancelled",
      "partiallysucceeded"
    ]);
  }
});

// src/provider.ts
function isProviderOptions(value) {
  return value && typeof value === "object" && !Array.isArray(value);
}
var DEFAULT_QUERY, WorkItemsProvider;
var init_provider = __esm({
  "src/provider.ts"() {
    "use strict";
    DEFAULT_QUERY = "My Activity";
    WorkItemsProvider = class {
      connectionId;
      client;
      postMessage;
      logger;
      debounceMs = 2e3;
      _workItems = [];
      _selectedWorkItem;
      _kanbanView = false;
      _currentFilters = {};
      _refreshInFlight = false;
      _lastRefreshTs = 0;
      _workItemTypes = [];
      _currentQuery = DEFAULT_QUERY;
      transformWorkItemsFn;
      _pendingRefreshTimer;
      _pendingRefreshQuery;
      constructor(connectionOrClient, clientOrPostMessage, postMessageOrOptions, maybeOptions) {
        if (typeof connectionOrClient === "string") {
          this.connectionId = connectionOrClient;
          this.client = clientOrPostMessage;
          this.postMessage = (typeof postMessageOrOptions === "function" ? postMessageOrOptions : void 0) || (() => {
          });
          this.applyOptions(maybeOptions ?? {});
        } else {
          this.connectionId = "default";
          this.client = connectionOrClient;
          this.postMessage = (typeof clientOrPostMessage === "function" ? clientOrPostMessage : void 0) || (() => {
          });
          this.applyOptions(isProviderOptions(postMessageOrOptions) ? postMessageOrOptions : {});
        }
      }
      applyOptions(options) {
        this._kanbanView = options.kanbanView ?? this._kanbanView;
        this._currentFilters = options.currentFilters ?? this._currentFilters;
        this.logger = options.logger ?? this.logger;
        if (typeof options.debounceMs === "number" && options.debounceMs >= 0) {
          this.debounceMs = options.debounceMs;
        }
        this.transformWorkItemsFn = options.transformWorkItems ?? this.transformWorkItemsFn;
      }
      updateClient(nextClient) {
        this.client = nextClient;
        this._workItemTypes = [];
      }
      setPostMessage(nextPostMessage) {
        this.postMessage = nextPostMessage || (() => {
        });
      }
      setLogger(nextLogger) {
        this.logger = nextLogger;
      }
      setTransformWorkItems(nextTransform) {
        this.transformWorkItemsFn = nextTransform;
      }
      getConnectionId() {
        return this.connectionId;
      }
      async refresh(query) {
        if (!this.client || typeof this.client.getWorkItems !== "function") {
          this.log("warn", "Cannot refresh work items; client missing getWorkItems");
          return;
        }
        const now = Date.now();
        const normalizedQuery = typeof query === "string" && query.trim().length > 0 ? query.trim() : this._currentQuery || DEFAULT_QUERY;
        this._currentQuery = normalizedQuery;
        const elapsed = now - this._lastRefreshTs;
        if (elapsed < this.debounceMs || this._refreshInFlight) {
          const delay2 = Math.max(this.debounceMs - elapsed, 0) || this.debounceMs;
          this._pendingRefreshQuery = normalizedQuery;
          if (this._pendingRefreshTimer) {
            clearTimeout(this._pendingRefreshTimer);
          }
          this._pendingRefreshTimer = setTimeout(() => {
            this._pendingRefreshTimer = void 0;
            const pending2 = this._pendingRefreshQuery;
            this._pendingRefreshQuery = void 0;
            void this.refresh(pending2);
          }, delay2);
          return;
        }
        this._refreshInFlight = true;
        if (this._pendingRefreshTimer) {
          clearTimeout(this._pendingRefreshTimer);
          this._pendingRefreshTimer = void 0;
          this._pendingRefreshQuery = void 0;
        }
        this._post({
          type: "workItemsLoading",
          query: normalizedQuery
        });
        try {
          const shouldFetchTypes = this._workItemTypes.length === 0 && typeof this.client.getWorkItemTypes === "function";
          const typePromise = shouldFetchTypes ? Promise.resolve().then(() => this.client.getWorkItemTypes()).catch((err) => {
            this.log("warn", "Failed to fetch work item types", {
              connectionId: this.connectionId,
              error: err?.message || String(err)
            });
            return null;
          }) : null;
          this.log("debug", "refresh(): starting fetch", {
            connectionId: this.connectionId,
            query: normalizedQuery
          });
          const fetched = await this.client.getWorkItems(normalizedQuery);
          const processed = await this._applyTransform(fetched);
          this.log("info", "refresh(): completed fetch", {
            connectionId: this.connectionId,
            count: Array.isArray(processed) ? processed.length : "n/a"
          });
          if (typePromise) {
            try {
              const rawTypes = await typePromise;
              if (Array.isArray(rawTypes) && rawTypes.length > 0) {
                this._mergeWorkItemTypesFromNames(this._normalizeTypeNames(rawTypes));
              }
            } catch {
            }
          }
          this._workItems = processed;
          this._mergeWorkItemTypesFromItems(processed);
          this._notifyWorkItemsChanged();
          if (processed.length === 0) {
            this.log("debug", "refresh(): no results for query", {
              connectionId: this.connectionId,
              query: normalizedQuery
            });
          }
        } catch (err) {
          const errorMessage = err?.message || String(err);
          this.log("error", "Failed to refresh work items", {
            connectionId: this.connectionId,
            query: normalizedQuery,
            error: errorMessage,
            stack: err?.stack
          });
          this._error(errorMessage);
        } finally {
          this._refreshInFlight = false;
          this._lastRefreshTs = Date.now();
        }
      }
      async getWorkItemById(id) {
        if (!this.client) return null;
        return this.client.getWorkItemById(id);
      }
      async createWorkItem(type2, title, description, assignedTo, extraFields) {
        if (!this.client || typeof this.client.createWorkItem !== "function") {
          throw new Error("No client");
        }
        const created = await this.client.createWorkItem(
          type2,
          title,
          description,
          assignedTo,
          extraFields
        );
        await this.refresh();
        return created;
      }
      async updateWorkItem(id, patchOps) {
        if (!this.client || typeof this.client.updateWorkItem !== "function") {
          throw new Error("No client");
        }
        const updated = await this.client.updateWorkItem(id, patchOps);
        await this.refresh();
        return updated;
      }
      async addWorkItemComment(id, text2) {
        if (!this.client || typeof this.client.addWorkItemComment !== "function") {
          throw new Error("No client");
        }
        return this.client.addWorkItemComment(id, text2);
      }
      async addTimeEntry(id, hours, note) {
        if (!this.client || typeof this.client.addTimeEntry !== "function") {
          throw new Error("No client");
        }
        await this.client.addTimeEntry(id, hours, note);
        await this.refresh();
      }
      async search(term) {
        if (!this.client || typeof this.client.searchWorkItems !== "function") {
          this.log("warn", "search() skipped; client missing searchWorkItems");
          return [];
        }
        const res = await this.client.searchWorkItems(term);
        await this.showWorkItems(res);
        return res;
      }
      async filter(filterObj) {
        if (!this.client || typeof this.client.filterWorkItems !== "function") {
          this.log("warn", "filter() skipped; client missing filterWorkItems");
          return [];
        }
        const res = await this.client.filterWorkItems(filterObj);
        await this.showWorkItems(res);
        return res;
      }
      async runWIQL(wiql) {
        if (!this.client || typeof this.client.runWIQL !== "function") {
          this.log("warn", "runWIQL() skipped; client missing runWIQL");
          return [];
        }
        return this.client.runWIQL(wiql);
      }
      async showWorkItems(items) {
        if (!Array.isArray(items)) return;
        const processed = await this._applyTransform(items);
        const shouldIgnoreEmpty = processed.length === 0 && this._workItems.length > 0;
        if (!shouldIgnoreEmpty) {
          this._workItems = processed;
        }
        this._mergeWorkItemTypesFromItems(shouldIgnoreEmpty ? this._workItems : processed);
        this._notifyWorkItemsChanged();
      }
      selectWorkItem(item) {
        this._selectedWorkItem = item;
        this._post({ type: "workItemSelected", workItem: item });
      }
      getSelectedWorkItem() {
        return this._selectedWorkItem;
      }
      getWorkItems() {
        return [...this._workItems];
      }
      dispose() {
        this._workItems = [];
        this._selectedWorkItem = void 0;
        this._currentFilters = {};
        this._workItemTypes = [];
      }
      _notifyWorkItemsChanged() {
        this._post({
          type: "workItemsLoaded",
          workItems: [...this._workItems],
          connectionId: this.connectionId,
          query: this._currentQuery,
          kanbanView: this._kanbanView,
          types: [...this._workItemTypes]
        });
      }
      _post(msg) {
        if (!this.postMessage) return;
        if (msg && typeof msg === "object" && !Array.isArray(msg)) {
          this.postMessage({ connectionId: this.connectionId, ...msg });
        } else {
          this.postMessage(msg);
        }
      }
      _error(message) {
        this._post({ type: "workItemsError", error: message });
      }
      log(level, message, meta) {
        if (!this.logger) return;
        const fn = this.logger[level];
        if (typeof fn === "function") {
          try {
            fn(message, meta);
          } catch {
          }
        }
      }
      getWorkItemTypeOptions() {
        return [...this._workItemTypes];
      }
      _normalizeTypeNames(rawTypes) {
        if (!Array.isArray(rawTypes)) return [];
        return rawTypes.map((entry) => {
          if (!entry) return "";
          if (typeof entry === "string") return entry.trim();
          if (typeof entry.name === "string") return entry.name.trim();
          if (typeof entry.text === "string") return entry.text.trim();
          if (typeof entry.referenceName === "string") return entry.referenceName.trim();
          return "";
        }).filter((name3) => name3.length > 0);
      }
      _mergeWorkItemTypesFromNames(names) {
        if (!Array.isArray(names) || names.length === 0) return;
        const current = new Set(this._workItemTypes);
        let changed = false;
        for (const raw of names) {
          const value = typeof raw === "string" ? raw.trim() : "";
          if (!value) continue;
          if (!current.has(value)) {
            current.add(value);
            changed = true;
          }
        }
        if (changed) {
          this._workItemTypes = Array.from(current).sort((a, b) => a.localeCompare(b));
        }
      }
      _mergeWorkItemTypesFromItems(items) {
        if (!Array.isArray(items) || items.length === 0) return;
        const names = items.map((item) => {
          const fromFlattened = typeof item?.type === "string" ? item.type : void 0;
          const fromFields = typeof item?.fields?.["System.WorkItemType"] === "string" ? item.fields["System.WorkItemType"] : void 0;
          const value = fromFlattened || fromFields;
          return typeof value === "string" ? value.trim() : "";
        }).filter((name3) => name3.length > 0);
        this._mergeWorkItemTypesFromNames(names);
      }
      async _applyTransform(items) {
        if (!Array.isArray(items)) return [];
        if (!this.transformWorkItemsFn) return [...items];
        try {
          const result = await this.transformWorkItemsFn({
            items: [...items],
            connectionId: this.connectionId
          });
          if (Array.isArray(result)) {
            return result;
          }
        } catch (error) {
          this.log("warn", "transformWorkItems failed", {
            connectionId: this.connectionId,
            error: error?.message || String(error)
          });
        }
        return [...items];
      }
    };
  }
});

// src/provider.js
var init_provider2 = __esm({
  "src/provider.js"() {
    "use strict";
    init_provider();
  }
});

// src/services/connection/providerFactory.ts
function createBranchAwareTransform(source2) {
  return async (payload) => {
    return enrichWorkItemsForConnection(source2, payload);
  };
}
var init_providerFactory = __esm({
  "src/services/connection/providerFactory.ts"() {
    "use strict";
    init_provider2();
    init_branchEnrichment();
  }
});

// src/bridge/sharedContextBridge.ts
function createSharedContextBridge({
  actor,
  logger: logger11,
  contextSelector
}) {
  const applicationManager = actor;
  let currentWebview;
  let disposed = false;
  let lastSignature = "";
  let pollInterval;
  function log2(message, meta) {
    try {
      logger11?.(message, meta);
    } catch (error) {
    }
  }
  function startPolling() {
    if (pollInterval) return;
    pollInterval = setInterval(() => {
      maybePostContext("poll");
    }, 100);
  }
  function stopPolling() {
    if (pollInterval) {
      clearInterval(pollInterval);
      pollInterval = void 0;
    }
  }
  function getApplicationContext() {
    try {
      if (applicationManager && typeof applicationManager.getContext === "function") {
        return applicationManager.getContext();
      }
    } catch (error) {
      log2("getApplicationContextFailed", { error: serializeError(error) });
    }
    return {};
  }
  function buildPayload(context) {
    if (contextSelector) {
      return contextSelector(context);
    }
    return context;
  }
  function maybePostContext(reason) {
    if (!currentWebview) {
      return;
    }
    try {
      const context = getApplicationContext();
      const payload = buildPayload(context);
      const signature = JSON.stringify(payload);
      if (signature === lastSignature) {
        return;
      }
      lastSignature = signature;
      const state2 = applicationManager && typeof applicationManager.getApplicationState === "function" ? applicationManager.getApplicationState() : "unknown";
      const message = {
        type: "contextUpdate",
        context: payload,
        meta: {
          reason,
          state: state2
        }
      };
      const maybeThenable = currentWebview.postMessage(message);
      if (typeof maybeThenable?.then === "function") {
        maybeThenable.then(void 0, (error) => {
          log2("postMessageFailed", { error: serializeError(error) });
        });
      }
    } catch (error) {
      log2("contextSerializationFailed", { error: serializeError(error) });
    }
  }
  function synchronizeImmediately(reason) {
    maybePostContext(reason);
  }
  function handleWebviewMessage(message) {
    if (!message || typeof message !== "object") {
      return false;
    }
    const msg = message;
    if (msg.type === "getContext") {
      synchronizeImmediately("explicit-request");
      return true;
    }
    return false;
  }
  startPolling();
  return {
    attachWebview(webview) {
      currentWebview = webview;
      synchronizeImmediately("webview-attached");
    },
    detachWebview() {
      currentWebview = void 0;
    },
    handleWebviewMessage,
    sync() {
      synchronizeImmediately("manual-sync");
    },
    dispose() {
      if (disposed) {
        return;
      }
      disposed = true;
      stopPolling();
      currentWebview = void 0;
    }
  };
}
function serializeError(error) {
  if (error instanceof Error) {
    return {
      message: error.message,
      name: error.name,
      stack: error.stack
    };
  }
  if (typeof error === "object" && error) {
    return { ...error };
  }
  return { value: String(error) };
}
var init_sharedContextBridge = __esm({
  "src/bridge/sharedContextBridge.ts"() {
    "use strict";
  }
});

// src/cache.ts
function startCacheCleanup() {
  if (cleanupInterval) return;
  cleanupInterval = setInterval(() => {
    workItemCache.cleanup();
    apiCache.cleanup();
    metadataCache.cleanup();
  }, 3e5);
}
function stopCacheCleanup() {
  if (cleanupInterval) {
    clearInterval(cleanupInterval);
    cleanupInterval = null;
  }
}
function getCacheStats() {
  const workItemsStats = workItemCache.getStats();
  const apiStats = apiCache.getStats();
  const metadataStats = metadataCache.getStats();
  return {
    workItems: workItemsStats,
    api: apiStats,
    metadata: metadataStats,
    totalMemoryUsage: workItemsStats.memoryUsage + apiStats.memoryUsage + metadataStats.memoryUsage
  };
}
var IntelligentCache, WorkItemCache, workItemCache, apiCache, metadataCache, cleanupInterval;
var init_cache = __esm({
  "src/cache.ts"() {
    "use strict";
    IntelligentCache = class {
      cache = /* @__PURE__ */ new Map();
      accessOrder = [];
      metrics;
      options;
      constructor(options = {}) {
        this.options = {
          maxSize: options.maxSize ?? 1e3,
          defaultTtl: options.defaultTtl ?? 3e5,
          // 5 minutes
          enableMetrics: options.enableMetrics ?? true,
          evictionPolicy: options.evictionPolicy ?? "both"
        };
        this.metrics = {
          hits: 0,
          misses: 0,
          evictions: 0,
          size: 0,
          maxSize: this.options.maxSize,
          hitRate: 0
        };
      }
      /**
       * Get a value from the cache
       */
      get(key2) {
        const entry = this.cache.get(key2);
        if (!entry) {
          this.metrics.misses++;
          this.updateHitRate();
          return null;
        }
        if (this.isExpired(entry)) {
          this.delete(key2);
          this.metrics.misses++;
          this.updateHitRate();
          return null;
        }
        entry.accessCount++;
        entry.lastAccessed = Date.now();
        this.updateAccessOrder(key2);
        this.metrics.hits++;
        this.updateHitRate();
        return entry.data;
      }
      /**
       * Set a value in the cache
       */
      set(key2, value, ttl) {
        const now = Date.now();
        const entry = {
          data: value,
          timestamp: now,
          ttl: ttl ?? this.options.defaultTtl,
          accessCount: 0,
          lastAccessed: now
        };
        if (this.cache.size >= this.options.maxSize && !this.cache.has(key2)) {
          this.evict();
        }
        this.cache.set(key2, entry);
        this.updateAccessOrder(key2);
        this.metrics.size = this.cache.size;
      }
      /**
       * Check if a key exists and is not expired
       */
      has(key2) {
        const entry = this.cache.get(key2);
        if (!entry) return false;
        if (this.isExpired(entry)) {
          this.delete(key2);
          return false;
        }
        return true;
      }
      /**
       * Delete a key from the cache
       */
      delete(key2) {
        const deleted = this.cache.delete(key2);
        if (deleted) {
          const index2 = this.accessOrder.indexOf(key2);
          if (index2 > -1) {
            this.accessOrder.splice(index2, 1);
          }
          this.metrics.size = this.cache.size;
        }
        return deleted;
      }
      /**
       * Clear all entries from the cache
       */
      clear() {
        this.cache.clear();
        this.accessOrder = [];
        this.metrics.size = 0;
      }
      /**
       * Get cache metrics
       */
      getMetrics() {
        return { ...this.metrics };
      }
      /**
       * Get cache size
       */
      size() {
        return this.cache.size;
      }
      /**
       * Clean up expired entries
       */
      cleanup() {
        let cleaned = 0;
        for (const [key2, entry] of this.cache.entries()) {
          if (this.isExpired(entry)) {
            this.delete(key2);
            cleaned++;
          }
        }
        return cleaned;
      }
      /**
       * Get all keys in the cache
       */
      keys() {
        return Array.from(this.cache.keys());
      }
      /**
       * Get cache statistics for debugging
       */
      getStats() {
        const topKeys = Array.from(this.cache.entries()).map(([key2, entry]) => ({
          key: key2,
          accessCount: entry.accessCount,
          lastAccessed: entry.lastAccessed
        })).sort((a, b) => b.accessCount - a.accessCount).slice(0, 10);
        const memoryUsage = this.cache.size * 100;
        return {
          metrics: this.getMetrics(),
          topKeys,
          memoryUsage
        };
      }
      isExpired(entry) {
        return Date.now() - entry.timestamp > entry.ttl;
      }
      updateAccessOrder(key2) {
        const index2 = this.accessOrder.indexOf(key2);
        if (index2 > -1) {
          this.accessOrder.splice(index2, 1);
        }
        this.accessOrder.push(key2);
      }
      evict() {
        if (this.cache.size === 0) return;
        let keyToEvict = null;
        switch (this.options.evictionPolicy) {
          case "lru":
            keyToEvict = this.accessOrder[0];
            break;
          case "ttl": {
            let oldestTime = Date.now();
            for (const [key2, entry] of this.cache.entries()) {
              if (entry.timestamp < oldestTime) {
                oldestTime = entry.timestamp;
                keyToEvict = key2;
              }
            }
            break;
          }
          case "both": {
            const now = Date.now();
            const oldThreshold = now - this.options.defaultTtl * 2;
            for (const [key2, entry] of this.cache.entries()) {
              if (entry.timestamp < oldThreshold) {
                keyToEvict = key2;
                break;
              }
            }
            if (!keyToEvict) {
              keyToEvict = this.accessOrder[0];
            }
            break;
          }
        }
        if (keyToEvict) {
          this.delete(keyToEvict);
          this.metrics.evictions++;
        }
      }
      updateHitRate() {
        const total = this.metrics.hits + this.metrics.misses;
        this.metrics.hitRate = total > 0 ? this.metrics.hits / total : 0;
      }
    };
    WorkItemCache = class _WorkItemCache extends IntelligentCache {
      static WORK_ITEM_TTL = 3e5;
      // 5 minutes
      static QUERY_TTL = 6e5;
      // 10 minutes
      static METADATA_TTL = 18e5;
      // 30 minutes
      constructor() {
        super({
          maxSize: 2e3,
          defaultTtl: _WorkItemCache.WORK_ITEM_TTL,
          enableMetrics: true,
          evictionPolicy: "both"
        });
      }
      /**
       * Cache work items with appropriate TTL
       */
      setWorkItems(key2, workItems) {
        this.set(key2, workItems, _WorkItemCache.WORK_ITEM_TTL);
      }
      /**
       * Cache query results with longer TTL
       */
      setQueryResult(key2, result) {
        this.set(key2, result, _WorkItemCache.QUERY_TTL);
      }
      /**
       * Cache metadata with longest TTL
       */
      setMetadata(key2, metadata) {
        this.set(key2, metadata, _WorkItemCache.METADATA_TTL);
      }
      /**
       * Generate cache key for work items query
       */
      static generateWorkItemsKey(connectionId, query, filters) {
        const filterStr = JSON.stringify(filters);
        return `workitems:${connectionId}:${Buffer.from(query + filterStr).toString("base64")}`;
      }
      /**
       * Generate cache key for query
       */
      static generateQueryKey(connectionId, query) {
        return `query:${connectionId}:${Buffer.from(query).toString("base64")}`;
      }
      /**
       * Generate cache key for metadata
       */
      static generateMetadataKey(connectionId, type2) {
        return `metadata:${connectionId}:${type2}`;
      }
    };
    workItemCache = new WorkItemCache();
    apiCache = new IntelligentCache({ maxSize: 500, defaultTtl: 3e5 });
    metadataCache = new IntelligentCache({ maxSize: 100, defaultTtl: 18e5 });
    cleanupInterval = null;
  }
});

// src/services/connection/connectionNormalization.ts
function normalizeConnections(rawConnections, legacyFallback) {
  const normalized = [];
  const seen = /* @__PURE__ */ new Map();
  let requiresSave = false;
  let added = 0;
  let migrated = 0;
  let deduplicated = 0;
  for (const raw of rawConnections) {
    if (!raw || typeof raw !== "object") continue;
    const conn = raw;
    if (!conn.organization || !conn.project) {
      continue;
    }
    const baseUrl = conn.baseUrl ? String(conn.baseUrl).trim() : "";
    const dedupeKey = `${String(conn.organization).trim()}|${String(conn.project).trim()}|${baseUrl}`;
    if (seen.has(dedupeKey)) {
      const existing = seen.get(dedupeKey);
      if (!existing.id && conn.id) {
        const index2 = normalized.indexOf(existing);
        if (index2 >= 0) {
          normalized[index2] = {
            ...existing,
            id: conn.id,
            // Merge other fields, preferring newer values
            tenantId: conn.tenantId || existing.tenantId,
            authMethod: conn.authMethod || existing.authMethod,
            apiBaseUrl: conn.apiBaseUrl || existing.apiBaseUrl,
            label: conn.label || existing.label
          };
          requiresSave = true;
          deduplicated++;
        }
      } else {
        deduplicated++;
        continue;
      }
    }
    const normalizedConn = {
      id: conn.id || `${conn.organization}-${conn.project}-${Date.now()}`,
      organization: String(conn.organization).trim(),
      project: String(conn.project).trim(),
      team: conn.team ? String(conn.team).trim() : void 0,
      label: conn.label ? String(conn.label).trim() : void 0,
      baseUrl: conn.baseUrl ? String(conn.baseUrl).trim() : void 0,
      apiBaseUrl: conn.apiBaseUrl ? String(conn.apiBaseUrl).trim() : void 0,
      authMethod: conn.authMethod === "entra" ? "entra" : "pat",
      patKey: conn.patKey ? String(conn.patKey).trim() : void 0,
      tenantId: conn.tenantId ? String(conn.tenantId).trim() : void 0,
      identityName: conn.identityName ? String(conn.identityName).trim() : void 0
    };
    normalized.push(normalizedConn);
    seen.set(dedupeKey, normalizedConn);
    if (!conn.id) {
      requiresSave = true;
      added++;
    }
    if (conn.organization !== normalizedConn.organization || conn.project !== normalizedConn.project || (conn.team || "") !== (normalizedConn.team || "") || (conn.label || "") !== (normalizedConn.label || "")) {
      requiresSave = true;
      migrated++;
    }
  }
  if (normalized.length === 0 && legacyFallback) {
    const legacyConn = {
      id: `${legacyFallback.organization}-${legacyFallback.project}-${Date.now()}`,
      organization: legacyFallback.organization,
      project: legacyFallback.project,
      team: legacyFallback.team,
      label: legacyFallback.label,
      authMethod: "pat"
    };
    normalized.push(legacyConn);
    requiresSave = true;
    added++;
    migrated++;
  }
  return {
    connections: normalized,
    requiresSave: requiresSave || deduplicated > 0,
    summary: {
      normalized: normalized.length,
      added,
      migrated,
      deduplicated
      // Track how many duplicates were removed
    }
  };
}
function resolveActiveConnectionId(persistedActive, connections3) {
  if (connections3.length === 0) {
    return {
      activeConnectionId: void 0,
      requiresPersistence: persistedActive !== void 0
      // Clear if persisted but no connections
    };
  }
  if (persistedActive) {
    const found = connections3.find((c) => c.id === persistedActive);
    if (found) {
      return {
        activeConnectionId: persistedActive,
        requiresPersistence: false
        // Already persisted and valid
      };
    }
  }
  const firstConnectionId = connections3[0]?.id;
  return {
    activeConnectionId: firstConnectionId,
    requiresPersistence: persistedActive !== firstConnectionId
    // Persist if different
  };
}
var init_connectionNormalization = __esm({
  "src/services/connection/connectionNormalization.ts"() {
    "use strict";
  }
});

// src/services/secrets/patMigration.ts
async function migrateGlobalPATToConnections(context, connections3) {
  try {
    const globalPAT = await context.secrets.get(LEGACY_PAT_KEY);
    if (!globalPAT) {
      return;
    }
    let migratedCount = 0;
    for (const connection of connections3) {
      if (connection.authMethod === "pat" && connection.patKey) {
        const existingPAT = await context.secrets.get(connection.patKey);
        if (!existingPAT) {
          await context.secrets.store(connection.patKey, globalPAT);
          migratedCount++;
        }
      }
    }
    if (migratedCount > 0) {
      await context.secrets.delete(LEGACY_PAT_KEY);
    }
  } catch (error) {
  }
}
var LEGACY_PAT_KEY;
var init_patMigration = __esm({
  "src/services/secrets/patMigration.ts"() {
    "use strict";
    LEGACY_PAT_KEY = "azureDevOpsPersonalAccessToken";
  }
});

// src/services/extensionHostBridge.ts
var extensionHostBridge_exports = {};
__export(extensionHostBridge_exports, {
  clearApplicationStoreBridge: () => clearApplicationStoreBridge,
  forwardProviderMessage: () => forwardProviderMessage,
  getActiveConnectionId: () => getActiveConnectionId,
  getApplicationStoreActor: () => getApplicationStoreActor,
  getExtensionContextRef: () => getExtensionContextRef,
  getLoadedConnections: () => getLoadedConnections,
  getSecretPAT: () => getSecretPAT,
  invokeActiveConnectionHandler: () => invokeActiveConnectionHandler,
  invokeRegisterAllCommands: () => invokeRegisterAllCommands,
  invokeWebviewMessageHandler: () => invokeWebviewMessageHandler,
  sendApplicationStoreEvent: () => sendApplicationStoreEvent,
  setActiveConnectionHandler: () => setActiveConnectionHandler,
  setActiveConnectionIdReader: () => setActiveConnectionIdReader,
  setApplicationStoreBridge: () => setApplicationStoreBridge,
  setExtensionContextRef: () => setExtensionContextRef,
  setForwardProviderMessage: () => setForwardProviderMessage,
  setGetSecretPAT: () => setGetSecretPAT,
  setLoadedConnectionsReader: () => setLoadedConnectionsReader,
  setRegisterAllCommands: () => setRegisterAllCommands,
  setWebviewMessageHandler: () => setWebviewMessageHandler
});
function setExtensionContextRef(context) {
  extensionContextRef = context;
  globalThis.extensionContext = context;
}
function getExtensionContextRef() {
  return extensionContextRef;
}
function setRegisterAllCommands(fn) {
  registerAllCommandsFn = fn;
}
async function invokeRegisterAllCommands(context) {
  if (!registerAllCommandsFn) {
    return;
  }
  await registerAllCommandsFn(context);
}
function setForwardProviderMessage(fn) {
  forwardProviderMessageFn = fn;
}
function forwardProviderMessage(connectionId, message) {
  if (!forwardProviderMessageFn) {
    return;
  }
  forwardProviderMessageFn(connectionId, message);
}
function setGetSecretPAT(fn) {
  getSecretPATFn = fn;
}
async function getSecretPAT(context, connectionId) {
  if (!getSecretPATFn) {
    return void 0;
  }
  return getSecretPATFn(context, connectionId);
}
function setLoadedConnectionsReader(fn) {
  loadedConnectionsReader = fn;
}
function getLoadedConnections() {
  return loadedConnectionsReader();
}
function setActiveConnectionIdReader(fn) {
  activeConnectionIdReader = fn;
}
function getActiveConnectionId() {
  return activeConnectionIdReader();
}
function setWebviewMessageHandler(handler) {
  webviewMessageHandler = handler;
}
async function invokeWebviewMessageHandler(message) {
  if (!webviewMessageHandler) {
    return;
  }
  try {
    await webviewMessageHandler(message);
  } catch (error) {
    logger2.error("Webview message handler failed", { meta: error });
  }
}
function setActiveConnectionHandler(handler) {
  activeConnectionHandler = handler;
}
async function invokeActiveConnectionHandler(connectionId, options) {
  if (!activeConnectionHandler) {
    return void 0;
  }
  try {
    return await activeConnectionHandler(connectionId, options);
  } catch (error) {
    logger2.error("Active connection handler failed", { meta: error });
    return void 0;
  }
}
function setApplicationStoreBridge(options) {
  applicationActorAccessor = options.getActor;
  applicationEventDispatcher = options.send;
}
function clearApplicationStoreBridge() {
  applicationActorAccessor = void 0;
  applicationEventDispatcher = void 0;
}
function getApplicationStoreActor() {
  return applicationActorAccessor ? applicationActorAccessor() : void 0;
}
function sendApplicationStoreEvent(event2) {
  if (!applicationEventDispatcher) {
    return false;
  }
  applicationEventDispatcher(event2);
  return true;
}
var logger2, extensionContextRef, registerAllCommandsFn, forwardProviderMessageFn, getSecretPATFn, loadedConnectionsReader, activeConnectionIdReader, applicationActorAccessor, applicationEventDispatcher, webviewMessageHandler, activeConnectionHandler;
var init_extensionHostBridge = __esm({
  "src/services/extensionHostBridge.ts"() {
    "use strict";
    init_unifiedLogger();
    logger2 = createLogger("extension-host-bridge");
    loadedConnectionsReader = () => [];
    activeConnectionIdReader = () => null;
  }
});

// src/features/commands/types.ts
var init_types = __esm({
  "src/features/commands/types.ts"() {
    "use strict";
  }
});

// src/services/auth/constants.ts
var DEFAULT_ENTRA_TENANT, DEFAULT_ENTRA_CLIENT_ID, AZURE_DEVOPS_CLIENT_ID, AZURE_CLI_CLIENT_ID, AZURE_DEVOPS_SCOPE, OFFLINE_ACCESS_SCOPE;
var init_constants = __esm({
  "src/services/auth/constants.ts"() {
    "use strict";
    DEFAULT_ENTRA_TENANT = "organizations";
    DEFAULT_ENTRA_CLIENT_ID = "c6c01810-2fff-45f0-861b-2ba02ae00ddc";
    AZURE_DEVOPS_CLIENT_ID = "872cd9fa-d31f-45e0-9eab-6e460a02d1f1";
    AZURE_CLI_CLIENT_ID = "04b07795-8ddb-461a-bbee-02f9e1bf7b46";
    AZURE_DEVOPS_SCOPE = "499b84ac-1321-427f-aa17-267ca6975798/.default";
    OFFLINE_ACCESS_SCOPE = "offline_access";
  }
});

// src/services/setupServiceHelpers.ts
var setupServiceHelpers_exports = {};
__export(setupServiceHelpers_exports, {
  createConnectionFromInfo: () => createConnectionFromInfo,
  parseWorkItemUrl: () => parseWorkItemUrl,
  saveConnection: () => saveConnection,
  showUrlInput: () => showUrlInput
});
function parseWorkItemUrl(url2) {
  try {
    const parsed = new URL(url2);
    const pathParts = parsed.pathname.split("/").filter(Boolean);
    if (parsed.hostname === "dev.azure.com") {
      if (pathParts.length >= 2) {
        return {
          organization: pathParts[0],
          project: pathParts[1],
          baseUrl: `https://dev.azure.com/${pathParts[0]}`
        };
      }
    }
    const vsMatch = parsed.hostname.match(/^(.+)\.visualstudio\.com$/);
    if (vsMatch && pathParts.length >= 1) {
      return {
        organization: vsMatch[1],
        project: pathParts[0],
        baseUrl: `https://${vsMatch[1]}.visualstudio.com`
      };
    }
    return null;
  } catch {
    return null;
  }
}
async function showUrlInput() {
  return await vscode3.window.showInputBox({
    prompt: "Enter an Azure DevOps work item URL to auto-configure your connection",
    placeHolder: "https://dev.azure.com/myorg/myproject/_workitems/edit/123",
    validateInput: (value) => {
      if (!value) return "URL is required";
      if (!value.includes("_workitems")) return "Please provide a work item URL";
      return null;
    }
  });
}
function createConnectionFromInfo(connectionInfo, authMethod, credentials) {
  const connectionId = `${connectionInfo.organization}-${connectionInfo.project}-${Date.now()}`;
  return {
    id: connectionId,
    organization: connectionInfo.organization,
    project: connectionInfo.project,
    baseUrl: connectionInfo.baseUrl,
    authMethod,
    ...authMethod === "pat" && credentials.token ? { patKey: `pat-${connectionId}` } : {},
    ...authMethod === "entra" && credentials.tenantId ? { tenantId: credentials.tenantId } : {},
    ...authMethod === "entra" && credentials.clientId ? { clientId: credentials.clientId } : {}
  };
}
async function saveConnection(context, connection, existingConnections, credentials) {
  if (connection.authMethod === "pat" && credentials?.token) {
    await context.secrets.store(`pat-${connection.id}`, credentials.token);
  }
  const settings = vscode3.workspace.getConfiguration("azureDevOpsIntegration");
  const updatedConnections = [...existingConnections, connection];
  await settings.update("connections", updatedConnections, vscode3.ConfigurationTarget.Global);
  try {
    const { setLoadedConnectionsReader: setLoadedConnectionsReader2 } = await Promise.resolve().then(() => (init_extensionHostBridge(), extensionHostBridge_exports));
    setLoadedConnectionsReader2(() => updatedConnections);
  } catch {
  }
}
var vscode3;
var init_setupServiceHelpers = __esm({
  "src/services/setupServiceHelpers.ts"() {
    "use strict";
    vscode3 = __toESM(require("vscode"), 1);
  }
});

// src/services/setupService.ts
var vscode4, logger3, DEFAULT_ENTRA_TENANT_ID, DEFAULT_ENTRA_CLIENT_ID2, FSMSetupService;
var init_setupService = __esm({
  "src/services/setupService.ts"() {
    "use strict";
    vscode4 = __toESM(require("vscode"), 1);
    init_unifiedLogger();
    logger3 = createLogger("fsm-setup-service");
    DEFAULT_ENTRA_TENANT_ID = "organizations";
    DEFAULT_ENTRA_CLIENT_ID2 = "c6c01810-2fff-45f0-861b-2ba02ae00ddc";
    FSMSetupService = class {
      context;
      constructor(context) {
        this.context = context;
      }
      async startSetup(options) {
        const settings = vscode4.workspace.getConfiguration("azureDevOpsIntegration");
        const existingConnections = settings.get("connections", []);
        const activeConnectionId3 = this.context.globalState.get(
          "azureDevOpsInt.activeConnectionId"
        );
        const startAtAuthChoice = options?.startAtAuthChoice ?? false;
        const targetConnectionId = options?.connectionId ?? activeConnectionId3;
        const targetConnection = targetConnectionId ? existingConnections.find((c) => c.id === targetConnectionId) : void 0;
        logger3.debug("Starting setup", {
          connectionsCount: existingConnections.length,
          activeConnectionId: activeConnectionId3,
          connectionAuthMethods: existingConnections.map((c) => ({
            id: c.id,
            authMethod: c.authMethod
          })),
          startAtAuthChoice,
          targetConnectionId
        });
        try {
          if (startAtAuthChoice && targetConnection) {
            return await this.reconfigureAuth(targetConnection, existingConnections, settings);
          }
          const { showUrlInput: showUrlInput2, parseWorkItemUrl: parseWorkItemUrl2, createConnectionFromInfo: createConnectionFromInfo2, saveConnection: saveConnection2 } = await Promise.resolve().then(() => (init_setupServiceHelpers(), setupServiceHelpers_exports));
          const url2 = await showUrlInput2();
          if (!url2) {
            const manageExisting = await vscode4.window.showQuickPick(
              ["Cancel", "Manage Existing Connections"],
              { placeHolder: "What would you like to do?" }
            );
            if (manageExisting === "Manage Existing Connections") {
              return await this.manageExistingConnections(existingConnections);
            }
            return { status: "cancelled" };
          }
          const connectionInfo = parseWorkItemUrl2(url2);
          if (!connectionInfo) {
            await vscode4.window.showErrorMessage(
              "Invalid work item URL. Please provide a valid Azure DevOps work item URL."
            );
            return { status: "cancelled" };
          }
          const authMethod = await this.showAuthMethodSelection();
          if (!authMethod) {
            return { status: "cancelled" };
          }
          let credentials = null;
          if (authMethod === "pat") {
            const token = await this.showPATInput();
            if (!token) {
              return { status: "cancelled" };
            }
            credentials = { token };
          } else {
            credentials = await this.showEntraConfig();
            if (!credentials) {
              return { status: "cancelled" };
            }
          }
          const newConnection = createConnectionFromInfo2(connectionInfo, authMethod, credentials);
          await saveConnection2(this.context, newConnection, existingConnections, credentials);
          logger3.info("\u2705 Connection saved successfully", { connectionId: newConnection.id });
          vscode4.window.showInformationMessage("Connection saved successfully!");
          return { status: "success", connectionId: newConnection.id };
        } catch (error) {
          logger3.error("Setup failed", {
            error: error instanceof Error ? error.message : String(error)
          });
          await vscode4.window.showErrorMessage(
            `Setup failed: ${error instanceof Error ? error.message : String(error)}`
          );
          return { status: "cancelled" };
        }
      }
      async showAuthMethodSelection(currentMethod) {
        const items = [
          {
            label: "Personal Access Token (PAT)",
            description: "Use a Personal Access Token for authentication",
            detail: "Recommended for most users. Generate a PAT from Azure DevOps settings.",
            value: "pat"
          },
          {
            label: "Microsoft Entra ID (OAuth)",
            description: "Use your Microsoft account to sign in",
            detail: "Enterprise authentication using your organizational account.",
            value: "entra"
          }
        ];
        const authMethod = await vscode4.window.showQuickPick(items, {
          placeHolder: "Choose authentication method",
          matchOnDescription: true,
          matchOnDetail: true,
          activeItem: currentMethod ? items.find((item) => item.value === currentMethod) : void 0
        });
        return authMethod?.value;
      }
      async showPATInput() {
        return await vscode4.window.showInputBox({
          prompt: "Enter your Personal Access Token",
          password: true,
          placeHolder: "Your PAT from Azure DevOps",
          validateInput: (value) => {
            if (!value) return "PAT is required";
            if (value.length < 20) return "PAT seems too short";
            return null;
          }
        });
      }
      async showEntraConfig() {
        return { tenantId: DEFAULT_ENTRA_TENANT_ID, clientId: DEFAULT_ENTRA_CLIENT_ID2 };
      }
      async reconfigureAuth(targetConnection, existingConnections, settings) {
        logger3.debug("Reconfiguring authentication for connection", {
          connectionId: targetConnection.id,
          authMethod: targetConnection.authMethod
        });
        const authMethod = await this.showAuthMethodSelection(targetConnection.authMethod);
        if (!authMethod) {
          return { status: "cancelled" };
        }
        let patToken;
        let tenantId;
        let clientId;
        if (authMethod === "pat") {
          patToken = await this.showPATInput();
          if (!patToken) {
            return { status: "cancelled" };
          }
        } else {
          tenantId = targetConnection.tenantId || DEFAULT_ENTRA_TENANT_ID;
          clientId = targetConnection.clientId || DEFAULT_ENTRA_CLIENT_ID2;
        }
        if (authMethod !== "pat" && targetConnection.patKey) {
          await this.context.secrets.delete(targetConnection.patKey);
        }
        const patKey = authMethod === "pat" ? targetConnection.patKey ?? `pat-${targetConnection.id}` : void 0;
        if (authMethod === "pat" && patKey && patToken) {
          await this.context.secrets.store(patKey, patToken);
        }
        const updatedConnection = {
          ...targetConnection,
          authMethod,
          patKey,
          tenantId: authMethod === "entra" ? tenantId : void 0,
          clientId: authMethod === "entra" ? clientId : void 0
        };
        const updatedConnections = existingConnections.map(
          (connection) => connection.id === targetConnection.id ? updatedConnection : connection
        );
        await settings.update("connections", updatedConnections, vscode4.ConfigurationTarget.Global);
        try {
          const { setLoadedConnectionsReader: setLoadedConnectionsReader2 } = await Promise.resolve().then(() => (init_extensionHostBridge(), extensionHostBridge_exports));
          setLoadedConnectionsReader2(() => updatedConnections);
        } catch (error) {
          logger3.warn("Failed to update bridge reader after auth reset", {
            error: error instanceof Error ? error.message : String(error)
          });
        }
        if (authMethod === "entra") {
          vscode4.window.showInformationMessage(
            "Authentication method updated. Starting Entra sign-in \u2014 complete the device code prompt to finish."
          );
        } else {
          vscode4.window.showInformationMessage("Authentication updated successfully.");
        }
        return { status: "success", connectionId: targetConnection.id };
      }
      async manageExistingConnections(connections3) {
        if (connections3.length === 0) {
          vscode4.window.showInformationMessage("No existing connections found.");
          return { status: "cancelled" };
        }
        const items = connections3.map((conn) => ({
          label: conn.label || `${conn.organization}/${conn.project}`,
          description: conn.authMethod === "pat" ? "Personal Access Token" : "Microsoft Entra ID",
          detail: conn.baseUrl,
          connection: conn
        }));
        const selected = await vscode4.window.showQuickPick(items, {
          placeHolder: "Select a connection to manage",
          matchOnDescription: true,
          matchOnDetail: true
        });
        if (!selected) {
          return { status: "cancelled" };
        }
        const action2 = await vscode4.window.showQuickPick(
          [
            { label: "Remove Connection", value: "remove", description: "Delete this connection" },
            {
              label: "Test Connection",
              value: "test",
              description: "Test if this connection is working"
            }
          ],
          {
            placeHolder: `Manage connection: ${selected.label}`
          }
        );
        if (action2?.value === "remove") {
          const confirm = await vscode4.window.showWarningMessage(
            `Are you sure you want to remove the connection "${selected.label}"?`,
            { modal: true },
            "Yes, Remove"
          );
          if (confirm === "Yes, Remove") {
            const settings = vscode4.workspace.getConfiguration("azureDevOpsIntegration");
            const updatedConnections = connections3.filter((c) => c.id !== selected.connection.id);
            await settings.update("connections", updatedConnections, vscode4.ConfigurationTarget.Global);
            if (selected.connection.patKey) {
              await this.context.secrets.delete(selected.connection.patKey);
            }
            vscode4.window.showInformationMessage(`Connection "${selected.label}" removed.`);
            return { status: "removed", removedConnectionId: selected.connection.id };
          }
        } else if (action2?.value === "test") {
          vscode4.window.showInformationMessage("Connection test not yet implemented.");
        }
        return { status: "cancelled" };
      }
    };
  }
});

// src/performance.ts
async function measureAsync(operation, fn, cacheHit) {
  const endTiming = performanceMonitor.startTiming(operation);
  try {
    const result = await fn();
    endTiming(void 0, cacheHit);
    return result;
  } catch (error) {
    endTiming(error instanceof Error ? error.message : "Unknown error", cacheHit);
    throw error;
  }
}
var performanceImpl, PerformanceMonitor, performanceMonitor, MemoryOptimizer;
var init_performance = __esm({
  "src/performance.ts"() {
    "use strict";
    init_cache();
    performanceImpl = { now: () => Date.now() };
    void (async () => {
      try {
        if (typeof process !== "undefined" && process?.versions?.node) {
          const { performance: performance2 } = await import("perf_hooks");
          if (performance2?.now) {
            performanceImpl = performance2;
          }
          return;
        }
      } catch {
      }
      if (typeof performance !== "undefined" && typeof performance.now === "function") {
        performanceImpl = performance;
      }
    })();
    PerformanceMonitor = class {
      metrics = [];
      maxMetrics = 1e3;
      memoryPeak = 0;
      isEnabled = true;
      /**
       * Start timing an operation
       */
      startTiming(operation) {
        const startTime = performanceImpl.now();
        const startMemory = this.getMemoryUsage();
        return (error, cacheHit) => {
          const endTime = performanceImpl.now();
          const endMemory = this.getMemoryUsage();
          const metric = {
            operation,
            duration: endTime - startTime,
            timestamp: Date.now(),
            memoryUsage: endMemory.heapUsed - startMemory.heapUsed,
            cacheHit,
            error
          };
          this.recordMetric(metric);
          return metric;
        };
      }
      /**
       * Record a performance metric
       */
      recordMetric(metric) {
        if (!this.isEnabled) return;
        this.metrics.push(metric);
        if (this.metrics.length > this.maxMetrics) {
          this.metrics = this.metrics.slice(-this.maxMetrics);
        }
        if (metric.memoryUsage && metric.memoryUsage > this.memoryPeak) {
          this.memoryPeak = metric.memoryUsage;
        }
      }
      /**
       * Get performance statistics
       */
      getStats() {
        if (this.metrics.length === 0) {
          return {
            totalOperations: 0,
            averageDuration: 0,
            minDuration: 0,
            maxDuration: 0,
            errorRate: 0,
            cacheHitRate: 0,
            memoryUsage: {
              current: this.getMemoryUsage().heapUsed,
              peak: this.memoryPeak,
              average: 0
            }
          };
        }
        const durations = this.metrics.map((m) => m.duration);
        const errors = this.metrics.filter((m) => m.error).length;
        const cacheHits = this.metrics.filter((m) => m.cacheHit === true).length;
        const memoryUsages = this.metrics.filter((m) => m.memoryUsage !== void 0).map((m) => m.memoryUsage);
        return {
          totalOperations: this.metrics.length,
          averageDuration: durations.reduce((a, b) => a + b, 0) / durations.length,
          minDuration: Math.min(...durations),
          maxDuration: Math.max(...durations),
          errorRate: errors / this.metrics.length,
          cacheHitRate: cacheHits / this.metrics.length,
          memoryUsage: {
            current: this.getMemoryUsage().heapUsed,
            peak: this.memoryPeak,
            average: memoryUsages.length > 0 ? memoryUsages.reduce((a, b) => a + b, 0) / memoryUsages.length : 0
          }
        };
      }
      /**
       * Get metrics for a specific operation
       */
      getOperationStats(operation) {
        const operationMetrics = this.metrics.filter((m) => m.operation === operation);
        if (operationMetrics.length === 0) {
          return this.getStats();
        }
        const durations = operationMetrics.map((m) => m.duration);
        const errors = operationMetrics.filter((m) => m.error).length;
        const cacheHits = operationMetrics.filter((m) => m.cacheHit === true).length;
        return {
          totalOperations: operationMetrics.length,
          averageDuration: durations.reduce((a, b) => a + b, 0) / durations.length,
          minDuration: Math.min(...durations),
          maxDuration: Math.max(...durations),
          errorRate: errors / operationMetrics.length,
          cacheHitRate: cacheHits / operationMetrics.length,
          memoryUsage: {
            current: this.getMemoryUsage().heapUsed,
            peak: this.memoryPeak,
            average: 0
          }
        };
      }
      /**
       * Get recent metrics
       */
      getRecentMetrics(count = 50) {
        return this.metrics.slice(-count);
      }
      /**
       * Clear all metrics
       */
      clear() {
        this.metrics = [];
        this.memoryPeak = 0;
      }
      /**
       * Enable or disable monitoring
       */
      setEnabled(enabled) {
        this.isEnabled = enabled;
      }
      /**
       * Get current memory usage
       */
      getMemoryUsage() {
        return process.memoryUsage();
      }
      /**
       * Get comprehensive performance report
       */
      getPerformanceReport() {
        const stats = this.getStats();
        const cacheStats = getCacheStats();
        const memoryUsage = this.getMemoryUsage();
        const recommendations = [];
        if (stats.averageDuration > 1e3) {
          recommendations.push("Consider optimizing slow operations (>1s average)");
        }
        if (stats.errorRate > 0.1) {
          recommendations.push("High error rate detected - investigate error handling");
        }
        if (stats.cacheHitRate < 0.5) {
          recommendations.push("Low cache hit rate - consider improving caching strategy");
        }
        if (memoryUsage.heapUsed > 100 * 1024 * 1024) {
          recommendations.push("High memory usage - consider memory optimization");
        }
        if (cacheStats.totalMemoryUsage > 50 * 1024 * 1024) {
          recommendations.push("Cache memory usage is high - consider reducing cache size");
        }
        return {
          stats,
          cacheStats,
          memoryUsage,
          recommendations
        };
      }
    };
    performanceMonitor = new PerformanceMonitor();
    MemoryOptimizer = class {
      static GC_THRESHOLD = 50 * 1024 * 1024;
      // 50MB
      static lastGC = 0;
      static GC_INTERVAL = 3e4;
      // 30 seconds
      /**
       * Force garbage collection if needed
       */
      static forceGCIfNeeded() {
        const memoryUsage = performanceMonitor.getMemoryUsage();
        const now = Date.now();
        if (memoryUsage.heapUsed > this.GC_THRESHOLD && now - this.lastGC > this.GC_INTERVAL) {
          if (global.gc) {
            global.gc();
            this.lastGC = now;
            return true;
          }
        }
        return false;
      }
      /**
       * Get memory usage summary
       */
      static getMemorySummary() {
        const current = performanceMonitor.getMemoryUsage();
        const peak = performanceMonitor.getStats().memoryUsage.peak;
        const recommendations = [];
        if (current.heapUsed > 100 * 1024 * 1024) {
          recommendations.push("Consider reducing memory usage");
        }
        if (current.external > 50 * 1024 * 1024) {
          recommendations.push("High external memory usage - check for memory leaks");
        }
        return {
          current,
          peak,
          recommendations
        };
      }
    };
  }
});

// src/praxis/connection/types.ts
var DEFAULT_CONNECTION_CONFIG;
var init_types2 = __esm({
  "src/praxis/connection/types.ts"() {
    "use strict";
    DEFAULT_CONNECTION_CONFIG = {
      maxRetryCount: 3,
      retryDelayMs: 1e3,
      refreshBackoffMinutes: 5,
      maxRefreshBackoffMinutes: 60
    };
  }
});

// node_modules/@plures/praxis/dist/node/chunk-JQ64KMLN.js
var init_chunk_JQ64KMLN = __esm({
  "node_modules/@plures/praxis/dist/node/chunk-JQ64KMLN.js"() {
  }
});

// node_modules/@plures/praxis/dist/node/chunk-S54337I5.js
var init_chunk_S54337I5 = __esm({
  "node_modules/@plures/praxis/dist/node/chunk-S54337I5.js"() {
  }
});

// node_modules/@plures/praxis/dist/node/chunk-SRM3OPPM.js
var init_chunk_SRM3OPPM = __esm({
  "node_modules/@plures/praxis/dist/node/chunk-SRM3OPPM.js"() {
  }
});

// node_modules/@plures/praxis/dist/node/chunk-VOMLVI6V.js
function safeClone(value) {
  if (value === null || typeof value !== "object") {
    return value;
  }
  if (typeof globalThis.structuredClone === "function") {
    try {
      return globalThis.structuredClone(value);
    } catch {
    }
  }
  if (Array.isArray(value)) {
    return [...value];
  }
  return { ...value };
}
function createPraxisEngine(options) {
  return new LogicEngine(options);
}
var PRAXIS_PROTOCOL_VERSION, LogicEngine;
var init_chunk_VOMLVI6V = __esm({
  "node_modules/@plures/praxis/dist/node/chunk-VOMLVI6V.js"() {
    PRAXIS_PROTOCOL_VERSION = "1.0.0";
    LogicEngine = class {
      state;
      registry;
      constructor(options) {
        this.registry = options.registry;
        this.state = {
          context: options.initialContext,
          facts: options.initialFacts ?? [],
          meta: options.initialMeta ?? {},
          protocolVersion: PRAXIS_PROTOCOL_VERSION
        };
      }
      /**
       * Get the current state (immutable copy)
       */
      getState() {
        return {
          context: safeClone(this.state.context),
          facts: [...this.state.facts],
          meta: this.state.meta ? safeClone(this.state.meta) : void 0,
          protocolVersion: this.state.protocolVersion
        };
      }
      /**
       * Get the current context
       */
      getContext() {
        return safeClone(this.state.context);
      }
      /**
       * Get current facts
       */
      getFacts() {
        return [...this.state.facts];
      }
      /**
       * Process events through the engine.
       * Applies all registered rules and checks all registered constraints.
       *
       * @param events Events to process
       * @returns Result with new state and diagnostics
       */
      step(events) {
        const config = {
          ruleIds: this.registry.getRuleIds(),
          constraintIds: this.registry.getConstraintIds()
        };
        return this.stepWithConfig(events, config);
      }
      /**
       * Process events with specific rule and constraint configuration.
       *
       * @param events Events to process
       * @param config Step configuration
       * @returns Result with new state and diagnostics
       */
      stepWithConfig(events, config) {
        const diagnostics = [];
        let newState = { ...this.state };
        const newFacts = [];
        for (const ruleId of config.ruleIds) {
          const rule = this.registry.getRule(ruleId);
          if (!rule) {
            diagnostics.push({
              kind: "rule-error",
              message: `Rule "${ruleId}" not found in registry`,
              data: { ruleId }
            });
            continue;
          }
          try {
            const ruleFacts = rule.impl(newState, events);
            newFacts.push(...ruleFacts);
          } catch (error) {
            diagnostics.push({
              kind: "rule-error",
              message: `Error executing rule "${ruleId}": ${error instanceof Error ? error.message : String(error)}`,
              data: { ruleId, error }
            });
          }
        }
        newState = {
          ...newState,
          facts: [...newState.facts, ...newFacts]
        };
        for (const constraintId of config.constraintIds) {
          const constraint = this.registry.getConstraint(constraintId);
          if (!constraint) {
            diagnostics.push({
              kind: "constraint-violation",
              message: `Constraint "${constraintId}" not found in registry`,
              data: { constraintId }
            });
            continue;
          }
          try {
            const result = constraint.impl(newState);
            if (result === false) {
              diagnostics.push({
                kind: "constraint-violation",
                message: `Constraint "${constraintId}" violated`,
                data: { constraintId, description: constraint.description }
              });
            } else if (typeof result === "string") {
              diagnostics.push({
                kind: "constraint-violation",
                message: result,
                data: { constraintId, description: constraint.description }
              });
            }
          } catch (error) {
            diagnostics.push({
              kind: "constraint-violation",
              message: `Error checking constraint "${constraintId}": ${error instanceof Error ? error.message : String(error)}`,
              data: { constraintId, error }
            });
          }
        }
        this.state = newState;
        return {
          state: newState,
          diagnostics
        };
      }
      /**
       * Update the context directly (for exceptional cases).
       * Generally, context should be updated through rules.
       *
       * @param updater Function that produces new context from old context
       */
      updateContext(updater) {
        this.state = {
          ...this.state,
          context: updater(this.state.context)
        };
      }
      /**
       * Add facts directly (for exceptional cases).
       * Generally, facts should be added through rules.
       *
       * @param facts Facts to add
       */
      addFacts(facts) {
        this.state = {
          ...this.state,
          facts: [...this.state.facts, ...facts]
        };
      }
      /**
       * Clear all facts
       */
      clearFacts() {
        this.state = {
          ...this.state,
          facts: []
        };
      }
      /**
       * Reset the engine to initial state
       */
      reset(options) {
        this.state = {
          context: options.initialContext,
          facts: options.initialFacts ?? [],
          meta: options.initialMeta ?? {},
          protocolVersion: PRAXIS_PROTOCOL_VERSION
        };
      }
    };
  }
});

// node_modules/svelte/src/constants.js
var EACH_INDEX_REACTIVE, EACH_IS_CONTROLLED, EACH_IS_ANIMATED, EACH_ITEM_IMMUTABLE, PROPS_IS_RUNES, PROPS_IS_UPDATED, PROPS_IS_BINDABLE, PROPS_IS_LAZY_INITIAL, TRANSITION_OUT, TRANSITION_GLOBAL, TEMPLATE_USE_IMPORT_NODE, TEMPLATE_USE_SVG, TEMPLATE_USE_MATHML, HYDRATION_START, HYDRATION_START_ELSE, HYDRATION_END, HYDRATION_ERROR, ELEMENT_PRESERVE_ATTRIBUTE_CASE, ELEMENT_IS_INPUT, UNINITIALIZED, FILENAME;
var init_constants2 = __esm({
  "node_modules/svelte/src/constants.js"() {
    EACH_INDEX_REACTIVE = 1 << 1;
    EACH_IS_CONTROLLED = 1 << 2;
    EACH_IS_ANIMATED = 1 << 3;
    EACH_ITEM_IMMUTABLE = 1 << 4;
    PROPS_IS_RUNES = 1 << 1;
    PROPS_IS_UPDATED = 1 << 2;
    PROPS_IS_BINDABLE = 1 << 3;
    PROPS_IS_LAZY_INITIAL = 1 << 4;
    TRANSITION_OUT = 1 << 1;
    TRANSITION_GLOBAL = 1 << 2;
    TEMPLATE_USE_IMPORT_NODE = 1 << 1;
    TEMPLATE_USE_SVG = 1 << 2;
    TEMPLATE_USE_MATHML = 1 << 3;
    HYDRATION_START = "[";
    HYDRATION_START_ELSE = "[!";
    HYDRATION_END = "]";
    HYDRATION_ERROR = {};
    ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
    ELEMENT_IS_INPUT = 1 << 2;
    UNINITIALIZED = /* @__PURE__ */ Symbol();
    FILENAME = /* @__PURE__ */ Symbol("filename");
  }
});

// node_modules/esm-env/browser-fallback.js
var init_browser_fallback = __esm({
  "node_modules/esm-env/browser-fallback.js"() {
  }
});

// node_modules/esm-env/dev-fallback.js
var node_env, dev_fallback_default;
var init_dev_fallback = __esm({
  "node_modules/esm-env/dev-fallback.js"() {
    node_env = globalThis.process?.env?.NODE_ENV;
    dev_fallback_default = node_env && !node_env.toLowerCase().startsWith("prod");
  }
});

// node_modules/esm-env/true.js
var init_true = __esm({
  "node_modules/esm-env/true.js"() {
  }
});

// node_modules/esm-env/index.js
var init_esm_env = __esm({
  "node_modules/esm-env/index.js"() {
    init_browser_fallback();
    init_dev_fallback();
    init_true();
  }
});

// node_modules/svelte/src/internal/shared/utils.js
function run_all(arr) {
  for (var i = 0; i < arr.length; i++) {
    arr[i]();
  }
}
function deferred() {
  var resolve;
  var reject;
  var promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
var is_array, index_of, array_from, object_keys, define_property, get_descriptor, object_prototype, array_prototype, get_prototype_of, is_extensible, noop;
var init_utils = __esm({
  "node_modules/svelte/src/internal/shared/utils.js"() {
    is_array = Array.isArray;
    index_of = Array.prototype.indexOf;
    array_from = Array.from;
    object_keys = Object.keys;
    define_property = Object.defineProperty;
    get_descriptor = Object.getOwnPropertyDescriptor;
    object_prototype = Object.prototype;
    array_prototype = Array.prototype;
    get_prototype_of = Object.getPrototypeOf;
    is_extensible = Object.isExtensible;
    noop = () => {
    };
  }
});

// node_modules/svelte/src/internal/client/constants.js
var DERIVED, EFFECT, RENDER_EFFECT, MANAGED_EFFECT, BLOCK_EFFECT, BRANCH_EFFECT, ROOT_EFFECT, BOUNDARY_EFFECT, CONNECTED, CLEAN, DIRTY, MAYBE_DIRTY, INERT, DESTROYED, EFFECT_RAN, EFFECT_TRANSPARENT, EAGER_EFFECT, HEAD_EFFECT, EFFECT_PRESERVED, USER_EFFECT, EFFECT_OFFSCREEN, WAS_MARKED, REACTION_IS_UPDATING, ASYNC, ERROR_VALUE, STATE_SYMBOL, LEGACY_PROPS, PROXY_PATH_SYMBOL, STALE_REACTION, COMMENT_NODE;
var init_constants3 = __esm({
  "node_modules/svelte/src/internal/client/constants.js"() {
    DERIVED = 1 << 1;
    EFFECT = 1 << 2;
    RENDER_EFFECT = 1 << 3;
    MANAGED_EFFECT = 1 << 24;
    BLOCK_EFFECT = 1 << 4;
    BRANCH_EFFECT = 1 << 5;
    ROOT_EFFECT = 1 << 6;
    BOUNDARY_EFFECT = 1 << 7;
    CONNECTED = 1 << 9;
    CLEAN = 1 << 10;
    DIRTY = 1 << 11;
    MAYBE_DIRTY = 1 << 12;
    INERT = 1 << 13;
    DESTROYED = 1 << 14;
    EFFECT_RAN = 1 << 15;
    EFFECT_TRANSPARENT = 1 << 16;
    EAGER_EFFECT = 1 << 17;
    HEAD_EFFECT = 1 << 18;
    EFFECT_PRESERVED = 1 << 19;
    USER_EFFECT = 1 << 20;
    EFFECT_OFFSCREEN = 1 << 25;
    WAS_MARKED = 1 << 15;
    REACTION_IS_UPDATING = 1 << 21;
    ASYNC = 1 << 22;
    ERROR_VALUE = 1 << 23;
    STATE_SYMBOL = /* @__PURE__ */ Symbol("$state");
    LEGACY_PROPS = /* @__PURE__ */ Symbol("legacy props");
    PROXY_PATH_SYMBOL = /* @__PURE__ */ Symbol("proxy path");
    STALE_REACTION = new class StaleReactionError extends Error {
      name = "StaleReactionError";
      message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
    }();
    COMMENT_NODE = 8;
  }
});

// node_modules/svelte/src/internal/shared/errors.js
var init_errors = __esm({
  "node_modules/svelte/src/internal/shared/errors.js"() {
    init_esm_env();
  }
});

// node_modules/svelte/src/internal/client/errors.js
function derived_references_self() {
  if (dev_fallback_default) {
    const error = new Error(`derived_references_self
A derived value cannot reference itself recursively
https://svelte.dev/e/derived_references_self`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/derived_references_self`);
  }
}
function effect_update_depth_exceeded() {
  if (dev_fallback_default) {
    const error = new Error(`effect_update_depth_exceeded
Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
https://svelte.dev/e/effect_update_depth_exceeded`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
function hydration_failed() {
  if (dev_fallback_default) {
    const error = new Error(`hydration_failed
Failed to hydrate the application
https://svelte.dev/e/hydration_failed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/hydration_failed`);
  }
}
function rune_outside_svelte(rune) {
  if (dev_fallback_default) {
    const error = new Error(`rune_outside_svelte
The \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files
https://svelte.dev/e/rune_outside_svelte`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
  }
}
function state_descriptors_fixed() {
  if (dev_fallback_default) {
    const error = new Error(`state_descriptors_fixed
Property descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.
https://svelte.dev/e/state_descriptors_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
  }
}
function state_prototype_fixed() {
  if (dev_fallback_default) {
    const error = new Error(`state_prototype_fixed
Cannot set prototype of \`$state\` object
https://svelte.dev/e/state_prototype_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
  }
}
function state_unsafe_mutation() {
  if (dev_fallback_default) {
    const error = new Error(`state_unsafe_mutation
Updating state inside \`$derived(...)\`, \`$inspect(...)\` or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`
https://svelte.dev/e/state_unsafe_mutation`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}
function svelte_boundary_reset_onerror() {
  if (dev_fallback_default) {
    const error = new Error(`svelte_boundary_reset_onerror
A \`<svelte:boundary>\` \`reset\` function cannot be called while an error is still being handled
https://svelte.dev/e/svelte_boundary_reset_onerror`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
  }
}
var init_errors2 = __esm({
  "node_modules/svelte/src/internal/client/errors.js"() {
    init_esm_env();
    init_errors();
  }
});

// node_modules/svelte/src/internal/client/warnings.js
function hydration_mismatch(location) {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] hydration_mismatch
%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : "Hydration failed because the initial UI does not match what was rendered on the server"}
https://svelte.dev/e/hydration_mismatch`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/hydration_mismatch`);
  }
}
function lifecycle_double_unmount() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/lifecycle_double_unmount`);
  }
}
function state_proxy_equality_mismatch(operator) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
  }
}
function state_proxy_unmount() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] state_proxy_unmount
%cTried to unmount a state proxy, rather than a component
https://svelte.dev/e/state_proxy_unmount`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_unmount`);
  }
}
function svelte_boundary_reset_noop() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] svelte_boundary_reset_noop
%cA \`<svelte:boundary>\` \`reset\` function only resets the boundary the first time it is called
https://svelte.dev/e/svelte_boundary_reset_noop`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/svelte_boundary_reset_noop`);
  }
}
var bold, normal;
var init_warnings = __esm({
  "node_modules/svelte/src/internal/client/warnings.js"() {
    init_esm_env();
    bold = "font-weight: bold";
    normal = "font-weight: normal";
  }
});

// node_modules/svelte/src/internal/client/dom/hydration.js
function set_hydrating(value) {
  hydrating = value;
}
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}
function hydrate_next() {
  return set_hydrate_node(get_next_sibling(hydrate_node));
}
function next(count = 1) {
  if (hydrating) {
    var i = count;
    var node = hydrate_node;
    while (i--) {
      node = /** @type {TemplateNode} */
      get_next_sibling(node);
    }
    hydrate_node = node;
  }
}
function skip_nodes(remove = true) {
  var depth = 0;
  var node = hydrate_node;
  while (true) {
    if (node.nodeType === COMMENT_NODE) {
      var data = (
        /** @type {Comment} */
        node.data
      );
      if (data === HYDRATION_END) {
        if (depth === 0) return node;
        depth -= 1;
      } else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
        depth += 1;
      }
    }
    var next2 = (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    if (remove) node.remove();
    node = next2;
  }
}
var hydrating, hydrate_node;
var init_hydration = __esm({
  "node_modules/svelte/src/internal/client/dom/hydration.js"() {
    init_constants3();
    init_constants2();
    init_warnings();
    init_operations();
    hydrating = false;
  }
});

// node_modules/svelte/src/internal/client/reactivity/equality.js
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a !== null && typeof a === "object" || typeof a === "function";
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}
var init_equality = __esm({
  "node_modules/svelte/src/internal/client/reactivity/equality.js"() {
  }
});

// node_modules/svelte/src/internal/flags/index.js
var async_mode_flag, legacy_mode_flag, tracing_mode_flag;
var init_flags = __esm({
  "node_modules/svelte/src/internal/flags/index.js"() {
    async_mode_flag = false;
    legacy_mode_flag = false;
    tracing_mode_flag = false;
  }
});

// node_modules/svelte/src/internal/shared/warnings.js
var init_warnings2 = __esm({
  "node_modules/svelte/src/internal/shared/warnings.js"() {
    init_esm_env();
  }
});

// node_modules/svelte/src/internal/shared/clone.js
var init_clone = __esm({
  "node_modules/svelte/src/internal/shared/clone.js"() {
    init_esm_env();
    init_warnings2();
    init_utils();
  }
});

// node_modules/svelte/src/internal/client/dev/tracing.js
function tag(source2, label) {
  source2.label = label;
  tag_proxy(source2.v, label);
  return source2;
}
function tag_proxy(value, label) {
  value?.[PROXY_PATH_SYMBOL]?.(label);
  return value;
}
var tracing_expressions;
var init_tracing = __esm({
  "node_modules/svelte/src/internal/client/dev/tracing.js"() {
    init_constants2();
    init_clone();
    init_constants3();
    init_effects();
    init_runtime();
    tracing_expressions = null;
  }
});

// node_modules/svelte/src/internal/shared/dev.js
function get_error(label) {
  const error = new Error();
  const stack2 = get_stack();
  if (stack2.length === 0) {
    return null;
  }
  stack2.unshift("\n");
  define_property(error, "stack", {
    value: stack2.join("\n")
  });
  define_property(error, "name", {
    value: label
  });
  return (
    /** @type {Error & { stack: string }} */
    error
  );
}
function get_stack() {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = Infinity;
  const stack2 = new Error().stack;
  Error.stackTraceLimit = limit;
  if (!stack2) return [];
  const lines = stack2.split("\n");
  const new_lines = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const posixified = line.replaceAll("\\", "/");
    if (line.trim() === "Error") {
      continue;
    }
    if (line.includes("validate_each_keys")) {
      return [];
    }
    if (posixified.includes("svelte/src/internal") || posixified.includes("node_modules/.vite")) {
      continue;
    }
    new_lines.push(line);
  }
  return new_lines;
}
var init_dev = __esm({
  "node_modules/svelte/src/internal/shared/dev.js"() {
    init_utils();
  }
});

// node_modules/svelte/src/internal/client/context.js
function set_component_context(context) {
  component_context = context;
}
function set_dev_stack(stack2) {
  dev_stack = stack2;
}
function set_dev_current_component_function(fn) {
  dev_current_component_function = fn;
}
function push(props, runes = false, fn) {
  component_context = {
    p: component_context,
    i: false,
    c: null,
    e: null,
    s: props,
    x: null,
    l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
  };
  if (dev_fallback_default) {
    component_context.function = fn;
    dev_current_component_function = fn;
  }
}
function pop(component2) {
  var context = (
    /** @type {ComponentContext} */
    component_context
  );
  var effects = context.e;
  if (effects !== null) {
    context.e = null;
    for (var fn of effects) {
      create_user_effect(fn);
    }
  }
  if (component2 !== void 0) {
    context.x = component2;
  }
  context.i = true;
  component_context = context.p;
  if (dev_fallback_default) {
    dev_current_component_function = component_context?.function ?? null;
  }
  return component2 ?? /** @type {T} */
  {};
}
function is_runes() {
  return !legacy_mode_flag || component_context !== null && component_context.l === null;
}
var component_context, dev_stack, dev_current_component_function;
var init_context = __esm({
  "node_modules/svelte/src/internal/client/context.js"() {
    init_esm_env();
    init_errors2();
    init_runtime();
    init_effects();
    init_flags();
    init_constants2();
    init_constants3();
    component_context = null;
    dev_stack = null;
    dev_current_component_function = null;
  }
});

// node_modules/svelte/src/internal/client/dom/task.js
function run_micro_tasks() {
  var tasks = micro_tasks;
  micro_tasks = [];
  run_all(tasks);
}
function queue_micro_task(fn) {
  if (micro_tasks.length === 0 && !is_flushing_sync) {
    var tasks = micro_tasks;
    queueMicrotask(() => {
      if (tasks === micro_tasks) run_micro_tasks();
    });
  }
  micro_tasks.push(fn);
}
function flush_tasks() {
  while (micro_tasks.length > 0) {
    run_micro_tasks();
  }
}
var micro_tasks;
var init_task = __esm({
  "node_modules/svelte/src/internal/client/dom/task.js"() {
    init_utils();
    init_batch();
    micro_tasks = [];
  }
});

// node_modules/svelte/src/internal/client/error-handling.js
function handle_error(error) {
  var effect2 = active_effect;
  if (effect2 === null) {
    active_reaction.f |= ERROR_VALUE;
    return error;
  }
  if (dev_fallback_default && error instanceof Error && !adjustments.has(error)) {
    adjustments.set(error, get_adjustments(error, effect2));
  }
  if ((effect2.f & EFFECT_RAN) === 0) {
    if ((effect2.f & BOUNDARY_EFFECT) === 0) {
      if (dev_fallback_default && !effect2.parent && error instanceof Error) {
        apply_adjustments(error);
      }
      throw error;
    }
    effect2.b.error(error);
  } else {
    invoke_error_boundary(error, effect2);
  }
}
function invoke_error_boundary(error, effect2) {
  while (effect2 !== null) {
    if ((effect2.f & BOUNDARY_EFFECT) !== 0) {
      try {
        effect2.b.error(error);
        return;
      } catch (e) {
        error = e;
      }
    }
    effect2 = effect2.parent;
  }
  if (dev_fallback_default && error instanceof Error) {
    apply_adjustments(error);
  }
  throw error;
}
function get_adjustments(error, effect2) {
  const message_descriptor = get_descriptor(error, "message");
  if (message_descriptor && !message_descriptor.configurable) return;
  var indent = is_firefox ? "  " : "	";
  var component_stack = `
${indent}in ${effect2.fn?.name || "<unknown>"}`;
  var context = effect2.ctx;
  while (context !== null) {
    component_stack += `
${indent}in ${context.function?.[FILENAME].split("/").pop()}`;
    context = context.p;
  }
  return {
    message: error.message + `
${component_stack}
`,
    stack: error.stack?.split("\n").filter((line) => !line.includes("svelte/src/internal")).join("\n")
  };
}
function apply_adjustments(error) {
  const adjusted = adjustments.get(error);
  if (adjusted) {
    define_property(error, "message", {
      value: adjusted.message
    });
    define_property(error, "stack", {
      value: adjusted.stack
    });
  }
}
var adjustments;
var init_error_handling = __esm({
  "node_modules/svelte/src/internal/client/error-handling.js"() {
    init_esm_env();
    init_constants2();
    init_operations();
    init_constants3();
    init_utils();
    init_runtime();
    adjustments = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/svelte/src/internal/client/reactivity/status.js
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
function update_derived_status(derived3) {
  if ((derived3.f & CONNECTED) !== 0 || derived3.deps === null) {
    set_signal_status(derived3, CLEAN);
  } else {
    set_signal_status(derived3, MAYBE_DIRTY);
  }
}
var STATUS_MASK;
var init_status = __esm({
  "node_modules/svelte/src/internal/client/reactivity/status.js"() {
    init_constants3();
    STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
  }
});

// node_modules/svelte/src/internal/client/reactivity/utils.js
function clear_marked(deps) {
  if (deps === null) return;
  for (const dep of deps) {
    if ((dep.f & DERIVED) === 0 || (dep.f & WAS_MARKED) === 0) {
      continue;
    }
    dep.f ^= WAS_MARKED;
    clear_marked(
      /** @type {Derived} */
      dep.deps
    );
  }
}
function defer_effect(effect2, dirty_effects, maybe_dirty_effects) {
  if ((effect2.f & DIRTY) !== 0) {
    dirty_effects.add(effect2);
  } else if ((effect2.f & MAYBE_DIRTY) !== 0) {
    maybe_dirty_effects.add(effect2);
  }
  clear_marked(effect2.deps);
  set_signal_status(effect2, CLEAN);
}
var init_utils2 = __esm({
  "node_modules/svelte/src/internal/client/reactivity/utils.js"() {
    init_constants3();
    init_status();
  }
});

// node_modules/svelte/src/internal/client/reactivity/batch.js
function flushSync(fn) {
  var was_flushing_sync = is_flushing_sync;
  is_flushing_sync = true;
  try {
    var result;
    if (fn) {
      if (current_batch !== null) {
        flush_effects();
      }
      result = fn();
    }
    while (true) {
      flush_tasks();
      if (queued_root_effects.length === 0) {
        current_batch?.flush();
        if (queued_root_effects.length === 0) {
          last_scheduled_effect = null;
          return (
            /** @type {T} */
            result
          );
        }
      }
      flush_effects();
    }
  } finally {
    is_flushing_sync = was_flushing_sync;
  }
}
function flush_effects() {
  is_flushing = true;
  var source_stacks = dev_fallback_default ? /* @__PURE__ */ new Set() : null;
  try {
    var flush_count = 0;
    while (queued_root_effects.length > 0) {
      var batch = Batch.ensure();
      if (flush_count++ > 1e3) {
        if (dev_fallback_default) {
          var updates = /* @__PURE__ */ new Map();
          for (const source2 of batch.current.keys()) {
            for (const [stack2, update2] of source2.updated ?? []) {
              var entry = updates.get(stack2);
              if (!entry) {
                entry = { error: update2.error, count: 0 };
                updates.set(stack2, entry);
              }
              entry.count += update2.count;
            }
          }
          for (const update2 of updates.values()) {
            if (update2.error) {
              console.error(update2.error);
            }
          }
        }
        infinite_loop_guard();
      }
      batch.process(queued_root_effects);
      old_values.clear();
      if (dev_fallback_default) {
        for (const source2 of batch.current.keys()) {
          source_stacks.add(source2);
        }
      }
    }
  } finally {
    is_flushing = false;
    last_scheduled_effect = null;
    if (dev_fallback_default) {
      for (
        const source2 of
        /** @type {Set<Source>} */
        source_stacks
      ) {
        source2.updated = null;
      }
    }
  }
}
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error) {
    if (dev_fallback_default) {
      define_property(error, "stack", { value: "" });
    }
    invoke_error_boundary(error, last_scheduled_effect);
  }
}
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0) return;
  var i = 0;
  while (i < length) {
    var effect2 = effects[i++];
    if ((effect2.f & (DESTROYED | INERT)) === 0 && is_dirty(effect2)) {
      eager_block_effects = /* @__PURE__ */ new Set();
      update_effect(effect2);
      if (effect2.deps === null && effect2.first === null && effect2.nodes === null) {
        if (effect2.teardown === null && effect2.ac === null) {
          unlink_effect(effect2);
        } else {
          effect2.fn = null;
        }
      }
      if (eager_block_effects?.size > 0) {
        old_values.clear();
        for (const e of eager_block_effects) {
          if ((e.f & (DESTROYED | INERT)) !== 0) continue;
          const ordered_effects = [e];
          let ancestor = e.parent;
          while (ancestor !== null) {
            if (eager_block_effects.has(ancestor)) {
              eager_block_effects.delete(ancestor);
              ordered_effects.push(ancestor);
            }
            ancestor = ancestor.parent;
          }
          for (let j = ordered_effects.length - 1; j >= 0; j--) {
            const e2 = ordered_effects[j];
            if ((e2.f & (DESTROYED | INERT)) !== 0) continue;
            update_effect(e2);
          }
        }
        eager_block_effects.clear();
      }
    }
  }
  eager_block_effects = null;
}
function mark_effects(value, sources, marked, checked) {
  if (marked.has(value)) return;
  marked.add(value);
  if (value.reactions !== null) {
    for (const reaction of value.reactions) {
      const flags2 = reaction.f;
      if ((flags2 & DERIVED) !== 0) {
        mark_effects(
          /** @type {Derived} */
          reaction,
          sources,
          marked,
          checked
        );
      } else if ((flags2 & (ASYNC | BLOCK_EFFECT)) !== 0 && (flags2 & DIRTY) === 0 && depends_on(reaction, sources, checked)) {
        set_signal_status(reaction, DIRTY);
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
}
function depends_on(reaction, sources, checked) {
  const depends = checked.get(reaction);
  if (depends !== void 0) return depends;
  if (reaction.deps !== null) {
    for (const dep of reaction.deps) {
      if (sources.includes(dep)) {
        return true;
      }
      if ((dep.f & DERIVED) !== 0 && depends_on(
        /** @type {Derived} */
        dep,
        sources,
        checked
      )) {
        checked.set(
          /** @type {Derived} */
          dep,
          true
        );
        return true;
      }
    }
  }
  checked.set(reaction, false);
  return false;
}
function schedule_effect(signal) {
  var effect2 = last_scheduled_effect = signal;
  while (effect2.parent !== null) {
    effect2 = effect2.parent;
    var flags2 = effect2.f;
    if (is_flushing && effect2 === active_effect && (flags2 & BLOCK_EFFECT) !== 0 && (flags2 & HEAD_EFFECT) === 0) {
      return;
    }
    if ((flags2 & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags2 & CLEAN) === 0) return;
      effect2.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect2);
}
var batches, current_batch, previous_batch, batch_values, queued_root_effects, last_scheduled_effect, is_flushing, is_flushing_sync, Batch, eager_block_effects;
var init_batch = __esm({
  "node_modules/svelte/src/internal/client/reactivity/batch.js"() {
    init_constants3();
    init_flags();
    init_utils();
    init_runtime();
    init_errors2();
    init_task();
    init_esm_env();
    init_error_handling();
    init_sources();
    init_effects();
    init_utils2();
    init_constants2();
    init_status();
    batches = /* @__PURE__ */ new Set();
    current_batch = null;
    previous_batch = null;
    batch_values = null;
    queued_root_effects = [];
    last_scheduled_effect = null;
    is_flushing = false;
    is_flushing_sync = false;
    Batch = class _Batch {
      committed = false;
      /**
       * The current values of any sources that are updated in this batch
       * They keys of this map are identical to `this.#previous`
       * @type {Map<Source, any>}
       */
      current = /* @__PURE__ */ new Map();
      /**
       * The values of any sources that are updated in this batch _before_ those updates took place.
       * They keys of this map are identical to `this.#current`
       * @type {Map<Source, any>}
       */
      previous = /* @__PURE__ */ new Map();
      /**
       * When the batch is committed (and the DOM is updated), we need to remove old branches
       * and append new ones by calling the functions added inside (if/each/key/etc) blocks
       * @type {Set<() => void>}
       */
      #commit_callbacks = /* @__PURE__ */ new Set();
      /**
       * If a fork is discarded, we need to destroy any effects that are no longer needed
       * @type {Set<(batch: Batch) => void>}
       */
      #discard_callbacks = /* @__PURE__ */ new Set();
      /**
       * The number of async effects that are currently in flight
       */
      #pending = 0;
      /**
       * The number of async effects that are currently in flight, _not_ inside a pending boundary
       */
      #blocking_pending = 0;
      /**
       * A deferred that resolves when the batch is committed, used with `settled()`
       * TODO replace with Promise.withResolvers once supported widely enough
       * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
       */
      #deferred = null;
      /**
       * Deferred effects (which run after async work has completed) that are DIRTY
       * @type {Set<Effect>}
       */
      #dirty_effects = /* @__PURE__ */ new Set();
      /**
       * Deferred effects that are MAYBE_DIRTY
       * @type {Set<Effect>}
       */
      #maybe_dirty_effects = /* @__PURE__ */ new Set();
      /**
       * A set of branches that still exist, but will be destroyed when this batch
       * is committed  we skip over these during `process`
       * @type {Set<Effect>}
       */
      skipped_effects = /* @__PURE__ */ new Set();
      is_fork = false;
      #decrement_queued = false;
      is_deferred() {
        return this.is_fork || this.#blocking_pending > 0;
      }
      /**
       *
       * @param {Effect[]} root_effects
       */
      process(root_effects) {
        queued_root_effects = [];
        this.apply();
        var effects = [];
        var render_effects = [];
        for (const root of root_effects) {
          this.#traverse_effect_tree(root, effects, render_effects);
        }
        if (this.is_deferred()) {
          this.#defer_effects(render_effects);
          this.#defer_effects(effects);
        } else {
          for (const fn of this.#commit_callbacks) fn();
          this.#commit_callbacks.clear();
          if (this.#pending === 0) {
            this.#commit();
          }
          previous_batch = this;
          current_batch = null;
          flush_queued_effects(render_effects);
          flush_queued_effects(effects);
          previous_batch = null;
          this.#deferred?.resolve();
        }
        batch_values = null;
      }
      /**
       * Traverse the effect tree, executing effects or stashing
       * them for later execution as appropriate
       * @param {Effect} root
       * @param {Effect[]} effects
       * @param {Effect[]} render_effects
       */
      #traverse_effect_tree(root, effects, render_effects) {
        root.f ^= CLEAN;
        var effect2 = root.first;
        var pending_boundary = null;
        while (effect2 !== null) {
          var flags2 = effect2.f;
          var is_branch = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
          var is_skippable_branch = is_branch && (flags2 & CLEAN) !== 0;
          var skip = is_skippable_branch || (flags2 & INERT) !== 0 || this.skipped_effects.has(effect2);
          if (async_mode_flag && pending_boundary === null && (flags2 & BOUNDARY_EFFECT) !== 0 && effect2.b?.is_pending) {
            pending_boundary = effect2;
          }
          if (!skip && effect2.fn !== null) {
            if (is_branch) {
              effect2.f ^= CLEAN;
            } else if (pending_boundary !== null && (flags2 & (EFFECT | RENDER_EFFECT | MANAGED_EFFECT)) !== 0) {
              pending_boundary.b.defer_effect(effect2);
            } else if ((flags2 & EFFECT) !== 0) {
              effects.push(effect2);
            } else if (async_mode_flag && (flags2 & (RENDER_EFFECT | MANAGED_EFFECT)) !== 0) {
              render_effects.push(effect2);
            } else if (is_dirty(effect2)) {
              if ((flags2 & BLOCK_EFFECT) !== 0) this.#dirty_effects.add(effect2);
              update_effect(effect2);
            }
            var child2 = effect2.first;
            if (child2 !== null) {
              effect2 = child2;
              continue;
            }
          }
          var parent = effect2.parent;
          effect2 = effect2.next;
          while (effect2 === null && parent !== null) {
            if (parent === pending_boundary) {
              pending_boundary = null;
            }
            effect2 = parent.next;
            parent = parent.parent;
          }
        }
      }
      /**
       * @param {Effect[]} effects
       */
      #defer_effects(effects) {
        for (var i = 0; i < effects.length; i += 1) {
          defer_effect(effects[i], this.#dirty_effects, this.#maybe_dirty_effects);
        }
      }
      /**
       * Associate a change to a given source with the current
       * batch, noting its previous and current values
       * @param {Source} source
       * @param {any} value
       */
      capture(source2, value) {
        if (value !== UNINITIALIZED && !this.previous.has(source2)) {
          this.previous.set(source2, value);
        }
        if ((source2.f & ERROR_VALUE) === 0) {
          this.current.set(source2, source2.v);
          batch_values?.set(source2, source2.v);
        }
      }
      activate() {
        current_batch = this;
        this.apply();
      }
      deactivate() {
        if (current_batch !== this) return;
        current_batch = null;
        batch_values = null;
      }
      flush() {
        this.activate();
        if (queued_root_effects.length > 0) {
          flush_effects();
          if (current_batch !== null && current_batch !== this) {
            return;
          }
        } else if (this.#pending === 0) {
          this.process([]);
        }
        this.deactivate();
      }
      discard() {
        for (const fn of this.#discard_callbacks) fn(this);
        this.#discard_callbacks.clear();
      }
      #commit() {
        if (batches.size > 1) {
          this.previous.clear();
          var previous_batch_values = batch_values;
          var is_earlier = true;
          for (const batch of batches) {
            if (batch === this) {
              is_earlier = false;
              continue;
            }
            const sources = [];
            for (const [source2, value] of this.current) {
              if (batch.current.has(source2)) {
                if (is_earlier && value !== batch.current.get(source2)) {
                  batch.current.set(source2, value);
                } else {
                  continue;
                }
              }
              sources.push(source2);
            }
            if (sources.length === 0) {
              continue;
            }
            const others = [...batch.current.keys()].filter((s) => !this.current.has(s));
            if (others.length > 0) {
              var prev_queued_root_effects = queued_root_effects;
              queued_root_effects = [];
              const marked = /* @__PURE__ */ new Set();
              const checked = /* @__PURE__ */ new Map();
              for (const source2 of sources) {
                mark_effects(source2, others, marked, checked);
              }
              if (queued_root_effects.length > 0) {
                current_batch = batch;
                batch.apply();
                for (const root of queued_root_effects) {
                  batch.#traverse_effect_tree(root, [], []);
                }
                batch.deactivate();
              }
              queued_root_effects = prev_queued_root_effects;
            }
          }
          current_batch = null;
          batch_values = previous_batch_values;
        }
        this.committed = true;
        batches.delete(this);
      }
      /**
       *
       * @param {boolean} blocking
       */
      increment(blocking) {
        this.#pending += 1;
        if (blocking) this.#blocking_pending += 1;
      }
      /**
       *
       * @param {boolean} blocking
       */
      decrement(blocking) {
        this.#pending -= 1;
        if (blocking) this.#blocking_pending -= 1;
        if (this.#decrement_queued) return;
        this.#decrement_queued = true;
        queue_micro_task(() => {
          this.#decrement_queued = false;
          if (!this.is_deferred()) {
            this.revive();
          } else if (queued_root_effects.length > 0) {
            this.flush();
          }
        });
      }
      revive() {
        for (const e of this.#dirty_effects) {
          this.#maybe_dirty_effects.delete(e);
          set_signal_status(e, DIRTY);
          schedule_effect(e);
        }
        for (const e of this.#maybe_dirty_effects) {
          set_signal_status(e, MAYBE_DIRTY);
          schedule_effect(e);
        }
        this.flush();
      }
      /** @param {() => void} fn */
      oncommit(fn) {
        this.#commit_callbacks.add(fn);
      }
      /** @param {(batch: Batch) => void} fn */
      ondiscard(fn) {
        this.#discard_callbacks.add(fn);
      }
      settled() {
        return (this.#deferred ??= deferred()).promise;
      }
      static ensure() {
        if (current_batch === null) {
          const batch = current_batch = new _Batch();
          batches.add(current_batch);
          if (!is_flushing_sync) {
            queue_micro_task(() => {
              if (current_batch !== batch) {
                return;
              }
              batch.flush();
            });
          }
        }
        return current_batch;
      }
      apply() {
        if (!async_mode_flag || !this.is_fork && batches.size === 1) return;
        batch_values = new Map(this.current);
        for (const batch of batches) {
          if (batch === this) continue;
          for (const [source2, previous] of batch.previous) {
            if (!batch_values.has(source2)) {
              batch_values.set(source2, previous);
            }
          }
        }
      }
    };
    eager_block_effects = null;
  }
});

// node_modules/svelte/src/reactivity/create-subscriber.js
function createSubscriber(start) {
  let subscribers = 0;
  let version3 = source(0);
  let stop;
  if (dev_fallback_default) {
    tag(version3, "createSubscriber version");
  }
  return () => {
    if (effect_tracking()) {
      get(version3);
      render_effect(() => {
        if (subscribers === 0) {
          stop = untrack(() => start(() => increment(version3)));
        }
        subscribers += 1;
        return () => {
          queue_micro_task(() => {
            subscribers -= 1;
            if (subscribers === 0) {
              stop?.();
              stop = void 0;
              increment(version3);
            }
          });
        };
      });
    }
  };
}
var init_create_subscriber = __esm({
  "node_modules/svelte/src/reactivity/create-subscriber.js"() {
    init_runtime();
    init_effects();
    init_sources();
    init_tracing();
    init_esm_env();
    init_task();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/boundary.js
function boundary(node, props, children) {
  new Boundary(node, props, children);
}
var flags, Boundary;
var init_boundary = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/boundary.js"() {
    init_constants3();
    init_constants2();
    init_context();
    init_error_handling();
    init_effects();
    init_runtime();
    init_hydration();
    init_task();
    init_errors2();
    init_warnings();
    init_esm_env();
    init_batch();
    init_sources();
    init_tracing();
    init_create_subscriber();
    init_operations();
    init_utils2();
    init_status();
    flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;
    Boundary = class {
      /** @type {Boundary | null} */
      parent;
      is_pending = false;
      /** @type {TemplateNode} */
      #anchor;
      /** @type {TemplateNode | null} */
      #hydrate_open = hydrating ? hydrate_node : null;
      /** @type {BoundaryProps} */
      #props;
      /** @type {((anchor: Node) => void)} */
      #children;
      /** @type {Effect} */
      #effect;
      /** @type {Effect | null} */
      #main_effect = null;
      /** @type {Effect | null} */
      #pending_effect = null;
      /** @type {Effect | null} */
      #failed_effect = null;
      /** @type {DocumentFragment | null} */
      #offscreen_fragment = null;
      /** @type {TemplateNode | null} */
      #pending_anchor = null;
      #local_pending_count = 0;
      #pending_count = 0;
      #pending_count_update_queued = false;
      #is_creating_fallback = false;
      /** @type {Set<Effect>} */
      #dirty_effects = /* @__PURE__ */ new Set();
      /** @type {Set<Effect>} */
      #maybe_dirty_effects = /* @__PURE__ */ new Set();
      /**
       * A source containing the number of pending async deriveds/expressions.
       * Only created if `$effect.pending()` is used inside the boundary,
       * otherwise updating the source results in needless `Batch.ensure()`
       * calls followed by no-op flushes
       * @type {Source<number> | null}
       */
      #effect_pending = null;
      #effect_pending_subscriber = createSubscriber(() => {
        this.#effect_pending = source(this.#local_pending_count);
        if (dev_fallback_default) {
          tag(this.#effect_pending, "$effect.pending()");
        }
        return () => {
          this.#effect_pending = null;
        };
      });
      /**
       * @param {TemplateNode} node
       * @param {BoundaryProps} props
       * @param {((anchor: Node) => void)} children
       */
      constructor(node, props, children) {
        this.#anchor = node;
        this.#props = props;
        this.#children = children;
        this.parent = /** @type {Effect} */
        active_effect.b;
        this.is_pending = !!this.#props.pending;
        this.#effect = block(() => {
          active_effect.b = this;
          if (hydrating) {
            const comment2 = this.#hydrate_open;
            hydrate_next();
            const server_rendered_pending = (
              /** @type {Comment} */
              comment2.nodeType === COMMENT_NODE && /** @type {Comment} */
              comment2.data === HYDRATION_START_ELSE
            );
            if (server_rendered_pending) {
              this.#hydrate_pending_content();
            } else {
              this.#hydrate_resolved_content();
              if (this.#pending_count === 0) {
                this.is_pending = false;
              }
            }
          } else {
            var anchor = this.#get_anchor();
            try {
              this.#main_effect = branch(() => children(anchor));
            } catch (error) {
              this.error(error);
            }
            if (this.#pending_count > 0) {
              this.#show_pending_snippet();
            } else {
              this.is_pending = false;
            }
          }
          return () => {
            this.#pending_anchor?.remove();
          };
        }, flags);
        if (hydrating) {
          this.#anchor = hydrate_node;
        }
      }
      #hydrate_resolved_content() {
        try {
          this.#main_effect = branch(() => this.#children(this.#anchor));
        } catch (error) {
          this.error(error);
        }
      }
      #hydrate_pending_content() {
        const pending2 = this.#props.pending;
        if (!pending2) return;
        this.#pending_effect = branch(() => pending2(this.#anchor));
        queue_micro_task(() => {
          var anchor = this.#get_anchor();
          this.#main_effect = this.#run(() => {
            Batch.ensure();
            return branch(() => this.#children(anchor));
          });
          if (this.#pending_count > 0) {
            this.#show_pending_snippet();
          } else {
            pause_effect(
              /** @type {Effect} */
              this.#pending_effect,
              () => {
                this.#pending_effect = null;
              }
            );
            this.is_pending = false;
          }
        });
      }
      #get_anchor() {
        var anchor = this.#anchor;
        if (this.is_pending) {
          this.#pending_anchor = create_text();
          this.#anchor.before(this.#pending_anchor);
          anchor = this.#pending_anchor;
        }
        return anchor;
      }
      /**
       * Defer an effect inside a pending boundary until the boundary resolves
       * @param {Effect} effect
       */
      defer_effect(effect2) {
        defer_effect(effect2, this.#dirty_effects, this.#maybe_dirty_effects);
      }
      /**
       * Returns `false` if the effect exists inside a boundary whose pending snippet is shown
       * @returns {boolean}
       */
      is_rendered() {
        return !this.is_pending && (!this.parent || this.parent.is_rendered());
      }
      has_pending_snippet() {
        return !!this.#props.pending;
      }
      /**
       * @param {() => Effect | null} fn
       */
      #run(fn) {
        var previous_effect = active_effect;
        var previous_reaction = active_reaction;
        var previous_ctx = component_context;
        set_active_effect(this.#effect);
        set_active_reaction(this.#effect);
        set_component_context(this.#effect.ctx);
        try {
          return fn();
        } catch (e) {
          handle_error(e);
          return null;
        } finally {
          set_active_effect(previous_effect);
          set_active_reaction(previous_reaction);
          set_component_context(previous_ctx);
        }
      }
      #show_pending_snippet() {
        const pending2 = (
          /** @type {(anchor: Node) => void} */
          this.#props.pending
        );
        if (this.#main_effect !== null) {
          this.#offscreen_fragment = document.createDocumentFragment();
          this.#offscreen_fragment.append(
            /** @type {TemplateNode} */
            this.#pending_anchor
          );
          move_effect(this.#main_effect, this.#offscreen_fragment);
        }
        if (this.#pending_effect === null) {
          this.#pending_effect = branch(() => pending2(this.#anchor));
        }
      }
      /**
       * Updates the pending count associated with the currently visible pending snippet,
       * if any, such that we can replace the snippet with content once work is done
       * @param {1 | -1} d
       */
      #update_pending_count(d) {
        if (!this.has_pending_snippet()) {
          if (this.parent) {
            this.parent.#update_pending_count(d);
          }
          return;
        }
        this.#pending_count += d;
        if (this.#pending_count === 0) {
          this.is_pending = false;
          for (const e of this.#dirty_effects) {
            set_signal_status(e, DIRTY);
            schedule_effect(e);
          }
          for (const e of this.#maybe_dirty_effects) {
            set_signal_status(e, MAYBE_DIRTY);
            schedule_effect(e);
          }
          this.#dirty_effects.clear();
          this.#maybe_dirty_effects.clear();
          if (this.#pending_effect) {
            pause_effect(this.#pending_effect, () => {
              this.#pending_effect = null;
            });
          }
          if (this.#offscreen_fragment) {
            this.#anchor.before(this.#offscreen_fragment);
            this.#offscreen_fragment = null;
          }
        }
      }
      /**
       * Update the source that powers `$effect.pending()` inside this boundary,
       * and controls when the current `pending` snippet (if any) is removed.
       * Do not call from inside the class
       * @param {1 | -1} d
       */
      update_pending_count(d) {
        this.#update_pending_count(d);
        this.#local_pending_count += d;
        if (!this.#effect_pending || this.#pending_count_update_queued) return;
        this.#pending_count_update_queued = true;
        queue_micro_task(() => {
          this.#pending_count_update_queued = false;
          if (this.#effect_pending) {
            internal_set(this.#effect_pending, this.#local_pending_count);
          }
        });
      }
      get_effect_pending() {
        this.#effect_pending_subscriber();
        return get(
          /** @type {Source<number>} */
          this.#effect_pending
        );
      }
      /** @param {unknown} error */
      error(error) {
        var onerror = this.#props.onerror;
        let failed = this.#props.failed;
        if (this.#is_creating_fallback || !onerror && !failed) {
          throw error;
        }
        if (this.#main_effect) {
          destroy_effect(this.#main_effect);
          this.#main_effect = null;
        }
        if (this.#pending_effect) {
          destroy_effect(this.#pending_effect);
          this.#pending_effect = null;
        }
        if (this.#failed_effect) {
          destroy_effect(this.#failed_effect);
          this.#failed_effect = null;
        }
        if (hydrating) {
          set_hydrate_node(
            /** @type {TemplateNode} */
            this.#hydrate_open
          );
          next();
          set_hydrate_node(skip_nodes());
        }
        var did_reset = false;
        var calling_on_error = false;
        const reset2 = () => {
          if (did_reset) {
            svelte_boundary_reset_noop();
            return;
          }
          did_reset = true;
          if (calling_on_error) {
            svelte_boundary_reset_onerror();
          }
          Batch.ensure();
          this.#local_pending_count = 0;
          if (this.#failed_effect !== null) {
            pause_effect(this.#failed_effect, () => {
              this.#failed_effect = null;
            });
          }
          this.is_pending = this.has_pending_snippet();
          this.#main_effect = this.#run(() => {
            this.#is_creating_fallback = false;
            return branch(() => this.#children(this.#anchor));
          });
          if (this.#pending_count > 0) {
            this.#show_pending_snippet();
          } else {
            this.is_pending = false;
          }
        };
        var previous_reaction = active_reaction;
        try {
          set_active_reaction(null);
          calling_on_error = true;
          onerror?.(error, reset2);
          calling_on_error = false;
        } catch (error2) {
          invoke_error_boundary(error2, this.#effect && this.#effect.parent);
        } finally {
          set_active_reaction(previous_reaction);
        }
        if (failed) {
          queue_micro_task(() => {
            this.#failed_effect = this.#run(() => {
              Batch.ensure();
              this.#is_creating_fallback = true;
              try {
                return branch(() => {
                  failed(
                    this.#anchor,
                    () => error,
                    () => reset2
                  );
                });
              } catch (error2) {
                invoke_error_boundary(
                  error2,
                  /** @type {Effect} */
                  this.#effect.parent
                );
                return null;
              } finally {
                this.#is_creating_fallback = false;
              }
            });
          });
        }
      }
    };
  }
});

// node_modules/svelte/src/internal/client/reactivity/async.js
var init_async = __esm({
  "node_modules/svelte/src/internal/client/reactivity/async.js"() {
    init_constants3();
    init_esm_env();
    init_context();
    init_boundary();
    init_error_handling();
    init_runtime();
    init_batch();
    init_deriveds();
    init_effects();
  }
});

// node_modules/svelte/src/internal/client/reactivity/deriveds.js
function destroy_derived_effects(derived3) {
  var effects = derived3.effects;
  if (effects !== null) {
    derived3.effects = null;
    for (var i = 0; i < effects.length; i += 1) {
      destroy_effect(
        /** @type {Effect} */
        effects[i]
      );
    }
  }
}
function get_derived_parent_effect(derived3) {
  var parent = derived3.parent;
  while (parent !== null) {
    if ((parent.f & DERIVED) === 0) {
      return (parent.f & DESTROYED) === 0 ? (
        /** @type {Effect} */
        parent
      ) : null;
    }
    parent = parent.parent;
  }
  return null;
}
function execute_derived(derived3) {
  var value;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived3));
  if (dev_fallback_default) {
    let prev_eager_effects = eager_effects;
    set_eager_effects(/* @__PURE__ */ new Set());
    try {
      if (stack.includes(derived3)) {
        derived_references_self();
      }
      stack.push(derived3);
      derived3.f &= ~WAS_MARKED;
      destroy_derived_effects(derived3);
      value = update_reaction(derived3);
    } finally {
      set_active_effect(prev_active_effect);
      set_eager_effects(prev_eager_effects);
      stack.pop();
    }
  } else {
    try {
      derived3.f &= ~WAS_MARKED;
      destroy_derived_effects(derived3);
      value = update_reaction(derived3);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value;
}
function update_derived(derived3) {
  var value = execute_derived(derived3);
  if (!derived3.equals(value)) {
    derived3.wv = increment_write_version();
    if (!current_batch?.is_fork || derived3.deps === null) {
      derived3.v = value;
      if (derived3.deps === null) {
        set_signal_status(derived3, CLEAN);
        return;
      }
    }
  }
  if (is_destroying_effect) {
    return;
  }
  if (batch_values !== null) {
    if (effect_tracking() || current_batch?.is_fork) {
      batch_values.set(derived3, value);
    }
  } else {
    update_derived_status(derived3);
  }
}
var recent_async_deriveds, stack;
var init_deriveds = __esm({
  "node_modules/svelte/src/internal/client/reactivity/deriveds.js"() {
    init_esm_env();
    init_constants3();
    init_runtime();
    init_equality();
    init_errors2();
    init_warnings();
    init_effects();
    init_sources();
    init_dev();
    init_flags();
    init_boundary();
    init_context();
    init_constants2();
    init_batch();
    init_async();
    init_utils();
    init_status();
    recent_async_deriveds = /* @__PURE__ */ new Set();
    stack = [];
  }
});

// node_modules/svelte/src/internal/client/reactivity/sources.js
function set_eager_effects(v) {
  eager_effects = v;
}
function set_eager_effects_deferred() {
  eager_effects_deferred = true;
}
function source(v, stack2) {
  var signal = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v,
    reactions: null,
    equals,
    rv: 0,
    wv: 0
  };
  if (dev_fallback_default && tracing_mode_flag) {
    signal.created = stack2 ?? get_error("created at");
    signal.updated = null;
    signal.set_during_effect = false;
    signal.trace = null;
  }
  return signal;
}
// @__NO_SIDE_EFFECTS__
function state(v, stack2) {
  const s = source(v, stack2);
  push_reaction_value(s);
  return s;
}
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value, immutable = false, trackable = true) {
  const s = source(initial_value);
  if (!immutable) {
    s.equals = safe_equals;
  }
  if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
    (component_context.l.s ??= []).push(s);
  }
  return s;
}
function set(source2, value, should_proxy = false) {
  if (active_reaction !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!untracking || (active_reaction.f & EAGER_EFFECT) !== 0) && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | EAGER_EFFECT)) !== 0 && !current_sources?.includes(source2)) {
    state_unsafe_mutation();
  }
  let new_value = should_proxy ? proxy(value) : value;
  if (dev_fallback_default) {
    tag_proxy(
      new_value,
      /** @type {string} */
      source2.label
    );
  }
  return internal_set(source2, new_value);
}
function internal_set(source2, value) {
  if (!source2.equals(value)) {
    var old_value = source2.v;
    if (is_destroying_effect) {
      old_values.set(source2, value);
    } else {
      old_values.set(source2, old_value);
    }
    source2.v = value;
    var batch = Batch.ensure();
    batch.capture(source2, old_value);
    if (dev_fallback_default) {
      if (tracing_mode_flag || active_effect !== null) {
        source2.updated ??= /* @__PURE__ */ new Map();
        const count = (source2.updated.get("")?.count ?? 0) + 1;
        source2.updated.set("", { error: (
          /** @type {any} */
          null
        ), count });
        if (tracing_mode_flag || count > 5) {
          const error = get_error("updated at");
          if (error !== null) {
            let entry = source2.updated.get(error.stack);
            if (!entry) {
              entry = { error, count: 0 };
              source2.updated.set(error.stack, entry);
            }
            entry.count++;
          }
        }
      }
      if (active_effect !== null) {
        source2.set_during_effect = true;
      }
    }
    if ((source2.f & DERIVED) !== 0) {
      const derived3 = (
        /** @type {Derived} */
        source2
      );
      if ((source2.f & DIRTY) !== 0) {
        execute_derived(derived3);
      }
      update_derived_status(derived3);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      if (untracked_writes === null) {
        set_untracked_writes([source2]);
      } else {
        untracked_writes.push(source2);
      }
    }
    if (!batch.is_fork && eager_effects.size > 0 && !eager_effects_deferred) {
      flush_eager_effects();
    }
  }
  return value;
}
function flush_eager_effects() {
  eager_effects_deferred = false;
  for (const effect2 of eager_effects) {
    if ((effect2.f & CLEAN) !== 0) {
      set_signal_status(effect2, MAYBE_DIRTY);
    }
    if (is_dirty(effect2)) {
      update_effect(effect2);
    }
  }
  eager_effects.clear();
}
function increment(source2) {
  set(source2, source2.v + 1);
}
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  var runes = is_runes();
  var length = reactions.length;
  for (var i = 0; i < length; i++) {
    var reaction = reactions[i];
    var flags2 = reaction.f;
    if (!runes && reaction === active_effect) continue;
    if (dev_fallback_default && (flags2 & EAGER_EFFECT) !== 0) {
      eager_effects.add(reaction);
      continue;
    }
    var not_dirty = (flags2 & DIRTY) === 0;
    if (not_dirty) {
      set_signal_status(reaction, status);
    }
    if ((flags2 & DERIVED) !== 0) {
      var derived3 = (
        /** @type {Derived} */
        reaction
      );
      batch_values?.delete(derived3);
      if ((flags2 & WAS_MARKED) === 0) {
        if (flags2 & CONNECTED) {
          reaction.f |= WAS_MARKED;
        }
        mark_reactions(derived3, MAYBE_DIRTY);
      }
    } else if (not_dirty) {
      if ((flags2 & BLOCK_EFFECT) !== 0 && eager_block_effects !== null) {
        eager_block_effects.add(
          /** @type {Effect} */
          reaction
        );
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
var eager_effects, old_values, eager_effects_deferred;
var init_sources = __esm({
  "node_modules/svelte/src/internal/client/reactivity/sources.js"() {
    init_esm_env();
    init_runtime();
    init_equality();
    init_constants3();
    init_errors2();
    init_flags();
    init_tracing();
    init_dev();
    init_context();
    init_batch();
    init_proxy();
    init_deriveds();
    init_status();
    eager_effects = /* @__PURE__ */ new Set();
    old_values = /* @__PURE__ */ new Map();
    eager_effects_deferred = false;
  }
});

// node_modules/svelte/src/internal/client/proxy.js
function proxy(value) {
  if (typeof value !== "object" || value === null || STATE_SYMBOL in value) {
    return value;
  }
  const prototype3 = get_prototype_of(value);
  if (prototype3 !== object_prototype && prototype3 !== array_prototype) {
    return value;
  }
  var sources = /* @__PURE__ */ new Map();
  var is_proxied_array = is_array(value);
  var version3 = state(0);
  var stack2 = dev_fallback_default && tracing_mode_flag ? get_error("created at") : null;
  var parent_version = update_version;
  var with_parent = (fn) => {
    if (update_version === parent_version) {
      return fn();
    }
    var reaction = active_reaction;
    var version4 = update_version;
    set_active_reaction(null);
    set_update_version(parent_version);
    var result = fn();
    set_active_reaction(reaction);
    set_update_version(version4);
    return result;
  };
  if (is_proxied_array) {
    sources.set("length", state(
      /** @type {any[]} */
      value.length,
      stack2
    ));
    if (dev_fallback_default) {
      value = /** @type {any} */
      inspectable_array(
        /** @type {any[]} */
        value
      );
    }
  }
  var path3 = "";
  let updating = false;
  function update_path(new_path) {
    if (updating) return;
    updating = true;
    path3 = new_path;
    tag(version3, `${path3} version`);
    for (const [prop2, source2] of sources) {
      tag(source2, get_label(path3, prop2));
    }
    updating = false;
  }
  return new Proxy(
    /** @type {any} */
    value,
    {
      defineProperty(_, prop2, descriptor) {
        if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
          state_descriptors_fixed();
        }
        var s = sources.get(prop2);
        if (s === void 0) {
          s = with_parent(() => {
            var s2 = state(descriptor.value, stack2);
            sources.set(prop2, s2);
            if (dev_fallback_default && typeof prop2 === "string") {
              tag(s2, get_label(path3, prop2));
            }
            return s2;
          });
        } else {
          set(s, descriptor.value, true);
        }
        return true;
      },
      deleteProperty(target, prop2) {
        var s = sources.get(prop2);
        if (s === void 0) {
          if (prop2 in target) {
            const s2 = with_parent(() => state(UNINITIALIZED, stack2));
            sources.set(prop2, s2);
            increment(version3);
            if (dev_fallback_default) {
              tag(s2, get_label(path3, prop2));
            }
          }
        } else {
          set(s, UNINITIALIZED);
          increment(version3);
        }
        return true;
      },
      get(target, prop2, receiver) {
        if (prop2 === STATE_SYMBOL) {
          return value;
        }
        if (dev_fallback_default && prop2 === PROXY_PATH_SYMBOL) {
          return update_path;
        }
        var s = sources.get(prop2);
        var exists = prop2 in target;
        if (s === void 0 && (!exists || get_descriptor(target, prop2)?.writable)) {
          s = with_parent(() => {
            var p = proxy(exists ? target[prop2] : UNINITIALIZED);
            var s2 = state(p, stack2);
            if (dev_fallback_default) {
              tag(s2, get_label(path3, prop2));
            }
            return s2;
          });
          sources.set(prop2, s);
        }
        if (s !== void 0) {
          var v = get(s);
          return v === UNINITIALIZED ? void 0 : v;
        }
        return Reflect.get(target, prop2, receiver);
      },
      getOwnPropertyDescriptor(target, prop2) {
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor && "value" in descriptor) {
          var s = sources.get(prop2);
          if (s) descriptor.value = get(s);
        } else if (descriptor === void 0) {
          var source2 = sources.get(prop2);
          var value2 = source2?.v;
          if (source2 !== void 0 && value2 !== UNINITIALIZED) {
            return {
              enumerable: true,
              configurable: true,
              value: value2,
              writable: true
            };
          }
        }
        return descriptor;
      },
      has(target, prop2) {
        if (prop2 === STATE_SYMBOL) {
          return true;
        }
        var s = sources.get(prop2);
        var has = s !== void 0 && s.v !== UNINITIALIZED || Reflect.has(target, prop2);
        if (s !== void 0 || active_effect !== null && (!has || get_descriptor(target, prop2)?.writable)) {
          if (s === void 0) {
            s = with_parent(() => {
              var p = has ? proxy(target[prop2]) : UNINITIALIZED;
              var s2 = state(p, stack2);
              if (dev_fallback_default) {
                tag(s2, get_label(path3, prop2));
              }
              return s2;
            });
            sources.set(prop2, s);
          }
          var value2 = get(s);
          if (value2 === UNINITIALIZED) {
            return false;
          }
        }
        return has;
      },
      set(target, prop2, value2, receiver) {
        var s = sources.get(prop2);
        var has = prop2 in target;
        if (is_proxied_array && prop2 === "length") {
          for (var i = value2; i < /** @type {Source<number>} */
          s.v; i += 1) {
            var other_s = sources.get(i + "");
            if (other_s !== void 0) {
              set(other_s, UNINITIALIZED);
            } else if (i in target) {
              other_s = with_parent(() => state(UNINITIALIZED, stack2));
              sources.set(i + "", other_s);
              if (dev_fallback_default) {
                tag(other_s, get_label(path3, i));
              }
            }
          }
        }
        if (s === void 0) {
          if (!has || get_descriptor(target, prop2)?.writable) {
            s = with_parent(() => state(void 0, stack2));
            if (dev_fallback_default) {
              tag(s, get_label(path3, prop2));
            }
            set(s, proxy(value2));
            sources.set(prop2, s);
          }
        } else {
          has = s.v !== UNINITIALIZED;
          var p = with_parent(() => proxy(value2));
          set(s, p);
        }
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor?.set) {
          descriptor.set.call(receiver, value2);
        }
        if (!has) {
          if (is_proxied_array && typeof prop2 === "string") {
            var ls = (
              /** @type {Source<number>} */
              sources.get("length")
            );
            var n = Number(prop2);
            if (Number.isInteger(n) && n >= ls.v) {
              set(ls, n + 1);
            }
          }
          increment(version3);
        }
        return true;
      },
      ownKeys(target) {
        get(version3);
        var own_keys = Reflect.ownKeys(target).filter((key3) => {
          var source3 = sources.get(key3);
          return source3 === void 0 || source3.v !== UNINITIALIZED;
        });
        for (var [key2, source2] of sources) {
          if (source2.v !== UNINITIALIZED && !(key2 in target)) {
            own_keys.push(key2);
          }
        }
        return own_keys;
      },
      setPrototypeOf() {
        state_prototype_fixed();
      }
    }
  );
}
function get_label(path3, prop2) {
  if (typeof prop2 === "symbol") return `${path3}[Symbol(${prop2.description ?? ""})]`;
  if (regex_is_valid_identifier.test(prop2)) return `${path3}.${prop2}`;
  return /^\d+$/.test(prop2) ? `${path3}[${prop2}]` : `${path3}['${prop2}']`;
}
function get_proxied_value(value) {
  try {
    if (value !== null && typeof value === "object" && STATE_SYMBOL in value) {
      return value[STATE_SYMBOL];
    }
  } catch {
  }
  return value;
}
function inspectable_array(array) {
  return new Proxy(array, {
    get(target, prop2, receiver) {
      var value = Reflect.get(target, prop2, receiver);
      if (!ARRAY_MUTATING_METHODS.has(
        /** @type {string} */
        prop2
      )) {
        return value;
      }
      return function(...args) {
        set_eager_effects_deferred();
        var result = value.apply(this, args);
        flush_eager_effects();
        return result;
      };
    }
  });
}
var regex_is_valid_identifier, ARRAY_MUTATING_METHODS;
var init_proxy = __esm({
  "node_modules/svelte/src/internal/client/proxy.js"() {
    init_esm_env();
    init_runtime();
    init_utils();
    init_sources();
    init_constants3();
    init_constants2();
    init_errors2();
    init_tracing();
    init_dev();
    init_flags();
    regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
    ARRAY_MUTATING_METHODS = /* @__PURE__ */ new Set([
      "copyWithin",
      "fill",
      "pop",
      "push",
      "reverse",
      "shift",
      "sort",
      "splice",
      "unshift"
    ]);
  }
});

// node_modules/svelte/src/internal/client/dev/equality.js
function init_array_prototype_warnings() {
  const array_prototype2 = Array.prototype;
  const cleanup = Array.__svelte_cleanup;
  if (cleanup) {
    cleanup();
  }
  const { indexOf, lastIndexOf, includes } = array_prototype2;
  array_prototype2.indexOf = function(item, from_index) {
    const index2 = indexOf.call(this, item, from_index);
    if (index2 === -1) {
      for (let i = from_index ?? 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.indexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.lastIndexOf = function(item, from_index) {
    const index2 = lastIndexOf.call(this, item, from_index ?? this.length - 1);
    if (index2 === -1) {
      for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.lastIndexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.includes = function(item, from_index) {
    const has = includes.call(this, item, from_index);
    if (!has) {
      for (let i = 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.includes(...)");
          break;
        }
      }
    }
    return has;
  };
  Array.__svelte_cleanup = () => {
    array_prototype2.indexOf = indexOf;
    array_prototype2.lastIndexOf = lastIndexOf;
    array_prototype2.includes = includes;
  };
}
var init_equality2 = __esm({
  "node_modules/svelte/src/internal/client/dev/equality.js"() {
    init_warnings();
    init_proxy();
  }
});

// node_modules/svelte/src/internal/client/dom/operations.js
function init_operations2() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  $document = document;
  is_firefox = /Firefox/.test(navigator.userAgent);
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  var text_prototype = Text.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  if (is_extensible(element_prototype)) {
    element_prototype.__click = void 0;
    element_prototype.__className = void 0;
    element_prototype.__attributes = null;
    element_prototype.__style = void 0;
    element_prototype.__e = void 0;
  }
  if (is_extensible(text_prototype)) {
    text_prototype.__t = void 0;
  }
  if (dev_fallback_default) {
    element_prototype.__svelte_meta = null;
    init_array_prototype_warnings();
  }
}
function create_text(value = "") {
  return document.createTextNode(value);
}
// @__NO_SIDE_EFFECTS__
function get_first_child(node) {
  return (
    /** @type {TemplateNode | null} */
    first_child_getter.call(node)
  );
}
// @__NO_SIDE_EFFECTS__
function get_next_sibling(node) {
  return (
    /** @type {TemplateNode | null} */
    next_sibling_getter.call(node)
  );
}
function clear_text_content(node) {
  node.textContent = "";
}
var $window, $document, is_firefox, first_child_getter, next_sibling_getter;
var init_operations = __esm({
  "node_modules/svelte/src/internal/client/dom/operations.js"() {
    init_hydration();
    init_esm_env();
    init_equality2();
    init_utils();
    init_runtime();
    init_flags();
    init_constants3();
    init_batch();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/misc.js
var init_misc = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/misc.js"() {
    init_hydration();
    init_operations();
    init_task();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js
function without_reactive_context(fn) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    return fn();
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
var init_shared = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js"() {
    init_effects();
    init_runtime();
    init_misc();
  }
});

// node_modules/svelte/src/internal/client/reactivity/effects.js
function push_effect(effect2, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect2;
  } else {
    parent_last.next = effect2;
    effect2.prev = parent_last;
    parent_effect.last = effect2;
  }
}
function create_effect(type2, fn, sync) {
  var parent = active_effect;
  if (dev_fallback_default) {
    while (parent !== null && (parent.f & EAGER_EFFECT) !== 0) {
      parent = parent.parent;
    }
  }
  if (parent !== null && (parent.f & INERT) !== 0) {
    type2 |= INERT;
  }
  var effect2 = {
    ctx: component_context,
    deps: null,
    nodes: null,
    f: type2 | DIRTY | CONNECTED,
    first: null,
    fn,
    last: null,
    next: null,
    parent,
    b: parent && parent.b,
    prev: null,
    teardown: null,
    wv: 0,
    ac: null
  };
  if (dev_fallback_default) {
    effect2.component_function = dev_current_component_function;
  }
  if (sync) {
    try {
      update_effect(effect2);
      effect2.f |= EFFECT_RAN;
    } catch (e2) {
      destroy_effect(effect2);
      throw e2;
    }
  } else if (fn !== null) {
    schedule_effect(effect2);
  }
  var e = effect2;
  if (sync && e.deps === null && e.teardown === null && e.nodes === null && e.first === e.last && // either `null`, or a singular child
  (e.f & EFFECT_PRESERVED) === 0) {
    e = e.first;
    if ((type2 & BLOCK_EFFECT) !== 0 && (type2 & EFFECT_TRANSPARENT) !== 0 && e !== null) {
      e.f |= EFFECT_TRANSPARENT;
    }
  }
  if (e !== null) {
    e.parent = parent;
    if (parent !== null) {
      push_effect(e, parent);
    }
    if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0 && (type2 & ROOT_EFFECT) === 0) {
      var derived3 = (
        /** @type {Derived} */
        active_reaction
      );
      (derived3.effects ??= []).push(e);
    }
  }
  return effect2;
}
function effect_tracking() {
  return active_reaction !== null && !untracking;
}
function create_user_effect(fn) {
  return create_effect(EFFECT | USER_EFFECT, fn, false);
}
function effect_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return () => {
    destroy_effect(effect2);
  };
}
function component_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return (options = {}) => {
    return new Promise((fulfil) => {
      if (options.outro) {
        pause_effect(effect2, () => {
          destroy_effect(effect2);
          fulfil(void 0);
        });
      } else {
        destroy_effect(effect2);
        fulfil(void 0);
      }
    });
  };
}
function render_effect(fn, flags2 = 0) {
  return create_effect(RENDER_EFFECT | flags2, fn, true);
}
function block(fn, flags2 = 0) {
  var effect2 = create_effect(BLOCK_EFFECT | flags2, fn, true);
  if (dev_fallback_default) {
    effect2.dev_stack = dev_stack;
  }
  return effect2;
}
function branch(fn) {
  return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true);
}
function execute_effect_teardown(effect2) {
  var teardown2 = effect2.teardown;
  if (teardown2 !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown2.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
function destroy_effect_children(signal, remove_dom = false) {
  var effect2 = signal.first;
  signal.first = signal.last = null;
  while (effect2 !== null) {
    const controller = effect2.ac;
    if (controller !== null) {
      without_reactive_context(() => {
        controller.abort(STALE_REACTION);
      });
    }
    var next2 = effect2.next;
    if ((effect2.f & ROOT_EFFECT) !== 0) {
      effect2.parent = null;
    } else {
      destroy_effect(effect2, remove_dom);
    }
    effect2 = next2;
  }
}
function destroy_block_effect_children(signal) {
  var effect2 = signal.first;
  while (effect2 !== null) {
    var next2 = effect2.next;
    if ((effect2.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect2);
    }
    effect2 = next2;
  }
}
function destroy_effect(effect2, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect2.f & HEAD_EFFECT) !== 0) && effect2.nodes !== null && effect2.nodes.end !== null) {
    remove_effect_dom(
      effect2.nodes.start,
      /** @type {TemplateNode} */
      effect2.nodes.end
    );
    removed = true;
  }
  destroy_effect_children(effect2, remove_dom && !removed);
  remove_reactions(effect2, 0);
  set_signal_status(effect2, DESTROYED);
  var transitions = effect2.nodes && effect2.nodes.t;
  if (transitions !== null) {
    for (const transition2 of transitions) {
      transition2.stop();
    }
  }
  execute_effect_teardown(effect2);
  var parent = effect2.parent;
  if (parent !== null && parent.first !== null) {
    unlink_effect(effect2);
  }
  if (dev_fallback_default) {
    effect2.component_function = null;
  }
  effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.fn = effect2.nodes = effect2.ac = null;
}
function remove_effect_dom(node, end) {
  while (node !== null) {
    var next2 = node === end ? null : get_next_sibling(node);
    node.remove();
    node = next2;
  }
}
function unlink_effect(effect2) {
  var parent = effect2.parent;
  var prev = effect2.prev;
  var next2 = effect2.next;
  if (prev !== null) prev.next = next2;
  if (next2 !== null) next2.prev = prev;
  if (parent !== null) {
    if (parent.first === effect2) parent.first = next2;
    if (parent.last === effect2) parent.last = prev;
  }
}
function pause_effect(effect2, callback, destroy = true) {
  var transitions = [];
  pause_children(effect2, transitions, true);
  var fn = () => {
    if (destroy) destroy_effect(effect2);
    if (callback) callback();
  };
  var remaining = transitions.length;
  if (remaining > 0) {
    var check = () => --remaining || fn();
    for (var transition2 of transitions) {
      transition2.out(check);
    }
  } else {
    fn();
  }
}
function pause_children(effect2, transitions, local) {
  if ((effect2.f & INERT) !== 0) return;
  effect2.f ^= INERT;
  var t = effect2.nodes && effect2.nodes.t;
  if (t !== null) {
    for (const transition2 of t) {
      if (transition2.is_global || local) {
        transitions.push(transition2);
      }
    }
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || // If this is a branch effect without a block effect parent,
    // it means the parent block effect was pruned. In that case,
    // transparency information was transferred to the branch effect.
    (child2.f & BRANCH_EFFECT) !== 0 && (effect2.f & BLOCK_EFFECT) !== 0;
    pause_children(child2, transitions, transparent ? local : false);
    child2 = sibling2;
  }
}
function move_effect(effect2, fragment) {
  if (!effect2.nodes) return;
  var node = effect2.nodes.start;
  var end = effect2.nodes.end;
  while (node !== null) {
    var next2 = node === end ? null : get_next_sibling(node);
    fragment.append(node);
    node = next2;
  }
}
var init_effects = __esm({
  "node_modules/svelte/src/internal/client/reactivity/effects.js"() {
    init_runtime();
    init_constants3();
    init_errors2();
    init_esm_env();
    init_utils();
    init_operations();
    init_context();
    init_batch();
    init_async();
    init_shared();
    init_status();
  }
});

// node_modules/svelte/src/internal/client/legacy.js
var captured_signals;
var init_legacy = __esm({
  "node_modules/svelte/src/internal/client/legacy.js"() {
    init_sources();
    init_runtime();
    captured_signals = null;
  }
});

// node_modules/svelte/src/internal/client/runtime.js
function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
function set_active_effect(effect2) {
  active_effect = effect2;
}
function push_reaction_value(value) {
  if (active_reaction !== null && (!async_mode_flag || (active_reaction.f & DERIVED) !== 0)) {
    if (current_sources === null) {
      current_sources = [value];
    } else {
      current_sources.push(value);
    }
  }
}
function set_untracked_writes(value) {
  untracked_writes = value;
}
function set_update_version(value) {
  update_version = value;
}
function increment_write_version() {
  return ++write_version;
}
function is_dirty(reaction) {
  var flags2 = reaction.f;
  if ((flags2 & DIRTY) !== 0) {
    return true;
  }
  if (flags2 & DERIVED) {
    reaction.f &= ~WAS_MARKED;
  }
  if ((flags2 & MAYBE_DIRTY) !== 0) {
    var dependencies = (
      /** @type {Value[]} */
      reaction.deps
    );
    var length = dependencies.length;
    for (var i = 0; i < length; i++) {
      var dependency = dependencies[i];
      if (is_dirty(
        /** @type {Derived} */
        dependency
      )) {
        update_derived(
          /** @type {Derived} */
          dependency
        );
      }
      if (dependency.wv > reaction.wv) {
        return true;
      }
    }
    if ((flags2 & CONNECTED) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    batch_values === null) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
function schedule_possible_effect_self_invalidation(signal, effect2, root = true) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  if (!async_mode_flag && current_sources?.includes(signal)) {
    return;
  }
  for (var i = 0; i < reactions.length; i++) {
    var reaction = reactions[i];
    if ((reaction.f & DERIVED) !== 0) {
      schedule_possible_effect_self_invalidation(
        /** @type {Derived} */
        reaction,
        effect2,
        false
      );
    } else if (effect2 === reaction) {
      if (root) {
        set_signal_status(reaction, DIRTY);
      } else if ((reaction.f & CLEAN) !== 0) {
        set_signal_status(reaction, MAYBE_DIRTY);
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
function update_reaction(reaction) {
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_sources = current_sources;
  var previous_component_context = component_context;
  var previous_untracking = untracking;
  var previous_update_version = update_version;
  var flags2 = reaction.f;
  new_deps = /** @type {null | Value[]} */
  null;
  skipped_deps = 0;
  untracked_writes = null;
  active_reaction = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  current_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  update_version = ++read_version;
  if (reaction.ac !== null) {
    without_reactive_context(() => {
      reaction.ac.abort(STALE_REACTION);
    });
    reaction.ac = null;
  }
  try {
    reaction.f |= REACTION_IS_UPDATING;
    var fn = (
      /** @type {Function} */
      reaction.fn
    );
    var result = fn();
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i = 0; i < new_deps.length; i++) {
          deps[skipped_deps + i] = new_deps[i];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (effect_tracking() && (reaction.f & CONNECTED) !== 0) {
        for (i = skipped_deps; i < deps.length; i++) {
          (deps[i].reactions ??= []).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
      for (i = 0; i < /** @type {Source[]} */
      untracked_writes.length; i++) {
        schedule_possible_effect_self_invalidation(
          untracked_writes[i],
          /** @type {Effect} */
          reaction
        );
      }
    }
    if (previous_reaction !== null && previous_reaction !== reaction) {
      read_version++;
      if (previous_reaction.deps !== null) {
        for (let i2 = 0; i2 < previous_skipped_deps; i2 += 1) {
          previous_reaction.deps[i2].rv = read_version;
        }
      }
      if (previous_deps !== null) {
        for (const dep of previous_deps) {
          dep.rv = read_version;
        }
      }
      if (untracked_writes !== null) {
        if (previous_untracked_writes === null) {
          previous_untracked_writes = untracked_writes;
        } else {
          previous_untracked_writes.push(.../** @type {Source[]} */
          untracked_writes);
        }
      }
    }
    if ((reaction.f & ERROR_VALUE) !== 0) {
      reaction.f ^= ERROR_VALUE;
    }
    return result;
  } catch (error) {
    return handle_error(error);
  } finally {
    reaction.f ^= REACTION_IS_UPDATING;
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    current_sources = previous_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    update_version = previous_update_version;
  }
}
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index2 = index_of.call(reactions, signal);
    if (index2 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index2] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !new_deps.includes(dependency))) {
    var derived3 = (
      /** @type {Derived} */
      dependency
    );
    if ((derived3.f & CONNECTED) !== 0) {
      derived3.f ^= CONNECTED;
      derived3.f &= ~WAS_MARKED;
    }
    update_derived_status(derived3);
    destroy_derived_effects(derived3);
    remove_reactions(derived3, 0);
  }
}
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null) return;
  for (var i = start_index; i < dependencies.length; i++) {
    remove_reaction(signal, dependencies[i]);
  }
}
function update_effect(effect2) {
  var flags2 = effect2.f;
  if ((flags2 & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect2, CLEAN);
  var previous_effect = active_effect;
  var was_updating_effect = is_updating_effect;
  active_effect = effect2;
  is_updating_effect = true;
  if (dev_fallback_default) {
    var previous_component_fn = dev_current_component_function;
    set_dev_current_component_function(effect2.component_function);
    var previous_stack = (
      /** @type {any} */
      dev_stack
    );
    set_dev_stack(effect2.dev_stack ?? dev_stack);
  }
  try {
    if ((flags2 & (BLOCK_EFFECT | MANAGED_EFFECT)) !== 0) {
      destroy_block_effect_children(effect2);
    } else {
      destroy_effect_children(effect2);
    }
    execute_effect_teardown(effect2);
    var teardown2 = update_reaction(effect2);
    effect2.teardown = typeof teardown2 === "function" ? teardown2 : null;
    effect2.wv = write_version;
    if (dev_fallback_default && tracing_mode_flag && (effect2.f & DIRTY) !== 0 && effect2.deps !== null) {
      for (var dep of effect2.deps) {
        if (dep.set_during_effect) {
          dep.wv = increment_write_version();
          dep.set_during_effect = false;
        }
      }
    }
  } finally {
    is_updating_effect = was_updating_effect;
    active_effect = previous_effect;
    if (dev_fallback_default) {
      set_dev_current_component_function(previous_component_fn);
      set_dev_stack(previous_stack);
    }
  }
}
function get(signal) {
  var flags2 = signal.f;
  var is_derived = (flags2 & DERIVED) !== 0;
  captured_signals?.add(signal);
  if (active_reaction !== null && !untracking) {
    var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;
    if (!destroyed && !current_sources?.includes(signal)) {
      var deps = active_reaction.deps;
      if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
        if (signal.rv < read_version) {
          signal.rv = read_version;
          if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
            skipped_deps++;
          } else if (new_deps === null) {
            new_deps = [signal];
          } else {
            new_deps.push(signal);
          }
        }
      } else {
        (active_reaction.deps ??= []).push(signal);
        var reactions = signal.reactions;
        if (reactions === null) {
          signal.reactions = [active_reaction];
        } else if (!reactions.includes(active_reaction)) {
          reactions.push(active_reaction);
        }
      }
    }
  }
  if (dev_fallback_default) {
    recent_async_deriveds.delete(signal);
    if (tracing_mode_flag && !untracking && tracing_expressions !== null && active_reaction !== null && tracing_expressions.reaction === active_reaction) {
      if (signal.trace) {
        signal.trace();
      } else {
        var trace2 = get_error("traced at");
        if (trace2) {
          var entry = tracing_expressions.entries.get(signal);
          if (entry === void 0) {
            entry = { traces: [] };
            tracing_expressions.entries.set(signal, entry);
          }
          var last = entry.traces[entry.traces.length - 1];
          if (trace2.stack !== last?.stack) {
            entry.traces.push(trace2);
          }
        }
      }
    }
  }
  if (is_destroying_effect && old_values.has(signal)) {
    return old_values.get(signal);
  }
  if (is_derived) {
    var derived3 = (
      /** @type {Derived} */
      signal
    );
    if (is_destroying_effect) {
      var value = derived3.v;
      if ((derived3.f & CLEAN) === 0 && derived3.reactions !== null || depends_on_old_values(derived3)) {
        value = execute_derived(derived3);
      }
      old_values.set(derived3, value);
      return value;
    }
    var should_connect = (derived3.f & CONNECTED) === 0 && !untracking && active_reaction !== null && (is_updating_effect || (active_reaction.f & CONNECTED) !== 0);
    var is_new = derived3.deps === null;
    if (is_dirty(derived3)) {
      if (should_connect) {
        derived3.f |= CONNECTED;
      }
      update_derived(derived3);
    }
    if (should_connect && !is_new) {
      reconnect(derived3);
    }
  }
  if (batch_values?.has(signal)) {
    return batch_values.get(signal);
  }
  if ((signal.f & ERROR_VALUE) !== 0) {
    throw signal.v;
  }
  return signal.v;
}
function reconnect(derived3) {
  if (derived3.deps === null) return;
  derived3.f |= CONNECTED;
  for (const dep of derived3.deps) {
    (dep.reactions ??= []).push(derived3);
    if ((dep.f & DERIVED) !== 0 && (dep.f & CONNECTED) === 0) {
      reconnect(
        /** @type {Derived} */
        dep
      );
    }
  }
}
function depends_on_old_values(derived3) {
  if (derived3.v === UNINITIALIZED) return true;
  if (derived3.deps === null) return false;
  for (const dep of derived3.deps) {
    if (old_values.has(dep)) {
      return true;
    }
    if ((dep.f & DERIVED) !== 0 && depends_on_old_values(
      /** @type {Derived} */
      dep
    )) {
      return true;
    }
  }
  return false;
}
function untrack(fn) {
  var previous_untracking = untracking;
  try {
    untracking = true;
    return fn();
  } finally {
    untracking = previous_untracking;
  }
}
var is_updating_effect, is_destroying_effect, active_reaction, untracking, active_effect, current_sources, new_deps, skipped_deps, untracked_writes, write_version, read_version, update_version;
var init_runtime = __esm({
  "node_modules/svelte/src/internal/client/runtime.js"() {
    init_esm_env();
    init_utils();
    init_effects();
    init_constants3();
    init_sources();
    init_deriveds();
    init_flags();
    init_tracing();
    init_dev();
    init_context();
    init_batch();
    init_error_handling();
    init_constants2();
    init_legacy();
    init_shared();
    init_status();
    is_updating_effect = false;
    is_destroying_effect = false;
    active_reaction = null;
    untracking = false;
    active_effect = null;
    current_sources = null;
    new_deps = null;
    skipped_deps = 0;
    untracked_writes = null;
    write_version = 1;
    read_version = 0;
    update_version = read_version;
  }
});

// node_modules/svelte/src/internal/client/hydratable.js
var init_hydratable = __esm({
  "node_modules/svelte/src/internal/client/hydratable.js"() {
    init_flags();
    init_hydration();
    init_warnings();
    init_errors2();
    init_esm_env();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/events.js
function handle_event_propagation(event2) {
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event2.type;
  var path3 = event2.composedPath?.() || [];
  var current_target = (
    /** @type {null | Element} */
    path3[0] || event2.target
  );
  last_propagated_event = event2;
  var path_idx = 0;
  var handled_at = last_propagated_event === event2 && event2.__root;
  if (handled_at) {
    var at_idx = path3.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event2.__root = handler_element;
      return;
    }
    var handler_idx = path3.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path3[path_idx] || event2.target;
  if (current_target === handler_element) return;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated != null && (!/** @type {any} */
        current_target.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
        // -> the target could not have been disabled because it emits the event in the first place
        event2.target === current_target)) {
          delegated.call(current_target, event2);
        }
      } catch (error) {
        if (throw_error) {
          other_errors.push(error);
        } else {
          throw_error = error;
        }
      }
      if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error of other_errors) {
        queueMicrotask(() => {
          throw error;
        });
      }
      throw throw_error;
    }
  } finally {
    event2.__root = handler_element;
    delete event2.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
var all_registered_events, root_event_handles, last_propagated_event;
var init_events = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/events.js"() {
    init_effects();
    init_utils();
    init_hydration();
    init_task();
    init_constants2();
    init_warnings();
    init_runtime();
    init_shared();
    all_registered_events = /* @__PURE__ */ new Set();
    root_event_handles = /* @__PURE__ */ new Set();
    last_propagated_event = null;
  }
});

// node_modules/svelte/src/internal/client/dom/reconciler.js
var init_reconciler = __esm({
  "node_modules/svelte/src/internal/client/dom/reconciler.js"() {
  }
});

// node_modules/svelte/src/internal/client/dom/template.js
function assign_nodes(start, end) {
  var effect2 = (
    /** @type {Effect} */
    active_effect
  );
  if (effect2.nodes === null) {
    effect2.nodes = { start, end, a: null, t: null };
  }
}
function append(anchor, dom) {
  if (hydrating) {
    var effect2 = (
      /** @type {Effect & { nodes: EffectNodes }} */
      active_effect
    );
    if ((effect2.f & EFFECT_RAN) === 0 || effect2.nodes.end === null) {
      effect2.nodes.end = hydrate_node;
    }
    hydrate_next();
    return;
  }
  if (anchor === null) {
    return;
  }
  anchor.before(
    /** @type {Node} */
    dom
  );
}
var init_template = __esm({
  "node_modules/svelte/src/internal/client/dom/template.js"() {
    init_hydration();
    init_operations();
    init_reconciler();
    init_runtime();
    init_constants2();
    init_constants3();
  }
});

// node_modules/svelte/src/utils.js
function is_passive_event(name3) {
  return PASSIVE_EVENTS.includes(name3);
}
var DOM_BOOLEAN_ATTRIBUTES, DOM_PROPERTIES, PASSIVE_EVENTS, STATE_CREATION_RUNES, RUNES;
var init_utils3 = __esm({
  "node_modules/svelte/src/utils.js"() {
    DOM_BOOLEAN_ATTRIBUTES = [
      "allowfullscreen",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "disabled",
      "formnovalidate",
      "indeterminate",
      "inert",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "seamless",
      "selected",
      "webkitdirectory",
      "defer",
      "disablepictureinpicture",
      "disableremoteplayback"
    ];
    DOM_PROPERTIES = [
      ...DOM_BOOLEAN_ATTRIBUTES,
      "formNoValidate",
      "isMap",
      "noModule",
      "playsInline",
      "readOnly",
      "value",
      "volume",
      "defaultValue",
      "defaultChecked",
      "srcObject",
      "noValidate",
      "allowFullscreen",
      "disablePictureInPicture",
      "disableRemotePlayback"
    ];
    PASSIVE_EVENTS = ["touchstart", "touchmove"];
    STATE_CREATION_RUNES = /** @type {const} */
    [
      "$state",
      "$state.raw",
      "$derived",
      "$derived.by"
    ];
    RUNES = /** @type {const} */
    [
      ...STATE_CREATION_RUNES,
      "$state.eager",
      "$state.snapshot",
      "$props",
      "$props.id",
      "$bindable",
      "$effect",
      "$effect.pre",
      "$effect.tracking",
      "$effect.root",
      "$effect.pending",
      "$inspect",
      "$inspect().with",
      "$inspect.trace",
      "$host"
    ];
  }
});

// node_modules/svelte/src/internal/client/render.js
function mount(component2, options) {
  return _mount(component2, options);
}
function hydrate(component2, options) {
  init_operations2();
  options.intro = options.intro ?? false;
  const target = options.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor = get_first_child(target);
    while (anchor && (anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    anchor.data !== HYDRATION_START)) {
      anchor = get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(
      /** @type {Comment} */
      anchor
    );
    const instance = _mount(component2, { ...options, anchor });
    set_hydrating(false);
    return (
      /**  @type {Exports} */
      instance
    );
  } catch (error) {
    if (error instanceof Error && error.message.split("\n").some((line) => line.startsWith("https://svelte.dev/e/"))) {
      throw error;
    }
    if (error !== HYDRATION_ERROR) {
      console.warn("Failed to hydrate: ", error);
    }
    if (options.recover === false) {
      hydration_failed();
    }
    init_operations2();
    clear_text_content(target);
    set_hydrating(false);
    return mount(component2, options);
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
  }
}
function _mount(Component2, { target, anchor, props = {}, events, context, intro = true }) {
  init_operations2();
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = (events2) => {
    for (var i = 0; i < events2.length; i++) {
      var event_name = events2[i];
      if (registered_events.has(event_name)) continue;
      registered_events.add(event_name);
      var passive2 = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
      var n = document_listeners.get(event_name);
      if (n === void 0) {
        document.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n + 1);
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component2 = void 0;
  var unmount2 = component_root(() => {
    var anchor_node = anchor ?? target.appendChild(create_text());
    boundary(
      /** @type {TemplateNode} */
      anchor_node,
      {
        pending: () => {
        }
      },
      (anchor_node2) => {
        if (context) {
          push({});
          var ctx = (
            /** @type {ComponentContext} */
            component_context
          );
          ctx.c = context;
        }
        if (events) {
          props.$$events = events;
        }
        if (hydrating) {
          assign_nodes(
            /** @type {TemplateNode} */
            anchor_node2,
            null
          );
        }
        should_intro = intro;
        component2 = Component2(anchor_node2, props) || {};
        should_intro = true;
        if (hydrating) {
          active_effect.nodes.end = hydrate_node;
          if (hydrate_node === null || hydrate_node.nodeType !== COMMENT_NODE || /** @type {Comment} */
          hydrate_node.data !== HYDRATION_END) {
            hydration_mismatch();
            throw HYDRATION_ERROR;
          }
        }
        if (context) {
          pop();
        }
      }
    );
    return () => {
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n = (
          /** @type {number} */
          document_listeners.get(event_name)
        );
        if (--n === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n);
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        anchor_node.parentNode?.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component2, unmount2);
  return component2;
}
function unmount(component2, options) {
  const fn = mounted_components.get(component2);
  if (fn) {
    mounted_components.delete(component2);
    return fn(options);
  }
  if (dev_fallback_default) {
    if (STATE_SYMBOL in component2) {
      state_proxy_unmount();
    } else {
      lifecycle_double_unmount();
    }
  }
  return Promise.resolve();
}
var should_intro, document_listeners, mounted_components;
var init_render = __esm({
  "node_modules/svelte/src/internal/client/render.js"() {
    init_esm_env();
    init_operations();
    init_constants2();
    init_runtime();
    init_context();
    init_effects();
    init_hydration();
    init_utils();
    init_events();
    init_warnings();
    init_errors2();
    init_template();
    init_utils3();
    init_constants3();
    init_boundary();
    should_intro = true;
    document_listeners = /* @__PURE__ */ new Map();
    mounted_components = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/svelte/src/internal/shared/validate.js
var init_validate = __esm({
  "node_modules/svelte/src/internal/shared/validate.js"() {
    init_utils3();
    init_warnings2();
    init_errors();
    init_errors();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/branches.js
var init_branches = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/branches.js"() {
    init_batch();
    init_effects();
    init_hydration();
    init_operations();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/snippet.js
var init_snippet = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/snippet.js"() {
    init_constants3();
    init_effects();
    init_context();
    init_hydration();
    init_reconciler();
    init_template();
    init_warnings();
    init_errors2();
    init_esm_env();
    init_operations();
    init_validate();
    init_branches();
  }
});

// node_modules/svelte/src/index-client.js
var init_index_client = __esm({
  "node_modules/svelte/src/index-client.js"() {
    init_runtime();
    init_utils();
    init_client();
    init_errors2();
    init_flags();
    init_context();
    init_esm_env();
    init_batch();
    init_context();
    init_hydratable();
    init_render();
    init_runtime();
    init_snippet();
    if (dev_fallback_default) {
      let throw_rune_error = function(rune) {
        if (!(rune in globalThis)) {
          let value;
          Object.defineProperty(globalThis, rune, {
            configurable: true,
            // eslint-disable-next-line getter-return
            get: () => {
              if (value !== void 0) {
                return value;
              }
              rune_outside_svelte(rune);
            },
            set: (v) => {
              value = v;
            }
          });
        }
      };
      throw_rune_error("$state");
      throw_rune_error("$effect");
      throw_rune_error("$derived");
      throw_rune_error("$inspect");
      throw_rune_error("$props");
      throw_rune_error("$bindable");
    }
  }
});

// node_modules/svelte/src/attachments/index.js
var init_attachments = __esm({
  "node_modules/svelte/src/attachments/index.js"() {
    init_client();
    init_constants2();
    init_index_client();
    init_effects();
  }
});

// node_modules/svelte/src/internal/client/dev/assign.js
var init_assign = __esm({
  "node_modules/svelte/src/internal/client/dev/assign.js"() {
    init_utils3();
    init_runtime();
    init_warnings();
  }
});

// node_modules/svelte/src/internal/client/dev/css.js
var init_css = __esm({
  "node_modules/svelte/src/internal/client/dev/css.js"() {
  }
});

// node_modules/svelte/src/internal/client/dev/elements.js
var init_elements = __esm({
  "node_modules/svelte/src/internal/client/dev/elements.js"() {
    init_constants3();
    init_constants2();
    init_hydration();
    init_context();
  }
});

// node_modules/svelte/src/internal/client/dev/hmr.js
var init_hmr = __esm({
  "node_modules/svelte/src/internal/client/dev/hmr.js"() {
    init_constants2();
    init_constants3();
    init_hydration();
    init_effects();
    init_sources();
    init_render();
    init_runtime();
  }
});

// node_modules/svelte/src/internal/client/dev/ownership.js
var init_ownership = __esm({
  "node_modules/svelte/src/internal/client/dev/ownership.js"() {
    init_utils();
    init_constants3();
    init_constants2();
    init_context();
    init_warnings();
    init_utils3();
  }
});

// node_modules/svelte/src/internal/client/dev/legacy.js
var init_legacy2 = __esm({
  "node_modules/svelte/src/internal/client/dev/legacy.js"() {
    init_errors2();
    init_context();
    init_constants2();
  }
});

// node_modules/svelte/src/internal/client/dev/inspect.js
var init_inspect = __esm({
  "node_modules/svelte/src/internal/client/dev/inspect.js"() {
    init_constants2();
    init_clone();
    init_effects();
    init_runtime();
    init_dev();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/async.js
var init_async2 = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/async.js"() {
    init_async();
    init_batch();
    init_runtime();
    init_hydration();
    init_boundary();
  }
});

// node_modules/svelte/src/internal/client/dev/validation.js
var init_validation = __esm({
  "node_modules/svelte/src/internal/client/dev/validation.js"() {
    init_errors2();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/await.js
var init_await = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/await.js"() {
    init_utils();
    init_effects();
    init_sources();
    init_hydration();
    init_task();
    init_constants2();
    init_context();
    init_batch();
    init_branches();
    init_async();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/if.js
var init_if = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/if.js"() {
    init_constants3();
    init_hydration();
    init_effects();
    init_constants2();
    init_branches();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/key.js
var init_key = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/key.js"() {
    init_context();
    init_effects();
    init_hydration();
    init_branches();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/css-props.js
var init_css_props = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/css-props.js"() {
    init_effects();
    init_hydration();
    init_operations();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/each.js
var init_each = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/each.js"() {
    init_constants2();
    init_hydration();
    init_operations();
    init_effects();
    init_sources();
    init_utils();
    init_constants3();
    init_task();
    init_runtime();
    init_esm_env();
    init_deriveds();
    init_batch();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/html.js
var init_html = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/html.js"() {
    init_constants2();
    init_effects();
    init_hydration();
    init_reconciler();
    init_template();
    init_warnings();
    init_utils3();
    init_esm_env();
    init_context();
    init_operations();
    init_runtime();
    init_constants3();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/slot.js
var init_slot = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/slot.js"() {
    init_hydration();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js
var init_svelte_component = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js"() {
    init_constants3();
    init_effects();
    init_hydration();
    init_branches();
  }
});

// node_modules/svelte/src/internal/client/timing.js
var init_timing = __esm({
  "node_modules/svelte/src/internal/client/timing.js"() {
    init_utils();
    init_esm_env();
  }
});

// node_modules/svelte/src/internal/client/loop.js
var init_loop = __esm({
  "node_modules/svelte/src/internal/client/loop.js"() {
    init_timing();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/transitions.js
var init_transitions = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/transitions.js"() {
    init_utils();
    init_effects();
    init_runtime();
    init_loop();
    init_render();
    init_constants2();
    init_constants3();
    init_task();
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/svelte-element.js
var init_svelte_element = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/svelte-element.js"() {
    init_constants2();
    init_hydration();
    init_operations();
    init_effects();
    init_render();
    init_runtime();
    init_context();
    init_esm_env();
    init_constants3();
    init_template();
    init_utils3();
    init_branches();
    init_transitions();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js
var init_svelte_head = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js"() {
    init_hydration();
    init_operations();
    init_effects();
    init_constants3();
  }
});

// node_modules/svelte/src/internal/client/dom/css.js
var init_css2 = __esm({
  "node_modules/svelte/src/internal/client/dom/css.js"() {
    init_esm_env();
    init_css();
    init_effects();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/actions.js
var init_actions = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/actions.js"() {
    init_effects();
    init_equality();
    init_runtime();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/attachments.js
var init_attachments2 = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/attachments.js"() {
    init_effects();
  }
});

// node_modules/svelte/src/escaping.js
var init_escaping = __esm({
  "node_modules/svelte/src/escaping.js"() {
  }
});

// node_modules/clsx/dist/clsx.mjs
var init_clsx = __esm({
  "node_modules/clsx/dist/clsx.mjs"() {
  }
});

// node_modules/svelte/src/internal/shared/attributes.js
var whitespace;
var init_attributes = __esm({
  "node_modules/svelte/src/internal/shared/attributes.js"() {
    init_escaping();
    init_clsx();
    whitespace = [..." 	\n\r\f\xA0\v\uFEFF"];
  }
});

// node_modules/svelte/src/internal/client/dom/elements/class.js
var init_class = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/class.js"() {
    init_attributes();
    init_hydration();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/style.js
var init_style = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/style.js"() {
    init_attributes();
    init_hydration();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/select.js
var init_select = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/select.js"() {
    init_effects();
    init_shared();
    init_proxy();
    init_utils();
    init_warnings();
    init_batch();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/attributes.js
var init_attributes2 = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/attributes.js"() {
    init_esm_env();
    init_hydration();
    init_utils();
    init_events();
    init_misc();
    init_warnings();
    init_constants3();
    init_task();
    init_utils3();
    init_runtime();
    init_attachments2();
    init_attributes();
    init_class();
    init_style();
    init_constants2();
    init_effects();
    init_select();
    init_async();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/customizable-select.js
var init_customizable_select = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/customizable-select.js"() {
    init_hydration();
    init_operations();
    init_attachments2();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/document.js
var init_document = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/document.js"() {
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/input.js
var init_input = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/input.js"() {
    init_esm_env();
    init_effects();
    init_shared();
    init_errors2();
    init_proxy();
    init_task();
    init_hydration();
    init_runtime();
    init_context();
    init_batch();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/media.js
var init_media = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/media.js"() {
    init_effects();
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/navigator.js
var init_navigator = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/navigator.js"() {
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/props.js
var init_props = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/props.js"() {
    init_effects();
    init_utils();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/size.js
var init_size = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/size.js"() {
    init_effects();
    init_runtime();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/this.js
var init_this = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/this.js"() {
    init_constants3();
    init_effects();
    init_runtime();
    init_task();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/universal.js
var init_universal = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/universal.js"() {
    init_effects();
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/window.js
var init_window = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/window.js"() {
    init_effects();
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/dom/legacy/event-modifiers.js
var init_event_modifiers = __esm({
  "node_modules/svelte/src/internal/client/dom/legacy/event-modifiers.js"() {
    init_utils();
    init_effects();
    init_events();
  }
});

// node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js
var init_lifecycle = __esm({
  "node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js"() {
    init_utils();
    init_context();
    init_deriveds();
    init_effects();
    init_runtime();
  }
});

// node_modules/svelte/src/internal/client/dom/legacy/misc.js
var init_misc2 = __esm({
  "node_modules/svelte/src/internal/client/dom/legacy/misc.js"() {
    init_sources();
    init_runtime();
    init_utils();
  }
});

// node_modules/svelte/src/store/utils.js
function subscribe_to_store(store, run3, invalidate) {
  if (store == null) {
    run3(void 0);
    if (invalidate) invalidate(void 0);
    return noop;
  }
  const unsub = untrack(
    () => store.subscribe(
      run3,
      // @ts-expect-error
      invalidate
    )
  );
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
var init_utils4 = __esm({
  "node_modules/svelte/src/store/utils.js"() {
    init_index_client();
    init_utils();
  }
});

// node_modules/svelte/src/store/shared/index.js
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop = null;
  const subscribers = /* @__PURE__ */ new Set();
  function set3(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set3(fn(
      /** @type {T} */
      value
    ));
  }
  function subscribe(run3, invalidate = noop) {
    const subscriber = [run3, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set3, update2) || noop;
    }
    run3(
      /** @type {T} */
      value
    );
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set3, update: update2, subscribe };
}
function derived2(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set3, update2) => {
    let started = false;
    const values = [];
    let pending2 = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending2) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set3, update2);
      if (auto) {
        set3(result);
      } else {
        cleanup = typeof result === "function" ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i) => subscribe_to_store(
        store,
        (value) => {
          values[i] = value;
          pending2 &= ~(1 << i);
          if (started) {
            sync();
          }
        },
        () => {
          pending2 |= 1 << i;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}
var subscriber_queue;
var init_shared2 = __esm({
  "node_modules/svelte/src/store/shared/index.js"() {
    init_utils();
    init_equality();
    init_utils4();
    subscriber_queue = [];
  }
});

// node_modules/svelte/src/internal/client/reactivity/store.js
var init_store = __esm({
  "node_modules/svelte/src/internal/client/reactivity/store.js"() {
    init_utils4();
    init_shared2();
    init_utils();
    init_runtime();
    init_effects();
    init_sources();
    init_esm_env();
  }
});

// node_modules/svelte/src/internal/client/reactivity/props.js
var init_props2 = __esm({
  "node_modules/svelte/src/internal/client/reactivity/props.js"() {
    init_esm_env();
    init_constants2();
    init_utils();
    init_sources();
    init_deriveds();
    init_runtime();
    init_errors2();
    init_constants3();
    init_proxy();
    init_store();
    init_flags();
  }
});

// node_modules/svelte/src/internal/client/validate.js
var init_validate2 = __esm({
  "node_modules/svelte/src/internal/client/validate.js"() {
    init_context();
    init_utils();
    init_errors2();
    init_constants2();
    init_effects();
    init_warnings();
    init_store();
    init_async();
  }
});

// node_modules/svelte/src/legacy/legacy-client.js
function createClassComponent(options) {
  return new Svelte4Component(options);
}
var Svelte4Component;
var init_legacy_client = __esm({
  "node_modules/svelte/src/legacy/legacy-client.js"() {
    init_constants3();
    init_effects();
    init_sources();
    init_render();
    init_runtime();
    init_batch();
    init_utils();
    init_errors2();
    init_warnings();
    init_esm_env();
    init_constants2();
    init_context();
    init_flags();
    init_status();
    init_event_modifiers();
    Svelte4Component = class {
      /** @type {any} */
      #events;
      /** @type {Record<string, any>} */
      #instance;
      /**
       * @param {ComponentConstructorOptions & {
       *  component: any;
       * }} options
       */
      constructor(options) {
        var sources = /* @__PURE__ */ new Map();
        var add_source = (key2, value) => {
          var s = mutable_source(value, false, false);
          sources.set(key2, s);
          return s;
        };
        const props = new Proxy(
          { ...options.props || {}, $$events: {} },
          {
            get(target, prop2) {
              return get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
            },
            has(target, prop2) {
              if (prop2 === LEGACY_PROPS) return true;
              get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
              return Reflect.has(target, prop2);
            },
            set(target, prop2, value) {
              set(sources.get(prop2) ?? add_source(prop2, value), value);
              return Reflect.set(target, prop2, value);
            }
          }
        );
        this.#instance = (options.hydrate ? hydrate : mount)(options.component, {
          target: options.target,
          anchor: options.anchor,
          props,
          context: options.context,
          intro: options.intro ?? false,
          recover: options.recover
        });
        if (!async_mode_flag && (!options?.props?.$$host || options.sync === false)) {
          flushSync();
        }
        this.#events = props.$$events;
        for (const key2 of Object.keys(this.#instance)) {
          if (key2 === "$set" || key2 === "$destroy" || key2 === "$on") continue;
          define_property(this, key2, {
            get() {
              return this.#instance[key2];
            },
            /** @param {any} value */
            set(value) {
              this.#instance[key2] = value;
            },
            enumerable: true
          });
        }
        this.#instance.$set = /** @param {Record<string, any>} next */
        (next2) => {
          Object.assign(props, next2);
        };
        this.#instance.$destroy = () => {
          unmount(this.#instance);
        };
      }
      /** @param {Record<string, any>} props */
      $set(props) {
        this.#instance.$set(props);
      }
      /**
       * @param {string} event
       * @param {(...args: any[]) => any} callback
       * @returns {any}
       */
      $on(event2, callback) {
        this.#events[event2] = this.#events[event2] || [];
        const cb = (...args) => callback.call(this, ...args);
        this.#events[event2].push(cb);
        return () => {
          this.#events[event2] = this.#events[event2].filter(
            /** @param {any} fn */
            (fn) => fn !== cb
          );
        };
      }
      $destroy() {
        this.#instance.$destroy();
      }
    };
  }
});

// node_modules/svelte/src/internal/client/dom/elements/custom-element.js
function get_custom_element_value(prop2, value, props_definition, transform) {
  const type2 = props_definition[prop2]?.type;
  value = type2 === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop2]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type2) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type2) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      // conversion already handled above
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach((node) => {
    result[
      /** @type {Element} node */
      node.slot || "default"
    ] = true;
  });
  return result;
}
var SvelteElement;
var init_custom_element = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/custom-element.js"() {
    init_legacy_client();
    init_effects();
    init_template();
    init_utils();
    if (typeof HTMLElement === "function") {
      SvelteElement = class extends HTMLElement {
        /** The Svelte component constructor */
        $$ctor;
        /** Slots */
        $$s;
        /** @type {any} The Svelte component instance */
        $$c;
        /** Whether or not the custom element is connected */
        $$cn = false;
        /** @type {Record<string, any>} Component props data */
        $$d = {};
        /** `true` if currently in the process of reflecting component props back to attributes */
        $$r = false;
        /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
        $$p_d = {};
        /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
        $$l = {};
        /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
        $$l_u = /* @__PURE__ */ new Map();
        /** @type {any} The managed render effect for reflecting attributes */
        $$me;
        /**
         * @param {*} $$componentCtor
         * @param {*} $$slots
         * @param {*} use_shadow_dom
         */
        constructor($$componentCtor, $$slots, use_shadow_dom) {
          super();
          this.$$ctor = $$componentCtor;
          this.$$s = $$slots;
          if (use_shadow_dom) {
            this.attachShadow({ mode: "open" });
          }
        }
        /**
         * @param {string} type
         * @param {EventListenerOrEventListenerObject} listener
         * @param {boolean | AddEventListenerOptions} [options]
         */
        addEventListener(type2, listener, options) {
          this.$$l[type2] = this.$$l[type2] || [];
          this.$$l[type2].push(listener);
          if (this.$$c) {
            const unsub = this.$$c.$on(type2, listener);
            this.$$l_u.set(listener, unsub);
          }
          super.addEventListener(type2, listener, options);
        }
        /**
         * @param {string} type
         * @param {EventListenerOrEventListenerObject} listener
         * @param {boolean | AddEventListenerOptions} [options]
         */
        removeEventListener(type2, listener, options) {
          super.removeEventListener(type2, listener, options);
          if (this.$$c) {
            const unsub = this.$$l_u.get(listener);
            if (unsub) {
              unsub();
              this.$$l_u.delete(listener);
            }
          }
        }
        async connectedCallback() {
          this.$$cn = true;
          if (!this.$$c) {
            let create_slot = function(name3) {
              return (anchor) => {
                const slot2 = document.createElement("slot");
                if (name3 !== "default") slot2.name = name3;
                append(anchor, slot2);
              };
            };
            await Promise.resolve();
            if (!this.$$cn || this.$$c) {
              return;
            }
            const $$slots = {};
            const existing_slots = get_custom_elements_slots(this);
            for (const name3 of this.$$s) {
              if (name3 in existing_slots) {
                if (name3 === "default" && !this.$$d.children) {
                  this.$$d.children = create_slot(name3);
                  $$slots.default = true;
                } else {
                  $$slots[name3] = create_slot(name3);
                }
              }
            }
            for (const attribute of this.attributes) {
              const name3 = this.$$g_p(attribute.name);
              if (!(name3 in this.$$d)) {
                this.$$d[name3] = get_custom_element_value(name3, attribute.value, this.$$p_d, "toProp");
              }
            }
            for (const key2 in this.$$p_d) {
              if (!(key2 in this.$$d) && this[key2] !== void 0) {
                this.$$d[key2] = this[key2];
                delete this[key2];
              }
            }
            this.$$c = createClassComponent({
              component: this.$$ctor,
              target: this.shadowRoot || this,
              props: {
                ...this.$$d,
                $$slots,
                $$host: this
              }
            });
            this.$$me = effect_root(() => {
              render_effect(() => {
                this.$$r = true;
                for (const key2 of object_keys(this.$$c)) {
                  if (!this.$$p_d[key2]?.reflect) continue;
                  this.$$d[key2] = this.$$c[key2];
                  const attribute_value = get_custom_element_value(
                    key2,
                    this.$$d[key2],
                    this.$$p_d,
                    "toAttribute"
                  );
                  if (attribute_value == null) {
                    this.removeAttribute(this.$$p_d[key2].attribute || key2);
                  } else {
                    this.setAttribute(this.$$p_d[key2].attribute || key2, attribute_value);
                  }
                }
                this.$$r = false;
              });
            });
            for (const type2 in this.$$l) {
              for (const listener of this.$$l[type2]) {
                const unsub = this.$$c.$on(type2, listener);
                this.$$l_u.set(listener, unsub);
              }
            }
            this.$$l = {};
          }
        }
        // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
        // and setting attributes through setAttribute etc, this is helpful
        /**
         * @param {string} attr
         * @param {string} _oldValue
         * @param {string} newValue
         */
        attributeChangedCallback(attr2, _oldValue, newValue) {
          if (this.$$r) return;
          attr2 = this.$$g_p(attr2);
          this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
          this.$$c?.$set({ [attr2]: this.$$d[attr2] });
        }
        disconnectedCallback() {
          this.$$cn = false;
          Promise.resolve().then(() => {
            if (!this.$$cn && this.$$c) {
              this.$$c.$destroy();
              this.$$me();
              this.$$c = void 0;
            }
          });
        }
        /**
         * @param {string} attribute_name
         */
        $$g_p(attribute_name) {
          return object_keys(this.$$p_d).find(
            (key2) => this.$$p_d[key2].attribute === attribute_name || !this.$$p_d[key2].attribute && key2.toLowerCase() === attribute_name
          ) || attribute_name;
        }
      };
    }
  }
});

// node_modules/svelte/src/internal/client/dev/console-log.js
var init_console_log = __esm({
  "node_modules/svelte/src/internal/client/dev/console-log.js"() {
    init_constants3();
    init_clone();
    init_warnings();
    init_runtime();
  }
});

// node_modules/svelte/src/internal/client/index.js
var init_client = __esm({
  "node_modules/svelte/src/internal/client/index.js"() {
    init_attachments();
    init_constants2();
    init_context();
    init_assign();
    init_css();
    init_elements();
    init_hmr();
    init_ownership();
    init_legacy2();
    init_tracing();
    init_inspect();
    init_async2();
    init_validation();
    init_await();
    init_if();
    init_key();
    init_css_props();
    init_each();
    init_html();
    init_slot();
    init_snippet();
    init_svelte_component();
    init_svelte_element();
    init_svelte_head();
    init_css2();
    init_actions();
    init_attachments2();
    init_attributes2();
    init_class();
    init_events();
    init_misc();
    init_customizable_select();
    init_style();
    init_transitions();
    init_document();
    init_input();
    init_media();
    init_navigator();
    init_props();
    init_select();
    init_size();
    init_this();
    init_universal();
    init_window();
    init_hydration();
    init_event_modifiers();
    init_lifecycle();
    init_misc2();
    init_template();
    init_async();
    init_batch();
    init_deriveds();
    init_effects();
    init_sources();
    init_props2();
    init_store();
    init_boundary();
    init_legacy();
    init_render();
    init_runtime();
    init_validate2();
    init_timing();
    init_proxy();
    init_custom_element();
    init_operations();
    init_attributes();
    init_clone();
    init_utils();
    init_validate();
    init_equality2();
    init_console_log();
    init_error_handling();
  }
});

// node_modules/@plures/praxis/dist/node/chunk-LE2ZJYFC.js
var PraxisRegistry;
var init_chunk_LE2ZJYFC = __esm({
  "node_modules/@plures/praxis/dist/node/chunk-LE2ZJYFC.js"() {
    init_chunk_VOMLVI6V();
    init_client();
    PraxisRegistry = class {
      rules = /* @__PURE__ */ new Map();
      constraints = /* @__PURE__ */ new Map();
      /**
       * Register a rule
       */
      registerRule(descriptor) {
        if (this.rules.has(descriptor.id)) {
          throw new Error(`Rule with id "${descriptor.id}" already registered`);
        }
        this.rules.set(descriptor.id, descriptor);
      }
      /**
       * Register a constraint
       */
      registerConstraint(descriptor) {
        if (this.constraints.has(descriptor.id)) {
          throw new Error(`Constraint with id "${descriptor.id}" already registered`);
        }
        this.constraints.set(descriptor.id, descriptor);
      }
      /**
       * Register a module (all its rules and constraints)
       */
      registerModule(module2) {
        for (const rule of module2.rules) {
          this.registerRule(rule);
        }
        for (const constraint of module2.constraints) {
          this.registerConstraint(constraint);
        }
      }
      /**
       * Get a rule by ID
       */
      getRule(id) {
        return this.rules.get(id);
      }
      /**
       * Get a constraint by ID
       */
      getConstraint(id) {
        return this.constraints.get(id);
      }
      /**
       * Get all registered rule IDs
       */
      getRuleIds() {
        return Array.from(this.rules.keys());
      }
      /**
       * Get all registered constraint IDs
       */
      getConstraintIds() {
        return Array.from(this.constraints.keys());
      }
      /**
       * Get all rules
       */
      getAllRules() {
        return Array.from(this.rules.values());
      }
      /**
       * Get all constraints
       */
      getAllConstraints() {
        return Array.from(this.constraints.values());
      }
    };
  }
});

// node_modules/@plures/praxis/dist/node/chunk-N5Y37EUV.js
var init_chunk_N5Y37EUV = __esm({
  "node_modules/@plures/praxis/dist/node/chunk-N5Y37EUV.js"() {
  }
});

// node_modules/@plures/praxis/dist/node/chunk-RJMWCNHR.js
var init_chunk_RJMWCNHR = __esm({
  "node_modules/@plures/praxis/dist/node/chunk-RJMWCNHR.js"() {
  }
});

// node_modules/@plures/praxis/dist/node/chunk-UATVJBNV.js
var init_chunk_UATVJBNV = __esm({
  "node_modules/@plures/praxis/dist/node/chunk-UATVJBNV.js"() {
  }
});

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend(target, source2) {
  var index2, length, key2, sourceKeys;
  if (source2) {
    sourceKeys = Object.keys(source2);
    for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
      key2 = sourceKeys[index2];
      target[key2] = source2[key2];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head2 = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head2 = " ... ";
    lineStart = position - maxHalfLength + head2.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head2 + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head2.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer) return null;
  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent !== "number") options.indent = 1;
  if (typeof options.linesBefore !== "number") options.linesBefore = 3;
  if (typeof options.linesAfter !== "number") options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag2, options) {
  options = options || {};
  Object.keys(options).forEach(function(name3) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name3) === -1) {
      throw new exception('Unknown option "' + name3 + '" is met in definition of "' + tag2 + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag2;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag2 + '" YAML type.');
  }
}
function compileList(schema2, name3) {
  var result = [];
  schema2[name3].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index2, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
    arguments[index2].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
function resolveYamlNull(data) {
  if (data === null) return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null) return false;
  var max = data.length, index2 = 0, hasDigits = false, ch;
  if (!max) return false;
  ch = data[index2];
  if (ch === "-" || ch === "+") {
    ch = data[++index2];
  }
  if (ch === "0") {
    if (index2 + 1 === max) return true;
    ch = data[++index2];
    if (ch === "b") {
      index2++;
      for (; index2 < max; index2++) {
        ch = data[index2];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index2++;
      for (; index2 < max; index2++) {
        ch = data[index2];
        if (ch === "_") continue;
        if (!isHexCode(data.charCodeAt(index2))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index2++;
      for (; index2 < max; index2++) {
        ch = data[index2];
        if (ch === "_") continue;
        if (!isOctCode(data.charCodeAt(index2))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index2 < max; index2++) {
    ch = data[index2];
    if (ch === "_") continue;
    if (!isDecCode(data.charCodeAt(index2))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-") delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64) continue;
    if (code < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object = data;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index2, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index2] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index2, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    keys = Object.keys(pair);
    result[index2] = [keys[0], pair[keys[0]]];
  }
  return result;
}
function resolveYamlSet(data) {
  if (data === null) return true;
  var key2, object = data;
  for (key2 in object) {
    if (_hasOwnProperty$2.call(object, key2)) {
      if (object[key2] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
function setProperty(object, key2, value) {
  if (key2 === "__proto__") {
    Object.defineProperty(object, key2, {
      configurable: true,
      enumerable: true,
      writable: true,
      value
    });
  } else {
    object[key2] = value;
  }
}
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state2, message) {
  var mark = {
    name: state2.filename,
    buffer: state2.input.slice(0, -1),
    // omit trailing \0
    position: state2.position,
    line: state2.line,
    column: state2.position - state2.lineStart
  };
  mark.snippet = snippet2(mark);
  return new exception(message, mark);
}
function throwError(state2, message) {
  throw generateError(state2, message);
}
function throwWarning(state2, message) {
  if (state2.onWarning) {
    state2.onWarning.call(null, generateError(state2, message));
  }
}
function captureSegment(state2, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state2.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state2, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state2, "the stream contains non-printable characters");
    }
    state2.result += _result;
  }
}
function mergeMappings(state2, destination, source2, overridableKeys) {
  var sourceKeys, key2, index2, quantity;
  if (!common.isObject(source2)) {
    throwError(state2, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source2);
  for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
    key2 = sourceKeys[index2];
    if (!_hasOwnProperty$1.call(destination, key2)) {
      setProperty(destination, key2, source2[key2]);
      overridableKeys[key2] = true;
    }
  }
}
function storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index2, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
      if (Array.isArray(keyNode[index2])) {
        throwError(state2, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
        keyNode[index2] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
        mergeMappings(state2, _result, valueNode[index2], overridableKeys);
      }
    } else {
      mergeMappings(state2, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state2.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state2.line = startLine || state2.line;
      state2.lineStart = startLineStart || state2.lineStart;
      state2.position = startPos || state2.position;
      throwError(state2, "duplicated mapping key");
    }
    setProperty(_result, keyNode, valueNode);
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state2) {
  var ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch === 10) {
    state2.position++;
  } else if (ch === 13) {
    state2.position++;
    if (state2.input.charCodeAt(state2.position) === 10) {
      state2.position++;
    }
  } else {
    throwError(state2, "a line break is expected");
  }
  state2.line += 1;
  state2.lineStart = state2.position;
  state2.firstTabInLine = -1;
}
function skipSeparationSpace(state2, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state2.input.charCodeAt(state2.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state2.firstTabInLine === -1) {
        state2.firstTabInLine = state2.position;
      }
      ch = state2.input.charCodeAt(++state2.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state2.input.charCodeAt(++state2.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state2);
      ch = state2.input.charCodeAt(state2.position);
      lineBreaks++;
      state2.lineIndent = 0;
      while (ch === 32) {
        state2.lineIndent++;
        ch = state2.input.charCodeAt(++state2.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state2.lineIndent < checkIndent) {
    throwWarning(state2, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state2) {
  var _position = state2.position, ch;
  ch = state2.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state2.input.charCodeAt(_position + 1) && ch === state2.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state2.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state2, count) {
  if (count === 1) {
    state2.result += " ";
  } else if (count > 1) {
    state2.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state2, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state2.kind, _result = state2.result, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state2.input.charCodeAt(state2.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state2.kind = "scalar";
  state2.result = "";
  captureStart = captureEnd = state2.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state2.input.charCodeAt(state2.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state2.input.charCodeAt(state2.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state2.position === state2.lineStart && testDocumentSeparator(state2) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state2.line;
      _lineStart = state2.lineStart;
      _lineIndent = state2.lineIndent;
      skipSeparationSpace(state2, false, -1);
      if (state2.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state2.input.charCodeAt(state2.position);
        continue;
      } else {
        state2.position = captureEnd;
        state2.line = _line;
        state2.lineStart = _lineStart;
        state2.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state2, captureStart, captureEnd, false);
      writeFoldedLines(state2, state2.line - _line);
      captureStart = captureEnd = state2.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state2.position + 1;
    }
    ch = state2.input.charCodeAt(++state2.position);
  }
  captureSegment(state2, captureStart, captureEnd, false);
  if (state2.result) {
    return true;
  }
  state2.kind = _kind;
  state2.result = _result;
  return false;
}
function readSingleQuotedScalar(state2, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 39) {
    return false;
  }
  state2.kind = "scalar";
  state2.result = "";
  state2.position++;
  captureStart = captureEnd = state2.position;
  while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state2, captureStart, state2.position, true);
      ch = state2.input.charCodeAt(++state2.position);
      if (ch === 39) {
        captureStart = state2.position;
        state2.position++;
        captureEnd = state2.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state2, captureStart, captureEnd, true);
      writeFoldedLines(state2, skipSeparationSpace(state2, false, nodeIndent));
      captureStart = captureEnd = state2.position;
    } else if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
      throwError(state2, "unexpected end of the document within a single quoted scalar");
    } else {
      state2.position++;
      captureEnd = state2.position;
    }
  }
  throwError(state2, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state2, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 34) {
    return false;
  }
  state2.kind = "scalar";
  state2.result = "";
  state2.position++;
  captureStart = captureEnd = state2.position;
  while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state2, captureStart, state2.position, true);
      state2.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state2, captureStart, state2.position, true);
      ch = state2.input.charCodeAt(++state2.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state2, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state2.result += simpleEscapeMap[ch];
        state2.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state2.input.charCodeAt(++state2.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state2, "expected hexadecimal character");
          }
        }
        state2.result += charFromCodepoint(hexResult);
        state2.position++;
      } else {
        throwError(state2, "unknown escape sequence");
      }
      captureStart = captureEnd = state2.position;
    } else if (is_EOL(ch)) {
      captureSegment(state2, captureStart, captureEnd, true);
      writeFoldedLines(state2, skipSeparationSpace(state2, false, nodeIndent));
      captureStart = captureEnd = state2.position;
    } else if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
      throwError(state2, "unexpected end of the document within a double quoted scalar");
    } else {
      state2.position++;
      captureEnd = state2.position;
    }
  }
  throwError(state2, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state2, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state2.tag, _result, _anchor = state2.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state2.anchor !== null) {
    state2.anchorMap[state2.anchor] = _result;
  }
  ch = state2.input.charCodeAt(++state2.position);
  while (ch !== 0) {
    skipSeparationSpace(state2, true, nodeIndent);
    ch = state2.input.charCodeAt(state2.position);
    if (ch === terminator) {
      state2.position++;
      state2.tag = _tag;
      state2.anchor = _anchor;
      state2.kind = isMapping ? "mapping" : "sequence";
      state2.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state2, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state2, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state2.input.charCodeAt(state2.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state2.position++;
        skipSeparationSpace(state2, true, nodeIndent);
      }
    }
    _line = state2.line;
    _lineStart = state2.lineStart;
    _pos = state2.position;
    composeNode(state2, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state2.tag;
    keyNode = state2.result;
    skipSeparationSpace(state2, true, nodeIndent);
    ch = state2.input.charCodeAt(state2.position);
    if ((isExplicitPair || state2.line === _line) && ch === 58) {
      isPair = true;
      ch = state2.input.charCodeAt(++state2.position);
      skipSeparationSpace(state2, true, nodeIndent);
      composeNode(state2, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state2.result;
    }
    if (isMapping) {
      storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state2, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state2, true, nodeIndent);
    ch = state2.input.charCodeAt(state2.position);
    if (ch === 44) {
      readNext = true;
      ch = state2.input.charCodeAt(++state2.position);
    } else {
      readNext = false;
    }
  }
  throwError(state2, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state2, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state2.kind = "scalar";
  state2.result = "";
  while (ch !== 0) {
    ch = state2.input.charCodeAt(++state2.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state2, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state2, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state2, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state2.input.charCodeAt(++state2.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state2.input.charCodeAt(++state2.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state2);
    state2.lineIndent = 0;
    ch = state2.input.charCodeAt(state2.position);
    while ((!detectedIndent || state2.lineIndent < textIndent) && ch === 32) {
      state2.lineIndent++;
      ch = state2.input.charCodeAt(++state2.position);
    }
    if (!detectedIndent && state2.lineIndent > textIndent) {
      textIndent = state2.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state2.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state2.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state2.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state2.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state2.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state2.result += " ";
        }
      } else {
        state2.result += common.repeat("\n", emptyLines);
      }
    } else {
      state2.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state2.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state2.input.charCodeAt(++state2.position);
    }
    captureSegment(state2, captureStart, state2.position, false);
  }
  return true;
}
function readBlockSequence(state2, nodeIndent) {
  var _line, _tag = state2.tag, _anchor = state2.anchor, _result = [], following, detected = false, ch;
  if (state2.firstTabInLine !== -1) return false;
  if (state2.anchor !== null) {
    state2.anchorMap[state2.anchor] = _result;
  }
  ch = state2.input.charCodeAt(state2.position);
  while (ch !== 0) {
    if (state2.firstTabInLine !== -1) {
      state2.position = state2.firstTabInLine;
      throwError(state2, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state2.input.charCodeAt(state2.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state2.position++;
    if (skipSeparationSpace(state2, true, -1)) {
      if (state2.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state2.input.charCodeAt(state2.position);
        continue;
      }
    }
    _line = state2.line;
    composeNode(state2, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state2.result);
    skipSeparationSpace(state2, true, -1);
    ch = state2.input.charCodeAt(state2.position);
    if ((state2.line === _line || state2.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state2, "bad indentation of a sequence entry");
    } else if (state2.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state2.tag = _tag;
    state2.anchor = _anchor;
    state2.kind = "sequence";
    state2.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state2, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state2.tag, _anchor = state2.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state2.firstTabInLine !== -1) return false;
  if (state2.anchor !== null) {
    state2.anchorMap[state2.anchor] = _result;
  }
  ch = state2.input.charCodeAt(state2.position);
  while (ch !== 0) {
    if (!atExplicitKey && state2.firstTabInLine !== -1) {
      state2.position = state2.firstTabInLine;
      throwError(state2, "tab characters must not be used in indentation");
    }
    following = state2.input.charCodeAt(state2.position + 1);
    _line = state2.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state2, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state2.position += 1;
      ch = following;
    } else {
      _keyLine = state2.line;
      _keyLineStart = state2.lineStart;
      _keyPos = state2.position;
      if (!composeNode(state2, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state2.line === _line) {
        ch = state2.input.charCodeAt(state2.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state2.input.charCodeAt(++state2.position);
        }
        if (ch === 58) {
          ch = state2.input.charCodeAt(++state2.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state2, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state2.tag;
          keyNode = state2.result;
        } else if (detected) {
          throwError(state2, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state2.tag = _tag;
          state2.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state2, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state2.tag = _tag;
        state2.anchor = _anchor;
        return true;
      }
    }
    if (state2.line === _line || state2.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state2.line;
        _keyLineStart = state2.lineStart;
        _keyPos = state2.position;
      }
      if (composeNode(state2, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state2.result;
        } else {
          valueNode = state2.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state2, true, -1);
      ch = state2.input.charCodeAt(state2.position);
    }
    if ((state2.line === _line || state2.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state2, "bad indentation of a mapping entry");
    } else if (state2.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state2.tag = _tag;
    state2.anchor = _anchor;
    state2.kind = "mapping";
    state2.result = _result;
  }
  return detected;
}
function readTagProperty(state2) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 33) return false;
  if (state2.tag !== null) {
    throwError(state2, "duplication of a tag property");
  }
  ch = state2.input.charCodeAt(++state2.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state2.input.charCodeAt(++state2.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state2.input.charCodeAt(++state2.position);
  } else {
    tagHandle = "!";
  }
  _position = state2.position;
  if (isVerbatim) {
    do {
      ch = state2.input.charCodeAt(++state2.position);
    } while (ch !== 0 && ch !== 62);
    if (state2.position < state2.length) {
      tagName = state2.input.slice(_position, state2.position);
      ch = state2.input.charCodeAt(++state2.position);
    } else {
      throwError(state2, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state2.input.slice(_position - 1, state2.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state2, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state2.position + 1;
        } else {
          throwError(state2, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state2.input.charCodeAt(++state2.position);
    }
    tagName = state2.input.slice(_position, state2.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state2, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state2, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state2, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state2.tag = tagName;
  } else if (_hasOwnProperty$1.call(state2.tagMap, tagHandle)) {
    state2.tag = state2.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state2.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state2.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state2, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state2) {
  var _position, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 38) return false;
  if (state2.anchor !== null) {
    throwError(state2, "duplication of an anchor property");
  }
  ch = state2.input.charCodeAt(++state2.position);
  _position = state2.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state2.input.charCodeAt(++state2.position);
  }
  if (state2.position === _position) {
    throwError(state2, "name of an anchor node must contain at least one character");
  }
  state2.anchor = state2.input.slice(_position, state2.position);
  return true;
}
function readAlias(state2) {
  var _position, alias, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 42) return false;
  ch = state2.input.charCodeAt(++state2.position);
  _position = state2.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state2.input.charCodeAt(++state2.position);
  }
  if (state2.position === _position) {
    throwError(state2, "name of an alias node must contain at least one character");
  }
  alias = state2.input.slice(_position, state2.position);
  if (!_hasOwnProperty$1.call(state2.anchorMap, alias)) {
    throwError(state2, 'unidentified alias "' + alias + '"');
  }
  state2.result = state2.anchorMap[alias];
  skipSeparationSpace(state2, true, -1);
  return true;
}
function composeNode(state2, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state2.listener !== null) {
    state2.listener("open", state2);
  }
  state2.tag = null;
  state2.anchor = null;
  state2.kind = null;
  state2.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state2, true, -1)) {
      atNewLine = true;
      if (state2.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state2.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state2.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state2) || readAnchorProperty(state2)) {
      if (skipSeparationSpace(state2, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state2.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state2.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state2.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state2.position - state2.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state2, blockIndent) || readBlockMapping(state2, blockIndent, flowIndent)) || readFlowCollection(state2, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state2, flowIndent) || readSingleQuotedScalar(state2, flowIndent) || readDoubleQuotedScalar(state2, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state2)) {
          hasContent = true;
          if (state2.tag !== null || state2.anchor !== null) {
            throwError(state2, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state2, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state2.tag === null) {
            state2.tag = "?";
          }
        }
        if (state2.anchor !== null) {
          state2.anchorMap[state2.anchor] = state2.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state2, blockIndent);
    }
  }
  if (state2.tag === null) {
    if (state2.anchor !== null) {
      state2.anchorMap[state2.anchor] = state2.result;
    }
  } else if (state2.tag === "?") {
    if (state2.result !== null && state2.kind !== "scalar") {
      throwError(state2, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state2.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state2.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state2.implicitTypes[typeIndex];
      if (type2.resolve(state2.result)) {
        state2.result = type2.construct(state2.result);
        state2.tag = type2.tag;
        if (state2.anchor !== null) {
          state2.anchorMap[state2.anchor] = state2.result;
        }
        break;
      }
    }
  } else if (state2.tag !== "!") {
    if (_hasOwnProperty$1.call(state2.typeMap[state2.kind || "fallback"], state2.tag)) {
      type2 = state2.typeMap[state2.kind || "fallback"][state2.tag];
    } else {
      type2 = null;
      typeList = state2.typeMap.multi[state2.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state2.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state2, "unknown tag !<" + state2.tag + ">");
    }
    if (state2.result !== null && type2.kind !== state2.kind) {
      throwError(state2, "unacceptable node kind for !<" + state2.tag + '> tag; it should be "' + type2.kind + '", not "' + state2.kind + '"');
    }
    if (!type2.resolve(state2.result, state2.tag)) {
      throwError(state2, "cannot resolve a node with !<" + state2.tag + "> explicit tag");
    } else {
      state2.result = type2.construct(state2.result, state2.tag);
      if (state2.anchor !== null) {
        state2.anchorMap[state2.anchor] = state2.result;
      }
    }
  }
  if (state2.listener !== null) {
    state2.listener("close", state2);
  }
  return state2.tag !== null || state2.anchor !== null || hasContent;
}
function readDocument(state2) {
  var documentStart = state2.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state2.version = null;
  state2.checkLineBreaks = state2.legacy;
  state2.tagMap = /* @__PURE__ */ Object.create(null);
  state2.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
    skipSeparationSpace(state2, true, -1);
    ch = state2.input.charCodeAt(state2.position);
    if (state2.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state2.input.charCodeAt(++state2.position);
    _position = state2.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state2.input.charCodeAt(++state2.position);
    }
    directiveName = state2.input.slice(_position, state2.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state2, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state2.input.charCodeAt(++state2.position);
      }
      if (ch === 35) {
        do {
          ch = state2.input.charCodeAt(++state2.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state2.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state2.input.charCodeAt(++state2.position);
      }
      directiveArgs.push(state2.input.slice(_position, state2.position));
    }
    if (ch !== 0) readLineBreak(state2);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state2, directiveName, directiveArgs);
    } else {
      throwWarning(state2, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state2, true, -1);
  if (state2.lineIndent === 0 && state2.input.charCodeAt(state2.position) === 45 && state2.input.charCodeAt(state2.position + 1) === 45 && state2.input.charCodeAt(state2.position + 2) === 45) {
    state2.position += 3;
    skipSeparationSpace(state2, true, -1);
  } else if (hasDirectives) {
    throwError(state2, "directives end mark is expected");
  }
  composeNode(state2, state2.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state2, true, -1);
  if (state2.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state2.input.slice(documentStart, state2.position))) {
    throwWarning(state2, "non-ASCII line breaks are interpreted as content");
  }
  state2.documents.push(state2.result);
  if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
    if (state2.input.charCodeAt(state2.position) === 46) {
      state2.position += 3;
      skipSeparationSpace(state2, true, -1);
    }
    return;
  }
  if (state2.position < state2.length - 1) {
    throwError(state2, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state2 = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state2.position = nullpos;
    throwError(state2, "null byte is not allowed in input");
  }
  state2.input += "\0";
  while (state2.input.charCodeAt(state2.position) === 32) {
    state2.lineIndent += 1;
    state2.position += 1;
  }
  while (state2.position < state2.length - 1) {
    readDocument(state2);
  }
  return state2.documents;
}
function loadAll$1(input, iterator2, options) {
  if (iterator2 !== null && typeof iterator2 === "object" && typeof options === "undefined") {
    options = iterator2;
    iterator2 = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator2 !== "function") {
    return documents;
  }
  for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
    iterator2(documents[index2]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
function compileStyleMap(schema2, map2) {
  var result, keys, index2, length, tag2, style, type2;
  if (map2 === null) return {};
  result = {};
  keys = Object.keys(map2);
  for (index2 = 0, length = keys.length; index2 < length; index2 += 1) {
    tag2 = keys[index2];
    style = String(map2[tag2]);
    if (tag2.slice(0, 2) === "!!") {
      tag2 = "tag:yaml.org,2002:" + tag2.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag2];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag2] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next2 = -1, result = "", line, length = string.length;
  while (position < length) {
    next2 = string.indexOf("\n", position);
    if (next2 === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next2 + 1);
      position = next2 + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state2, level) {
  return "\n" + common.repeat(" ", state2.indent * level);
}
function testImplicitResolving(state2, str2) {
  var index2, length, type2;
  for (index2 = 0, length = state2.implicitTypes.length; index2 < length; index2 += 1) {
    type2 = state2.implicitTypes[index2];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state2, string, level, iskey, inblock) {
  state2.dump = (function() {
    if (string.length === 0) {
      return state2.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state2.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state2.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state2.indent * Math.max(1, level);
    var lineWidth = state2.lineWidth === -1 ? -1 : Math.max(Math.min(state2.lineWidth, 40), state2.lineWidth - indent);
    var singleLineOnly = iskey || state2.flowLevel > -1 && level >= state2.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state2, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state2.indent,
      lineWidth,
      testAmbiguity,
      state2.quotingType,
      state2.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state2.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state2.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  })();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = (function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  })();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next2 = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next2 = match.index;
    if (next2 - start > width) {
      end = curr > start ? curr : next2;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next2;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state2, level, object) {
  var _result = "", _tag = state2.tag, index2, length, value;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    value = object[index2];
    if (state2.replacer) {
      value = state2.replacer.call(object, String(index2), value);
    }
    if (writeNode(state2, level, value, false, false) || typeof value === "undefined" && writeNode(state2, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state2.condenseFlow ? " " : "");
      _result += state2.dump;
    }
  }
  state2.tag = _tag;
  state2.dump = "[" + _result + "]";
}
function writeBlockSequence(state2, level, object, compact) {
  var _result = "", _tag = state2.tag, index2, length, value;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    value = object[index2];
    if (state2.replacer) {
      value = state2.replacer.call(object, String(index2), value);
    }
    if (writeNode(state2, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state2, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state2, level);
      }
      if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state2.dump;
    }
  }
  state2.tag = _tag;
  state2.dump = _result || "[]";
}
function writeFlowMapping(state2, level, object) {
  var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, pairBuffer;
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state2.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index2];
    objectValue = object[objectKey];
    if (state2.replacer) {
      objectValue = state2.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state2, level, objectKey, false, false)) {
      continue;
    }
    if (state2.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state2.dump + (state2.condenseFlow ? '"' : "") + ":" + (state2.condenseFlow ? "" : " ");
    if (!writeNode(state2, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state2.dump;
    _result += pairBuffer;
  }
  state2.tag = _tag;
  state2.dump = "{" + _result + "}";
}
function writeBlockMapping(state2, level, object, compact) {
  var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state2.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state2.sortKeys === "function") {
    objectKeyList.sort(state2.sortKeys);
  } else if (state2.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state2, level);
    }
    objectKey = objectKeyList[index2];
    objectValue = object[objectKey];
    if (state2.replacer) {
      objectValue = state2.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state2, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state2.tag !== null && state2.tag !== "?" || state2.dump && state2.dump.length > 1024;
    if (explicitPair) {
      if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state2.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state2, level);
    }
    if (!writeNode(state2, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state2.dump;
    _result += pairBuffer;
  }
  state2.tag = _tag;
  state2.dump = _result || "{}";
}
function detectType(state2, object, explicit) {
  var _result, typeList, index2, length, type2, style;
  typeList = explicit ? state2.explicitTypes : state2.implicitTypes;
  for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {
    type2 = typeList[index2];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state2.tag = type2.representName(object);
        } else {
          state2.tag = type2.tag;
        }
      } else {
        state2.tag = "?";
      }
      if (type2.represent) {
        style = state2.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state2.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state2, level, object, block2, compact, iskey, isblockseq) {
  state2.tag = null;
  state2.dump = object;
  if (!detectType(state2, object, false)) {
    detectType(state2, object, true);
  }
  var type2 = _toString.call(state2.dump);
  var inblock = block2;
  var tagStr;
  if (block2) {
    block2 = state2.flowLevel < 0 || state2.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state2.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state2.tag !== null && state2.tag !== "?" || duplicate || state2.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state2.usedDuplicates[duplicateIndex]) {
    state2.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state2.usedDuplicates[duplicateIndex]) {
      state2.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block2 && Object.keys(state2.dump).length !== 0) {
        writeBlockMapping(state2, level, state2.dump, compact);
        if (duplicate) {
          state2.dump = "&ref_" + duplicateIndex + state2.dump;
        }
      } else {
        writeFlowMapping(state2, level, state2.dump);
        if (duplicate) {
          state2.dump = "&ref_" + duplicateIndex + " " + state2.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block2 && state2.dump.length !== 0) {
        if (state2.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state2, level - 1, state2.dump, compact);
        } else {
          writeBlockSequence(state2, level, state2.dump, compact);
        }
        if (duplicate) {
          state2.dump = "&ref_" + duplicateIndex + state2.dump;
        }
      } else {
        writeFlowSequence(state2, level, state2.dump);
        if (duplicate) {
          state2.dump = "&ref_" + duplicateIndex + " " + state2.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state2.tag !== "?") {
        writeScalar(state2, state2.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state2.skipInvalid) return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state2.tag !== null && state2.tag !== "?") {
      tagStr = encodeURI(
        state2.tag[0] === "!" ? state2.tag.slice(1) : state2.tag
      ).replace(/!/g, "%21");
      if (state2.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state2.dump = tagStr + " " + state2.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state2) {
  var objects = [], duplicatesIndexes = [], index2, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {
    state2.duplicates.push(objects[duplicatesIndexes[index2]]);
  }
  state2.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index2, length;
  if (object !== null && typeof object === "object") {
    index2 = objects.indexOf(object);
    if (index2 !== -1) {
      if (duplicatesIndexes.indexOf(index2) === -1) {
        duplicatesIndexes.push(index2);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
          inspectNode(object[index2], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
          inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state2 = new State(options);
  if (!state2.noRefs) getDuplicateReferences(input, state2);
  var value = input;
  if (state2.replacer) {
    value = state2.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state2, 0, value, true, true)) return state2.dump + "\n";
  return "";
}
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var isNothing_1, isObject_1, toArray_1, repeat_1, isNegativeZero_1, extend_1, common, exception, snippet2, TYPE_CONSTRUCTOR_OPTIONS, YAML_NODE_KINDS, type, schema, str, seq, map, failsafe, _null, bool, int, YAML_FLOAT_PATTERN, SCIENTIFIC_WITHOUT_DOT, float, json, core, YAML_DATE_REGEXP, YAML_TIMESTAMP_REGEXP, timestamp, merge, BASE64_MAP, binary, _hasOwnProperty$3, _toString$2, omap, _toString$1, pairs, _hasOwnProperty$2, set2, _default, _hasOwnProperty$1, CONTEXT_FLOW_IN, CONTEXT_FLOW_OUT, CONTEXT_BLOCK_IN, CONTEXT_BLOCK_OUT, CHOMPING_CLIP, CHOMPING_STRIP, CHOMPING_KEEP, PATTERN_NON_PRINTABLE, PATTERN_NON_ASCII_LINE_BREAKS, PATTERN_FLOW_INDICATORS, PATTERN_TAG_HANDLE, PATTERN_TAG_URI, simpleEscapeCheck, simpleEscapeMap, i, directiveHandlers, loadAll_1, load_1, loader, _toString, _hasOwnProperty, CHAR_BOM, CHAR_TAB, CHAR_LINE_FEED, CHAR_CARRIAGE_RETURN, CHAR_SPACE, CHAR_EXCLAMATION, CHAR_DOUBLE_QUOTE, CHAR_SHARP, CHAR_PERCENT, CHAR_AMPERSAND, CHAR_SINGLE_QUOTE, CHAR_ASTERISK, CHAR_COMMA, CHAR_MINUS, CHAR_COLON, CHAR_EQUALS, CHAR_GREATER_THAN, CHAR_QUESTION, CHAR_COMMERCIAL_AT, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_GRAVE_ACCENT, CHAR_LEFT_CURLY_BRACKET, CHAR_VERTICAL_LINE, CHAR_RIGHT_CURLY_BRACKET, ESCAPE_SEQUENCES, DEPRECATED_BOOLEANS_SYNTAX, DEPRECATED_BASE60_SYNTAX, QUOTING_TYPE_SINGLE, QUOTING_TYPE_DOUBLE, STYLE_PLAIN, STYLE_SINGLE, STYLE_LITERAL, STYLE_FOLDED, STYLE_DOUBLE, dump_1, dumper, load, loadAll, dump, safeLoad, safeLoadAll, safeDump;
var init_js_yaml = __esm({
  "node_modules/js-yaml/dist/js-yaml.mjs"() {
    isNothing_1 = isNothing;
    isObject_1 = isObject;
    toArray_1 = toArray;
    repeat_1 = repeat;
    isNegativeZero_1 = isNegativeZero;
    extend_1 = extend;
    common = {
      isNothing: isNothing_1,
      isObject: isObject_1,
      toArray: toArray_1,
      repeat: repeat_1,
      isNegativeZero: isNegativeZero_1,
      extend: extend_1
    };
    YAMLException$1.prototype = Object.create(Error.prototype);
    YAMLException$1.prototype.constructor = YAMLException$1;
    YAMLException$1.prototype.toString = function toString(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    exception = YAMLException$1;
    snippet2 = makeSnippet;
    TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    type = Type$1;
    Schema$1.prototype.extend = function extend2(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof type) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit) implicit = implicit.concat(definition.implicit);
        if (definition.explicit) explicit = explicit.concat(definition.explicit);
      } else {
        throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) {
          throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type$1.loadKind && type$1.loadKind !== "scalar") {
          throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type$1.multi) {
          throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) {
          throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema$1.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    schema = Schema$1;
    str = new type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
    seq = new type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
    map = new type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
    failsafe = new schema({
      explicit: [
        str,
        seq,
        map
      ]
    });
    _null = new type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
    bool = new type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
    int = new type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
    YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    float = new type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
    json = failsafe.extend({
      implicit: [
        _null,
        bool,
        int,
        float
      ]
    });
    core = json;
    YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    timestamp = new type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
    merge = new type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
    BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    binary = new type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
    _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    _toString$2 = Object.prototype.toString;
    omap = new type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
    _toString$1 = Object.prototype.toString;
    pairs = new type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
    _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    set2 = new type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
    _default = core.extend({
      implicit: [
        timestamp,
        merge
      ],
      explicit: [
        binary,
        omap,
        pairs,
        set2
      ]
    });
    _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    CONTEXT_FLOW_IN = 1;
    CONTEXT_FLOW_OUT = 2;
    CONTEXT_BLOCK_IN = 3;
    CONTEXT_BLOCK_OUT = 4;
    CHOMPING_CLIP = 1;
    CHOMPING_STRIP = 2;
    CHOMPING_KEEP = 3;
    PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    simpleEscapeCheck = new Array(256);
    simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    directiveHandlers = {
      YAML: function handleYamlDirective(state2, name3, args) {
        var match, major, minor;
        if (state2.version !== null) {
          throwError(state2, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state2, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state2, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state2, "unacceptable YAML version of the document");
        }
        state2.version = args[0];
        state2.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state2, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state2, name3, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state2, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state2, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty$1.call(state2.tagMap, handle)) {
          throwError(state2, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state2, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state2, "tag prefix is malformed: " + prefix);
        }
        state2.tagMap[handle] = prefix;
      }
    };
    loadAll_1 = loadAll$1;
    load_1 = load$1;
    loader = {
      loadAll: loadAll_1,
      load: load_1
    };
    _toString = Object.prototype.toString;
    _hasOwnProperty = Object.prototype.hasOwnProperty;
    CHAR_BOM = 65279;
    CHAR_TAB = 9;
    CHAR_LINE_FEED = 10;
    CHAR_CARRIAGE_RETURN = 13;
    CHAR_SPACE = 32;
    CHAR_EXCLAMATION = 33;
    CHAR_DOUBLE_QUOTE = 34;
    CHAR_SHARP = 35;
    CHAR_PERCENT = 37;
    CHAR_AMPERSAND = 38;
    CHAR_SINGLE_QUOTE = 39;
    CHAR_ASTERISK = 42;
    CHAR_COMMA = 44;
    CHAR_MINUS = 45;
    CHAR_COLON = 58;
    CHAR_EQUALS = 61;
    CHAR_GREATER_THAN = 62;
    CHAR_QUESTION = 63;
    CHAR_COMMERCIAL_AT = 64;
    CHAR_LEFT_SQUARE_BRACKET = 91;
    CHAR_RIGHT_SQUARE_BRACKET = 93;
    CHAR_GRAVE_ACCENT = 96;
    CHAR_LEFT_CURLY_BRACKET = 123;
    CHAR_VERTICAL_LINE = 124;
    CHAR_RIGHT_CURLY_BRACKET = 125;
    ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    QUOTING_TYPE_SINGLE = 1;
    QUOTING_TYPE_DOUBLE = 2;
    STYLE_PLAIN = 1;
    STYLE_SINGLE = 2;
    STYLE_LITERAL = 3;
    STYLE_FOLDED = 4;
    STYLE_DOUBLE = 5;
    dump_1 = dump$1;
    dumper = {
      dump: dump_1
    };
    load = loader.load;
    loadAll = loader.loadAll;
    dump = dumper.dump;
    safeLoad = renamed("safeLoad", "load");
    safeLoadAll = renamed("safeLoadAll", "loadAll");
    safeDump = renamed("safeDump", "dump");
  }
});

// node_modules/@plures/praxis/dist/node/chunk-UY7YEBE2.js
var init_chunk_UY7YEBE2 = __esm({
  "node_modules/@plures/praxis/dist/node/chunk-UY7YEBE2.js"() {
    init_chunk_UATVJBNV();
    init_js_yaml();
  }
});

// node_modules/@plures/praxis/dist/node/chunk-QGM4M3NI.js
var init_chunk_QGM4M3NI = __esm({
  "node_modules/@plures/praxis/dist/node/chunk-QGM4M3NI.js"() {
  }
});

// node_modules/@plures/praxis/dist/node/index.js
function defineFact(tag2) {
  return {
    tag: tag2,
    create(payload) {
      return { tag: tag2, payload };
    },
    is(fact) {
      return fact.tag === tag2;
    }
  };
}
function defineEvent(tag2) {
  return {
    tag: tag2,
    create(payload) {
      return { tag: tag2, payload };
    },
    is(event2) {
      return event2.tag === tag2;
    }
  };
}
function defineRule(options) {
  return {
    id: options.id,
    description: options.description,
    impl: options.impl,
    meta: options.meta
  };
}
function findEvent(events, definition) {
  return events.find(definition.is);
}
var init_node = __esm({
  "node_modules/@plures/praxis/dist/node/index.js"() {
    init_chunk_JQ64KMLN();
    init_chunk_S54337I5();
    init_chunk_SRM3OPPM();
    init_chunk_LE2ZJYFC();
    init_chunk_N5Y37EUV();
    init_chunk_RJMWCNHR();
    init_chunk_UY7YEBE2();
    init_chunk_UATVJBNV();
    init_chunk_VOMLVI6V();
    init_chunk_QGM4M3NI();
  }
});

// src/praxis/connection/facts.ts
var ConnectionStateFact, ConnectionDataFact, ConnectionEstablishedFact, ConnectionFailedFact, ConnectEvent, DisconnectEvent, AuthenticatedEvent, AuthConnectionFailedEvent, ClientCreatedEvent, ClientFailedEvent, ProviderCreatedEvent, ProviderFailedEvent, ConnectionErrorEvent, TokenExpiredConnectionEvent, RefreshAuthEvent, TokenRefreshedEvent, TokenRefreshFailedEvent, RetryConnectionEvent, ResetConnectionEvent;
var init_facts = __esm({
  "src/praxis/connection/facts.ts"() {
    "use strict";
    init_node();
    ConnectionStateFact = defineFact(
      "ConnectionState"
    );
    ConnectionDataFact = defineFact(
      "ConnectionData"
    );
    ConnectionEstablishedFact = defineFact("ConnectionEstablished");
    ConnectionFailedFact = defineFact("ConnectionFailed");
    ConnectEvent = defineEvent("CONNECT");
    DisconnectEvent = defineEvent("DISCONNECT");
    AuthenticatedEvent = defineEvent("AUTHENTICATED");
    AuthConnectionFailedEvent = defineEvent(
      "AUTH_CONNECTION_FAILED"
    );
    ClientCreatedEvent = defineEvent(
      "CLIENT_CREATED"
    );
    ClientFailedEvent = defineEvent("CLIENT_FAILED");
    ProviderCreatedEvent = defineEvent(
      "PROVIDER_CREATED"
    );
    ProviderFailedEvent = defineEvent(
      "PROVIDER_FAILED"
    );
    ConnectionErrorEvent = defineEvent(
      "CONNECTION_ERROR"
    );
    TokenExpiredConnectionEvent = defineEvent(
      "TOKEN_EXPIRED"
    );
    RefreshAuthEvent = defineEvent("REFRESH_AUTH");
    TokenRefreshedEvent = defineEvent("TOKEN_REFRESHED");
    TokenRefreshFailedEvent = defineEvent(
      "TOKEN_REFRESH_FAILED"
    );
    RetryConnectionEvent = defineEvent("RETRY");
    ResetConnectionEvent = defineEvent("RESET");
  }
});

// src/praxis/connection/rules.ts
var connectRule, disconnectRule, authenticatedRule, authConnectionFailedRule, clientCreatedRule, clientFailedRule, providerCreatedRule, providerFailedRule, connectionErrorRule, tokenExpiredConnectionRule, refreshAuthRule, tokenRefreshedRule, tokenRefreshFailedRule, retryConnectionRule, resetConnectionRule;
var init_rules = __esm({
  "src/praxis/connection/rules.ts"() {
    "use strict";
    init_node();
    init_types2();
    init_facts();
    connectRule = defineRule({
      id: "connection.connect",
      description: "Initiate connection to Azure DevOps",
      impl: (state2, events) => {
        const connectEvent = findEvent(events, ConnectEvent);
        if (!connectEvent) return [];
        const allowedStates = [
          "disconnected",
          "auth_failed",
          "client_failed",
          "provider_failed",
          "connection_error"
        ];
        if (!allowedStates.includes(state2.context.connectionState)) return [];
        state2.context.connectionState = "authenticating";
        state2.context.connectionData = {
          ...state2.context.connectionData,
          config: connectEvent.payload.config,
          connectionId: connectEvent.payload.config.id,
          authMethod: connectEvent.payload.config.authMethod || "pat",
          forceInteractive: connectEvent.payload.forceInteractive || false,
          retryCount: 0,
          lastError: void 0
        };
        return [];
      }
    });
    disconnectRule = defineRule({
      id: "connection.disconnect",
      description: "Disconnect from Azure DevOps",
      impl: (state2, events) => {
        const disconnectEvent = findEvent(events, DisconnectEvent);
        if (!disconnectEvent) return [];
        state2.context.connectionState = "disconnected";
        state2.context.connectionData = {
          ...state2.context.connectionData,
          isConnected: false,
          client: void 0,
          provider: void 0,
          credential: void 0,
          pat: void 0,
          accessToken: void 0,
          accessTokenExpiresAt: void 0,
          lastError: void 0,
          forceInteractive: false
        };
        return [];
      }
    });
    authenticatedRule = defineRule({
      id: "connection.authenticated",
      description: "Handle successful authentication",
      impl: (state2, events) => {
        const authEvent = findEvent(events, AuthenticatedEvent);
        if (!authEvent) return [];
        if (state2.context.connectionState !== "authenticating") return [];
        state2.context.connectionState = "creating_client";
        state2.context.connectionData = {
          ...state2.context.connectionData,
          credential: authEvent.payload.credential,
          accessToken: authEvent.payload.credential,
          accessTokenExpiresAt: authEvent.payload.expiresAt,
          lastError: void 0
        };
        return [];
      }
    });
    authConnectionFailedRule = defineRule({
      id: "connection.authFailed",
      description: "Handle authentication failure",
      impl: (state2, events) => {
        const failedEvent = findEvent(events, AuthConnectionFailedEvent);
        if (!failedEvent) return [];
        if (state2.context.connectionState !== "authenticating") return [];
        state2.context.connectionState = "auth_failed";
        state2.context.connectionData = {
          ...state2.context.connectionData,
          lastError: failedEvent.payload.error,
          retryCount: state2.context.connectionData.retryCount + 1,
          reauthInProgress: false,
          forceInteractive: false
        };
        return [];
      }
    });
    clientCreatedRule = defineRule({
      id: "connection.clientCreated",
      description: "Handle Azure client creation success",
      impl: (state2, events) => {
        const clientEvent = findEvent(events, ClientCreatedEvent);
        if (!clientEvent) return [];
        if (state2.context.connectionState !== "creating_client") return [];
        state2.context.connectionState = "creating_provider";
        state2.context.connectionData = {
          ...state2.context.connectionData,
          client: clientEvent.payload.client
        };
        return [];
      }
    });
    clientFailedRule = defineRule({
      id: "connection.clientFailed",
      description: "Handle Azure client creation failure",
      impl: (state2, events) => {
        const failedEvent = findEvent(events, ClientFailedEvent);
        if (!failedEvent) return [];
        if (state2.context.connectionState !== "creating_client") return [];
        state2.context.connectionState = "client_failed";
        state2.context.connectionData = {
          ...state2.context.connectionData,
          lastError: failedEvent.payload.error
        };
        return [];
      }
    });
    providerCreatedRule = defineRule({
      id: "connection.providerCreated",
      description: "Handle provider creation success",
      impl: (state2, events) => {
        const providerEvent = findEvent(events, ProviderCreatedEvent);
        if (!providerEvent) return [];
        if (state2.context.connectionState !== "creating_provider") return [];
        state2.context.connectionState = "connected";
        state2.context.connectionData = {
          ...state2.context.connectionData,
          provider: providerEvent.payload.provider,
          isConnected: true,
          retryCount: 0,
          lastError: void 0
        };
        return [];
      }
    });
    providerFailedRule = defineRule({
      id: "connection.providerFailed",
      description: "Handle provider creation failure",
      impl: (state2, events) => {
        const failedEvent = findEvent(events, ProviderFailedEvent);
        if (!failedEvent) return [];
        if (state2.context.connectionState !== "creating_provider") return [];
        state2.context.connectionState = "provider_failed";
        state2.context.connectionData = {
          ...state2.context.connectionData,
          lastError: failedEvent.payload.error
        };
        return [];
      }
    });
    connectionErrorRule = defineRule({
      id: "connection.error",
      description: "Handle connection error",
      impl: (state2, events) => {
        const errorEvent = findEvent(events, ConnectionErrorEvent);
        if (!errorEvent) return [];
        if (state2.context.connectionState !== "connected") return [];
        state2.context.connectionState = "connection_error";
        state2.context.connectionData = {
          ...state2.context.connectionData,
          lastError: errorEvent.payload.error,
          isConnected: false
        };
        return [];
      }
    });
    tokenExpiredConnectionRule = defineRule({
      id: "connection.tokenExpired",
      description: "Handle token expiration",
      impl: (state2, events) => {
        const expiredEvent = findEvent(events, TokenExpiredConnectionEvent);
        if (!expiredEvent) return [];
        if (state2.context.connectionState !== "connected") return [];
        if (state2.context.connectionData.authMethod === "entra") {
          state2.context.connectionState = "auth_failed";
          state2.context.connectionData = {
            ...state2.context.connectionData,
            lastError: "Session expired. Please sign in again."
          };
        } else {
          state2.context.connectionState = "token_refresh";
        }
        return [];
      }
    });
    refreshAuthRule = defineRule({
      id: "connection.refreshAuth",
      description: "Start authentication token refresh",
      impl: (state2, events) => {
        const refreshEvent = findEvent(events, RefreshAuthEvent);
        if (!refreshEvent) return [];
        if (state2.context.connectionState !== "connected") return [];
        state2.context.connectionState = "token_refresh";
        return [];
      }
    });
    tokenRefreshedRule = defineRule({
      id: "connection.tokenRefreshed",
      description: "Handle successful token refresh",
      impl: (state2, events) => {
        const refreshedEvent = findEvent(events, TokenRefreshedEvent);
        if (!refreshedEvent) return [];
        if (state2.context.connectionState !== "token_refresh") return [];
        state2.context.connectionState = "connected";
        state2.context.connectionData = {
          ...state2.context.connectionData,
          credential: refreshedEvent.payload.token,
          accessToken: refreshedEvent.payload.token,
          accessTokenExpiresAt: refreshedEvent.payload.expiresAt,
          refreshFailureCount: 0,
          lastRefreshFailure: void 0,
          refreshBackoffUntil: void 0
        };
        return [];
      }
    });
    tokenRefreshFailedRule = defineRule({
      id: "connection.tokenRefreshFailed",
      description: "Handle failed token refresh",
      impl: (state2, events) => {
        const failedEvent = findEvent(events, TokenRefreshFailedEvent);
        if (!failedEvent) return [];
        if (state2.context.connectionState !== "token_refresh") return [];
        const newFailureCount = state2.context.connectionData.refreshFailureCount + 1;
        const backoffMinutes = Math.min(
          DEFAULT_CONNECTION_CONFIG.maxRefreshBackoffMinutes,
          Math.pow(2, newFailureCount) * DEFAULT_CONNECTION_CONFIG.refreshBackoffMinutes
        );
        state2.context.connectionState = "auth_failed";
        state2.context.connectionData = {
          ...state2.context.connectionData,
          lastError: failedEvent.payload.error,
          refreshFailureCount: newFailureCount,
          lastRefreshFailure: /* @__PURE__ */ new Date(),
          refreshBackoffUntil: new Date(Date.now() + backoffMinutes * 60 * 1e3)
        };
        return [];
      }
    });
    retryConnectionRule = defineRule({
      id: "connection.retry",
      description: "Retry connection after failure",
      impl: (state2, events) => {
        const retryEvent = findEvent(events, RetryConnectionEvent);
        if (!retryEvent) return [];
        const failedStates = ["auth_failed", "client_failed", "provider_failed", "connection_error"];
        if (!failedStates.includes(state2.context.connectionState)) return [];
        if (state2.context.connectionData.retryCount >= DEFAULT_CONNECTION_CONFIG.maxRetryCount) {
          return [];
        }
        state2.context.connectionState = "authenticating";
        state2.context.connectionData = {
          ...state2.context.connectionData,
          lastError: void 0
        };
        return [];
      }
    });
    resetConnectionRule = defineRule({
      id: "connection.reset",
      description: "Reset connection state",
      impl: (state2, events) => {
        const resetEvent = findEvent(events, ResetConnectionEvent);
        if (!resetEvent) return [];
        state2.context.connectionState = "disconnected";
        state2.context.connectionData = {
          ...state2.context.connectionData,
          retryCount: 0,
          refreshFailureCount: 0,
          lastRefreshFailure: void 0,
          refreshBackoffUntil: void 0,
          reauthInProgress: false,
          lastError: void 0,
          forceInteractive: false,
          client: void 0,
          provider: void 0,
          credential: void 0,
          isConnected: false
        };
        return [];
      }
    });
  }
});

// src/praxis/connection/engine.ts
function createConnectionEngine(config, initialConfig) {
  const registry2 = new PraxisRegistry();
  registry2.registerRule(connectRule);
  registry2.registerRule(disconnectRule);
  registry2.registerRule(authenticatedRule);
  registry2.registerRule(authConnectionFailedRule);
  registry2.registerRule(clientCreatedRule);
  registry2.registerRule(clientFailedRule);
  registry2.registerRule(providerCreatedRule);
  registry2.registerRule(providerFailedRule);
  registry2.registerRule(connectionErrorRule);
  registry2.registerRule(tokenExpiredConnectionRule);
  registry2.registerRule(refreshAuthRule);
  registry2.registerRule(tokenRefreshedRule);
  registry2.registerRule(tokenRefreshFailedRule);
  registry2.registerRule(retryConnectionRule);
  registry2.registerRule(resetConnectionRule);
  return createPraxisEngine({
    initialContext: {
      connectionState: "disconnected",
      connectionData: {
        connectionId: config.id,
        config,
        authMethod: config.authMethod || "pat",
        isConnected: false,
        retryCount: 0,
        refreshFailureCount: 0,
        reauthInProgress: false,
        forceInteractive: false,
        ...initialConfig
      }
    },
    registry: registry2,
    initialFacts: []
  });
}
var init_engine = __esm({
  "src/praxis/connection/engine.ts"() {
    "use strict";
    init_node();
    init_rules();
  }
});

// src/praxis/connection/manager.ts
var PraxisConnectionManager;
var init_manager = __esm({
  "src/praxis/connection/manager.ts"() {
    "use strict";
    init_types2();
    init_facts();
    init_engine();
    PraxisConnectionManager = class {
      engine;
      isStarted = false;
      constructor(config, initialConfig) {
        this.engine = createConnectionEngine(config, initialConfig);
      }
      start() {
        this.isStarted = true;
      }
      stop() {
        this.isStarted = false;
      }
      getConnectionState() {
        return this.engine.getContext().connectionState;
      }
      getConnectionData() {
        return this.engine.getContext().connectionData;
      }
      /**
       * Initiate connection
       */
      connect(options) {
        if (!this.isStarted) return false;
        if (this.getConnectionState() !== "disconnected") return false;
        const config = this.getConnectionData().config;
        this.engine.step([
          ConnectEvent.create({
            config,
            forceInteractive: options?.forceInteractive
          })
        ]);
        return this.getConnectionState() === "authenticating";
      }
      /**
       * Disconnect from Azure DevOps
       */
      disconnect() {
        if (!this.isStarted) return false;
        this.engine.step([DisconnectEvent.create({})]);
        return this.getConnectionState() === "disconnected";
      }
      /**
       * Handle successful authentication
       */
      authenticated(credential, expiresAt) {
        if (!this.isStarted) return false;
        if (this.getConnectionState() !== "authenticating") return false;
        this.engine.step([AuthenticatedEvent.create({ credential, expiresAt })]);
        return this.getConnectionState() === "creating_client";
      }
      /**
       * Handle failed authentication
       */
      authFailed(error) {
        if (!this.isStarted) return false;
        if (this.getConnectionState() !== "authenticating") return false;
        this.engine.step([AuthConnectionFailedEvent.create({ error })]);
        return this.getConnectionState() === "auth_failed";
      }
      /**
       * Handle client creation success
       */
      clientCreated(client2) {
        if (!this.isStarted) return false;
        if (this.getConnectionState() !== "creating_client") return false;
        this.engine.step([ClientCreatedEvent.create({ client: client2 })]);
        return this.getConnectionState() === "creating_provider";
      }
      /**
       * Handle client creation failure
       */
      clientFailed(error) {
        if (!this.isStarted) return false;
        if (this.getConnectionState() !== "creating_client") return false;
        this.engine.step([ClientFailedEvent.create({ error })]);
        return this.getConnectionState() === "client_failed";
      }
      /**
       * Handle provider creation success
       */
      providerCreated(provider2) {
        if (!this.isStarted) return false;
        if (this.getConnectionState() !== "creating_provider") return false;
        this.engine.step([ProviderCreatedEvent.create({ provider: provider2 })]);
        return this.getConnectionState() === "connected";
      }
      /**
       * Handle provider creation failure
       */
      providerFailed(error) {
        if (!this.isStarted) return false;
        if (this.getConnectionState() !== "creating_provider") return false;
        this.engine.step([ProviderFailedEvent.create({ error })]);
        return this.getConnectionState() === "provider_failed";
      }
      /**
       * Handle connection error
       */
      connectionError(error) {
        if (!this.isStarted) return false;
        if (this.getConnectionState() !== "connected") return false;
        this.engine.step([ConnectionErrorEvent.create({ error })]);
        return this.getConnectionState() === "connection_error";
      }
      /**
       * Handle token expiration
       */
      tokenExpired() {
        if (!this.isStarted) return false;
        if (this.getConnectionState() !== "connected") return false;
        this.engine.step([TokenExpiredConnectionEvent.create({})]);
        const newState = this.getConnectionState();
        return newState === "auth_failed" || newState === "token_refresh";
      }
      /**
       * Handle successful token refresh
       */
      tokenRefreshed(token, expiresAt) {
        if (!this.isStarted) return false;
        if (this.getConnectionState() !== "token_refresh") return false;
        this.engine.step([TokenRefreshedEvent.create({ token, expiresAt })]);
        return this.getConnectionState() === "connected";
      }
      /**
       * Handle failed token refresh
       */
      tokenRefreshFailed(error) {
        if (!this.isStarted) return false;
        if (this.getConnectionState() !== "token_refresh") return false;
        this.engine.step([TokenRefreshFailedEvent.create({ error })]);
        return this.getConnectionState() === "auth_failed";
      }
      /**
       * Retry connection after failure
       */
      retry() {
        if (!this.isStarted) return false;
        const currentState = this.getConnectionState();
        const failedStates = ["auth_failed", "client_failed", "provider_failed", "connection_error"];
        if (!failedStates.includes(currentState)) return false;
        const connectionData = this.getConnectionData();
        if (connectionData.retryCount >= DEFAULT_CONNECTION_CONFIG.maxRetryCount) {
          return false;
        }
        this.engine.step([RetryConnectionEvent.create({})]);
        return this.getConnectionState() === "authenticating";
      }
      /**
       * Reset connection state
       */
      reset() {
        if (!this.isStarted) return;
        this.engine.step([ResetConnectionEvent.create({})]);
      }
      /**
       * Check if connected
       */
      isConnected() {
        return this.getConnectionState() === "connected";
      }
      /**
       * Check if authenticating
       */
      isAuthenticating() {
        return this.getConnectionState() === "authenticating";
      }
      /**
       * Check if in a failed state
       */
      isFailed() {
        const failedStates = ["auth_failed", "client_failed", "provider_failed", "connection_error"];
        return failedStates.includes(this.getConnectionState());
      }
      /**
       * Get the client if available
       */
      getClient() {
        if (!this.isConnected()) return void 0;
        return this.getConnectionData().client;
      }
      /**
       * Get the provider if available
       */
      getProvider() {
        if (!this.isConnected()) return void 0;
        return this.getConnectionData().provider;
      }
      /**
       * Get connection snapshot
       */
      getSnapshot() {
        const state2 = this.getConnectionState();
        const data = this.getConnectionData();
        return {
          state: state2,
          connectionId: data.connectionId,
          isConnected: data.isConnected,
          authMethod: data.authMethod,
          hasClient: !!data.client,
          hasProvider: !!data.provider,
          error: data.lastError,
          retryCount: data.retryCount
        };
      }
      /**
       * Get status information
       */
      getStatus() {
        return {
          isStarted: this.isStarted,
          connectionState: this.getConnectionState(),
          connectionContext: this.getConnectionData()
        };
      }
      /**
       * Validate that manager is in sync
       */
      validateSync() {
        return this.isStarted;
      }
      /**
       * Get the underlying engine for advanced operations
       */
      getEngine() {
        return this.engine;
      }
    };
  }
});

// src/logging/ComponentLogger.ts
var ComponentLogger_exports = {};
__export(ComponentLogger_exports, {
  Component: () => Component,
  ComponentLogger: () => ComponentLogger,
  LOG_LEVEL_NAMES: () => LOG_LEVEL_NAMES,
  LogLevel: () => LogLevel,
  componentLogger: () => componentLogger,
  createComponentLogger: () => createComponentLogger
});
async function getVscode() {
  if (vscode5) return vscode5;
  try {
    if (typeof window === "undefined") {
      vscode5 = await import("vscode");
    }
  } catch {
  }
  return vscode5;
}
function createComponentLogger(component2, instanceId) {
  return {
    debug: (message, context, data) => componentLogger.debug(component2, message, { component: component2, instanceId, ...context }, data),
    info: (message, context, data) => componentLogger.info(component2, message, { component: component2, instanceId, ...context }, data),
    warn: (message, context, data) => componentLogger.warn(component2, message, { component: component2, instanceId, ...context }, data),
    error: (message, context, data) => componentLogger.error(component2, message, { component: component2, instanceId, ...context }, data),
    logStateTransition: (fromState, toState, event2, machineId) => componentLogger.logStateTransition(
      component2,
      instanceId || "unknown",
      fromState,
      toState,
      event2,
      machineId
    ),
    logEvent: (event2, currentState, machineId, data) => componentLogger.logEvent(
      component2,
      instanceId || "unknown",
      event2,
      currentState,
      machineId,
      data
    ),
    logError: (error, currentState, machineId) => componentLogger.logError(component2, instanceId || "unknown", error, currentState, machineId)
  };
}
var vscode5, LogLevel, LOG_LEVEL_NAMES, Component, DEFAULT_CONFIG, ComponentLogger, componentLogger;
var init_ComponentLogger = __esm({
  "src/logging/ComponentLogger.ts"() {
    "use strict";
    vscode5 = null;
    LogLevel = /* @__PURE__ */ ((LogLevel3) => {
      LogLevel3[LogLevel3["DEBUG"] = 0] = "DEBUG";
      LogLevel3[LogLevel3["INFO"] = 1] = "INFO";
      LogLevel3[LogLevel3["WARN"] = 2] = "WARN";
      LogLevel3[LogLevel3["ERROR"] = 3] = "ERROR";
      LogLevel3[LogLevel3["OFF"] = 4] = "OFF";
      return LogLevel3;
    })(LogLevel || {});
    LOG_LEVEL_NAMES = {
      [0 /* DEBUG */]: "DEBUG",
      [1 /* INFO */]: "INFO",
      [2 /* WARN */]: "WARN",
      [3 /* ERROR */]: "ERROR",
      [4 /* OFF */]: "OFF"
    };
    Component = /* @__PURE__ */ ((Component2) => {
      Component2["APPLICATION"] = "APPLICATION";
      Component2["CONNECTION"] = "CONNECTION";
      Component2["TIMER"] = "TIMER";
      Component2["WEBVIEW"] = "WEBVIEW";
      Component2["AUTH"] = "AUTH";
      Component2["DATA"] = "DATA";
      Component2["ADAPTER"] = "ADAPTER";
      Component2["MACHINE"] = "MACHINE";
      return Component2;
    })(Component || {});
    DEFAULT_CONFIG = {
      enabled: true,
      level: 0 /* DEBUG */,
      // More verbose logging by default
      components: {
        ["APPLICATION" /* APPLICATION */]: true,
        ["CONNECTION" /* CONNECTION */]: true,
        ["TIMER" /* TIMER */]: true,
        ["WEBVIEW" /* WEBVIEW */]: true,
        // Enable webview logging
        ["AUTH" /* AUTH */]: true,
        ["DATA" /* DATA */]: true,
        // Enable data logging
        ["ADAPTER" /* ADAPTER */]: true,
        // Enable adapter logging
        ["MACHINE" /* MACHINE */]: true
        // Enable machine logging
      },
      destinations: {
        console: true,
        outputChannel: true,
        file: false
      },
      includeTimestamp: true,
      includeStackTrace: false,
      maxLogEntries: 1e3,
      contextTracking: true
    };
    ComponentLogger = class _ComponentLogger {
      static instance;
      config = DEFAULT_CONFIG;
      logBuffer = [];
      outputChannel;
      logCounter = 0;
      configListeners = [];
      logListeners = [];
      constructor() {
        void getVscode();
        this.loadConfiguration();
      }
      static getInstance() {
        if (!_ComponentLogger.instance) {
          _ComponentLogger.instance = new _ComponentLogger();
        }
        return _ComponentLogger.instance;
      }
      // ============================================================================
      // CONFIGURATION MANAGEMENT
      // ============================================================================
      loadConfiguration() {
        try {
          if (typeof vscode5 !== "undefined" && vscode5?.workspace) {
            const vscodeConfig = vscode5.workspace.getConfiguration("azureDevOpsIntegration.logging");
            this.config = {
              enabled: vscodeConfig.get("enabled", DEFAULT_CONFIG.enabled),
              level: vscodeConfig.get("level", DEFAULT_CONFIG.level),
              components: {
                ...DEFAULT_CONFIG.components,
                ...vscodeConfig.get("components", {})
              },
              destinations: {
                ...DEFAULT_CONFIG.destinations,
                ...vscodeConfig.get("destinations", {})
              },
              includeTimestamp: vscodeConfig.get("includeTimestamp", DEFAULT_CONFIG.includeTimestamp),
              includeStackTrace: vscodeConfig.get(
                "includeStackTrace",
                DEFAULT_CONFIG.includeStackTrace
              ),
              maxLogEntries: vscodeConfig.get("maxLogEntries", DEFAULT_CONFIG.maxLogEntries),
              contextTracking: vscodeConfig.get("contextTracking", DEFAULT_CONFIG.contextTracking)
            };
          } else {
            this.config = { ...DEFAULT_CONFIG };
          }
          this.configListeners.forEach((listener) => listener(this.config));
        } catch (error) {
          this.config = { ...DEFAULT_CONFIG };
        }
      }
      updateConfiguration(updates) {
        this.config = { ...this.config, ...updates };
        this.configListeners.forEach((listener) => listener(this.config));
        try {
          if (typeof vscode5 !== "undefined" && vscode5?.workspace) {
            const vscodeConfig = vscode5.workspace.getConfiguration("azureDevOpsIntegration.logging");
            Object.entries(updates).forEach(([key2, value]) => {
              vscodeConfig.update(key2, value, vscode5.ConfigurationTarget.Global);
            });
          }
        } catch (error) {
        }
      }
      onConfigurationChange(listener) {
        this.configListeners.push(listener);
        if (vscode5 && vscode5.Disposable) {
          return new vscode5.Disposable(() => {
            const index2 = this.configListeners.indexOf(listener);
            if (index2 >= 0) {
              this.configListeners.splice(index2, 1);
            }
          });
        } else {
          return {
            dispose: () => {
              const index2 = this.configListeners.indexOf(listener);
              if (index2 >= 0) {
                this.configListeners.splice(index2, 1);
              }
            }
          };
        }
      }
      onLogEntry(listener) {
        this.logListeners.push(listener);
        if (vscode5 && vscode5.Disposable) {
          return new vscode5.Disposable(() => {
            const index2 = this.logListeners.indexOf(listener);
            if (index2 >= 0) {
              this.logListeners.splice(index2, 1);
            }
          });
        } else {
          return {
            dispose: () => {
              const index2 = this.logListeners.indexOf(listener);
              if (index2 >= 0) {
                this.logListeners.splice(index2, 1);
              }
            }
          };
        }
      }
      // ============================================================================
      // OUTPUT CHANNEL MANAGEMENT
      // ============================================================================
      getOutputChannel() {
        if (!this.outputChannel) {
          if (typeof vscode5 !== "undefined" && vscode5?.window) {
            this.outputChannel = vscode5.window.createOutputChannel("Azure DevOps Int (Praxis)");
          } else {
            return null;
          }
        }
        return this.outputChannel;
      }
      // ============================================================================
      // CORE LOGGING METHODS
      // ============================================================================
      shouldLog(level, component2) {
        if (!this.config.enabled) return false;
        if (level < this.config.level) return false;
        if (!this.config.components[component2]) return false;
        return true;
      }
      createLogEntry(level, component2, message, context, data) {
        const entry = {
          id: `log_${++this.logCounter}`,
          timestamp: Date.now(),
          level,
          component: component2,
          message,
          context: this.config.contextTracking ? context : void 0,
          data
        };
        if (this.config.includeStackTrace && level >= 2 /* WARN */) {
          entry.stackTrace = new Error().stack;
        }
        return entry;
      }
      formatLogEntry(entry) {
        const timestamp2 = this.config.includeTimestamp ? new Date(entry.timestamp).toISOString() : "";
        const level = LOG_LEVEL_NAMES[entry.level].padEnd(5);
        const component2 = `[${entry.component}]`.padEnd(12);
        let contextStr = "";
        if (entry.context) {
          const parts = [];
          if (entry.context.instanceId) parts.push(`id:${entry.context.instanceId}`);
          if (entry.context.connectionId) parts.push(`conn:${entry.context.connectionId}`);
          if (entry.context.state) parts.push(`state:${entry.context.state}`);
          if (entry.context.event) parts.push(`event:${entry.context.event}`);
          if (entry.context.machineId) parts.push(`machine:${entry.context.machineId}`);
          if (parts.length > 0) {
            contextStr = `{${parts.join(", ")}} `;
          }
        }
        let formatted = `${timestamp2} ${level} ${component2} ${contextStr}${entry.message}`;
        if (entry.data) {
          formatted += `
  Data: ${JSON.stringify(entry.data, null, 2)}`;
        }
        if (entry.stackTrace && this.config.includeStackTrace) {
          formatted += `
  Stack: ${entry.stackTrace}`;
        }
        return formatted;
      }
      writeToDestinations(entry) {
        const formatted = this.formatLogEntry(entry);
        this.logListeners.forEach((listener) => {
          try {
            listener(entry);
          } catch (e) {
          }
        });
        if (this.config.destinations.console) {
          const levelName = LOG_LEVEL_NAMES[entry.level];
          switch (levelName) {
            case "ERROR":
              console.error(formatted);
              break;
            case "WARN":
              console.warn(formatted);
              break;
            case "INFO":
              console.info(formatted);
              break;
            case "DEBUG":
            case "TRACE":
              if (typeof console.debug === "function") {
                console.debug(formatted);
              } else {
                console.log(formatted);
              }
              break;
            default:
              console.log(formatted);
              break;
          }
        }
        if (this.config.destinations.outputChannel) {
          const outputChannel2 = this.getOutputChannel();
          if (outputChannel2) {
            outputChannel2.appendLine(formatted);
          }
        }
        if (this.config.destinations.file) {
        }
      }
      addToBuffer(entry) {
        this.logBuffer.push(entry);
        if (this.logBuffer.length > this.config.maxLogEntries) {
          this.logBuffer = this.logBuffer.slice(-this.config.maxLogEntries);
        }
      }
      log(level, component2, message, context, data) {
        if (!this.shouldLog(level, component2)) return;
        const entry = this.createLogEntry(level, component2, message, context, data);
        this.addToBuffer(entry);
        this.writeToDestinations(entry);
      }
      // ============================================================================
      // PUBLIC LOGGING API
      // ============================================================================
      debug(component2, message, context, data) {
        this.log(0 /* DEBUG */, component2, message, context, data);
      }
      info(component2, message, context, data) {
        this.log(1 /* INFO */, component2, message, context, data);
      }
      warn(component2, message, context, data) {
        this.log(2 /* WARN */, component2, message, context, data);
      }
      error(component2, message, context, data) {
        this.log(3 /* ERROR */, component2, message, context, data);
      }
      // ============================================================================
      // COMPONENT-SPECIFIC LOGGING HELPERS
      // ============================================================================
      logStateTransition(component2, instanceId, fromState, toState, event2, machineId) {
        this.info(component2, `State transition: ${fromState} \u2192 ${toState}`, {
          component: component2,
          instanceId,
          state: toState,
          event: event2,
          machineId
        });
      }
      logEvent(component2, instanceId, event2, currentState, machineId, data) {
        this.debug(
          component2,
          `Event: ${event2}`,
          {
            component: component2,
            instanceId,
            state: currentState,
            event: event2,
            machineId
          },
          data
        );
      }
      logError(component2, instanceId, error, currentState, machineId) {
        this.error(
          component2,
          `Error: ${error.message}`,
          {
            component: component2,
            instanceId,
            state: currentState,
            machineId
          },
          { error: error.stack }
        );
      }
      logConnectionActivity(connectionId, activity, state2, data) {
        this.info(
          "CONNECTION" /* CONNECTION */,
          activity,
          {
            component: "CONNECTION" /* CONNECTION */,
            connectionId,
            state: state2
          },
          data
        );
      }
      // ============================================================================
      // UTILITY METHODS
      // ============================================================================
      getLogBuffer() {
        return [...this.logBuffer];
      }
      clearLogBuffer() {
        this.logBuffer = [];
      }
      exportLogs() {
        return this.logBuffer.map((entry) => this.formatLogEntry(entry)).join("\n");
      }
      getConfiguration() {
        return { ...this.config };
      }
      showOutputChannel() {
        const outputChannel2 = this.getOutputChannel();
        if (outputChannel2) {
          outputChannel2.show(true);
        }
      }
      getStats() {
        const stats = {
          totalEntries: this.logBuffer.length,
          entriesByLevel: {},
          entriesByComponent: {}
        };
        Object.values(LogLevel).forEach((level) => {
          if (typeof level === "number") {
            stats.entriesByLevel[level] = 0;
          }
        });
        Object.values(Component).forEach((component2) => {
          stats.entriesByComponent[component2] = 0;
        });
        this.logBuffer.forEach((entry) => {
          stats.entriesByLevel[entry.level]++;
          stats.entriesByComponent[entry.component]++;
        });
        return stats;
      }
    };
    componentLogger = ComponentLogger.getInstance();
  }
});

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
var init_bind = __esm({
  "node_modules/axios/lib/helpers/bind.js"() {
    "use strict";
  }
});

// node_modules/axios/lib/utils.js
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    if (isBuffer(obj)) {
      return;
    }
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key2;
    for (i = 0; i < len; i++) {
      key2 = keys[i];
      fn.call(null, obj[key2], key2, obj);
    }
  }
}
function findKey(obj, key2) {
  if (isBuffer(obj)) {
    return null;
  }
  key2 = key2.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key2 === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
function merge2() {
  const { caseless, skipUndefined } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key2) => {
    const targetKey = caseless && findKey(result, key2) || key2;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge2(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge2({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
var toString2, getPrototypeOf, iterator, toStringTag, kindOf, kindOfTest, typeOfTest, isArray, isUndefined, isArrayBuffer, isString, isFunction, isNumber, isObject2, isBoolean2, isPlainObject, isEmptyObject, isDate, isFile, isBlob, isFileList, isStream, isFormData, isURLSearchParams, isReadableStream, isRequest, isResponse, isHeaders, trim, _global, isContextDefined, extend3, stripBOM, inherits, toFlatObject, endsWith, toArray2, isTypedArray, forEachEntry, matchAll, isHTMLForm, toCamelCase, hasOwnProperty, isRegExp, reduceDescriptors, freezeMethods, toObjectSet, noop2, toFiniteNumber, toJSONObject, isAsyncFn, isThenable, _setImmediate, asap, isIterable, utils_default;
var init_utils5 = __esm({
  "node_modules/axios/lib/utils.js"() {
    "use strict";
    init_bind();
    ({ toString: toString2 } = Object.prototype);
    ({ getPrototypeOf } = Object);
    ({ iterator, toStringTag } = Symbol);
    kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str2 = toString2.call(thing);
      return cache[str2] || (cache[str2] = str2.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    kindOfTest = (type2) => {
      type2 = type2.toLowerCase();
      return (thing) => kindOf(thing) === type2;
    };
    typeOfTest = (type2) => (thing) => typeof thing === type2;
    ({ isArray } = Array);
    isUndefined = typeOfTest("undefined");
    isArrayBuffer = kindOfTest("ArrayBuffer");
    isString = typeOfTest("string");
    isFunction = typeOfTest("function");
    isNumber = typeOfTest("number");
    isObject2 = (thing) => thing !== null && typeof thing === "object";
    isBoolean2 = (thing) => thing === true || thing === false;
    isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype3 = getPrototypeOf(val);
      return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(toStringTag in val) && !(iterator in val);
    };
    isEmptyObject = (val) => {
      if (!isObject2(val) || isBuffer(val)) {
        return false;
      }
      try {
        return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
      } catch (e) {
        return false;
      }
    };
    isDate = kindOfTest("Date");
    isFile = kindOfTest("File");
    isBlob = kindOfTest("Blob");
    isFileList = kindOfTest("FileList");
    isStream = (val) => isObject2(val) && isFunction(val.pipe);
    isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    isURLSearchParams = kindOfTest("URLSearchParams");
    [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
    trim = (str2) => str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    _global = (() => {
      if (typeof globalThis !== "undefined") return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    isContextDefined = (context) => !isUndefined(context) && context !== _global;
    extend3 = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key2) => {
        if (thisArg && isFunction(val)) {
          a[key2] = bind(val, thisArg);
        } else {
          a[key2] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
      let props;
      let i;
      let prop2;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null) return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop2 = props[i];
          if ((!propFilter || propFilter(prop2, sourceObj, destObj)) && !merged[prop2]) {
            destObj[prop2] = sourceObj[prop2];
            merged[prop2] = true;
          }
        }
        sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    endsWith = (str2, searchString, position) => {
      str2 = String(str2);
      if (position === void 0 || position > str2.length) {
        position = str2.length;
      }
      position -= searchString.length;
      const lastIndex = str2.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    toArray2 = (thing) => {
      if (!thing) return null;
      if (isArray(thing)) return thing;
      let i = thing.length;
      if (!isNumber(i)) return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    forEachEntry = (obj, fn) => {
      const generator = obj && obj[iterator];
      const _iterator = generator.call(obj);
      let result;
      while ((result = _iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    matchAll = (regExp, str2) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str2)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    isHTMLForm = kindOfTest("HTMLFormElement");
    toCamelCase = (str2) => {
      return str2.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop2) => hasOwnProperty2.call(obj, prop2))(Object.prototype);
    isRegExp = kindOfTest("RegExp");
    reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name3) => {
        let ret;
        if ((ret = reducer(descriptor, name3, obj)) !== false) {
          reducedDescriptors[name3] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name3) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name3) !== -1) {
          return false;
        }
        const value = obj[name3];
        if (!isFunction(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name3 + "'");
          };
        }
      });
    };
    toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
      return obj;
    };
    noop2 = () => {
    };
    toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };
    toJSONObject = (obj) => {
      const stack2 = new Array(10);
      const visit = (source2, i) => {
        if (isObject2(source2)) {
          if (stack2.indexOf(source2) >= 0) {
            return;
          }
          if (isBuffer(source2)) {
            return source2;
          }
          if (!("toJSON" in source2)) {
            stack2[i] = source2;
            const target = isArray(source2) ? [] : {};
            forEach(source2, (value, key2) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key2] = reducedValue);
            });
            stack2[i] = void 0;
            return target;
          }
        }
        return source2;
      };
      return visit(obj, 0);
    };
    isAsyncFn = kindOfTest("AsyncFunction");
    isThenable = (thing) => thing && (isObject2(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported ? ((token, callbacks) => {
        _global.addEventListener("message", ({ source: source2, data }) => {
          if (source2 === _global && data === token) {
            callbacks.length && callbacks.shift()();
          }
        }, false);
        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token, "*");
        };
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(
      typeof setImmediate === "function",
      isFunction(_global.postMessage)
    );
    asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
    isIterable = (thing) => thing != null && isFunction(thing[iterator]);
    utils_default = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean: isBoolean2,
      isObject: isObject2,
      isPlainObject,
      isEmptyObject,
      isReadableStream,
      isRequest,
      isResponse,
      isHeaders,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge: merge2,
      extend: extend3,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray: toArray2,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop: noop2,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap,
      isIterable
    };
  }
});

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
var prototype, descriptors, AxiosError_default;
var init_AxiosError = __esm({
  "node_modules/axios/lib/core/AxiosError.js"() {
    "use strict";
    init_utils5();
    utils_default.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils_default.toJSONObject(this.config),
          code: this.code,
          status: this.status
        };
      }
    });
    prototype = AxiosError.prototype;
    descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype);
      utils_default.toFlatObject(error, axiosError, function filter2(obj) {
        return obj !== Error.prototype;
      }, (prop2) => {
        return prop2 !== "isAxiosError";
      });
      const msg = error && error.message ? error.message : "Error";
      const errCode = code == null && error ? error.code : code;
      AxiosError.call(axiosError, msg, errCode, config, request, response);
      if (error && axiosError.cause == null) {
        Object.defineProperty(axiosError, "cause", { value: error, configurable: true });
      }
      axiosError.name = error && error.name || "Error";
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    AxiosError_default = AxiosError;
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    var util3 = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util3.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source2, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source2;
      var realEmit = source2.emit;
      source2.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source2, arguments);
      };
      source2.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source2.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    var util3 = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util3.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream4) {
      return typeof stream4 !== "function" && typeof stream4 !== "string" && typeof stream4 !== "boolean" && typeof stream4 !== "number" && !Buffer.isBuffer(stream4);
    };
    CombinedStream.prototype.append = function(stream4) {
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        if (!(stream4 instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream4, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream4.on("data", this._checkDataSize.bind(this));
          stream4 = newStream;
        }
        this._handleErrors(stream4);
        if (this.pauseStreams) {
          stream4.pause();
        }
      }
      this._streams.push(stream4);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream4 = this._streams.shift();
      if (typeof stream4 == "undefined") {
        this.end();
        return;
      }
      if (typeof stream4 !== "function") {
        this._pipeNext(stream4);
        return;
      }
      var getStream = stream4;
      getStream(function(stream5) {
        var isStreamLike = CombinedStream.isStreamLike(stream5);
        if (isStreamLike) {
          stream5.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream5);
        }
        this._pipeNext(stream5);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream4) {
      this._currentStream = stream4;
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        stream4.on("end", this._getNext.bind(this));
        stream4.pipe(this, { end: false });
        return;
      }
      var value = stream4;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream4) {
      var self3 = this;
      stream4.on("error", function(err) {
        self3._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self3 = this;
      this._streams.forEach(function(stream4) {
        if (!stream4.dataSize) {
          return;
        }
        self3.dataSize += stream4.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str2) {
      if (!str2 || typeof str2 !== "string") {
        return false;
      }
      var mime = str2.indexOf("/") === -1 ? exports2.lookup(str2) : str2;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path3) {
      if (!path3 || typeof path3 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path3).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions2, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type2) {
        var mime = db[type2];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions2[type2] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type2;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports2, module2) {
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports2, module2) {
    var defer = require_defer();
    module2.exports = async2;
    function async2(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports2, module2) {
    module2.exports = abort;
    function abort(state2) {
      Object.keys(state2.jobs).forEach(clean.bind(state2));
      state2.jobs = {};
    }
    function clean(key2) {
      if (typeof this.jobs[key2] == "function") {
        this.jobs[key2]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    var async2 = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator2, state2, callback) {
      var key2 = state2["keyedList"] ? state2["keyedList"][state2.index] : state2.index;
      state2.jobs[key2] = runJob(iterator2, key2, list[key2], function(error, output) {
        if (!(key2 in state2.jobs)) {
          return;
        }
        delete state2.jobs[key2];
        if (error) {
          abort(state2);
        } else {
          state2.results[key2] = output;
        }
        callback(error, state2.results);
      });
    }
    function runJob(iterator2, key2, item, callback) {
      var aborter;
      if (iterator2.length == 2) {
        aborter = iterator2(item, async2(callback));
      } else {
        aborter = iterator2(item, key2, async2(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports2, module2) {
    module2.exports = state2;
    function state2(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    var abort = require_abort();
    var async2 = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async2(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator2, callback) {
      var state2 = initState(list);
      while (state2.index < (state2["keyedList"] || list).length) {
        iterate(list, iterator2, state2, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state2.jobs).length === 0) {
            callback(null, state2.results);
            return;
          }
        });
        state2.index++;
      }
      return terminator.bind(state2, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator2, sortMethod, callback) {
      var state2 = initState(list, sortMethod);
      iterate(list, iterator2, state2, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state2.index++;
        if (state2.index < (state2["keyedList"] || list).length) {
          iterate(list, iterator2, state2, iteratorHandler);
          return;
        }
        callback(null, state2.results);
      });
      return terminator.bind(state2, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports2, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator2, callback) {
      return serialOrdered(list, iterator2, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports2, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = /* @__PURE__ */ Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof /* @__PURE__ */ Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str2 = "";
      for (var i = 0; i < arr.length; i += 1) {
        str2 += arr[i];
        if (i + 1 < arr.length) {
          str2 += joiner;
        }
      }
      return str2;
    };
    module2.exports = function bind2(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    var bind2 = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind2.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    var bind2 = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind2, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind2 = require_function_bind();
    module2.exports = bind2.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? (function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    })() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name3) {
      var value;
      if (name3 === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name3 === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name3 === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name3 === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name3 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name3] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind2 = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind2.call($call, Array.prototype.concat);
    var $spliceApply = bind2.call($apply, Array.prototype.splice);
    var $replace = bind2.call($call, String.prototype.replace);
    var $strSlice = bind2.call($call, String.prototype.slice);
    var $exec = bind2.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name3, allowMissing) {
      var intrinsicName = name3;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name3 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name3 + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name3, allowMissing) {
      if (typeof name3 !== "string" || name3.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name3) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name3);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name3 + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({
  "node_modules/es-set-tostringtag/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var $TypeError = require_type();
    var toStringTag2 = hasToStringTag ? Symbol.toStringTag : null;
    module2.exports = function setToStringTag(object, value) {
      var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
      var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
      if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
        throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
      }
      if (toStringTag2 && (overrideIfSet || !hasOwn(object, toStringTag2))) {
        if ($defineProperty) {
          $defineProperty(object, toStringTag2, {
            configurable: !nonConfigurable,
            enumerable: false,
            value,
            writable: false
          });
        } else {
          object[toStringTag2] = value;
        }
      }
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports2, module2) {
    "use strict";
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop2) {
        dst[prop2] = dst[prop2] || src[prop2];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports2, module2) {
    "use strict";
    var CombinedStream = require_combined_stream();
    var util3 = require("util");
    var path3 = require("path");
    var http5 = require("http");
    var https3 = require("https");
    var parseUrl = require("url").parse;
    var fs3 = require("fs");
    var Stream = require("stream").Stream;
    var crypto6 = require("crypto");
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var setToStringTag = require_es_set_tostringtag();
    var hasOwn = require_hasown();
    var populate = require_populate();
    function FormData3(options) {
      if (!(this instanceof FormData3)) {
        return new FormData3(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    util3.inherits(FormData3, CombinedStream);
    FormData3.LINE_BREAK = "\r\n";
    FormData3.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData3.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options === "string") {
        options = { filename: options };
      }
      var append3 = CombinedStream.prototype.append.bind(this);
      if (typeof value === "number" || value == null) {
        value = String(value);
      }
      if (Array.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append3(header);
      append3(value);
      append3(footer);
      this._trackLength(header, value, options);
    };
    FormData3.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += Number(options.knownLength);
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData3.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData3.prototype._lengthRetriever = function(value, callback) {
      if (hasOwn(value, "fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs3.stat(value.path, function(err, stat) {
            if (err) {
              callback(err);
              return;
            }
            var fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (hasOwn(value, "httpVersion")) {
        callback(null, Number(value.headers["content-length"]));
      } else if (hasOwn(value, "httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, Number(response.headers["content-length"]));
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData3.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header === "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header === "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop2 in headers) {
        if (hasOwn(headers, prop2)) {
          header = headers[prop2];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop2 + ": " + header.join("; ") + FormData3.LINE_BREAK;
          }
        }
      }
      return "--" + this.getBoundary() + FormData3.LINE_BREAK + contents + FormData3.LINE_BREAK;
    };
    FormData3.prototype._getContentDisposition = function(value, options) {
      var filename;
      if (typeof options.filepath === "string") {
        filename = path3.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value && (value.name || value.path)) {
        filename = path3.basename(options.filename || value && (value.name || value.path));
      } else if (value && value.readable && hasOwn(value, "httpVersion")) {
        filename = path3.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        return 'filename="' + filename + '"';
      }
    };
    FormData3.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && value && typeof value === "object") {
        contentType = FormData3.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData3.prototype._multiPartFooter = function() {
      return function(next2) {
        var footer = FormData3.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next2(footer);
      }.bind(this);
    };
    FormData3.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData3.LINE_BREAK;
    };
    FormData3.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (hasOwn(userHeaders, header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData3.prototype.setBoundary = function(boundary2) {
      if (typeof boundary2 !== "string") {
        throw new TypeError("FormData boundary must be a string");
      }
      this._boundary = boundary2;
    };
    FormData3.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData3.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary2 = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary2.length + 2) !== boundary2) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData3.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData3.prototype._generateBoundary = function() {
      this._boundary = "--------------------------" + crypto6.randomBytes(12).toString("hex");
    };
    FormData3.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData3.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData3.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData3.prototype.submit = function(params, cb) {
      var request;
      var options;
      var defaults2 = { method: "post" };
      if (typeof params === "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults2);
      } else {
        options = populate(params, defaults2);
        if (!options.port) {
          options.port = options.protocol === "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol === "https:") {
        request = https3.request(options);
      } else {
        request = http5.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData3.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData3.prototype.toString = function() {
      return "[object FormData]";
    };
    setToStringTag(FormData3.prototype, "FormData");
    module2.exports = FormData3;
  }
});

// node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data, FormData_default;
var init_FormData = __esm({
  "node_modules/axios/lib/platform/node/classes/FormData.js"() {
    import_form_data = __toESM(require_form_data(), 1);
    FormData_default = import_form_data.default;
  }
});

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key2) {
  return utils_default.endsWith(key2, "[]") ? key2.slice(0, -2) : key2;
}
function renderKey(path3, key2, dots) {
  if (!path3) return key2;
  return path3.concat(key2).map(function each2(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source2) {
    return !utils_default.isUndefined(source2[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (utils_default.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key2, path3) {
    let arr = value;
    if (value && !path3 && typeof value === "object") {
      if (utils_default.endsWith(key2, "{}")) {
        key2 = metaTokens ? key2 : key2.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key2, "[]")) && (arr = utils_default.toArray(value))) {
        key2 = removeBrackets(key2);
        arr.forEach(function each2(el, index2) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key2], index2, dots) : indexes === null ? key2 : key2 + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path3, key2, dots), convertValue(value));
    return false;
  }
  const stack2 = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path3) {
    if (utils_default.isUndefined(value)) return;
    if (stack2.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path3.join("."));
    }
    stack2.push(value);
    utils_default.forEach(value, function each2(el, key2) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key2) ? key2.trim() : key2,
        path3,
        exposedHelpers
      );
      if (result === true) {
        build(el, path3 ? path3.concat(key2) : [key2]);
      }
    });
    stack2.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var predicates, toFormData_default;
var init_toFormData = __esm({
  "node_modules/axios/lib/helpers/toFormData.js"() {
    "use strict";
    init_utils5();
    init_AxiosError();
    init_FormData();
    predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop2) {
      return /^is[A-Z]/.test(prop2);
    });
    toFormData_default = toFormData;
  }
});

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str2) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str2).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2, AxiosURLSearchParams_default;
var init_AxiosURLSearchParams = __esm({
  "node_modules/axios/lib/helpers/AxiosURLSearchParams.js"() {
    "use strict";
    init_toFormData();
    prototype2 = AxiosURLSearchParams.prototype;
    prototype2.append = function append2(name3, value) {
      this._pairs.push([name3, value]);
    };
    prototype2.toString = function toString3(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode);
      } : encode;
      return this._pairs.map(function each2(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    AxiosURLSearchParams_default = AxiosURLSearchParams;
  }
});

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode2;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}
var init_buildURL = __esm({
  "node_modules/axios/lib/helpers/buildURL.js"() {
    "use strict";
    init_utils5();
    init_AxiosURLSearchParams();
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager, InterceptorManager_default;
var init_InterceptorManager = __esm({
  "node_modules/axios/lib/core/InterceptorManager.js"() {
    "use strict";
    init_utils5();
    InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {void}
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils_default.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    InterceptorManager_default = InterceptorManager;
  }
});

// node_modules/axios/lib/defaults/transitional.js
var transitional_default;
var init_transitional = __esm({
  "node_modules/axios/lib/defaults/transitional.js"() {
    "use strict";
    transitional_default = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// node_modules/axios/lib/platform/node/classes/URLSearchParams.js
var import_url, URLSearchParams_default;
var init_URLSearchParams = __esm({
  "node_modules/axios/lib/platform/node/classes/URLSearchParams.js"() {
    "use strict";
    import_url = __toESM(require("url"), 1);
    URLSearchParams_default = import_url.default.URLSearchParams;
  }
});

// node_modules/axios/lib/platform/node/index.js
var import_crypto, ALPHA, DIGIT, ALPHABET, generateString, node_default;
var init_node2 = __esm({
  "node_modules/axios/lib/platform/node/index.js"() {
    import_crypto = __toESM(require("crypto"), 1);
    init_URLSearchParams();
    init_FormData();
    ALPHA = "abcdefghijklmnopqrstuvwxyz";
    DIGIT = "0123456789";
    ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str2 = "";
      const { length } = alphabet;
      const randomValues = new Uint32Array(size);
      import_crypto.default.randomFillSync(randomValues);
      for (let i = 0; i < size; i++) {
        str2 += alphabet[randomValues[i] % length];
      }
      return str2;
    };
    node_default = {
      isNode: true,
      classes: {
        URLSearchParams: URLSearchParams_default,
        FormData: FormData_default,
        Blob: typeof Blob !== "undefined" && Blob || null
      },
      ALPHABET,
      generateString,
      protocols: ["http", "https", "file", "data"]
    };
  }
});

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv, _navigator, hasStandardBrowserEnv, hasStandardBrowserWebWorkerEnv, origin;
var init_utils6 = __esm({
  "node_modules/axios/lib/platform/common/utils.js"() {
    hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    _navigator = typeof navigator === "object" && navigator || void 0;
    hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
    hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    origin = hasBrowserEnv && window.location.href || "http://localhost";
  }
});

// node_modules/axios/lib/platform/index.js
var platform_default;
var init_platform = __esm({
  "node_modules/axios/lib/platform/index.js"() {
    init_node2();
    init_utils6();
    platform_default = {
      ...utils_exports,
      ...node_default
    };
  }
});

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), {
    visitor: function(value, key2, path3, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key2, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}
var init_toURLEncodedForm = __esm({
  "node_modules/axios/lib/helpers/toURLEncodedForm.js"() {
    "use strict";
    init_utils5();
    init_toFormData();
    init_platform();
  }
});

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name3) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name3).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key2;
  for (i = 0; i < len; i++) {
    key2 = keys[i];
    obj[key2] = arr[key2];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path3, value, target, index2) {
    let name3 = path3[index2++];
    if (name3 === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name3);
    const isLast = index2 >= path3.length;
    name3 = !name3 && utils_default.isArray(target) ? target.length : name3;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name3)) {
        target[name3] = [target[name3], value];
      } else {
        target[name3] = value;
      }
      return !isNumericKey;
    }
    if (!target[name3] || !utils_default.isObject(target[name3])) {
      target[name3] = [];
    }
    const result = buildPath(path3, value, target[name3], index2);
    if (result && utils_default.isArray(target[name3])) {
      target[name3] = arrayToObject(target[name3]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name3, value) => {
      buildPath(parsePropPath(name3), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default;
var init_formDataToJSON = __esm({
  "node_modules/axios/lib/helpers/formDataToJSON.js"() {
    "use strict";
    init_utils5();
    formDataToJSON_default = formDataToJSON;
  }
});

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults, defaults_default;
var init_defaults = __esm({
  "node_modules/axios/lib/defaults/index.js"() {
    "use strict";
    init_utils5();
    init_AxiosError();
    init_transitional();
    init_toFormData();
    init_toURLEncodedForm();
    init_platform();
    init_formDataToJSON();
    defaults = {
      transitional: transitional_default,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils_default.isObject(data);
        if (isObjectPayload && utils_default.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils_default.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
        }
        if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
          return data;
        }
        if (utils_default.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils_default.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData_default(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional2 = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
          return data;
        }
        if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data, this.parseReviver);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform_default.classes.FormData,
        Blob: platform_default.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    defaults_default = defaults;
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf, parseHeaders_default;
var init_parseHeaders = __esm({
  "node_modules/axios/lib/helpers/parseHeaders.js"() {
    "use strict";
    init_utils5();
    ignoreDuplicateOf = utils_default.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    parseHeaders_default = (rawHeaders) => {
      const parsed = {};
      let key2;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key2 = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key2 || parsed[key2] && ignoreDuplicateOf[key2]) {
          return;
        }
        if (key2 === "set-cookie") {
          if (parsed[key2]) {
            parsed[key2].push(val);
          } else {
            parsed[key2] = [val];
          }
        } else {
          parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/core/AxiosHeaders.js
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str2) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str2)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str2) => {
    return char.toUpperCase() + str2;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var $internals, isValidHeaderName, AxiosHeaders, AxiosHeaders_default;
var init_AxiosHeaders = __esm({
  "node_modules/axios/lib/core/AxiosHeaders.js"() {
    "use strict";
    init_utils5();
    init_parseHeaders();
    $internals = /* @__PURE__ */ Symbol("internals");
    isValidHeaderName = (str2) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str2.trim());
    AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self3 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key2 = utils_default.findKey(self3, lHeader);
          if (!key2 || self3[key2] === void 0 || _rewrite === true || _rewrite === void 0 && self3[key2] !== false) {
            self3[key2 || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders_default(header), valueOrRewrite);
        } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
          let obj = {}, dest, key2;
          for (const entry of header) {
            if (!utils_default.isArray(entry)) {
              throw TypeError("Object iterator must return a key-value pair");
            }
            obj[key2 = entry[0]] = (dest = obj[key2]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
          }
          setHeaders(obj, valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key2 = utils_default.findKey(this, header);
          if (key2) {
            const value = this[key2];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils_default.isFunction(parser)) {
              return parser.call(this, value, key2);
            }
            if (utils_default.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key2 = utils_default.findKey(this, header);
          return !!(key2 && this[key2] !== void 0 && (!matcher || matchHeaderValue(this, this[key2], key2, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self3 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key2 = utils_default.findKey(self3, _header);
            if (key2 && (!matcher || matchHeaderValue(self3, self3[key2], key2, matcher))) {
              delete self3[key2];
              deleted = true;
            }
          }
        }
        if (utils_default.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key2 = keys[i];
          if (!matcher || matchHeaderValue(this, this[key2], key2, matcher, true)) {
            delete this[key2];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self3 = this;
        const headers = {};
        utils_default.forEach(this, (value, header) => {
          const key2 = utils_default.findKey(headers, header);
          if (key2) {
            self3[key2] = normalizeValue(value);
            delete self3[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self3[header];
          }
          self3[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils_default.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      getSetCookie() {
        return this.get("set-cookie") || [];
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype3 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype3, _header);
            accessors[lHeader] = true;
          }
        }
        utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key2) => {
      let mapped = key2[0].toUpperCase() + key2.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils_default.freezeMethods(AxiosHeaders);
    AxiosHeaders_default = AxiosHeaders;
  }
});

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
var init_transformData = __esm({
  "node_modules/axios/lib/core/transformData.js"() {
    "use strict";
    init_utils5();
    init_defaults();
    init_AxiosHeaders();
  }
});

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
var init_isCancel = __esm({
  "node_modules/axios/lib/cancel/isCancel.js"() {
    "use strict";
  }
});

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
var CanceledError_default;
var init_CanceledError = __esm({
  "node_modules/axios/lib/cancel/CanceledError.js"() {
    "use strict";
    init_AxiosError();
    init_utils5();
    utils_default.inherits(CanceledError, AxiosError_default, {
      __CANCEL__: true
    });
    CanceledError_default = CanceledError;
  }
});

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
var init_settle = __esm({
  "node_modules/axios/lib/core/settle.js"() {
    "use strict";
    init_AxiosError();
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
var init_isAbsoluteURL = __esm({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"() {
    "use strict";
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
var init_combineURLs = __esm({
  "node_modules/axios/lib/helpers/combineURLs.js"() {
    "use strict";
  }
});

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
var init_buildFullPath = __esm({
  "node_modules/axios/lib/core/buildFullPath.js"() {
    "use strict";
    init_isAbsoluteURL();
    init_combineURLs();
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url2) {
      var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy2 = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy2 && proxy2.indexOf("://") === -1) {
        proxy2 = proto + "://" + proxy2;
      }
      return proxy2;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy2) {
        if (!proxy2) {
          return true;
        }
        var parsedProxy = proxy2.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy2;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key2) {
      return process.env[key2.toLowerCase()] || process.env[key2.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str2) {
      str2 = String(str2);
      if (str2.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str2
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type2 = (match[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name3) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name3 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env5) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env5).forEach((key2) => {
        createDebug[key2] = env5[key2];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self3 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self3.diff = ms;
          self3.prev = prevTime;
          self3.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index2];
              match = formatter.call(self3, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug.formatArgs.call(self3, args);
          const logFn = self3.log || createDebug.log;
          logFn.apply(self3, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend4;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend4(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name3) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name3, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name3, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save2;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save2(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env: env5 } = process;
    var flagForceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      flagForceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      flagForceColor = 1;
    }
    function envForceColor() {
      if ("FORCE_COLOR" in env5) {
        if (env5.FORCE_COLOR === "true") {
          return 1;
        }
        if (env5.FORCE_COLOR === "false") {
          return 0;
        }
        return env5.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env5.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
      const noFlagForceColor = envForceColor();
      if (noFlagForceColor !== void 0) {
        flagForceColor = noFlagForceColor;
      }
      const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
      if (forceColor === 0) {
        return 0;
      }
      if (sniffFlags) {
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }
        if (hasFlag("color=256")) {
          return 2;
        }
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env5.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env5) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => sign in env5) || env5.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env5) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env5.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env5.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env5) {
        const version3 = Number.parseInt((env5.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env5.TERM_PROGRAM) {
          case "iTerm.app":
            return version3 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env5.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env5.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env5) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream4, options = {}) {
      const level = supportsColor(stream4, {
        streamIsTTY: stream4 && stream4.isTTY,
        ...options
      });
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
      stderr: getSupportLevel({ isTTY: tty.isatty(2) })
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util3 = require("util");
    exports2.init = init2;
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save2;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.destroy = util3.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key2) => {
      return /^debug_/i.test(key2);
    }).reduce((obj, key2) => {
      const prop2 = key2.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key2];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop2] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name3, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name3} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name3 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util3.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save2(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init2(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts).split("\n").map((str2) => str2.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    var url2 = require("url");
    var URL2 = url2.URL;
    var http5 = require("http");
    var https3 = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug();
    (function detectUnsupportedEnvironment() {
      var looksLikeNode = typeof process !== "undefined";
      var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
      var looksLikeV8 = isFunction3(Error.captureStackTrace);
      if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
      }
    })();
    var useNativeURL = false;
    try {
      assert(new URL2(""));
    } catch (error) {
      useNativeURL = error.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers2 = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event2) {
      eventHandlers2[event2] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event2, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop3;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self3 = this;
      this._onNativeResponse = function(response) {
        try {
          self3._processResponse(response);
        } catch (cause) {
          self3.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString2(data) && !isBuffer2(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction3(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction3(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction3(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self3 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self3._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name3, value) {
      this._options.headers[name3] = value;
      this._currentRequest.setHeader(name3, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name3) {
      delete this._options.headers[name3];
      this._currentRequest.removeHeader(name3);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self3 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self3._timeout) {
          clearTimeout(self3._timeout);
        }
        self3._timeout = setTimeout(function() {
          self3.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self3._timeout) {
          clearTimeout(self3._timeout);
          self3._timeout = null;
        }
        self3.removeListener("abort", clearTimer);
        self3.removeListener("error", clearTimer);
        self3.removeListener("response", clearTimer);
        self3.removeListener("close", clearTimer);
        if (callback) {
          self3.removeListener("timeout", callback);
        }
        if (!self3.socket) {
          self3._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event2 of events) {
        request.on(event2, eventHandlers2[event2]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self3 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self3._currentRequest) {
            if (error) {
              self3.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self3._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction3(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString2(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback = options;
            options = validateUrl(input);
            input = { protocol };
          }
          if (isFunction3(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString2(options.host) && !isString2(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get3(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get3, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop3() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL2(input);
      } else {
        parsed = validateUrl(url2.parse(input));
        if (!isString2(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative, base) {
      return useNativeURL ? new URL2(relative, base) : parseUrl(url2.resolve(base, relative));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread3 = target || {};
      for (var key2 of preservedUrlFields) {
        spread3[key2] = urlObject[key2];
      }
      if (spread3.hostname.startsWith("[")) {
        spread3.hostname = spread3.hostname.slice(1, -1);
      }
      if (spread3.port !== "") {
        spread3.port = Number(spread3.port);
      }
      spread3.path = spread3.search ? spread3.pathname + spread3.search : spread3.pathname;
      return spread3;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        if (isFunction3(Error.captureStackTrace)) {
          Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request, error) {
      for (var event2 of events) {
        request.removeListener(event2, eventHandlers2[event2]);
      }
      request.on("error", noop3);
      request.destroy(error);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString2(subdomain) && isString2(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString2(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction3(value) {
      return typeof value === "function";
    }
    function isBuffer2(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL2 && value instanceof URL2;
    }
    module2.exports = wrap({ http: http5, https: https3 });
    module2.exports.wrap = wrap;
  }
});

// node_modules/axios/lib/env/data.js
var VERSION;
var init_data = __esm({
  "node_modules/axios/lib/env/data.js"() {
    VERSION = "1.13.2";
  }
});

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}
var init_parseProtocol = __esm({
  "node_modules/axios/lib/helpers/parseProtocol.js"() {
    "use strict";
  }
});

// node_modules/axios/lib/helpers/fromDataURI.js
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform_default.classes.Blob;
  const protocol = parseProtocol(uri);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
    const match = DATA_URL_PATTERN.exec(uri);
    if (!match) {
      throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
    }
    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime });
    }
    return buffer;
  }
  throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}
var DATA_URL_PATTERN;
var init_fromDataURI = __esm({
  "node_modules/axios/lib/helpers/fromDataURI.js"() {
    "use strict";
    init_AxiosError();
    init_parseProtocol();
    init_platform();
    DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
  }
});

// node_modules/axios/lib/helpers/AxiosTransformStream.js
var import_stream, kInternals, AxiosTransformStream, AxiosTransformStream_default;
var init_AxiosTransformStream = __esm({
  "node_modules/axios/lib/helpers/AxiosTransformStream.js"() {
    "use strict";
    import_stream = __toESM(require("stream"), 1);
    init_utils5();
    kInternals = /* @__PURE__ */ Symbol("internals");
    AxiosTransformStream = class extends import_stream.default.Transform {
      constructor(options) {
        options = utils_default.toFlatObject(options, {
          maxRate: 0,
          chunkSize: 64 * 1024,
          minChunkSize: 100,
          timeWindow: 500,
          ticksRate: 2,
          samplesCount: 15
        }, null, (prop2, source2) => {
          return !utils_default.isUndefined(source2[prop2]);
        });
        super({
          readableHighWaterMark: options.chunkSize
        });
        const internals = this[kInternals] = {
          timeWindow: options.timeWindow,
          chunkSize: options.chunkSize,
          maxRate: options.maxRate,
          minChunkSize: options.minChunkSize,
          bytesSeen: 0,
          isCaptured: false,
          notifiedBytesLoaded: 0,
          ts: Date.now(),
          bytes: 0,
          onReadCallback: null
        };
        this.on("newListener", (event2) => {
          if (event2 === "progress") {
            if (!internals.isCaptured) {
              internals.isCaptured = true;
            }
          }
        });
      }
      _read(size) {
        const internals = this[kInternals];
        if (internals.onReadCallback) {
          internals.onReadCallback();
        }
        return super._read(size);
      }
      _transform(chunk, encoding, callback) {
        const internals = this[kInternals];
        const maxRate = internals.maxRate;
        const readableHighWaterMark = this.readableHighWaterMark;
        const timeWindow = internals.timeWindow;
        const divider = 1e3 / timeWindow;
        const bytesThreshold = maxRate / divider;
        const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
        const pushChunk = (_chunk, _callback) => {
          const bytes = Buffer.byteLength(_chunk);
          internals.bytesSeen += bytes;
          internals.bytes += bytes;
          internals.isCaptured && this.emit("progress", internals.bytesSeen);
          if (this.push(_chunk)) {
            process.nextTick(_callback);
          } else {
            internals.onReadCallback = () => {
              internals.onReadCallback = null;
              process.nextTick(_callback);
            };
          }
        };
        const transformChunk = (_chunk, _callback) => {
          const chunkSize = Buffer.byteLength(_chunk);
          let chunkRemainder = null;
          let maxChunkSize = readableHighWaterMark;
          let bytesLeft;
          let passed = 0;
          if (maxRate) {
            const now = Date.now();
            if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
              internals.ts = now;
              bytesLeft = bytesThreshold - internals.bytes;
              internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
              passed = 0;
            }
            bytesLeft = bytesThreshold - internals.bytes;
          }
          if (maxRate) {
            if (bytesLeft <= 0) {
              return setTimeout(() => {
                _callback(null, _chunk);
              }, timeWindow - passed);
            }
            if (bytesLeft < maxChunkSize) {
              maxChunkSize = bytesLeft;
            }
          }
          if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
            chunkRemainder = _chunk.subarray(maxChunkSize);
            _chunk = _chunk.subarray(0, maxChunkSize);
          }
          pushChunk(_chunk, chunkRemainder ? () => {
            process.nextTick(_callback, null, chunkRemainder);
          } : _callback);
        };
        transformChunk(chunk, function transformNextChunk(err, _chunk) {
          if (err) {
            return callback(err);
          }
          if (_chunk) {
            transformChunk(_chunk, transformNextChunk);
          } else {
            callback(null);
          }
        });
      }
    };
    AxiosTransformStream_default = AxiosTransformStream;
  }
});

// node_modules/axios/lib/helpers/readBlob.js
var asyncIterator, readBlob, readBlob_default;
var init_readBlob = __esm({
  "node_modules/axios/lib/helpers/readBlob.js"() {
    ({ asyncIterator } = Symbol);
    readBlob = async function* (blob) {
      if (blob.stream) {
        yield* blob.stream();
      } else if (blob.arrayBuffer) {
        yield await blob.arrayBuffer();
      } else if (blob[asyncIterator]) {
        yield* blob[asyncIterator]();
      } else {
        yield blob;
      }
    };
    readBlob_default = readBlob;
  }
});

// node_modules/axios/lib/helpers/formDataToStream.js
var import_util, import_stream2, BOUNDARY_ALPHABET, textEncoder, CRLF, CRLF_BYTES, CRLF_BYTES_COUNT, FormDataPart, formDataToStream, formDataToStream_default;
var init_formDataToStream = __esm({
  "node_modules/axios/lib/helpers/formDataToStream.js"() {
    import_util = __toESM(require("util"), 1);
    import_stream2 = require("stream");
    init_utils5();
    init_readBlob();
    init_platform();
    BOUNDARY_ALPHABET = platform_default.ALPHABET.ALPHA_DIGIT + "-_";
    textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new import_util.default.TextEncoder();
    CRLF = "\r\n";
    CRLF_BYTES = textEncoder.encode(CRLF);
    CRLF_BYTES_COUNT = 2;
    FormDataPart = class {
      constructor(name3, value) {
        const { escapeName } = this.constructor;
        const isStringValue = utils_default.isString(value);
        let headers = `Content-Disposition: form-data; name="${escapeName(name3)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
        if (isStringValue) {
          value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
        } else {
          headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
        }
        this.headers = textEncoder.encode(headers + CRLF);
        this.contentLength = isStringValue ? value.byteLength : value.size;
        this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
        this.name = name3;
        this.value = value;
      }
      async *encode() {
        yield this.headers;
        const { value } = this;
        if (utils_default.isTypedArray(value)) {
          yield value;
        } else {
          yield* readBlob_default(value);
        }
        yield CRLF_BYTES;
      }
      static escapeName(name3) {
        return String(name3).replace(/[\r\n"]/g, (match) => ({
          "\r": "%0D",
          "\n": "%0A",
          '"': "%22"
        })[match]);
      }
    };
    formDataToStream = (form, headersHandler, options) => {
      const {
        tag: tag2 = "form-data-boundary",
        size = 25,
        boundary: boundary2 = tag2 + "-" + platform_default.generateString(size, BOUNDARY_ALPHABET)
      } = options || {};
      if (!utils_default.isFormData(form)) {
        throw TypeError("FormData instance required");
      }
      if (boundary2.length < 1 || boundary2.length > 70) {
        throw Error("boundary must be 10-70 characters long");
      }
      const boundaryBytes = textEncoder.encode("--" + boundary2 + CRLF);
      const footerBytes = textEncoder.encode("--" + boundary2 + "--" + CRLF);
      let contentLength = footerBytes.byteLength;
      const parts = Array.from(form.entries()).map(([name3, value]) => {
        const part = new FormDataPart(name3, value);
        contentLength += part.size;
        return part;
      });
      contentLength += boundaryBytes.byteLength * parts.length;
      contentLength = utils_default.toFiniteNumber(contentLength);
      const computedHeaders = {
        "Content-Type": `multipart/form-data; boundary=${boundary2}`
      };
      if (Number.isFinite(contentLength)) {
        computedHeaders["Content-Length"] = contentLength;
      }
      headersHandler && headersHandler(computedHeaders);
      return import_stream2.Readable.from((async function* () {
        for (const part of parts) {
          yield boundaryBytes;
          yield* part.encode();
        }
        yield footerBytes;
      })());
    };
    formDataToStream_default = formDataToStream;
  }
});

// node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
var import_stream3, ZlibHeaderTransformStream, ZlibHeaderTransformStream_default;
var init_ZlibHeaderTransformStream = __esm({
  "node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js"() {
    "use strict";
    import_stream3 = __toESM(require("stream"), 1);
    ZlibHeaderTransformStream = class extends import_stream3.default.Transform {
      __transform(chunk, encoding, callback) {
        this.push(chunk);
        callback();
      }
      _transform(chunk, encoding, callback) {
        if (chunk.length !== 0) {
          this._transform = this.__transform;
          if (chunk[0] !== 120) {
            const header = Buffer.alloc(2);
            header[0] = 120;
            header[1] = 156;
            this.push(header, encoding);
          }
        }
        this.__transform(chunk, encoding, callback);
      }
    };
    ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;
  }
});

// node_modules/axios/lib/helpers/callbackify.js
var callbackify, callbackify_default;
var init_callbackify = __esm({
  "node_modules/axios/lib/helpers/callbackify.js"() {
    init_utils5();
    callbackify = (fn, reducer) => {
      return utils_default.isAsyncFn(fn) ? function(...args) {
        const cb = args.pop();
        fn.apply(this, args).then((value) => {
          try {
            reducer ? cb(null, ...reducer(value)) : cb(null, value);
          } catch (err) {
            cb(err);
          }
        }, cb);
      } : fn;
    };
    callbackify_default = callbackify;
  }
});

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head2 = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push2(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head2] = chunkLength;
    timestamps[head2] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head2) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head2 = (head2 + 1) % samplesCount;
    if (head2 === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default;
var init_speedometer = __esm({
  "node_modules/axios/lib/helpers/speedometer.js"() {
    "use strict";
    speedometer_default = speedometer;
  }
});

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp2 = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke2 = (args, now = Date.now()) => {
    timestamp2 = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp2;
    if (passed >= threshold) {
      invoke2(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke2(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke2(lastArgs);
  return [throttled, flush];
}
var throttle_default;
var init_throttle = __esm({
  "node_modules/axios/lib/helpers/throttle.js"() {
    throttle_default = throttle;
  }
});

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer, progressEventDecorator, asyncDecorator;
var init_progressEventReducer = __esm({
  "node_modules/axios/lib/helpers/progressEventReducer.js"() {
    init_speedometer();
    init_throttle();
    init_utils5();
    progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer_default(50, 250);
      return throttle_default((e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? "download" : "upload"]: true
        };
        listener(data);
      }, freq);
    };
    progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;
      return [(loaded) => throttled[0]({
        lengthComputable,
        total,
        loaded
      }), throttled[1]];
    };
    asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));
  }
});

// node_modules/axios/lib/helpers/estimateDataURLDecodedBytes.js
function estimateDataURLDecodedBytes(url2) {
  if (!url2 || typeof url2 !== "string") return 0;
  if (!url2.startsWith("data:")) return 0;
  const comma = url2.indexOf(",");
  if (comma < 0) return 0;
  const meta = url2.slice(5, comma);
  const body = url2.slice(comma + 1);
  const isBase64 = /;base64/i.test(meta);
  if (isBase64) {
    let effectiveLen = body.length;
    const len = body.length;
    for (let i = 0; i < len; i++) {
      if (body.charCodeAt(i) === 37 && i + 2 < len) {
        const a = body.charCodeAt(i + 1);
        const b = body.charCodeAt(i + 2);
        const isHex = (a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102) && (b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102);
        if (isHex) {
          effectiveLen -= 2;
          i += 2;
        }
      }
    }
    let pad = 0;
    let idx = len - 1;
    const tailIsPct3D = (j) => j >= 2 && body.charCodeAt(j - 2) === 37 && // '%'
    body.charCodeAt(j - 1) === 51 && // '3'
    (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100);
    if (idx >= 0) {
      if (body.charCodeAt(idx) === 61) {
        pad++;
        idx--;
      } else if (tailIsPct3D(idx)) {
        pad++;
        idx -= 3;
      }
    }
    if (pad === 1 && idx >= 0) {
      if (body.charCodeAt(idx) === 61) {
        pad++;
      } else if (tailIsPct3D(idx)) {
        pad++;
      }
    }
    const groups = Math.floor(effectiveLen / 4);
    const bytes = groups * 3 - (pad || 0);
    return bytes > 0 ? bytes : 0;
  }
  return Buffer.byteLength(body, "utf8");
}
var init_estimateDataURLDecodedBytes = __esm({
  "node_modules/axios/lib/helpers/estimateDataURLDecodedBytes.js"() {
  }
});

// node_modules/axios/lib/adapters/http.js
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location) {
  let proxy2 = configProxy;
  if (!proxy2 && proxy2 !== false) {
    const proxyUrl = import_proxy_from_env.default.getProxyForUrl(location);
    if (proxyUrl) {
      proxy2 = new URL(proxyUrl);
    }
  }
  if (proxy2) {
    if (proxy2.username) {
      proxy2.auth = (proxy2.username || "") + ":" + (proxy2.password || "");
    }
    if (proxy2.auth) {
      if (proxy2.auth.username || proxy2.auth.password) {
        proxy2.auth = (proxy2.auth.username || "") + ":" + (proxy2.auth.password || "");
      }
      const base64 = Buffer.from(proxy2.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy2.hostname || proxy2.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy2.port;
    options.path = location;
    if (proxy2.protocol) {
      options.protocol = proxy2.protocol.includes(":") ? proxy2.protocol : `${proxy2.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
var import_proxy_from_env, import_http, import_https, import_http2, import_util2, import_follow_redirects, import_zlib, import_stream4, import_events5, zlibOptions, brotliOptions, isBrotliSupported, httpFollow, httpsFollow, isHttps, supportedProtocols, flushOnFinish, Http2Sessions, http2Sessions, isHttpAdapterSupported, wrapAsync, resolveFamily, buildAddressEntry, http2Transport, http_default;
var init_http = __esm({
  "node_modules/axios/lib/adapters/http.js"() {
    init_utils5();
    init_settle();
    init_buildFullPath();
    init_buildURL();
    import_proxy_from_env = __toESM(require_proxy_from_env(), 1);
    import_http = __toESM(require("http"), 1);
    import_https = __toESM(require("https"), 1);
    import_http2 = __toESM(require("http2"), 1);
    import_util2 = __toESM(require("util"), 1);
    import_follow_redirects = __toESM(require_follow_redirects(), 1);
    import_zlib = __toESM(require("zlib"), 1);
    init_data();
    init_transitional();
    init_AxiosError();
    init_CanceledError();
    init_platform();
    init_fromDataURI();
    import_stream4 = __toESM(require("stream"), 1);
    init_AxiosHeaders();
    init_AxiosTransformStream();
    import_events5 = require("events");
    init_formDataToStream();
    init_readBlob();
    init_ZlibHeaderTransformStream();
    init_callbackify();
    init_progressEventReducer();
    init_estimateDataURLDecodedBytes();
    zlibOptions = {
      flush: import_zlib.default.constants.Z_SYNC_FLUSH,
      finishFlush: import_zlib.default.constants.Z_SYNC_FLUSH
    };
    brotliOptions = {
      flush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH,
      finishFlush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH
    };
    isBrotliSupported = utils_default.isFunction(import_zlib.default.createBrotliDecompress);
    ({ http: httpFollow, https: httpsFollow } = import_follow_redirects.default);
    isHttps = /https:?/;
    supportedProtocols = platform_default.protocols.map((protocol) => {
      return protocol + ":";
    });
    flushOnFinish = (stream4, [throttled, flush]) => {
      stream4.on("end", flush).on("error", flush);
      return throttled;
    };
    Http2Sessions = class {
      constructor() {
        this.sessions = /* @__PURE__ */ Object.create(null);
      }
      getSession(authority, options) {
        options = Object.assign({
          sessionTimeout: 1e3
        }, options);
        let authoritySessions = this.sessions[authority];
        if (authoritySessions) {
          let len = authoritySessions.length;
          for (let i = 0; i < len; i++) {
            const [sessionHandle, sessionOptions] = authoritySessions[i];
            if (!sessionHandle.destroyed && !sessionHandle.closed && import_util2.default.isDeepStrictEqual(sessionOptions, options)) {
              return sessionHandle;
            }
          }
        }
        const session = import_http2.default.connect(authority, options);
        let removed;
        const removeSession = () => {
          if (removed) {
            return;
          }
          removed = true;
          let entries = authoritySessions, len = entries.length, i = len;
          while (i--) {
            if (entries[i][0] === session) {
              if (len === 1) {
                delete this.sessions[authority];
              } else {
                entries.splice(i, 1);
              }
              return;
            }
          }
        };
        const originalRequestFn = session.request;
        const { sessionTimeout } = options;
        if (sessionTimeout != null) {
          let timer;
          let streamsCount = 0;
          session.request = function() {
            const stream4 = originalRequestFn.apply(this, arguments);
            streamsCount++;
            if (timer) {
              clearTimeout(timer);
              timer = null;
            }
            stream4.once("close", () => {
              if (!--streamsCount) {
                timer = setTimeout(() => {
                  timer = null;
                  removeSession();
                }, sessionTimeout);
              }
            });
            return stream4;
          };
        }
        session.once("close", removeSession);
        let entry = [
          session,
          options
        ];
        authoritySessions ? authoritySessions.push(entry) : authoritySessions = this.sessions[authority] = [entry];
        return session;
      }
    };
    http2Sessions = new Http2Sessions();
    isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
    wrapAsync = (asyncExecutor) => {
      return new Promise((resolve, reject) => {
        let onDone;
        let isDone;
        const done = (value, isRejected) => {
          if (isDone) return;
          isDone = true;
          onDone && onDone(value, isRejected);
        };
        const _resolve = (value) => {
          done(value);
          resolve(value);
        };
        const _reject = (reason) => {
          done(reason, true);
          reject(reason);
        };
        asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
      });
    };
    resolveFamily = ({ address, family }) => {
      if (!utils_default.isString(address)) {
        throw TypeError("address must be a string");
      }
      return {
        address,
        family: family || (address.indexOf(".") < 0 ? 6 : 4)
      };
    };
    buildAddressEntry = (address, family) => resolveFamily(utils_default.isObject(address) ? address : { address, family });
    http2Transport = {
      request(options, cb) {
        const authority = options.protocol + "//" + options.hostname + ":" + (options.port || 80);
        const { http2Options, headers } = options;
        const session = http2Sessions.getSession(authority, http2Options);
        const {
          HTTP2_HEADER_SCHEME,
          HTTP2_HEADER_METHOD,
          HTTP2_HEADER_PATH,
          HTTP2_HEADER_STATUS
        } = import_http2.default.constants;
        const http2Headers = {
          [HTTP2_HEADER_SCHEME]: options.protocol.replace(":", ""),
          [HTTP2_HEADER_METHOD]: options.method,
          [HTTP2_HEADER_PATH]: options.path
        };
        utils_default.forEach(headers, (header, name3) => {
          name3.charAt(0) !== ":" && (http2Headers[name3] = header);
        });
        const req = session.request(http2Headers);
        req.once("response", (responseHeaders) => {
          const response = req;
          responseHeaders = Object.assign({}, responseHeaders);
          const status = responseHeaders[HTTP2_HEADER_STATUS];
          delete responseHeaders[HTTP2_HEADER_STATUS];
          response.headers = responseHeaders;
          response.statusCode = +status;
          cb(response);
        });
        return req;
      }
    };
    http_default = isHttpAdapterSupported && function httpAdapter(config) {
      return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
        let { data, lookup, family, httpVersion = 1, http2Options } = config;
        const { responseType, responseEncoding } = config;
        const method = config.method.toUpperCase();
        let isDone;
        let rejected = false;
        let req;
        httpVersion = +httpVersion;
        if (Number.isNaN(httpVersion)) {
          throw TypeError(`Invalid protocol version: '${config.httpVersion}' is not a number`);
        }
        if (httpVersion !== 1 && httpVersion !== 2) {
          throw TypeError(`Unsupported protocol version '${httpVersion}'`);
        }
        const isHttp2 = httpVersion === 2;
        if (lookup) {
          const _lookup = callbackify_default(lookup, (value) => utils_default.isArray(value) ? value : [value]);
          lookup = (hostname, opt, cb) => {
            _lookup(hostname, opt, (err, arg0, arg1) => {
              if (err) {
                return cb(err);
              }
              const addresses = utils_default.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
              opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
            });
          };
        }
        const abortEmitter = new import_events5.EventEmitter();
        function abort(reason) {
          try {
            abortEmitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config, req) : reason);
          } catch (err) {
            console.warn("emit error", err);
          }
        }
        abortEmitter.once("abort", reject);
        const onFinished = () => {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(abort);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", abort);
          }
          abortEmitter.removeAllListeners();
        };
        if (config.cancelToken || config.signal) {
          config.cancelToken && config.cancelToken.subscribe(abort);
          if (config.signal) {
            config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
          }
        }
        onDone((response, isRejected) => {
          isDone = true;
          if (isRejected) {
            rejected = true;
            onFinished();
            return;
          }
          const { data: data2 } = response;
          if (data2 instanceof import_stream4.default.Readable || data2 instanceof import_stream4.default.Duplex) {
            const offListeners = import_stream4.default.finished(data2, () => {
              offListeners();
              onFinished();
            });
          } else {
            onFinished();
          }
        });
        const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
        const parsed = new URL(fullPath, platform_default.hasBrowserEnv ? platform_default.origin : void 0);
        const protocol = parsed.protocol || supportedProtocols[0];
        if (protocol === "data:") {
          if (config.maxContentLength > -1) {
            const dataUrl = String(config.url || fullPath || "");
            const estimated = estimateDataURLDecodedBytes(dataUrl);
            if (estimated > config.maxContentLength) {
              return reject(new AxiosError_default(
                "maxContentLength size of " + config.maxContentLength + " exceeded",
                AxiosError_default.ERR_BAD_RESPONSE,
                config
              ));
            }
          }
          let convertedData;
          if (method !== "GET") {
            return settle(resolve, reject, {
              status: 405,
              statusText: "method not allowed",
              headers: {},
              config
            });
          }
          try {
            convertedData = fromDataURI(config.url, responseType === "blob", {
              Blob: config.env && config.env.Blob
            });
          } catch (err) {
            throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config);
          }
          if (responseType === "text") {
            convertedData = convertedData.toString(responseEncoding);
            if (!responseEncoding || responseEncoding === "utf8") {
              convertedData = utils_default.stripBOM(convertedData);
            }
          } else if (responseType === "stream") {
            convertedData = import_stream4.default.Readable.from(convertedData);
          }
          return settle(resolve, reject, {
            data: convertedData,
            status: 200,
            statusText: "OK",
            headers: new AxiosHeaders_default(),
            config
          });
        }
        if (supportedProtocols.indexOf(protocol) === -1) {
          return reject(new AxiosError_default(
            "Unsupported protocol " + protocol,
            AxiosError_default.ERR_BAD_REQUEST,
            config
          ));
        }
        const headers = AxiosHeaders_default.from(config.headers).normalize();
        headers.set("User-Agent", "axios/" + VERSION, false);
        const { onUploadProgress, onDownloadProgress } = config;
        const maxRate = config.maxRate;
        let maxUploadRate = void 0;
        let maxDownloadRate = void 0;
        if (utils_default.isSpecCompliantForm(data)) {
          const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
          data = formDataToStream_default(data, (formHeaders) => {
            headers.set(formHeaders);
          }, {
            tag: `axios-${VERSION}-boundary`,
            boundary: userBoundary && userBoundary[1] || void 0
          });
        } else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
          headers.set(data.getHeaders());
          if (!headers.hasContentLength()) {
            try {
              const knownLength = await import_util2.default.promisify(data.getLength).call(data);
              Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
            } catch (e) {
            }
          }
        } else if (utils_default.isBlob(data) || utils_default.isFile(data)) {
          data.size && headers.setContentType(data.type || "application/octet-stream");
          headers.setContentLength(data.size || 0);
          data = import_stream4.default.Readable.from(readBlob_default(data));
        } else if (data && !utils_default.isStream(data)) {
          if (Buffer.isBuffer(data)) {
          } else if (utils_default.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils_default.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(new AxiosError_default(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              AxiosError_default.ERR_BAD_REQUEST,
              config
            ));
          }
          headers.setContentLength(data.length, false);
          if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
            return reject(new AxiosError_default(
              "Request body larger than maxBodyLength limit",
              AxiosError_default.ERR_BAD_REQUEST,
              config
            ));
          }
        }
        const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
        if (utils_default.isArray(maxRate)) {
          maxUploadRate = maxRate[0];
          maxDownloadRate = maxRate[1];
        } else {
          maxUploadRate = maxDownloadRate = maxRate;
        }
        if (data && (onUploadProgress || maxUploadRate)) {
          if (!utils_default.isStream(data)) {
            data = import_stream4.default.Readable.from(data, { objectMode: false });
          }
          data = import_stream4.default.pipeline([data, new AxiosTransformStream_default({
            maxRate: utils_default.toFiniteNumber(maxUploadRate)
          })], utils_default.noop);
          onUploadProgress && data.on("progress", flushOnFinish(
            data,
            progressEventDecorator(
              contentLength,
              progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
            )
          ));
        }
        let auth = void 0;
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password || "";
          auth = username + ":" + password;
        }
        if (!auth && parsed.username) {
          const urlUsername = parsed.username;
          const urlPassword = parsed.password;
          auth = urlUsername + ":" + urlPassword;
        }
        auth && headers.delete("authorization");
        let path3;
        try {
          path3 = buildURL(
            parsed.pathname + parsed.search,
            config.params,
            config.paramsSerializer
          ).replace(/^\?/, "");
        } catch (err) {
          const customErr = new Error(err.message);
          customErr.config = config;
          customErr.url = config.url;
          customErr.exists = true;
          return reject(customErr);
        }
        headers.set(
          "Accept-Encoding",
          "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
          false
        );
        const options = {
          path: path3,
          method,
          headers: headers.toJSON(),
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth,
          protocol,
          family,
          beforeRedirect: dispatchBeforeRedirect,
          beforeRedirects: {},
          http2Options
        };
        !utils_default.isUndefined(lookup) && (options.lookup = lookup);
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
          options.port = parsed.port;
          setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        let transport;
        const isHttpsRequest = isHttps.test(options.protocol);
        options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        if (isHttp2) {
          transport = http2Transport;
        } else {
          if (config.transport) {
            transport = config.transport;
          } else if (config.maxRedirects === 0) {
            transport = isHttpsRequest ? import_https.default : import_http.default;
          } else {
            if (config.maxRedirects) {
              options.maxRedirects = config.maxRedirects;
            }
            if (config.beforeRedirect) {
              options.beforeRedirects.config = config.beforeRedirect;
            }
            transport = isHttpsRequest ? httpsFollow : httpFollow;
          }
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        } else {
          options.maxBodyLength = Infinity;
        }
        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }
        req = transport.request(options, function handleResponse(res) {
          if (req.destroyed) return;
          const streams = [res];
          const responseLength = utils_default.toFiniteNumber(res.headers["content-length"]);
          if (onDownloadProgress || maxDownloadRate) {
            const transformStream = new AxiosTransformStream_default({
              maxRate: utils_default.toFiniteNumber(maxDownloadRate)
            });
            onDownloadProgress && transformStream.on("progress", flushOnFinish(
              transformStream,
              progressEventDecorator(
                responseLength,
                progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
              )
            ));
            streams.push(transformStream);
          }
          let responseStream = res;
          const lastRequest = res.req || req;
          if (config.decompress !== false && res.headers["content-encoding"]) {
            if (method === "HEAD" || res.statusCode === 204) {
              delete res.headers["content-encoding"];
            }
            switch ((res.headers["content-encoding"] || "").toLowerCase()) {
              /*eslint default-case:0*/
              case "gzip":
              case "x-gzip":
              case "compress":
              case "x-compress":
                streams.push(import_zlib.default.createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "deflate":
                streams.push(new ZlibHeaderTransformStream_default());
                streams.push(import_zlib.default.createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "br":
                if (isBrotliSupported) {
                  streams.push(import_zlib.default.createBrotliDecompress(brotliOptions));
                  delete res.headers["content-encoding"];
                }
            }
          }
          responseStream = streams.length > 1 ? import_stream4.default.pipeline(streams, utils_default.noop) : streams[0];
          const response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: new AxiosHeaders_default(res.headers),
            config,
            request: lastRequest
          };
          if (responseType === "stream") {
            response.data = responseStream;
            settle(resolve, reject, response);
          } else {
            const responseBuffer = [];
            let totalResponseBytes = 0;
            responseStream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                rejected = true;
                responseStream.destroy();
                abort(new AxiosError_default(
                  "maxContentLength size of " + config.maxContentLength + " exceeded",
                  AxiosError_default.ERR_BAD_RESPONSE,
                  config,
                  lastRequest
                ));
              }
            });
            responseStream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              const err = new AxiosError_default(
                "stream has been aborted",
                AxiosError_default.ERR_BAD_RESPONSE,
                config,
                lastRequest
              );
              responseStream.destroy(err);
              reject(err);
            });
            responseStream.on("error", function handleStreamError(err) {
              if (req.destroyed) return;
              reject(AxiosError_default.from(err, null, config, lastRequest));
            });
            responseStream.on("end", function handleStreamEnd() {
              try {
                let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (responseType !== "arraybuffer") {
                  responseData = responseData.toString(responseEncoding);
                  if (!responseEncoding || responseEncoding === "utf8") {
                    responseData = utils_default.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                return reject(AxiosError_default.from(err, null, config, response.request, response));
              }
              settle(resolve, reject, response);
            });
          }
          abortEmitter.once("abort", (err) => {
            if (!responseStream.destroyed) {
              responseStream.emit("error", err);
              responseStream.destroy();
            }
          });
        });
        abortEmitter.once("abort", (err) => {
          if (req.close) {
            req.close();
          } else {
            req.destroy(err);
          }
        });
        req.on("error", function handleRequestError(err) {
          reject(AxiosError_default.from(err, null, config, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config.timeout) {
          const timeout = parseInt(config.timeout, 10);
          if (Number.isNaN(timeout)) {
            abort(new AxiosError_default(
              "error trying to parse `config.timeout` to int",
              AxiosError_default.ERR_BAD_OPTION_VALUE,
              config,
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            if (isDone) return;
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional2 = config.transitional || transitional_default;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            abort(new AxiosError_default(
              timeoutErrorMessage,
              transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
              config,
              req
            ));
          });
        } else {
          req.setTimeout(0);
        }
        if (utils_default.isStream(data)) {
          let ended = false;
          let errored = false;
          data.on("end", () => {
            ended = true;
          });
          data.once("error", (err) => {
            errored = true;
            req.destroy(err);
          });
          data.on("close", () => {
            if (!ended && !errored) {
              abort(new CanceledError_default("Request stream has been aborted", config, req));
            }
          });
          data.pipe(req);
        } else {
          data && req.write(data);
          req.end();
        }
      });
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default;
var init_isURLSameOrigin = __esm({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"() {
    init_platform();
    isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
      url2 = new URL(url2, platform_default.origin);
      return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
    })(
      new URL(platform_default.origin),
      platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
    ) : () => true;
  }
});

// node_modules/axios/lib/helpers/cookies.js
var cookies_default;
var init_cookies = __esm({
  "node_modules/axios/lib/helpers/cookies.js"() {
    init_utils5();
    init_platform();
    cookies_default = platform_default.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name3, value, expires, path3, domain, secure, sameSite) {
          if (typeof document === "undefined") return;
          const cookie = [`${name3}=${encodeURIComponent(value)}`];
          if (utils_default.isNumber(expires)) {
            cookie.push(`expires=${new Date(expires).toUTCString()}`);
          }
          if (utils_default.isString(path3)) {
            cookie.push(`path=${path3}`);
          }
          if (utils_default.isString(domain)) {
            cookie.push(`domain=${domain}`);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          if (utils_default.isString(sameSite)) {
            cookie.push(`SameSite=${sameSite}`);
          }
          document.cookie = cookie.join("; ");
        },
        read(name3) {
          if (typeof document === "undefined") return null;
          const match = document.cookie.match(new RegExp("(?:^|; )" + name3 + "=([^;]*)"));
          return match ? decodeURIComponent(match[1]) : null;
        },
        remove(name3) {
          this.write(name3, "", Date.now() - 864e5, "/");
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
  }
});

// node_modules/axios/lib/core/mergeConfig.js
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source2, prop2, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source2)) {
      return utils_default.merge.call({ caseless }, target, source2);
    } else if (utils_default.isPlainObject(source2)) {
      return utils_default.merge({}, source2);
    } else if (utils_default.isArray(source2)) {
      return source2.slice();
    }
    return source2;
  }
  function mergeDeepProperties(a, b, prop2, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, prop2, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, prop2, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop2) {
    if (prop2 in config2) {
      return getMergedValue(a, b);
    } else if (prop2 in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop2) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop2, true)
  };
  utils_default.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop2) {
    const merge3 = mergeMap[prop2] || mergeDeepProperties;
    const configValue = merge3(config1[prop2], config2[prop2], prop2);
    utils_default.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config[prop2] = configValue);
  });
  return config;
}
var headersToObject;
var init_mergeConfig = __esm({
  "node_modules/axios/lib/core/mergeConfig.js"() {
    "use strict";
    init_utils5();
    init_AxiosHeaders();
    headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
  }
});

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default;
var init_resolveConfig = __esm({
  "node_modules/axios/lib/helpers/resolveConfig.js"() {
    init_platform();
    init_utils5();
    init_isURLSameOrigin();
    init_cookies();
    init_buildFullPath();
    init_mergeConfig();
    init_AxiosHeaders();
    init_buildURL();
    resolveConfig_default = (config) => {
      const newConfig = mergeConfig({}, config);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders_default.from(headers);
      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
      if (auth) {
        headers.set(
          "Authorization",
          "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
        );
      }
      if (utils_default.isFormData(data)) {
        if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(void 0);
        } else if (utils_default.isFunction(data.getHeaders)) {
          const formHeaders = data.getHeaders();
          const allowedHeaders = ["content-type", "content-length"];
          Object.entries(formHeaders).forEach(([key2, val]) => {
            if (allowedHeaders.includes(key2.toLowerCase())) {
              headers.set(key2, val);
            }
          });
        }
      }
      if (platform_default.hasStandardBrowserEnv) {
        withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
  }
});

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported, xhr_default;
var init_xhr = __esm({
  "node_modules/axios/lib/adapters/xhr.js"() {
    init_utils5();
    init_settle();
    init_transitional();
    init_AxiosError();
    init_CanceledError();
    init_parseProtocol();
    init_platform();
    init_AxiosHeaders();
    init_progressEventReducer();
    init_resolveConfig();
    isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    xhr_default = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        const _config = resolveConfig_default(config);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
          flushUpload && flushUpload();
          flushDownload && flushDownload();
          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
          _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders_default.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError(event2) {
          const msg = event2 && event2.message ? event2.message : "Network Error";
          const err = new AxiosError_default(msg, AxiosError_default.ERR_NETWORK, config, request);
          err.event = event2 || null;
          reject(err);
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional2 = _config.transitional || transitional_default;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError_default(
            timeoutErrorMessage,
            transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key2) {
            request.setRequestHeader(key2, val);
          });
        }
        if (!utils_default.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
          request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
          request.upload.addEventListener("progress", uploadThrottled);
          request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(_config.url);
        if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
  }
});

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals, composeSignals_default;
var init_composeSignals = __esm({
  "node_modules/axios/lib/helpers/composeSignals.js"() {
    init_CanceledError();
    init_AxiosError();
    init_utils5();
    composeSignals = (signals, timeout) => {
      const { length } = signals = signals ? signals.filter(Boolean) : [];
      if (timeout || length) {
        let controller = new AbortController();
        let aborted2;
        const onabort = function(reason) {
          if (!aborted2) {
            aborted2 = true;
            unsubscribe();
            const err = reason instanceof Error ? reason : this.reason;
            controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
          }
        };
        let timer = timeout && setTimeout(() => {
          timer = null;
          onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
        }, timeout);
        const unsubscribe = () => {
          if (signals) {
            timer && clearTimeout(timer);
            timer = null;
            signals.forEach((signal2) => {
              signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
            });
            signals = null;
          }
        };
        signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
        const { signal } = controller;
        signal.unsubscribe = () => utils_default.asap(unsubscribe);
        return signal;
      }
    };
    composeSignals_default = composeSignals;
  }
});

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk, readBytes, readStream, trackStream;
var init_trackStream = __esm({
  "node_modules/axios/lib/helpers/trackStream.js"() {
    streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;
      if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
      }
      let pos = 0;
      let end;
      while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
      }
    };
    readBytes = async function* (iterable, chunkSize) {
      for await (const chunk of readStream(iterable)) {
        yield* streamChunk(chunk, chunkSize);
      }
    };
    readStream = async function* (stream4) {
      if (stream4[Symbol.asyncIterator]) {
        yield* stream4;
        return;
      }
      const reader = stream4.getReader();
      try {
        for (; ; ) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          yield value;
        }
      } finally {
        await reader.cancel();
      }
    };
    trackStream = (stream4, chunkSize, onProgress, onFinish) => {
      const iterator2 = readBytes(stream4, chunkSize);
      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };
      return new ReadableStream({
        async pull(controller) {
          try {
            const { done: done2, value } = await iterator2.next();
            if (done2) {
              _onFinish();
              controller.close();
              return;
            }
            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator2.return();
        }
      }, {
        highWaterMark: 2
      });
    };
  }
});

// node_modules/axios/lib/adapters/fetch.js
var DEFAULT_CHUNK_SIZE, isFunction2, globalFetchAPI, ReadableStream2, TextEncoder2, test, factory, seedCache, getFetch, adapter;
var init_fetch = __esm({
  "node_modules/axios/lib/adapters/fetch.js"() {
    init_platform();
    init_utils5();
    init_AxiosError();
    init_composeSignals();
    init_trackStream();
    init_AxiosHeaders();
    init_progressEventReducer();
    init_resolveConfig();
    init_settle();
    DEFAULT_CHUNK_SIZE = 64 * 1024;
    ({ isFunction: isFunction2 } = utils_default);
    globalFetchAPI = (({ Request, Response }) => ({
      Request,
      Response
    }))(utils_default.global);
    ({
      ReadableStream: ReadableStream2,
      TextEncoder: TextEncoder2
    } = utils_default.global);
    test = (fn, ...args) => {
      try {
        return !!fn(...args);
      } catch (e) {
        return false;
      }
    };
    factory = (env5) => {
      env5 = utils_default.merge.call({
        skipUndefined: true
      }, globalFetchAPI, env5);
      const { fetch: envFetch, Request, Response } = env5;
      const isFetchSupported = envFetch ? isFunction2(envFetch) : typeof fetch === "function";
      const isRequestSupported = isFunction2(Request);
      const isResponseSupported = isFunction2(Response);
      if (!isFetchSupported) {
        return false;
      }
      const isReadableStreamSupported = isFetchSupported && isFunction2(ReadableStream2);
      const encodeText = isFetchSupported && (typeof TextEncoder2 === "function" ? /* @__PURE__ */ ((encoder) => (str2) => encoder.encode(str2))(new TextEncoder2()) : async (str2) => new Uint8Array(await new Request(str2).arrayBuffer()));
      const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
        let duplexAccessed = false;
        const hasContentType = new Request(platform_default.origin, {
          body: new ReadableStream2(),
          method: "POST",
          get duplex() {
            duplexAccessed = true;
            return "half";
          }
        }).headers.has("Content-Type");
        return duplexAccessed && !hasContentType;
      });
      const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
      const resolvers = {
        stream: supportsResponseStream && ((res) => res.body)
      };
      isFetchSupported && (() => {
        ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type2) => {
          !resolvers[type2] && (resolvers[type2] = (res, config) => {
            let method = res && res[type2];
            if (method) {
              return method.call(res);
            }
            throw new AxiosError_default(`Response type '${type2}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
          });
        });
      })();
      const getBodyLength = async (body) => {
        if (body == null) {
          return 0;
        }
        if (utils_default.isBlob(body)) {
          return body.size;
        }
        if (utils_default.isSpecCompliantForm(body)) {
          const _request = new Request(platform_default.origin, {
            method: "POST",
            body
          });
          return (await _request.arrayBuffer()).byteLength;
        }
        if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
          return body.byteLength;
        }
        if (utils_default.isURLSearchParams(body)) {
          body = body + "";
        }
        if (utils_default.isString(body)) {
          return (await encodeText(body)).byteLength;
        }
      };
      const resolveBodyLength = async (headers, body) => {
        const length = utils_default.toFiniteNumber(headers.getContentLength());
        return length == null ? getBodyLength(body) : length;
      };
      return async (config) => {
        let {
          url: url2,
          method,
          data,
          signal,
          cancelToken,
          timeout,
          onDownloadProgress,
          onUploadProgress,
          responseType,
          headers,
          withCredentials = "same-origin",
          fetchOptions
        } = resolveConfig_default(config);
        let _fetch = envFetch || fetch;
        responseType = responseType ? (responseType + "").toLowerCase() : "text";
        let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
        let request = null;
        const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
          composedSignal.unsubscribe();
        });
        let requestContentLength;
        try {
          if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
            let _request = new Request(url2, {
              method: "POST",
              body: data,
              duplex: "half"
            });
            let contentTypeHeader;
            if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
              headers.setContentType(contentTypeHeader);
            }
            if (_request.body) {
              const [onProgress, flush] = progressEventDecorator(
                requestContentLength,
                progressEventReducer(asyncDecorator(onUploadProgress))
              );
              data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
            }
          }
          if (!utils_default.isString(withCredentials)) {
            withCredentials = withCredentials ? "include" : "omit";
          }
          const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
          const resolvedOptions = {
            ...fetchOptions,
            signal: composedSignal,
            method: method.toUpperCase(),
            headers: headers.normalize().toJSON(),
            body: data,
            duplex: "half",
            credentials: isCredentialsSupported ? withCredentials : void 0
          };
          request = isRequestSupported && new Request(url2, resolvedOptions);
          let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url2, resolvedOptions));
          const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
          if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
            const options = {};
            ["status", "statusText", "headers"].forEach((prop2) => {
              options[prop2] = response[prop2];
            });
            const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
            const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
              responseContentLength,
              progressEventReducer(asyncDecorator(onDownloadProgress), true)
            ) || [];
            response = new Response(
              trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
                flush && flush();
                unsubscribe && unsubscribe();
              }),
              options
            );
          }
          responseType = responseType || "text";
          let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
          !isStreamResponse && unsubscribe && unsubscribe();
          return await new Promise((resolve, reject) => {
            settle(resolve, reject, {
              data: responseData,
              headers: AxiosHeaders_default.from(response.headers),
              status: response.status,
              statusText: response.statusText,
              config,
              request
            });
          });
        } catch (err) {
          unsubscribe && unsubscribe();
          if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
            throw Object.assign(
              new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request),
              {
                cause: err.cause || err
              }
            );
          }
          throw AxiosError_default.from(err, err && err.code, config, request);
        }
      };
    };
    seedCache = /* @__PURE__ */ new Map();
    getFetch = (config) => {
      let env5 = config && config.env || {};
      const { fetch: fetch2, Request, Response } = env5;
      const seeds = [
        Request,
        Response,
        fetch2
      ];
      let len = seeds.length, i = len, seed, target, map2 = seedCache;
      while (i--) {
        seed = seeds[i];
        target = map2.get(seed);
        target === void 0 && map2.set(seed, target = i ? /* @__PURE__ */ new Map() : factory(env5));
        map2 = target;
      }
      return target;
    };
    adapter = getFetch();
  }
});

// node_modules/axios/lib/adapters/adapters.js
function getAdapter(adapters, config) {
  adapters = utils_default.isArray(adapters) ? adapters : [adapters];
  const { length } = adapters;
  let nameOrAdapter;
  let adapter2;
  const rejectedReasons = {};
  for (let i = 0; i < length; i++) {
    nameOrAdapter = adapters[i];
    let id;
    adapter2 = nameOrAdapter;
    if (!isResolvedHandle(nameOrAdapter)) {
      adapter2 = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
      if (adapter2 === void 0) {
        throw new AxiosError_default(`Unknown adapter '${id}'`);
      }
    }
    if (adapter2 && (utils_default.isFunction(adapter2) || (adapter2 = adapter2.get(config)))) {
      break;
    }
    rejectedReasons[id || "#" + i] = adapter2;
  }
  if (!adapter2) {
    const reasons = Object.entries(rejectedReasons).map(
      ([id, state2]) => `adapter ${id} ` + (state2 === false ? "is not supported by the environment" : "is not available in the build")
    );
    let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
    throw new AxiosError_default(
      `There is no suitable adapter to dispatch the request ` + s,
      "ERR_NOT_SUPPORT"
    );
  }
  return adapter2;
}
var knownAdapters, renderReason, isResolvedHandle, adapters_default;
var init_adapters = __esm({
  "node_modules/axios/lib/adapters/adapters.js"() {
    init_utils5();
    init_http();
    init_xhr();
    init_fetch();
    init_AxiosError();
    knownAdapters = {
      http: http_default,
      xhr: xhr_default,
      fetch: {
        get: getFetch
      }
    };
    utils_default.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    renderReason = (reason) => `- ${reason}`;
    isResolvedHandle = (adapter2) => utils_default.isFunction(adapter2) || adapter2 === null || adapter2 === false;
    adapters_default = {
      /**
       * Resolve an adapter from a list of adapter names or functions.
       * @type {Function}
       */
      getAdapter,
      /**
       * Exposes all known adapters
       * @type {Object<string, Function|Object>}
       */
      adapters: knownAdapters
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters_default.getAdapter(config.adapter || defaults_default.adapter, config);
  return adapter2(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
var init_dispatchRequest = __esm({
  "node_modules/axios/lib/core/dispatchRequest.js"() {
    "use strict";
    init_transformData();
    init_isCancel();
    init_defaults();
    init_CanceledError();
    init_AxiosHeaders();
    init_adapters();
  }
});

// node_modules/axios/lib/helpers/validator.js
function assertOptions(options, schema2, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema2[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validators, deprecatedWarnings, validator_default;
var init_validator = __esm({
  "node_modules/axios/lib/helpers/validator.js"() {
    "use strict";
    init_data();
    init_AxiosError();
    validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
      validators[type2] = function validator(thing) {
        return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
      };
    });
    deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version3, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator === false) {
          throw new AxiosError_default(
            formatMessage(opt, " has been removed" + (version3 ? " in " + version3 : "")),
            AxiosError_default.ERR_DEPRECATED
          );
        }
        if (version3 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version3 + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    validators.spelling = function spelling(correctSpelling) {
      return (value, opt) => {
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
      };
    };
    validator_default = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var validators2, Axios, Axios_default;
var init_Axios = __esm({
  "node_modules/axios/lib/core/Axios.js"() {
    "use strict";
    init_utils5();
    init_buildURL();
    init_InterceptorManager();
    init_dispatchRequest();
    init_mergeConfig();
    init_buildFullPath();
    init_validator();
    init_AxiosHeaders();
    validators2 = validator_default.validators;
    Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig || {};
        this.interceptors = {
          request: new InterceptorManager_default(),
          response: new InterceptorManager_default()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy = {};
            Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
            const stack2 = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            try {
              if (!err.stack) {
                err.stack = stack2;
              } else if (stack2 && !String(err.stack).endsWith(stack2.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack2;
              }
            } catch (e) {
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional: transitional2, paramsSerializer, headers } = config;
        if (transitional2 !== void 0) {
          validator_default.assertOptions(transitional2, {
            silentJSONParsing: validators2.transitional(validators2.boolean),
            forcedJSONParsing: validators2.transitional(validators2.boolean),
            clarifyTimeoutError: validators2.transitional(validators2.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils_default.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator_default.assertOptions(paramsSerializer, {
              encode: validators2.function,
              serialize: validators2.function
            }, true);
          }
        }
        if (config.allowAbsoluteUrls !== void 0) {
        } else if (this.defaults.allowAbsoluteUrls !== void 0) {
          config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
        } else {
          config.allowAbsoluteUrls = true;
        }
        validator_default.assertOptions(config, {
          baseUrl: validators2.spelling("baseURL"),
          withXsrfToken: validators2.spelling("withXSRFToken")
        }, true);
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils_default.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils_default.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift(...requestInterceptorChain);
          chain.push(...responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url2, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url: url2,
          data: (config || {}).data
        }));
      };
    });
    utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url2, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: url2,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    Axios_default = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken, CancelToken_default;
var init_CancelToken = __esm({
  "node_modules/axios/lib/cancel/CancelToken.js"() {
    "use strict";
    init_CanceledError();
    CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners) return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError_default(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index2 = this._listeners.indexOf(listener);
        if (index2 !== -1) {
          this._listeners.splice(index2, 1);
        }
      }
      toAbortSignal() {
        const controller = new AbortController();
        const abort = (err) => {
          controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = () => this.unsubscribe(abort);
        return controller.signal;
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    CancelToken_default = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
var init_spread = __esm({
  "node_modules/axios/lib/helpers/spread.js"() {
    "use strict";
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}
var init_isAxiosError = __esm({
  "node_modules/axios/lib/helpers/isAxiosError.js"() {
    "use strict";
    init_utils5();
  }
});

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode, HttpStatusCode_default;
var init_HttpStatusCode = __esm({
  "node_modules/axios/lib/helpers/HttpStatusCode.js"() {
    HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511,
      WebServerIsDown: 521,
      ConnectionTimedOut: 522,
      OriginIsUnreachable: 523,
      TimeoutOccurred: 524,
      SslHandshakeFailed: 525,
      InvalidSslCertificate: 526
    };
    Object.entries(HttpStatusCode).forEach(([key2, value]) => {
      HttpStatusCode[value] = key2;
    });
    HttpStatusCode_default = HttpStatusCode;
  }
});

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios, axios_default;
var init_axios = __esm({
  "node_modules/axios/lib/axios.js"() {
    "use strict";
    init_utils5();
    init_bind();
    init_Axios();
    init_mergeConfig();
    init_defaults();
    init_formDataToJSON();
    init_CanceledError();
    init_CancelToken();
    init_isCancel();
    init_data();
    init_toFormData();
    init_AxiosError();
    init_spread();
    init_isAxiosError();
    init_AxiosHeaders();
    init_adapters();
    init_HttpStatusCode();
    axios = createInstance(defaults_default);
    axios.Axios = Axios_default;
    axios.CanceledError = CanceledError_default;
    axios.CancelToken = CancelToken_default;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData_default;
    axios.AxiosError = AxiosError_default;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders_default;
    axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters_default.getAdapter;
    axios.HttpStatusCode = HttpStatusCode_default;
    axios.default = axios;
    axios_default = axios;
  }
});

// node_modules/axios/index.js
var Axios2, AxiosError2, CanceledError2, isCancel2, CancelToken2, VERSION2, all2, Cancel, isAxiosError2, spread2, toFormData2, AxiosHeaders2, HttpStatusCode2, formToJSON, getAdapter2, mergeConfig2;
var init_axios2 = __esm({
  "node_modules/axios/index.js"() {
    init_axios();
    ({
      Axios: Axios2,
      AxiosError: AxiosError2,
      CanceledError: CanceledError2,
      isCancel: isCancel2,
      CancelToken: CancelToken2,
      VERSION: VERSION2,
      all: all2,
      Cancel,
      isAxiosError: isAxiosError2,
      spread: spread2,
      toFormData: toFormData2,
      AxiosHeaders: AxiosHeaders2,
      HttpStatusCode: HttpStatusCode2,
      formToJSON,
      getAdapter: getAdapter2,
      mergeConfig: mergeConfig2
    } = axios_default);
  }
});

// src/rateLimiter.ts
var RateLimiter;
var init_rateLimiter = __esm({
  "src/rateLimiter.ts"() {
    "use strict";
    RateLimiter = class {
      constructor(ratePerSecond, burst) {
        this.ratePerSecond = ratePerSecond;
        this.burst = burst;
        this.tokens = burst;
        this.lastRefill = Date.now();
      }
      tokens;
      queue = [];
      lastRefill;
      timer = null;
      refill() {
        const now = Date.now();
        const elapsed = (now - this.lastRefill) / 1e3;
        if (elapsed <= 0) return;
        this.lastRefill = now;
        this.tokens = Math.min(this.burst, this.tokens + elapsed * this.ratePerSecond);
      }
      scheduleDrain() {
        if (this.timer || this.queue.length === 0) return;
        const delay2 = 50;
        this.timer = setTimeout(() => {
          this.timer = null;
          this.refill();
          while (this.queue.length && this.tokens >= 1) {
            this.tokens -= 1;
            const resolve = this.queue.shift();
            resolve && resolve();
          }
          if (this.queue.length) this.scheduleDrain();
        }, delay2);
      }
      acquire() {
        this.refill();
        if (this.tokens >= 1 && this.queue.length === 0) {
          this.tokens -= 1;
          return Promise.resolve();
        }
        return new Promise((res) => {
          this.queue.push(res);
          this.scheduleDrain();
        });
      }
    };
  }
});

// src/azureClient.ts
var logger4, escapeRegExp, stripProjectSegment, AzureDevOpsIntClient;
var init_azureClient = __esm({
  "src/azureClient.ts"() {
    "use strict";
    init_axios2();
    init_rateLimiter();
    init_cache();
    init_performance();
    init_unifiedLogger();
    logger4 = createLogger("azureClient");
    escapeRegExp = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    stripProjectSegment = (url2, encodedProject, rawProject) => {
      const candidates = /* @__PURE__ */ new Set();
      if (encodedProject) {
        candidates.add(encodedProject);
        const doubleEncoded = encodeURIComponent(encodedProject);
        if (doubleEncoded && doubleEncoded !== encodedProject) {
          candidates.add(doubleEncoded);
        }
      }
      if (rawProject?.trim()) {
        candidates.add(rawProject.trim());
      }
      try {
        const decoded = decodeURIComponent(encodedProject);
        if (decoded) {
          candidates.add(decoded);
          const fullyDecoded = decodeURIComponent(decoded);
          if (fullyDecoded) {
            candidates.add(fullyDecoded);
          }
        }
      } catch {
      }
      return Array.from(candidates).reduce((current, candidate) => {
        if (!candidate) {
          return current;
        }
        const pattern = new RegExp(`/${escapeRegExp(candidate)}$`);
        return current.replace(pattern, "");
      }, url2);
    };
    AzureDevOpsIntClient = class _AzureDevOpsIntClient {
      organization;
      project;
      encodedOrganization;
      encodedProject;
      axios;
      _repoCache;
      credential;
      // PAT or access token
      authType;
      limiter;
      onAuthFailure;
      team;
      encodedTeam;
      // Capability cache: prefer using [System.StateCategory] unless Azure DevOps rejects it for this org/project
      preferStateCategory;
      cachedIdentity;
      identityName;
      // Fallback identity name for on-prem servers
      // baseUrl is for browser/UI links only (e.g., openExternal). Never for REST calls.
      baseUrl;
      // apiBaseUrl is the canonical root for REST calls (must include project + '/_apis').
      apiBaseUrl;
      static connectionDataApiVersions = [
        "7.1-preview.1",
        "7.0-preview.1",
        "6.0-preview.1",
        "5.1-preview.2",
        "5.0-preview.3",
        "5.0-preview",
        "5.0"
      ];
      _authorizedGet(url2) {
        return this.axios.get(url2, { baseURL: void 0 });
      }
      constructor(organization, project, credential, options = {}) {
        this.organization = organization;
        this.project = project;
        this.credential = credential;
        this.authType = options.authType ?? "pat";
        this.onAuthFailure = options.onAuthFailure;
        this.team = options.team?.trim() ? options.team.trim() : void 0;
        this.preferStateCategory = options.wiqlPreferStateCategory ?? true;
        this.identityName = options.identityName?.trim() ? options.identityName.trim() : void 0;
        if (this.identityName) {
          logger4.info("Configured with fallback identityName for on-prem", {
            meta: { identityName: this.identityName }
          });
        }
        this.encodedOrganization = encodeURIComponent(organization);
        this.encodedProject = encodeURIComponent(project);
        this.encodedTeam = this.team ? encodeURIComponent(this.team) : void 0;
        const trimTrailingSlash = (value) => value ? value.replace(/\/+$/, "") : void 0;
        const normalizeBaseUrl = (value) => {
          const fallback2 = `https://dev.azure.com/${this.encodedOrganization}`;
          if (!value) {
            return fallback2;
          }
          const trimmed = trimTrailingSlash(value) ?? fallback2;
          const withoutApis = trimmed.replace(/\/_apis$/i, "");
          if (/visualstudio\.com/i.test(withoutApis)) {
            return withoutApis;
          }
          if (/dev\.azure\.com/i.test(withoutApis)) {
            return `https://dev.azure.com/${this.encodedOrganization}`;
          }
          const normalized = stripProjectSegment(withoutApis, this.encodedProject, this.project);
          return trimTrailingSlash(normalized) ?? fallback2;
        };
        const ensureApiSuffix = (value) => {
          const trimmed = trimTrailingSlash(value) ?? value;
          return /\/_apis$/i.test(trimmed) ? trimmed : `${trimmed}/_apis`;
        };
        if (options.apiBaseUrl) {
          const manualApi = ensureApiSuffix(options.apiBaseUrl).replace(/\/+$/, "");
          const baseCandidate = manualApi.replace(/\/_apis$/i, "");
          const derivedBase = stripProjectSegment(baseCandidate, this.encodedProject, this.project);
          const preferredBase = options.baseUrl ? normalizeBaseUrl(options.baseUrl) : normalizeBaseUrl(derivedBase);
          this.baseUrl = preferredBase;
          this.apiBaseUrl = manualApi;
          logger4.info("Using apiBaseUrl from settings", {
            meta: { apiBaseUrl: this.apiBaseUrl, baseUrl: this.baseUrl }
          });
        } else if (options.baseUrl) {
          this.baseUrl = normalizeBaseUrl(options.baseUrl);
          this.apiBaseUrl = `${this.baseUrl}/${this.encodedProject}/_apis`;
        } else {
          this.baseUrl = `https://dev.azure.com/${this.encodedOrganization}`;
          this.apiBaseUrl = `${this.baseUrl}/${this.encodedProject}/_apis`;
        }
        this.baseUrl = this.baseUrl.replace(/\/+$/, "");
        this.apiBaseUrl = this.apiBaseUrl.replace(/\/+$/, "");
        this.axios = axios_default.create({
          baseURL: this.apiBaseUrl,
          timeout: 3e4,
          // 30s network timeout for slow Azure DevOps APIs
          headers: {
            "Content-Type": "application/json"
          }
        });
        const rps = Math.max(1, Math.min(50, options.ratePerSecond ?? 5));
        const burst = Math.max(1, Math.min(100, options.burst ?? 10));
        this.limiter = new RateLimiter(rps, burst);
        this.axios.interceptors.request.use(async (cfg) => {
          await this.limiter.acquire();
          if (this.authType === "pat") {
            (cfg.headers ||= {})["Authorization"] = `Basic ${Buffer.from(":" + this.credential).toString("base64")}`;
          } else {
            (cfg.headers ||= {})["Authorization"] = `Bearer ${this.credential}`;
          }
          cfg.__start = Date.now();
          cfg.__attempt = (cfg.__attempt || 0) + 1;
          const authHeader = cfg.headers?.["Authorization"];
          const tokenDebug = authHeader ? `${authHeader.substring(0, 20)}...${authHeader.substring(authHeader.length - 10)}` : "NO_AUTH_HEADER";
          logger4.debug("HTTP request", {
            meta: {
              method: cfg.method?.toUpperCase(),
              url: cfg.url,
              attempt: cfg.__attempt,
              token: tokenDebug
            }
          });
          return cfg;
        });
        this.axios.interceptors.response.use(
          (resp) => {
            const ms = Date.now() - resp.config.__start;
            logger4.debug("HTTP response", {
              meta: {
                method: resp.config.method?.toUpperCase(),
                url: resp.config.url,
                status: resp.status,
                duration: `${ms}ms`
              }
            });
            return resp;
          },
          async (err) => {
            const cfg = err.config || {};
            const ms = cfg.__start ? Date.now() - cfg.__start : "n/a";
            if (err.response) {
              const { status: status2, statusText, data } = err.response;
              if (status2 === 404) {
                logger4.error("HTTP 404 Details", {
                  meta: {
                    method: cfg.method?.toUpperCase(),
                    url: cfg.url,
                    fullUrl: cfg.baseURL + cfg.url,
                    status: status2,
                    statusText,
                    responseData: data,
                    authType: this.authType,
                    organization: this.organization,
                    project: this.project
                  }
                });
              }
              logger4.error("HTTP error", {
                meta: {
                  method: cfg.method?.toUpperCase(),
                  url: cfg.url,
                  status: status2,
                  statusText,
                  duration: `${ms}ms`
                }
              });
              if (data) {
                let snippet3;
                try {
                  snippet3 = typeof data === "string" ? data.slice(0, 500) : JSON.stringify(data).slice(0, 500);
                } catch {
                  snippet3 = "[unserializable response data]";
                }
                logger4.error("HTTP error body", { meta: { snippet: snippet3 } });
              }
              if (status2 === 401 && this.authType === "bearer") {
                logger4.error("HTTP 401 Unauthorized - authentication required");
                const authError = new Error(
                  `Authentication failed: 401 Unauthorized. Please re-authenticate.`
                );
                authError.name = "AuthenticationError";
                authError.status = status2;
                try {
                  this.onAuthFailure?.(authError);
                } catch (callbackError) {
                  logger4.error("onAuthFailure callback threw", { meta: callbackError });
                }
                throw authError;
              }
              if (status2 === 401 && this.authType === "pat") {
                const errorMessage = data?.message || (typeof data === "string" ? data : "") || "";
                const isPatExpired = errorMessage.toLowerCase().includes("expired") || errorMessage.toLowerCase().includes("personal access token used has expired");
                if (isPatExpired) {
                  logger4.error("HTTP 401 Unauthorized - PAT expired");
                  const authError = new Error(
                    `Personal Access Token has expired. Please update your PAT.`
                  );
                  authError.name = "AuthenticationError";
                  authError.status = status2;
                  authError.isPatExpired = true;
                  try {
                    this.onAuthFailure?.(authError);
                  } catch (callbackError) {
                    logger4.error("onAuthFailure callback threw", { meta: callbackError });
                  }
                  throw authError;
                }
              }
            } else if (err.code === "ECONNABORTED") {
              logger4.error("HTTP timeout", {
                meta: { method: cfg.method?.toUpperCase(), url: cfg.url, duration: `${ms}ms` }
              });
            } else {
              logger4.error("HTTP network error", { meta: { message: err.message } });
            }
            const status = err.response?.status;
            const attempt = cfg.__attempt || 1;
            const maxAttempts = 4;
            if (status && (status === 429 || status >= 500 && status < 600) && attempt < maxAttempts) {
              const backoffBase = 250 * Math.pow(2, attempt - 1);
              const jitter = Math.random() * backoffBase * 0.3;
              const delay2 = Math.min(4e3, backoffBase + jitter);
              logger4.warn("HTTP retry", {
                meta: { url: cfg.url, status, retryInMs: Math.round(delay2), attempt: attempt + 1 }
              });
              return new Promise((resolve) => setTimeout(resolve, delay2)).then(() => this.axios(cfg));
            }
            return Promise.reject(err);
          }
        );
      }
      /**
       * Update the credential (PAT or access token)
       * Useful for refreshing Entra ID tokens
       */
      updateCredential(newCredential) {
        this.credential = newCredential;
      }
      // Build a REST endpoint URL from apiBaseUrl (for HTTP calls)
      buildFullUrl(path3) {
        return `${this.apiBaseUrl}${path3}`;
      }
      // Build a browser URL from baseUrl (for openExternal)
      getBrowserUrl(path3) {
        return `${this.baseUrl}/${this.encodedProject}${path3}`;
      }
      buildTeamApiUrl(path3) {
        if (!this.encodedTeam) return this.buildFullUrl(path3);
        const baseWithoutApis = this.apiBaseUrl.replace(/\/_apis$/, "");
        return `${baseWithoutApis}/${this.encodedTeam}/_apis${path3}`;
      }
      // ---------------- Identity Helpers ----------------
      /**
       * Fetches the authenticated Azure DevOps user identity GUID using connectionData.
       * Falls back to null on error.
       */
      async getAuthenticatedUserId() {
        logger4.debug("Testing authentication...");
        const identity = await this._getAuthenticatedIdentity();
        if (identity?.id) {
          logger4.info("Authentication successful", {
            meta: {
              displayName: identity.displayName || "Unknown",
              uniqueName: identity.uniqueName || "Unknown"
            }
          });
          logger4.debug("Authentication method: Personal Access Token (PAT)");
          logger4.debug("PAT has at least basic read permissions");
          logger4.debug("If work item creation works, PAT also has work item write permissions");
        } else {
          logger4.warn("Authentication failed - no user identity returned");
        }
        try {
          logger4.debug("Resolved identity object", { meta: identity });
        } catch {
        }
        return identity?.id ?? null;
      }
      async _getAuthenticatedIdentity() {
        if (this.cachedIdentity) return this.cachedIdentity;
        try {
          let resp;
          const attempts = [];
          const attemptConnectionData = async (basePath, desc, useAxiosBase) => {
            let lastError2;
            const sanitized = basePath.replace(/([&?]+)api-version=[^&]+/i, "").replace(/[&?]+$/, "");
            for (const version3 of _AzureDevOpsIntClient.connectionDataApiVersions) {
              const separator = sanitized.includes("?") ? "&" : "?";
              const fullUrl = `${sanitized}${separator}api-version=${version3}`;
              attempts.push({ desc: `${desc} (v=${version3})`, url: fullUrl });
              try {
                return useAxiosBase ? await this.axios.get(fullUrl) : await this._authorizedGet(fullUrl);
              } catch (error) {
                lastError2 = error;
                if (!this._shouldRetryConnectionDataVersion(error)) {
                  throw error;
                }
              }
            }
            throw lastError2 || new Error("connectionData api-version attempts exhausted");
          };
          try {
            const orgLevel = this.baseUrl.replace(/\/$/, "") + "/_apis/connectionData";
            resp = await attemptConnectionData(orgLevel, "baseUrl org-level", false);
          } catch (err1) {
            try {
              const apiRoot = stripProjectSegment(
                this.apiBaseUrl.replace(/\/_apis\/?$/, ""),
                this.encodedProject,
                this.project
              );
              const apiConn = apiRoot.replace(/\/$/, "") + "/_apis/connectionData";
              resp = await attemptConnectionData(apiConn, "apiBaseUrl without project", false);
            } catch (err2) {
              try {
                resp = await attemptConnectionData(
                  "/connectionData",
                  "relative to axios baseURL",
                  true
                );
              } catch (err3) {
                logger4.error("connectionData attempts failed", { meta: { attempts } });
                throw err1 || err2 || err3;
              }
            }
          }
          const user = resp.data?.authenticatedUser ?? {};
          const resolvedId = typeof user.id === "string" || typeof user.id === "number" ? String(user.id) : typeof user.descriptor === "string" ? user.descriptor : typeof user.subjectDescriptor === "string" ? user.subjectDescriptor : void 0;
          const displayName = typeof user.providerDisplayName === "string" ? user.providerDisplayName : typeof user.displayName === "string" ? user.displayName : void 0;
          const uniqueName = typeof user.uniqueName === "string" ? user.uniqueName : typeof user.unique_name === "string" ? user.unique_name : typeof user.mailAddress === "string" ? user.mailAddress : typeof user.email === "string" ? user.email : typeof user.principalName === "string" ? user.principalName : typeof user.subjectDescriptor === "string" ? user.subjectDescriptor : typeof user.descriptor === "string" ? user.descriptor : void 0;
          const identity = {
            id: resolvedId,
            displayName,
            uniqueName
          };
          this.cachedIdentity = identity;
          try {
            logger4.debug("Resolved identity object", { meta: identity });
          } catch {
          }
          if (!this.cachedIdentity.uniqueName && this.identityName) {
            logger4.debug("Using provided identityName as fallback", {
              meta: { identityName: this.identityName }
            });
            this.cachedIdentity.uniqueName = this.identityName;
          }
          return this.cachedIdentity;
        } catch (e) {
          logger4.error("Error fetching authenticated user identity", { meta: e });
          if (this.identityName) {
            logger4.debug("connectionData failed, using identityName fallback", {
              meta: { identityName: this.identityName }
            });
            this.cachedIdentity = {
              uniqueName: this.identityName
            };
            return this.cachedIdentity;
          }
          return null;
        }
      }
      _shouldRetryConnectionDataVersion(error) {
        const status = error?.response?.status;
        if (status !== 400) {
          return false;
        }
        const message = String(
          error?.response?.data?.message || error?.response?.data?.error?.message || error?.response?.data || error?.message || ""
        );
        return /preview/i.test(message) || /api[- ]?version/i.test(message);
      }
      /**
       * Normalize query name to canonical form for consistent caching and matching
       * Known query names are matched case-insensitively
       *
       * @param query - The query name to normalize
       * @returns The normalized query name in canonical form, or the original trimmed input for custom WIQL
       * @throws {Error} If query is null, undefined, not a string, empty, or only whitespace
       */
      _normalizeQueryName(query) {
        if (query === null || query === void 0 || typeof query !== "string") {
          throw new Error(`Invalid query parameter: expected non-empty string, got ${typeof query}`);
        }
        const trimmed = query.trim();
        if (trimmed.length === 0) {
          throw new Error("Query name cannot be empty or contain only whitespace");
        }
        const knownQueries = [
          "My Activity",
          "Assigned to me",
          "My Work Items",
          "Recently Updated",
          "All Active",
          "All Work Items",
          "Current Sprint",
          "Created By Me",
          "Following",
          "Mentioned"
        ];
        const normalized = knownQueries.find((q) => q.toLowerCase() === trimmed.toLowerCase());
        return normalized || trimmed;
      }
      buildWIQL(queryNameOrText) {
        return this._buildWIQL(queryNameOrText, this.preferStateCategory);
      }
      _selectFields() {
        return `[System.Id], [System.Title], [System.State], [System.WorkItemType], 
                           [System.AssignedTo], [System.CreatedDate], [System.ChangedDate],
                           [System.IterationPath], [System.Tags], [Microsoft.VSTS.Common.Priority]`;
      }
      _buildWIQL(queryNameOrText, useStateCategory) {
        const fields = this._selectFields();
        const selectedSprint = null;
        const sprintClause = selectedSprint ? `AND [System.IterationPath] = '${selectedSprint}'` : "";
        const activeFilter = this._activeStateFilter(useStateCategory);
        switch (queryNameOrText) {
          case "My Activity":
            return `SELECT ${fields} FROM WorkItems 
                        WHERE [System.TeamProject] = @Project
                        AND ([System.AssignedTo] = @Me OR [System.CreatedBy] = @Me OR [System.ChangedBy] = @Me)
                        ${activeFilter}
                        ${sprintClause}
                        ORDER BY [System.ChangedDate] DESC`;
          case "Assigned to me":
          case "My Work Items":
            return `SELECT ${fields} FROM WorkItems 
                        WHERE [System.TeamProject] = @Project
                        AND [System.AssignedTo] = @Me 
                        ${activeFilter}
                        ${sprintClause}
                        ORDER BY [System.ChangedDate] DESC`;
          case "Current Sprint":
            return selectedSprint ? `SELECT ${fields} FROM WorkItems 
                            WHERE [System.IterationPath] = '${selectedSprint}'
                            ${activeFilter}
                            ORDER BY [Microsoft.VSTS.Common.Priority] ASC, [System.Id] ASC` : `SELECT ${fields} FROM WorkItems 
                        WHERE [System.IterationPath] UNDER @CurrentIteration 
                        ${activeFilter}
                        ORDER BY [Microsoft.VSTS.Common.Priority] ASC, [System.Id] ASC`;
          case "All Active":
            return `SELECT ${fields} FROM WorkItems 
                        WHERE [System.TeamProject] = @Project
                        ${activeFilter}
                        ${sprintClause}
                        ORDER BY [System.ChangedDate] DESC`;
          case "All Work Items":
            return `SELECT ${fields} FROM WorkItems 
                        WHERE [System.TeamProject] = @Project
                        AND [System.State] <> 'Removed'
                        ${sprintClause}
                        ORDER BY [System.ChangedDate] DESC`;
          case "Recently Updated":
            return `SELECT ${fields} FROM WorkItems 
                        WHERE [System.TeamProject] = @Project
                        AND [System.ChangedDate] >= @Today - 3
                        ${activeFilter}
                        ${sprintClause}
                        ORDER BY [System.ChangedDate] DESC`;
          case "Created By Me":
          case "Created by Me":
          case "Created by me":
            return `SELECT ${fields} FROM WorkItems 
                        WHERE [System.TeamProject] = @Project
                        AND [System.CreatedBy] = @Me 
                        ${activeFilter}
                        ${sprintClause}
                        ORDER BY [System.ChangedDate] DESC`;
          default:
            return queryNameOrText;
        }
      }
      _activeStateFilter(useStateCategory) {
        if (useStateCategory) {
          return `AND [System.StateCategory] <> 'Completed' AND [System.State] <> 'Removed'`;
        }
        return `AND [System.State] NOT IN ('Closed','Done','Resolved','Removed')`;
      }
      _isTooManyResultsError(err) {
        const status = err?.response?.status;
        if (status !== 400) return false;
        const message = String(
          err?.response?.data?.message || err?.response?.data?.value?.Message || err?.message || ""
        );
        return /exceeds the size limit/i.test(message) || /WorkItemTrackingQueryResultSizeLimitExceededException/i.test(message) || /VS402337/i.test(message);
      }
      _mapRawWorkItems(rawItems) {
        if (!Array.isArray(rawItems)) return [];
        return rawItems.filter((item) => item && typeof item.id === "number").map((item) => {
          const mapped = {
            id: item.id,
            fields: item.fields || {}
          };
          if (Array.isArray(item.relations) && item.relations.length > 0) {
            const relations = item.relations.filter((rel) => rel && typeof rel === "object").map((rel) => {
              const attributes = rel.attributes && typeof rel.attributes === "object" ? { ...rel.attributes } : void 0;
              return {
                url: typeof rel.url === "string" ? rel.url : void 0,
                rel: typeof rel.rel === "string" ? rel.rel : void 0,
                attributes
              };
            }).filter(Boolean);
            if (relations.length > 0) {
              mapped.relations = relations;
            }
          }
          return mapped;
        });
      }
      async _fetchWorkItemsByIds(ids) {
        if (!Array.isArray(ids) || ids.length === 0) return [];
        const uniqueIds = Array.from(new Set(ids.filter((id) => Number.isFinite(id))));
        if (uniqueIds.length === 0) return [];
        const results = [];
        const chunkSize = 200;
        for (let i = 0; i < uniqueIds.length; i += chunkSize) {
          const chunk = uniqueIds.slice(i, i + chunkSize);
          if (chunk.length === 0) continue;
          try {
            const resp = await this.axios.get(
              `/wit/workitems?ids=${chunk.join(",")}&$expand=all&api-version=7.1`
            );
            const rawItems = resp.data?.value || [];
            results.push(...this._mapRawWorkItems(rawItems));
          } catch (err) {
            logger4.warn("Failed to expand work item chunk", { meta: { error: err?.message || err } });
          }
        }
        return results;
      }
      _filterItemsForProject(items) {
        if (!Array.isArray(items) || !this.project) return Array.isArray(items) ? [...items] : [];
        const target = this.project.trim().toLowerCase();
        return items.filter((item) => {
          const projectName = item?.fields?.["System.TeamProject"];
          if (!projectName || typeof projectName !== "string") return true;
          return projectName.trim().toLowerCase() === target;
        });
      }
      _sortByChangedDateDesc(items) {
        return [...items].sort((a, b) => {
          const aDate = new Date(a?.fields?.["System.ChangedDate"] || 0).getTime();
          const bDate = new Date(b?.fields?.["System.ChangedDate"] || 0).getTime();
          return bDate - aDate;
        });
      }
      async _getFollowedWorkItems() {
        try {
          const resp = await this.axios.get("/work/workitems/favorites?api-version=7.1");
          const entries = Array.isArray(resp.data?.value) ? resp.data.value : [];
          const ids = entries.map((entry) => {
            if (typeof entry?.workItemId === "number") return entry.workItemId;
            if (typeof entry?.id === "number") return entry.id;
            const nested = entry?.workItem?.id;
            return typeof nested === "number" ? nested : NaN;
          }).filter((id) => Number.isFinite(id));
          if (ids.length === 0) return [];
          const items = await this._fetchWorkItemsByIds(ids);
          const filtered = this._filterItemsForProject(items);
          return this._sortByChangedDateDesc(filtered);
        } catch (err) {
          logger4.warn("Failed to fetch followed work items", { meta: { error: err?.message || err } });
          return [];
        }
      }
      async _getMentionedWorkItems() {
        const identity = await this._getAuthenticatedIdentity();
        if (!identity) return [];
        const terms = /* @__PURE__ */ new Set();
        if (typeof identity.displayName === "string" && identity.displayName.trim()) {
          terms.add(identity.displayName.trim());
        }
        if (typeof identity.uniqueName === "string" && identity.uniqueName.trim()) {
          terms.add(identity.uniqueName.trim());
        }
        if (terms.size === 0) return [];
        const clauses = Array.from(terms).map(
          (term) => `[System.History] CONTAINS '${this._escapeWIQL(term)}'`
        );
        const fields = this._selectFields();
        const stateFilter = this._activeStateFilter(this.preferStateCategory);
        const query = `SELECT ${fields} FROM WorkItems 
                        WHERE [System.TeamProject] = @Project
                        AND (${clauses.join(" OR ")})
                        ${stateFilter}
                        ORDER BY [System.ChangedDate] DESC`;
        try {
          return await this.runWIQL(query);
        } catch (err) {
          logger4.warn("Failed to fetch mentioned work items", { meta: { error: err?.message || err } });
          return [];
        }
      }
      async getWorkItems(query) {
        return await measureAsync("getWorkItems", async () => {
          let wiql = "";
          let wiqlToSend = "";
          try {
            const normalizedQuery = this._normalizeQueryName(query);
            const cacheKey = WorkItemCache.generateWorkItemsKey(
              `${this.organization}-${this.project}`,
              normalizedQuery,
              { team: this.team }
            );
            const cached = workItemCache.get(cacheKey);
            if (cached) {
              logger4.debug("Cache hit for query", { meta: { query, normalizedQuery } });
              return cached;
            }
            if (normalizedQuery === "Following") {
              const result = await this._getFollowedWorkItems();
              workItemCache.setWorkItems(cacheKey, result);
              return result;
            }
            if (normalizedQuery === "Mentioned") {
              const result = await this._getMentionedWorkItems();
              workItemCache.setWorkItems(cacheKey, result);
              return result;
            }
            wiql = this.buildWIQL(normalizedQuery);
            if (normalizedQuery === "Current Sprint") {
              try {
                const cur = await this.getCurrentIteration();
                const iterPath = cur?.path;
                if (iterPath && typeof iterPath === "string") {
                  const safePath = this._escapeWIQL(iterPath);
                  wiql = `SELECT [System.Id], [System.Title], [System.State], [System.WorkItemType], [System.AssignedTo], [System.CreatedDate], [System.ChangedDate], [System.IterationPath], [System.Tags], [Microsoft.VSTS.Common.Priority] FROM WorkItems WHERE [System.IterationPath] UNDER '${safePath}' AND [System.State] <> 'Closed' AND [System.State] <> 'Removed' ORDER BY [Microsoft.VSTS.Common.Priority] ASC, [System.Id] ASC`;
                }
              } catch (e) {
                logger4.warn("getCurrentIteration failed, using @CurrentIteration", { meta: e });
              }
            }
            logger4.debug("Fetching work items with query", {
              meta: { wiql, apiBaseUrl: this.axios.defaults.baseURL }
            });
            wiqlToSend = wiql;
            const knownUserScopedQueries = ["My Activity", "Assigned to me", "My Work Items"];
            const isKnownQuery = [
              "Recently Updated",
              "All Active",
              "Current Sprint",
              ...knownUserScopedQueries
            ].includes(normalizedQuery);
            const needsLimit = !knownUserScopedQueries.includes(normalizedQuery) && (["Recently Updated", "All Active", "Current Sprint"].includes(normalizedQuery) || !isKnownQuery);
            if (needsLimit) {
              logger4.debug("Applying hard limit of 100 items for query", { meta: { query } });
            }
            if (/@Me\b/i.test(wiql) && this.identityName) {
              try {
                const resolved = await this._getAuthenticatedIdentity();
                if (resolved) {
                  const idVal = resolved.uniqueName || resolved.displayName || resolved.id || this.identityName;
                  if (idVal) {
                    const escaped = this._escapeWIQL(String(idVal));
                    wiqlToSend = wiql.replace(/@Me\b/g, `'${escaped}'`);
                    logger4.debug("Replacing @Me with explicit identity for on-prem compatibility", {
                      meta: { idVal, reason: "identityName configured" }
                    });
                  }
                }
              } catch (identErr) {
                logger4.warn("Failed resolving identity for @Me replacement", { meta: identErr });
              }
            } else if (/@Me\b/i.test(wiql)) {
              logger4.debug("Using @Me token directly (cloud Azure DevOps)", {
                meta: { hasIdentityName: !!this.identityName }
              });
            }
            const wiqlEndpoint = "/wit/wiql?api-version=7.1";
            let wiqlResp;
            try {
              wiqlResp = await this.axios.post(wiqlEndpoint, { query: wiqlToSend });
            } catch (err) {
              if (this._isMissingStateCategoryError(err)) {
                logger4.warn("StateCategory unsupported in WIQL. Retrying with legacy state filters.");
                this.preferStateCategory = false;
                const wiqlLegacy = this._buildWIQL(normalizedQuery, false);
                logger4.debug("Fallback WIQL", { meta: { wiqlLegacy } });
                let legacyToSend = wiqlLegacy;
                if (/@Me\b/i.test(wiqlLegacy) && this.identityName) {
                  try {
                    const resolved2 = await this._getAuthenticatedIdentity();
                    if (resolved2) {
                      const idVal2 = resolved2.uniqueName || resolved2.displayName || resolved2.id || this.identityName;
                      if (idVal2) {
                        legacyToSend = wiqlLegacy.replace(
                          /@Me\b/g,
                          `'${this._escapeWIQL(String(idVal2))}'`
                        );
                        logger4.debug("Replacing @Me in fallback WIQL with explicit identity", {
                          meta: { idVal2 }
                        });
                      }
                    }
                  } catch (e) {
                    logger4.warn("Identity resolution failed for fallback WIQL", { meta: e });
                  }
                }
                wiqlResp = await this.axios.post(wiqlEndpoint, { query: legacyToSend });
                wiql = wiqlLegacy;
              } else if (this._isTooManyResultsError(err)) {
                const DAYS = 1;
                const idx = wiqlToSend.lastIndexOf("ORDER BY");
                const head2 = idx > -1 ? wiqlToSend.slice(0, idx).trimEnd() : wiqlToSend;
                const tail = idx > -1 ? wiqlToSend.slice(idx) : "ORDER BY [System.ChangedDate] DESC";
                let bounded = `${head2}
AND [System.ChangedDate] >= @Today - ${DAYS}
${tail}`;
                if (/@Me\b/i.test(bounded) && this.identityName) {
                  try {
                    const resolved3 = await this._getAuthenticatedIdentity();
                    if (resolved3) {
                      const idVal3 = resolved3.uniqueName || resolved3.displayName || resolved3.id || this.identityName;
                      if (idVal3) {
                        bounded = bounded.replace(/@Me\b/g, `'${this._escapeWIQL(String(idVal3))}'`);
                      }
                    }
                  } catch {
                  }
                }
                logger4.warn("Result too large; retrying WIQL with shorter ChangedDate bound", {
                  meta: { days: DAYS, query }
                });
                try {
                  wiqlResp = await this.axios.post(wiqlEndpoint, { query: bounded });
                  wiql = bounded;
                } catch (retryErr) {
                  if (this._isTooManyResultsError(retryErr)) {
                    throw new Error(
                      `Query "${query}" returns too many work items (>20,000). Try filtering by a specific area path, iteration, or work item type to narrow results.`
                    );
                  }
                  throw retryErr;
                }
              } else {
                throw err;
              }
            }
            logger4.debug("WIQL response status", { meta: { status: wiqlResp.status } });
            try {
              const bodySnippet = JSON.stringify(wiqlResp.data).slice(0, 2e3);
              logger4.debug("WIQL response body (truncated)", { meta: { bodySnippet } });
            } catch {
            }
            let refs = wiqlResp.data?.workItems || [];
            logger4.debug("WIQL reference count", { meta: { count: refs.length } });
            if (needsLimit && refs.length > 100) {
              refs = refs.slice(0, 100);
              logger4.debug("Applied client-side limit", { meta: { reducedTo: refs.length } });
            }
            if (refs.length === 0) {
              const isUserScopedQuery = knownUserScopedQueries.includes(normalizedQuery);
              if (isUserScopedQuery) {
                const hadMeToken = /@Me\b/i.test(wiql);
                const meWasReplaced = hadMeToken && wiqlToSend !== wiql;
                const identityInfo = hadMeToken ? await this._getAuthenticatedIdentity().catch(() => null) : null;
                logger4.debug("User-scoped query returned 0 results", {
                  meta: {
                    query,
                    normalizedQuery,
                    originalWIQL: wiql,
                    sentWIQL: wiqlToSend,
                    hadMeToken,
                    meWasReplaced,
                    usingMeDirectly: hadMeToken && !meWasReplaced,
                    identityInfo: identityInfo ? {
                      id: identityInfo.id,
                      displayName: identityInfo.displayName,
                      uniqueName: identityInfo.uniqueName
                    } : null,
                    wiqlEndpoint,
                    responseStatus: wiqlResp?.status
                  }
                });
                return [];
              }
              logger4.debug("No work items matched query. Trying simpler query...");
              const simpleWiql = `SELECT [System.Id], [System.Title] FROM WorkItems 
            WHERE [System.TeamProject] = @Project
            AND [System.ChangedDate] >= @Today - 90
            AND [System.State] NOT IN ('Closed','Done','Resolved','Removed')
            ORDER BY [System.ChangedDate] DESC`;
              const simpleResp = await this.axios.post("/wit/wiql?api-version=7.1", {
                query: simpleWiql
              });
              try {
                const simpleSnippet = JSON.stringify(simpleResp.data).slice(0, 1500);
                logger4.debug("simpleWIQL response body (truncated)", { meta: { simpleSnippet } });
              } catch {
              }
              const simpleRefs = simpleResp.data?.workItems || [];
              logger4.debug("Simple query returned work items", { meta: { count: simpleRefs.length } });
              if (simpleRefs.length === 0) {
                logger4.debug("No work items in project at all.");
                return [];
              }
              logger4.debug("Original query matched nothing, fetching simple query results...");
              let simpleIdsArr = simpleRefs.map((w) => Number(w.id)).filter((id) => Number.isFinite(id));
              if (simpleIdsArr.length === 0) {
                logger4.debug("No valid IDs in simple query results.");
                return [];
              }
              if (simpleIdsArr.length > 200) {
                simpleIdsArr = simpleIdsArr.slice(0, 200);
                logger4.debug("Applied limit to simple query IDs", {
                  meta: { reducedTo: simpleIdsArr.length }
                });
              }
              logger4.debug("Expanding simple query IDs (chunked)", {
                meta: { count: simpleIdsArr.length }
              });
              const fallbackItems = await this._fetchWorkItemsByIds(simpleIdsArr);
              logger4.debug("Returning work items from simple query fallback", {
                meta: { count: fallbackItems.length }
              });
              workItemCache.setWorkItems(cacheKey, fallbackItems);
              return fallbackItems;
            }
            if (refs.length > 500) {
              refs = refs.slice(0, 500);
              logger4.debug("Applied global client-side limit", { meta: { reducedTo: refs.length } });
            }
            const idsArray = refs.map((w) => Number(w.id)).filter((id) => Number.isFinite(id));
            logger4.debug("Expanding IDs (chunked)", { meta: { count: idsArray.length } });
            const items = await this._fetchWorkItemsByIds(idsArray);
            logger4.debug("Returning mapped work items", { meta: { count: items.length } });
            workItemCache.setWorkItems(cacheKey, items);
            return items;
          } catch (err) {
            logger4.error("GETWI error", { meta: { error: err?.message || err } });
            let errorMessage = "Failed to fetch work items";
            const status = err?.response?.status;
            if (status === 401 || status === 403) {
              errorMessage = `Authentication failed (${status}). Please check:
\u2022 Your Personal Access Token (PAT) is valid and not expired
\u2022 The PAT has "Work Items (Read)" permission
\u2022 You have access to this project`;
            } else if (status === 404) {
              logger4.debug("GETWI 404 Not Found", {
                meta: {
                  organization: this.organization,
                  project: this.project,
                  authType: this.authType,
                  url: err?.request?.url || err?.config?.url
                }
              });
              errorMessage = `Project not found (404). Please verify:
\u2022 Organization: "${this.organization}"
\u2022 Project: "${this.project}"
\u2022 The project name matches exactly (case-sensitive)`;
            } else if (status === 400) {
              const apiError = err?.response?.data?.message || err?.response?.data?.value?.Message;
              if (apiError) {
                errorMessage = `Invalid query (400): ${apiError}`;
              } else {
                errorMessage = `Invalid query (400). The WIQL query may contain unsupported fields or syntax for this project.
Query name: "${query}"`;
              }
              logger4.error("WIQL that failed", { meta: { wiql: wiqlToSend || wiql } });
            } else if (status >= 500) {
              errorMessage = `Azure DevOps server error (${status}). The service may be temporarily unavailable.`;
            } else if (err?.code === "ENOTFOUND" || err?.code === "ECONNREFUSED") {
              errorMessage = `Network error: Cannot reach Azure DevOps.
\u2022 Check your internet connection
\u2022 Verify your base URL is correct
\u2022 Current URL: ${this.axios.defaults.baseURL}`;
            } else if (err?.message) {
              errorMessage = `${errorMessage}: ${err.message}`;
            }
            if (err?.response) {
              logger4.error("GETWI HTTP status", { meta: { status } });
              try {
                logger4.error("GETWI response data", {
                  meta: { data: JSON.stringify(err.response.data).slice(0, 600) }
                });
              } catch {
              }
            }
            throw new Error(errorMessage);
          }
        });
      }
      _isMissingStateCategoryError(err) {
        const status = err?.response?.status;
        const bodyMessage = String(
          err?.response?.data?.message || err?.response?.data || err?.message || ""
        );
        if (status === 400 && /statecategory/i.test(bodyMessage)) return true;
        if (status === 400 && /\bSystem\.State\b/i.test(bodyMessage) && /not found|unknown|does not exist|is not valid/i.test(bodyMessage))
          return true;
        return false;
      }
      async getWorkItemById(id) {
        try {
          const resp = await this.axios.get(`/wit/workitems/${id}?$expand=all&api-version=7.1`);
          return { id: resp.data.id, fields: resp.data.fields };
        } catch (err) {
          logger4.error("Error fetching work item by id", { meta: err });
          return null;
        }
      }
      async runWIQL(wiql) {
        try {
          const wiqlResp = await this.axios.post("/wit/wiql?api-version=7.1", { query: wiql });
          if (!wiqlResp.data.workItems || wiqlResp.data.workItems.length === 0) return [];
          const idsArray = wiqlResp.data.workItems.map((w) => Number(w.id)).filter((id) => Number.isFinite(id));
          const limited = idsArray.length > 500 ? idsArray.slice(0, 500) : idsArray;
          return await this._fetchWorkItemsByIds(limited);
        } catch (err) {
          logger4.error("runWIQL failed", { meta: err });
          return [];
        }
      }
      async searchWorkItems(term) {
        if (!term?.trim()) return [];
        const safe = this._escapeWIQL(term.trim());
        const wiql = `SELECT [System.Id], [System.Title], [System.State] FROM WorkItems 
                 WHERE [System.Title] CONTAINS '${safe}' OR [System.Id] = '${safe}'
                 ORDER BY [System.ChangedDate] DESC`;
        return this.runWIQL(wiql);
      }
      async filterWorkItems(filter2) {
        const base = "SELECT [System.Id], [System.Title], [System.State], [System.WorkItemType], [System.AssignedTo], [System.IterationPath] FROM WorkItems WHERE ";
        const clauses = [];
        if (filter2?.sprint && filter2.sprint !== "All") {
          if (filter2.sprint === "@CurrentIteration")
            clauses.push("[System.IterationPath] UNDER @CurrentIteration");
          else clauses.push(`[System.IterationPath] = '${this._escapeWIQL(filter2.sprint)}'`);
        }
        if (filter2?.includeState)
          clauses.push(`[System.State] = '${this._escapeWIQL(filter2.includeState)}'`);
        else if (Array.isArray(filter2?.excludeStates) && filter2.excludeStates.length) {
          filter2.excludeStates.forEach(
            (st) => clauses.push(`[System.State] <> '${this._escapeWIQL(st)}'`)
          );
        }
        if (filter2?.type && filter2.type !== "All")
          clauses.push(`[System.WorkItemType] = '${this._escapeWIQL(filter2.type)}'`);
        if (filter2?.assignedTo === "Me") clauses.push("[System.AssignedTo] = @Me");
        else if (filter2?.assignedTo === "Unassigned") clauses.push('[System.AssignedTo] = ""');
        if (clauses.length === 0) clauses.push('[System.State] <> "Removed"');
        const wiql = base + clauses.join(" AND ") + " ORDER BY [System.ChangedDate] DESC";
        return this.runWIQL(wiql);
      }
      async createWorkItem(type2, title, description, assignedTo, extraFields) {
        logger4.debug("Creating work item", { meta: { type: type2, title: title.substring(0, 50) + "..." } });
        const patch = [{ op: "add", path: "/fields/System.Title", value: title }];
        if (description)
          patch.push({ op: "add", path: "/fields/System.Description", value: description });
        if (assignedTo) patch.push({ op: "add", path: "/fields/System.AssignedTo", value: assignedTo });
        if (extraFields && typeof extraFields === "object") {
          for (const [field, value] of Object.entries(extraFields)) {
            if (value === void 0 || value === null || value === "") continue;
            patch.push({ op: "add", path: `/fields/${field}`, value });
          }
        }
        try {
          const resp = await this.axios.post(`/wit/workitems/$${type2}?api-version=7.1`, patch, {
            headers: { "Content-Type": "application/json-patch+json" }
          });
          logger4.info("Work item created successfully", { meta: { workItemId: resp.data.id } });
          logger4.debug("Authentication has work item WRITE permissions");
          logger4.debug("Required permission: vso.work_write (for PAT) or equivalent scope (for OAuth)");
          return { id: resp.data.id, fields: resp.data.fields };
        } catch (error) {
          logger4.error("Work item creation failed", {
            meta: { status: error.response?.status, statusText: error.response?.statusText }
          });
          if (error.response?.status === 403) {
            logger4.error("Permission denied - authentication lacks work item write permissions");
            logger4.error("Check your PAT scopes or Azure AD permissions");
          }
          throw error;
        }
      }
      async updateWorkItem(id, patchOps) {
        const resp = await this.axios.patch(`/wit/workitems/${id}?api-version=7.1`, patchOps, {
          headers: { "Content-Type": "application/json-patch+json" }
        });
        return { id: resp.data.id, fields: resp.data.fields };
      }
      async addWorkItemComment(id, text2) {
        const resp = await this.axios.post(`/wit/workitems/${id}/comments?api-version=7.0-preview.3`, {
          text: text2
        });
        return resp.data;
      }
      async addTimeEntry(id, hours, note) {
        if (typeof hours !== "number" || hours <= 0) throw new Error("hours must be positive number");
        const patch = [
          { op: "add", path: "/fields/Microsoft.VSTS.Scheduling.CompletedWork", value: hours }
        ];
        await this.updateWorkItem(id, patch);
        if (note) await this.addWorkItemComment(id, `Time tracked: ${hours} hours. ${note}`);
      }
      async getWorkItemTypes() {
        try {
          const resp = await this.axios.get(`/wit/workitemtypes?api-version=7.1`);
          return resp.data.value || [];
        } catch (e) {
          logger4.error("Error fetching work item types", { meta: e });
          return [];
        }
      }
      async getWorkItemTypeStates(workItemType) {
        try {
          const resp = await this.axios.get(
            `/wit/workitemtypes/${encodeURIComponent(workItemType)}?api-version=7.1`
          );
          const states = resp.data.states || [];
          return states.map((state2) => state2.name || state2);
        } catch (e) {
          logger4.error(`Error fetching states for work item type ${workItemType}`, { meta: e });
          return [];
        }
      }
      async getIterations() {
        try {
          const url2 = this.buildTeamApiUrl("/work/teamsettings/iterations?api-version=7.1");
          const resp = await this.axios.get(url2);
          return resp.data.value || [];
        } catch (err) {
          logger4.error("Error fetching iterations", { meta: err });
          return [];
        }
      }
      async getCurrentIteration() {
        return await measureAsync("getCurrentIteration", async () => {
          try {
            const cacheKey = WorkItemCache.generateMetadataKey(
              `${this.organization}-${this.project}`,
              `currentIteration-${this.team || "default"}`
            );
            const cached = workItemCache.get(cacheKey);
            if (cached) {
              return cached;
            }
            const url2 = this.buildTeamApiUrl(
              "/work/teamsettings/iterations?$timeframe=current&api-version=7.1"
            );
            const resp = await this.axios.get(url2);
            const result = resp.data.value?.[0] || null;
            workItemCache.setMetadata(cacheKey, result);
            return result;
          } catch (err) {
            logger4.error("Error fetching current iteration", { meta: err });
            return null;
          }
        });
      }
      _escapeWIQL(value) {
        return String(value).replace(/'/g, "''");
      }
      // ---------------- Git & PR Helpers ----------------
      async getTeams() {
        return await measureAsync("getTeams", async () => {
          try {
            const cacheKey = WorkItemCache.generateMetadataKey(
              `${this.organization}-${this.project}`,
              "teams"
            );
            const cached = workItemCache.get(cacheKey);
            if (cached) {
              return cached;
            }
            const orgTeamsUrl = this.baseUrl.replace(/\/$/, "") + `/_apis/projects/${this.encodedProject}/teams?api-version=7.1`;
            const resp = await this.axios.get(orgTeamsUrl);
            const result = resp.data?.value || [];
            workItemCache.setMetadata(cacheKey, result);
            return result;
          } catch (e) {
            logger4.error("Error fetching teams", { meta: e });
            return [];
          }
        });
      }
      async getRepositories(force = false) {
        return await measureAsync("getRepositories", async () => {
          if (this._repoCache && !force) return this._repoCache;
          const cacheKey = WorkItemCache.generateMetadataKey(
            `${this.organization}-${this.project}`,
            "repositories"
          );
          if (!force) {
            const cached = workItemCache.get(cacheKey);
            if (cached) {
              this._repoCache = cached;
              return cached;
            }
          }
          try {
            const resp = await this.axios.get(`/git/repositories`);
            this._repoCache = resp.data.value || [];
            workItemCache.setMetadata(cacheKey, this._repoCache);
            return this._repoCache;
          } catch (e) {
            logger4.error("Error fetching repositories", { meta: e });
            return [];
          }
        });
      }
      async getDefaultRepository() {
        const repos = await this.getRepositories();
        return Array.isArray(repos) ? repos[0] : void 0;
      }
      async getPullRequests(repositoryId, status = "active") {
        try {
          const resp = await this.axios.get(`/git/pullrequests`, {
            params: { "searchCriteria.repositoryId": repositoryId, "searchCriteria.status": status }
          });
          const prs = resp.data.value || [];
          return prs.map((pr) => ({
            id: pr.pullRequestId,
            title: pr.title,
            status: pr.status,
            createdBy: pr.createdBy?.displayName,
            sourceRefName: pr.sourceRefName,
            targetRefName: pr.targetRefName,
            repository: pr.repository?.name,
            webUrl: pr._links?.web?.href || this.getBrowserUrl(
              `/_git/${encodeURIComponent(pr.repository?.name)}/pullrequest/${pr.pullRequestId}`
            )
          }));
        } catch (e) {
          logger4.error("Error fetching pull requests", { meta: e });
          return [];
        }
      }
      /**
       * Fetch pull requests across all repositories in the project, filtered by creator or reviewer = current user.
       * Merges results for authored and reviewing PRs to emulate an OR filter. Duplicates are de-duplicated by PR id.
       */
      async getMyPullRequestsAcrossRepos(status = "active") {
        const me = await this.getAuthenticatedUserId();
        if (!me) {
          logger4.warn("Could not determine authenticated user id; returning empty PR list");
          return [];
        }
        try {
          const [authoredResp, reviewingResp] = await Promise.all([
            this.axios.get(`/git/pullrequests`, {
              params: { "searchCriteria.creatorId": me, "searchCriteria.status": status }
            }),
            this.axios.get(`/git/pullrequests`, {
              params: { "searchCriteria.reviewerId": me, "searchCriteria.status": status }
            })
          ]);
          const authored = authoredResp.data?.value || [];
          const reviewing = reviewingResp.data?.value || [];
          const combined = [...authored, ...reviewing];
          const seen = /* @__PURE__ */ new Set();
          const mapped = combined.filter((pr) => pr && typeof pr.pullRequestId === "number").filter((pr) => {
            if (seen.has(pr.pullRequestId)) return false;
            seen.add(pr.pullRequestId);
            return true;
          }).map((pr) => ({
            id: pr.pullRequestId,
            title: pr.title,
            status: pr.status,
            createdBy: pr.createdBy?.displayName,
            sourceRefName: pr.sourceRefName,
            targetRefName: pr.targetRefName,
            repository: pr.repository?.name,
            webUrl: pr._links?.web?.href || this.getBrowserUrl(
              `/_git/${encodeURIComponent(pr.repository?.name)}/pullrequest/${pr.pullRequestId}`
            ),
            createdDate: pr.creationDate
          }));
          mapped.sort((a, b) => {
            const at = a.createdDate ? new Date(a.createdDate).getTime() : 0;
            const bt = b.createdDate ? new Date(b.createdDate).getTime() : 0;
            return bt - at;
          });
          return mapped;
        } catch (e) {
          logger4.error("Error fetching my pull requests across repos", { meta: e });
          return [];
        }
      }
      async createPullRequest(repositoryId, sourceRefName, targetRefName, title, description) {
        try {
          const payload = { sourceRefName, targetRefName, title };
          if (description) payload.description = description;
          const resp = await this.axios.post(
            `/git/repositories/${repositoryId}/pullrequests?api-version=7.1`,
            payload
          );
          return resp.data;
        } catch (e) {
          logger4.error("Error creating pull request", { meta: e });
          throw e;
        }
      }
      // ---------------- Build Helpers ----------------
      async getRecentBuilds(options = {}) {
        const { top = 10, branchName, repositoryId, definitions, resultFilter, statusFilter } = options;
        try {
          const params = {
            $top: top,
            queryOrder: "finishTimeDescending",
            "api-version": "7.0"
          };
          if (branchName) params.branchName = branchName;
          if (repositoryId) params.repositoryId = repositoryId;
          if (definitions !== void 0) {
            params.definitions = Array.isArray(definitions) ? definitions.join(",") : definitions;
          }
          if (resultFilter) params.resultFilter = resultFilter;
          if (statusFilter) params.statusFilter = statusFilter;
          const resp = await this.axios.get(`/build/builds`, { params });
          const values = Array.isArray(resp.data?.value) ? resp.data.value : [];
          return values.map((b) => ({
            id: b.id,
            buildNumber: b.buildNumber,
            status: b.status,
            result: b.result,
            definition: b.definition?.name,
            queueTime: b.queueTime,
            finishTime: b.finishTime,
            webUrl: b._links?.web?.href
          }));
        } catch (e) {
          logger4.error("Error fetching builds", { meta: e });
          return [];
        }
      }
    };
  }
});

// src/azureClient.js
var init_azureClient2 = __esm({
  "src/azureClient.js"() {
    "use strict";
    init_azureClient();
  }
});

// node_modules/@azure/msal-node/dist/cache/serializer/Serializer.mjs
var Serializer;
var init_Serializer = __esm({
  "node_modules/@azure/msal-node/dist/cache/serializer/Serializer.mjs"() {
    "use strict";
    Serializer = class {
      /**
       * serialize the JSON blob
       * @param data - JSON blob cache
       */
      static serializeJSONBlob(data) {
        return JSON.stringify(data);
      }
      /**
       * Serialize Accounts
       * @param accCache - cache of accounts
       */
      static serializeAccounts(accCache) {
        const accounts = {};
        Object.keys(accCache).map(function(key2) {
          const accountEntity = accCache[key2];
          accounts[key2] = {
            home_account_id: accountEntity.homeAccountId,
            environment: accountEntity.environment,
            realm: accountEntity.realm,
            local_account_id: accountEntity.localAccountId,
            username: accountEntity.username,
            authority_type: accountEntity.authorityType,
            name: accountEntity.name,
            client_info: accountEntity.clientInfo,
            last_modification_time: accountEntity.lastModificationTime,
            last_modification_app: accountEntity.lastModificationApp,
            tenantProfiles: accountEntity.tenantProfiles?.map((tenantProfile) => {
              return JSON.stringify(tenantProfile);
            })
          };
        });
        return accounts;
      }
      /**
       * Serialize IdTokens
       * @param idTCache - cache of ID tokens
       */
      static serializeIdTokens(idTCache) {
        const idTokens = {};
        Object.keys(idTCache).map(function(key2) {
          const idTEntity = idTCache[key2];
          idTokens[key2] = {
            home_account_id: idTEntity.homeAccountId,
            environment: idTEntity.environment,
            credential_type: idTEntity.credentialType,
            client_id: idTEntity.clientId,
            secret: idTEntity.secret,
            realm: idTEntity.realm
          };
        });
        return idTokens;
      }
      /**
       * Serializes AccessTokens
       * @param atCache - cache of access tokens
       */
      static serializeAccessTokens(atCache) {
        const accessTokens = {};
        Object.keys(atCache).map(function(key2) {
          const atEntity = atCache[key2];
          accessTokens[key2] = {
            home_account_id: atEntity.homeAccountId,
            environment: atEntity.environment,
            credential_type: atEntity.credentialType,
            client_id: atEntity.clientId,
            secret: atEntity.secret,
            realm: atEntity.realm,
            target: atEntity.target,
            cached_at: atEntity.cachedAt,
            expires_on: atEntity.expiresOn,
            extended_expires_on: atEntity.extendedExpiresOn,
            refresh_on: atEntity.refreshOn,
            key_id: atEntity.keyId,
            token_type: atEntity.tokenType,
            requestedClaims: atEntity.requestedClaims,
            requestedClaimsHash: atEntity.requestedClaimsHash,
            userAssertionHash: atEntity.userAssertionHash
          };
        });
        return accessTokens;
      }
      /**
       * Serialize refreshTokens
       * @param rtCache - cache of refresh tokens
       */
      static serializeRefreshTokens(rtCache) {
        const refreshTokens = {};
        Object.keys(rtCache).map(function(key2) {
          const rtEntity = rtCache[key2];
          refreshTokens[key2] = {
            home_account_id: rtEntity.homeAccountId,
            environment: rtEntity.environment,
            credential_type: rtEntity.credentialType,
            client_id: rtEntity.clientId,
            secret: rtEntity.secret,
            family_id: rtEntity.familyId,
            target: rtEntity.target,
            realm: rtEntity.realm
          };
        });
        return refreshTokens;
      }
      /**
       * Serialize amdtCache
       * @param amdtCache - cache of app metadata
       */
      static serializeAppMetadata(amdtCache) {
        const appMetadata = {};
        Object.keys(amdtCache).map(function(key2) {
          const amdtEntity = amdtCache[key2];
          appMetadata[key2] = {
            client_id: amdtEntity.clientId,
            environment: amdtEntity.environment,
            family_id: amdtEntity.familyId
          };
        });
        return appMetadata;
      }
      /**
       * Serialize the cache
       * @param inMemCache - itemised cache read from the JSON
       */
      static serializeAllCache(inMemCache) {
        return {
          Account: this.serializeAccounts(inMemCache.accounts),
          IdToken: this.serializeIdTokens(inMemCache.idTokens),
          AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),
          RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),
          AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata)
        };
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/utils/Constants.mjs
var Constants, HttpStatus, OIDC_DEFAULT_SCOPES, OIDC_SCOPES, HeaderNames, AADAuthorityConstants, ClaimsRequestKeys, PromptValue, CodeChallengeMethodValues, OAuthResponseType, ResponseMode, GrantType, CacheAccountType, Separators, CredentialType, APP_METADATA, CLIENT_INFO, THE_FAMILY_ID, AUTHORITY_METADATA_CONSTANTS, AuthorityMetadataSource, SERVER_TELEM_CONSTANTS, AuthenticationScheme, ThrottlingConstants, Errors, PasswordGrantConstants, RegionDiscoverySources, RegionDiscoveryOutcomes, CacheOutcome, DEFAULT_TOKEN_RENEWAL_OFFSET_SEC, EncodingTypes;
var init_Constants = __esm({
  "node_modules/@azure/msal-common/dist/utils/Constants.mjs"() {
    "use strict";
    Constants = {
      LIBRARY_NAME: "MSAL.JS",
      SKU: "msal.js.common",
      // default authority
      DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
      DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
      DEFAULT_COMMON_TENANT: "common",
      // ADFS String
      ADFS: "adfs",
      DSTS: "dstsv2",
      // Default AAD Instance Discovery Endpoint
      AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
      // CIAM URL
      CIAM_AUTH_URL: ".ciamlogin.com",
      AAD_TENANT_DOMAIN_SUFFIX: ".onmicrosoft.com",
      // Resource delimiter - used for certain cache entries
      RESOURCE_DELIM: "|",
      // Placeholder for non-existent account ids/objects
      NO_ACCOUNT: "NO_ACCOUNT",
      // Claims
      CLAIMS: "claims",
      // Consumer UTID
      CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
      // Default scopes
      OPENID_SCOPE: "openid",
      PROFILE_SCOPE: "profile",
      OFFLINE_ACCESS_SCOPE: "offline_access",
      EMAIL_SCOPE: "email",
      CODE_GRANT_TYPE: "authorization_code",
      RT_GRANT_TYPE: "refresh_token",
      S256_CODE_CHALLENGE_METHOD: "S256",
      URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
      AUTHORIZATION_PENDING: "authorization_pending",
      NOT_DEFINED: "not_defined",
      EMPTY_STRING: "",
      NOT_APPLICABLE: "N/A",
      NOT_AVAILABLE: "Not Available",
      FORWARD_SLASH: "/",
      IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
      IMDS_VERSION: "2020-06-01",
      IMDS_TIMEOUT: 2e3,
      AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
      REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
      KNOWN_PUBLIC_CLOUDS: [
        "login.microsoftonline.com",
        "login.windows.net",
        "login.microsoft.com",
        "sts.windows.net"
      ],
      SHR_NONCE_VALIDITY: 240,
      INVALID_INSTANCE: "invalid_instance"
    };
    HttpStatus = {
      SUCCESS: 200,
      SUCCESS_RANGE_START: 200,
      SUCCESS_RANGE_END: 299,
      REDIRECT: 302,
      CLIENT_ERROR: 400,
      CLIENT_ERROR_RANGE_START: 400,
      BAD_REQUEST: 400,
      UNAUTHORIZED: 401,
      NOT_FOUND: 404,
      REQUEST_TIMEOUT: 408,
      GONE: 410,
      TOO_MANY_REQUESTS: 429,
      CLIENT_ERROR_RANGE_END: 499,
      SERVER_ERROR: 500,
      SERVER_ERROR_RANGE_START: 500,
      SERVICE_UNAVAILABLE: 503,
      GATEWAY_TIMEOUT: 504,
      SERVER_ERROR_RANGE_END: 599,
      MULTI_SIDED_ERROR: 600
    };
    OIDC_DEFAULT_SCOPES = [
      Constants.OPENID_SCOPE,
      Constants.PROFILE_SCOPE,
      Constants.OFFLINE_ACCESS_SCOPE
    ];
    OIDC_SCOPES = [...OIDC_DEFAULT_SCOPES, Constants.EMAIL_SCOPE];
    HeaderNames = {
      CONTENT_TYPE: "Content-Type",
      CONTENT_LENGTH: "Content-Length",
      RETRY_AFTER: "Retry-After",
      CCS_HEADER: "X-AnchorMailbox",
      WWWAuthenticate: "WWW-Authenticate",
      AuthenticationInfo: "Authentication-Info",
      X_MS_REQUEST_ID: "x-ms-request-id",
      X_MS_HTTP_VERSION: "x-ms-httpver"
    };
    AADAuthorityConstants = {
      COMMON: "common",
      ORGANIZATIONS: "organizations",
      CONSUMERS: "consumers"
    };
    ClaimsRequestKeys = {
      ACCESS_TOKEN: "access_token",
      XMS_CC: "xms_cc"
    };
    PromptValue = {
      LOGIN: "login",
      SELECT_ACCOUNT: "select_account",
      CONSENT: "consent",
      NONE: "none",
      CREATE: "create",
      NO_SESSION: "no_session"
    };
    CodeChallengeMethodValues = {
      PLAIN: "plain",
      S256: "S256"
    };
    OAuthResponseType = {
      CODE: "code",
      IDTOKEN_TOKEN: "id_token token",
      IDTOKEN_TOKEN_REFRESHTOKEN: "id_token token refresh_token"
    };
    ResponseMode = {
      QUERY: "query",
      FRAGMENT: "fragment",
      FORM_POST: "form_post"
    };
    GrantType = {
      IMPLICIT_GRANT: "implicit",
      AUTHORIZATION_CODE_GRANT: "authorization_code",
      CLIENT_CREDENTIALS_GRANT: "client_credentials",
      RESOURCE_OWNER_PASSWORD_GRANT: "password",
      REFRESH_TOKEN_GRANT: "refresh_token",
      DEVICE_CODE_GRANT: "device_code",
      JWT_BEARER: "urn:ietf:params:oauth:grant-type:jwt-bearer"
    };
    CacheAccountType = {
      MSSTS_ACCOUNT_TYPE: "MSSTS",
      ADFS_ACCOUNT_TYPE: "ADFS",
      MSAV1_ACCOUNT_TYPE: "MSA",
      GENERIC_ACCOUNT_TYPE: "Generic"
      // NTLM, Kerberos, FBA, Basic etc
    };
    Separators = {
      CACHE_KEY_SEPARATOR: "-",
      CLIENT_INFO_SEPARATOR: "."
    };
    CredentialType = {
      ID_TOKEN: "IdToken",
      ACCESS_TOKEN: "AccessToken",
      ACCESS_TOKEN_WITH_AUTH_SCHEME: "AccessToken_With_AuthScheme",
      REFRESH_TOKEN: "RefreshToken"
    };
    APP_METADATA = "appmetadata";
    CLIENT_INFO = "client_info";
    THE_FAMILY_ID = "1";
    AUTHORITY_METADATA_CONSTANTS = {
      CACHE_KEY: "authority-metadata",
      REFRESH_TIME_SECONDS: 3600 * 24
      // 24 Hours
    };
    AuthorityMetadataSource = {
      CONFIG: "config",
      CACHE: "cache",
      NETWORK: "network",
      HARDCODED_VALUES: "hardcoded_values"
    };
    SERVER_TELEM_CONSTANTS = {
      SCHEMA_VERSION: 5,
      MAX_LAST_HEADER_BYTES: 330,
      MAX_CACHED_ERRORS: 50,
      CACHE_KEY: "server-telemetry",
      CATEGORY_SEPARATOR: "|",
      VALUE_SEPARATOR: ",",
      OVERFLOW_TRUE: "1",
      OVERFLOW_FALSE: "0",
      UNKNOWN_ERROR: "unknown_error"
    };
    AuthenticationScheme = {
      BEARER: "Bearer",
      POP: "pop",
      SSH: "ssh-cert"
    };
    ThrottlingConstants = {
      // Default time to throttle RequestThumbprint in seconds
      DEFAULT_THROTTLE_TIME_SECONDS: 60,
      // Default maximum time to throttle in seconds, overrides what the server sends back
      DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
      // Prefix for storing throttling entries
      THROTTLING_PREFIX: "throttling",
      // Value assigned to the x-ms-lib-capability header to indicate to the server the library supports throttling
      X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429"
    };
    Errors = {
      INVALID_GRANT_ERROR: "invalid_grant",
      CLIENT_MISMATCH_ERROR: "client_mismatch"
    };
    PasswordGrantConstants = {
      username: "username",
      password: "password"
    };
    RegionDiscoverySources = {
      FAILED_AUTO_DETECTION: "1",
      INTERNAL_CACHE: "2",
      ENVIRONMENT_VARIABLE: "3",
      IMDS: "4"
    };
    RegionDiscoveryOutcomes = {
      CONFIGURED_NO_AUTO_DETECTION: "2",
      AUTO_DETECTION_REQUESTED_SUCCESSFUL: "4",
      AUTO_DETECTION_REQUESTED_FAILED: "5"
    };
    CacheOutcome = {
      // When a token is found in the cache or the cache is not supposed to be hit when making the request
      NOT_APPLICABLE: "0",
      // When the token request goes to the identity provider because force_refresh was set to true. Also occurs if claims were requested
      FORCE_REFRESH_OR_CLAIMS: "1",
      // When the token request goes to the identity provider because no cached access token exists
      NO_CACHED_ACCESS_TOKEN: "2",
      // When the token request goes to the identity provider because cached access token expired
      CACHED_ACCESS_TOKEN_EXPIRED: "3",
      // When the token request goes to the identity provider because refresh_in was used and the existing token needs to be refreshed
      PROACTIVELY_REFRESHED: "4"
    };
    DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;
    EncodingTypes = {
      BASE64: "base64",
      HEX: "hex",
      UTF8: "utf-8"
    };
  }
});

// node_modules/@azure/msal-common/dist/error/AuthErrorCodes.mjs
var AuthErrorCodes_exports = {};
__export(AuthErrorCodes_exports, {
  postRequestFailed: () => postRequestFailed,
  unexpectedError: () => unexpectedError
});
var unexpectedError, postRequestFailed;
var init_AuthErrorCodes = __esm({
  "node_modules/@azure/msal-common/dist/error/AuthErrorCodes.mjs"() {
    "use strict";
    unexpectedError = "unexpected_error";
    postRequestFailed = "post_request_failed";
  }
});

// node_modules/@azure/msal-common/dist/error/AuthError.mjs
function createAuthError(code, additionalMessage) {
  return new AuthError(code, additionalMessage ? `${AuthErrorMessages[code]} ${additionalMessage}` : AuthErrorMessages[code]);
}
var AuthErrorMessages, AuthErrorMessage, AuthError;
var init_AuthError = __esm({
  "node_modules/@azure/msal-common/dist/error/AuthError.mjs"() {
    "use strict";
    init_Constants();
    init_AuthErrorCodes();
    AuthErrorMessages = {
      [unexpectedError]: "Unexpected error in authentication.",
      [postRequestFailed]: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details."
    };
    AuthErrorMessage = {
      unexpectedError: {
        code: unexpectedError,
        desc: AuthErrorMessages[unexpectedError]
      },
      postRequestFailed: {
        code: postRequestFailed,
        desc: AuthErrorMessages[postRequestFailed]
      }
    };
    AuthError = class _AuthError extends Error {
      constructor(errorCode, errorMessage, suberror) {
        const errorString = errorMessage ? `${errorCode}: ${errorMessage}` : errorCode;
        super(errorString);
        Object.setPrototypeOf(this, _AuthError.prototype);
        this.errorCode = errorCode || Constants.EMPTY_STRING;
        this.errorMessage = errorMessage || Constants.EMPTY_STRING;
        this.subError = suberror || Constants.EMPTY_STRING;
        this.name = "AuthError";
      }
      setCorrelationId(correlationId) {
        this.correlationId = correlationId;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs
var ClientAuthErrorCodes_exports = {};
__export(ClientAuthErrorCodes_exports, {
  authTimeNotFound: () => authTimeNotFound,
  authorizationCodeMissingFromServerResponse: () => authorizationCodeMissingFromServerResponse,
  bindingKeyNotRemoved: () => bindingKeyNotRemoved,
  cannotAppendScopeSet: () => cannotAppendScopeSet,
  cannotRemoveEmptyScope: () => cannotRemoveEmptyScope,
  clientInfoDecodingError: () => clientInfoDecodingError,
  clientInfoEmptyError: () => clientInfoEmptyError,
  deviceCodeExpired: () => deviceCodeExpired,
  deviceCodePollingCancelled: () => deviceCodePollingCancelled,
  deviceCodeUnknownError: () => deviceCodeUnknownError,
  emptyInputScopeSet: () => emptyInputScopeSet,
  endSessionEndpointNotSupported: () => endSessionEndpointNotSupported,
  endpointResolutionError: () => endpointResolutionError,
  hashNotDeserialized: () => hashNotDeserialized,
  invalidAssertion: () => invalidAssertion,
  invalidCacheEnvironment: () => invalidCacheEnvironment,
  invalidCacheRecord: () => invalidCacheRecord,
  invalidClientCredential: () => invalidClientCredential,
  invalidState: () => invalidState,
  keyIdMissing: () => keyIdMissing,
  maxAgeTranspired: () => maxAgeTranspired,
  methodNotImplemented: () => methodNotImplemented,
  missingTenantIdError: () => missingTenantIdError,
  multipleMatchingAccounts: () => multipleMatchingAccounts,
  multipleMatchingAppMetadata: () => multipleMatchingAppMetadata,
  multipleMatchingTokens: () => multipleMatchingTokens,
  nestedAppAuthBridgeDisabled: () => nestedAppAuthBridgeDisabled,
  networkError: () => networkError,
  noAccountFound: () => noAccountFound,
  noAccountInSilentRequest: () => noAccountInSilentRequest,
  noCryptoObject: () => noCryptoObject,
  noNetworkConnectivity: () => noNetworkConnectivity,
  nonceMismatch: () => nonceMismatch,
  nullOrEmptyToken: () => nullOrEmptyToken,
  openIdConfigError: () => openIdConfigError,
  platformBrokerError: () => platformBrokerError,
  requestCannotBeMade: () => requestCannotBeMade,
  stateMismatch: () => stateMismatch,
  stateNotFound: () => stateNotFound,
  tokenClaimsCnfRequiredForSignedJwt: () => tokenClaimsCnfRequiredForSignedJwt,
  tokenParsingError: () => tokenParsingError,
  tokenRefreshRequired: () => tokenRefreshRequired,
  unexpectedCredentialType: () => unexpectedCredentialType,
  userCanceled: () => userCanceled,
  userTimeoutReached: () => userTimeoutReached
});
var clientInfoDecodingError, clientInfoEmptyError, tokenParsingError, nullOrEmptyToken, endpointResolutionError, networkError, openIdConfigError, hashNotDeserialized, invalidState, stateMismatch, stateNotFound, nonceMismatch, authTimeNotFound, maxAgeTranspired, multipleMatchingTokens, multipleMatchingAccounts, multipleMatchingAppMetadata, requestCannotBeMade, cannotRemoveEmptyScope, cannotAppendScopeSet, emptyInputScopeSet, deviceCodePollingCancelled, deviceCodeExpired, deviceCodeUnknownError, noAccountInSilentRequest, invalidCacheRecord, invalidCacheEnvironment, noAccountFound, noCryptoObject, unexpectedCredentialType, invalidAssertion, invalidClientCredential, tokenRefreshRequired, userTimeoutReached, tokenClaimsCnfRequiredForSignedJwt, authorizationCodeMissingFromServerResponse, bindingKeyNotRemoved, endSessionEndpointNotSupported, keyIdMissing, noNetworkConnectivity, userCanceled, missingTenantIdError, methodNotImplemented, nestedAppAuthBridgeDisabled, platformBrokerError;
var init_ClientAuthErrorCodes = __esm({
  "node_modules/@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs"() {
    "use strict";
    clientInfoDecodingError = "client_info_decoding_error";
    clientInfoEmptyError = "client_info_empty_error";
    tokenParsingError = "token_parsing_error";
    nullOrEmptyToken = "null_or_empty_token";
    endpointResolutionError = "endpoints_resolution_error";
    networkError = "network_error";
    openIdConfigError = "openid_config_error";
    hashNotDeserialized = "hash_not_deserialized";
    invalidState = "invalid_state";
    stateMismatch = "state_mismatch";
    stateNotFound = "state_not_found";
    nonceMismatch = "nonce_mismatch";
    authTimeNotFound = "auth_time_not_found";
    maxAgeTranspired = "max_age_transpired";
    multipleMatchingTokens = "multiple_matching_tokens";
    multipleMatchingAccounts = "multiple_matching_accounts";
    multipleMatchingAppMetadata = "multiple_matching_appMetadata";
    requestCannotBeMade = "request_cannot_be_made";
    cannotRemoveEmptyScope = "cannot_remove_empty_scope";
    cannotAppendScopeSet = "cannot_append_scopeset";
    emptyInputScopeSet = "empty_input_scopeset";
    deviceCodePollingCancelled = "device_code_polling_cancelled";
    deviceCodeExpired = "device_code_expired";
    deviceCodeUnknownError = "device_code_unknown_error";
    noAccountInSilentRequest = "no_account_in_silent_request";
    invalidCacheRecord = "invalid_cache_record";
    invalidCacheEnvironment = "invalid_cache_environment";
    noAccountFound = "no_account_found";
    noCryptoObject = "no_crypto_object";
    unexpectedCredentialType = "unexpected_credential_type";
    invalidAssertion = "invalid_assertion";
    invalidClientCredential = "invalid_client_credential";
    tokenRefreshRequired = "token_refresh_required";
    userTimeoutReached = "user_timeout_reached";
    tokenClaimsCnfRequiredForSignedJwt = "token_claims_cnf_required_for_signedjwt";
    authorizationCodeMissingFromServerResponse = "authorization_code_missing_from_server_response";
    bindingKeyNotRemoved = "binding_key_not_removed";
    endSessionEndpointNotSupported = "end_session_endpoint_not_supported";
    keyIdMissing = "key_id_missing";
    noNetworkConnectivity = "no_network_connectivity";
    userCanceled = "user_canceled";
    missingTenantIdError = "missing_tenant_id_error";
    methodNotImplemented = "method_not_implemented";
    nestedAppAuthBridgeDisabled = "nested_app_auth_bridge_disabled";
    platformBrokerError = "platform_broker_error";
  }
});

// node_modules/@azure/msal-common/dist/error/ClientAuthError.mjs
function createClientAuthError(errorCode, additionalMessage) {
  return new ClientAuthError(errorCode, additionalMessage);
}
var ClientAuthErrorMessages, ClientAuthErrorMessage, ClientAuthError;
var init_ClientAuthError = __esm({
  "node_modules/@azure/msal-common/dist/error/ClientAuthError.mjs"() {
    "use strict";
    init_AuthError();
    init_ClientAuthErrorCodes();
    ClientAuthErrorMessages = {
      [clientInfoDecodingError]: "The client info could not be parsed/decoded correctly",
      [clientInfoEmptyError]: "The client info was empty",
      [tokenParsingError]: "Token cannot be parsed",
      [nullOrEmptyToken]: "The token is null or empty",
      [endpointResolutionError]: "Endpoints cannot be resolved",
      [networkError]: "Network request failed",
      [openIdConfigError]: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints.",
      [hashNotDeserialized]: "The hash parameters could not be deserialized",
      [invalidState]: "State was not the expected format",
      [stateMismatch]: "State mismatch error",
      [stateNotFound]: "State not found",
      [nonceMismatch]: "Nonce mismatch error",
      [authTimeNotFound]: "Max Age was requested and the ID token is missing the auth_time variable. auth_time is an optional claim and is not enabled by default - it must be enabled. See https://aka.ms/msaljs/optional-claims for more information.",
      [maxAgeTranspired]: "Max Age is set to 0, or too much time has elapsed since the last end-user authentication.",
      [multipleMatchingTokens]: "The cache contains multiple tokens satisfying the requirements. Call AcquireToken again providing more requirements such as authority or account.",
      [multipleMatchingAccounts]: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account",
      [multipleMatchingAppMetadata]: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata",
      [requestCannotBeMade]: "Token request cannot be made without authorization code or refresh token.",
      [cannotRemoveEmptyScope]: "Cannot remove null or empty scope from ScopeSet",
      [cannotAppendScopeSet]: "Cannot append ScopeSet",
      [emptyInputScopeSet]: "Empty input ScopeSet cannot be processed",
      [deviceCodePollingCancelled]: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true.",
      [deviceCodeExpired]: "Device code is expired.",
      [deviceCodeUnknownError]: "Device code stopped polling for unknown reasons.",
      [noAccountInSilentRequest]: "Please pass an account object, silent flow is not supported without account information",
      [invalidCacheRecord]: "Cache record object was null or undefined.",
      [invalidCacheEnvironment]: "Invalid environment when attempting to create cache entry",
      [noAccountFound]: "No account found in cache for given key.",
      [noCryptoObject]: "No crypto object detected.",
      [unexpectedCredentialType]: "Unexpected credential type.",
      [invalidAssertion]: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515",
      [invalidClientCredential]: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential",
      [tokenRefreshRequired]: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired.",
      [userTimeoutReached]: "User defined timeout for device code polling reached",
      [tokenClaimsCnfRequiredForSignedJwt]: "Cannot generate a POP jwt if the token_claims are not populated",
      [authorizationCodeMissingFromServerResponse]: "Server response does not contain an authorization code to proceed",
      [bindingKeyNotRemoved]: "Could not remove the credential's binding key from storage.",
      [endSessionEndpointNotSupported]: "The provided authority does not support logout",
      [keyIdMissing]: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key.",
      [noNetworkConnectivity]: "No network connectivity. Check your internet connection.",
      [userCanceled]: "User cancelled the flow.",
      [missingTenantIdError]: "A tenant id - not common, organizations, or consumers - must be specified when using the client_credentials flow.",
      [methodNotImplemented]: "This method has not been implemented",
      [nestedAppAuthBridgeDisabled]: "The nested app auth bridge is disabled",
      [platformBrokerError]: "An error occurred in the native broker. See the platformBrokerError property for details."
    };
    ClientAuthErrorMessage = {
      clientInfoDecodingError: {
        code: clientInfoDecodingError,
        desc: ClientAuthErrorMessages[clientInfoDecodingError]
      },
      clientInfoEmptyError: {
        code: clientInfoEmptyError,
        desc: ClientAuthErrorMessages[clientInfoEmptyError]
      },
      tokenParsingError: {
        code: tokenParsingError,
        desc: ClientAuthErrorMessages[tokenParsingError]
      },
      nullOrEmptyToken: {
        code: nullOrEmptyToken,
        desc: ClientAuthErrorMessages[nullOrEmptyToken]
      },
      endpointResolutionError: {
        code: endpointResolutionError,
        desc: ClientAuthErrorMessages[endpointResolutionError]
      },
      networkError: {
        code: networkError,
        desc: ClientAuthErrorMessages[networkError]
      },
      unableToGetOpenidConfigError: {
        code: openIdConfigError,
        desc: ClientAuthErrorMessages[openIdConfigError]
      },
      hashNotDeserialized: {
        code: hashNotDeserialized,
        desc: ClientAuthErrorMessages[hashNotDeserialized]
      },
      invalidStateError: {
        code: invalidState,
        desc: ClientAuthErrorMessages[invalidState]
      },
      stateMismatchError: {
        code: stateMismatch,
        desc: ClientAuthErrorMessages[stateMismatch]
      },
      stateNotFoundError: {
        code: stateNotFound,
        desc: ClientAuthErrorMessages[stateNotFound]
      },
      nonceMismatchError: {
        code: nonceMismatch,
        desc: ClientAuthErrorMessages[nonceMismatch]
      },
      authTimeNotFoundError: {
        code: authTimeNotFound,
        desc: ClientAuthErrorMessages[authTimeNotFound]
      },
      maxAgeTranspired: {
        code: maxAgeTranspired,
        desc: ClientAuthErrorMessages[maxAgeTranspired]
      },
      multipleMatchingTokens: {
        code: multipleMatchingTokens,
        desc: ClientAuthErrorMessages[multipleMatchingTokens]
      },
      multipleMatchingAccounts: {
        code: multipleMatchingAccounts,
        desc: ClientAuthErrorMessages[multipleMatchingAccounts]
      },
      multipleMatchingAppMetadata: {
        code: multipleMatchingAppMetadata,
        desc: ClientAuthErrorMessages[multipleMatchingAppMetadata]
      },
      tokenRequestCannotBeMade: {
        code: requestCannotBeMade,
        desc: ClientAuthErrorMessages[requestCannotBeMade]
      },
      removeEmptyScopeError: {
        code: cannotRemoveEmptyScope,
        desc: ClientAuthErrorMessages[cannotRemoveEmptyScope]
      },
      appendScopeSetError: {
        code: cannotAppendScopeSet,
        desc: ClientAuthErrorMessages[cannotAppendScopeSet]
      },
      emptyInputScopeSetError: {
        code: emptyInputScopeSet,
        desc: ClientAuthErrorMessages[emptyInputScopeSet]
      },
      DeviceCodePollingCancelled: {
        code: deviceCodePollingCancelled,
        desc: ClientAuthErrorMessages[deviceCodePollingCancelled]
      },
      DeviceCodeExpired: {
        code: deviceCodeExpired,
        desc: ClientAuthErrorMessages[deviceCodeExpired]
      },
      DeviceCodeUnknownError: {
        code: deviceCodeUnknownError,
        desc: ClientAuthErrorMessages[deviceCodeUnknownError]
      },
      NoAccountInSilentRequest: {
        code: noAccountInSilentRequest,
        desc: ClientAuthErrorMessages[noAccountInSilentRequest]
      },
      invalidCacheRecord: {
        code: invalidCacheRecord,
        desc: ClientAuthErrorMessages[invalidCacheRecord]
      },
      invalidCacheEnvironment: {
        code: invalidCacheEnvironment,
        desc: ClientAuthErrorMessages[invalidCacheEnvironment]
      },
      noAccountFound: {
        code: noAccountFound,
        desc: ClientAuthErrorMessages[noAccountFound]
      },
      noCryptoObj: {
        code: noCryptoObject,
        desc: ClientAuthErrorMessages[noCryptoObject]
      },
      unexpectedCredentialType: {
        code: unexpectedCredentialType,
        desc: ClientAuthErrorMessages[unexpectedCredentialType]
      },
      invalidAssertion: {
        code: invalidAssertion,
        desc: ClientAuthErrorMessages[invalidAssertion]
      },
      invalidClientCredential: {
        code: invalidClientCredential,
        desc: ClientAuthErrorMessages[invalidClientCredential]
      },
      tokenRefreshRequired: {
        code: tokenRefreshRequired,
        desc: ClientAuthErrorMessages[tokenRefreshRequired]
      },
      userTimeoutReached: {
        code: userTimeoutReached,
        desc: ClientAuthErrorMessages[userTimeoutReached]
      },
      tokenClaimsRequired: {
        code: tokenClaimsCnfRequiredForSignedJwt,
        desc: ClientAuthErrorMessages[tokenClaimsCnfRequiredForSignedJwt]
      },
      noAuthorizationCodeFromServer: {
        code: authorizationCodeMissingFromServerResponse,
        desc: ClientAuthErrorMessages[authorizationCodeMissingFromServerResponse]
      },
      bindingKeyNotRemovedError: {
        code: bindingKeyNotRemoved,
        desc: ClientAuthErrorMessages[bindingKeyNotRemoved]
      },
      logoutNotSupported: {
        code: endSessionEndpointNotSupported,
        desc: ClientAuthErrorMessages[endSessionEndpointNotSupported]
      },
      keyIdMissing: {
        code: keyIdMissing,
        desc: ClientAuthErrorMessages[keyIdMissing]
      },
      noNetworkConnectivity: {
        code: noNetworkConnectivity,
        desc: ClientAuthErrorMessages[noNetworkConnectivity]
      },
      userCanceledError: {
        code: userCanceled,
        desc: ClientAuthErrorMessages[userCanceled]
      },
      missingTenantIdError: {
        code: missingTenantIdError,
        desc: ClientAuthErrorMessages[missingTenantIdError]
      },
      nestedAppAuthBridgeDisabled: {
        code: nestedAppAuthBridgeDisabled,
        desc: ClientAuthErrorMessages[nestedAppAuthBridgeDisabled]
      },
      platformBrokerError: {
        code: platformBrokerError,
        desc: ClientAuthErrorMessages[platformBrokerError]
      }
    };
    ClientAuthError = class _ClientAuthError extends AuthError {
      constructor(errorCode, additionalMessage) {
        super(errorCode, additionalMessage ? `${ClientAuthErrorMessages[errorCode]}: ${additionalMessage}` : ClientAuthErrorMessages[errorCode]);
        this.name = "ClientAuthError";
        Object.setPrototypeOf(this, _ClientAuthError.prototype);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/crypto/ICrypto.mjs
var DEFAULT_CRYPTO_IMPLEMENTATION;
var init_ICrypto = __esm({
  "node_modules/@azure/msal-common/dist/crypto/ICrypto.mjs"() {
    "use strict";
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
    DEFAULT_CRYPTO_IMPLEMENTATION = {
      createNewGuid: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64Decode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64Encode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64UrlEncode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      encodeKid: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      async getPublicKeyThumbprint() {
        throw createClientAuthError(methodNotImplemented);
      },
      async removeTokenBindingKey() {
        throw createClientAuthError(methodNotImplemented);
      },
      async clearKeystore() {
        throw createClientAuthError(methodNotImplemented);
      },
      async signJwt() {
        throw createClientAuthError(methodNotImplemented);
      },
      async hashString() {
        throw createClientAuthError(methodNotImplemented);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/logger/Logger.mjs
var LogLevel2, Logger;
var init_Logger = __esm({
  "node_modules/@azure/msal-common/dist/logger/Logger.mjs"() {
    "use strict";
    init_Constants();
    (function(LogLevel3) {
      LogLevel3[LogLevel3["Error"] = 0] = "Error";
      LogLevel3[LogLevel3["Warning"] = 1] = "Warning";
      LogLevel3[LogLevel3["Info"] = 2] = "Info";
      LogLevel3[LogLevel3["Verbose"] = 3] = "Verbose";
      LogLevel3[LogLevel3["Trace"] = 4] = "Trace";
    })(LogLevel2 || (LogLevel2 = {}));
    Logger = class _Logger {
      constructor(loggerOptions, packageName, packageVersion) {
        this.level = LogLevel2.Info;
        const defaultLoggerCallback = () => {
          return;
        };
        const setLoggerOptions = loggerOptions || _Logger.createDefaultLoggerOptions();
        this.localCallback = setLoggerOptions.loggerCallback || defaultLoggerCallback;
        this.piiLoggingEnabled = setLoggerOptions.piiLoggingEnabled || false;
        this.level = typeof setLoggerOptions.logLevel === "number" ? setLoggerOptions.logLevel : LogLevel2.Info;
        this.correlationId = setLoggerOptions.correlationId || Constants.EMPTY_STRING;
        this.packageName = packageName || Constants.EMPTY_STRING;
        this.packageVersion = packageVersion || Constants.EMPTY_STRING;
      }
      static createDefaultLoggerOptions() {
        return {
          loggerCallback: () => {
          },
          piiLoggingEnabled: false,
          logLevel: LogLevel2.Info
        };
      }
      /**
       * Create new Logger with existing configurations.
       */
      clone(packageName, packageVersion, correlationId) {
        return new _Logger({
          loggerCallback: this.localCallback,
          piiLoggingEnabled: this.piiLoggingEnabled,
          logLevel: this.level,
          correlationId: correlationId || this.correlationId
        }, packageName, packageVersion);
      }
      /**
       * Log message with required options.
       */
      logMessage(logMessage, options) {
        if (options.logLevel > this.level || !this.piiLoggingEnabled && options.containsPii) {
          return;
        }
        const timestamp2 = (/* @__PURE__ */ new Date()).toUTCString();
        const logHeader = `[${timestamp2}] : [${options.correlationId || this.correlationId || ""}]`;
        const log2 = `${logHeader} : ${this.packageName}@${this.packageVersion} : ${LogLevel2[options.logLevel]} - ${logMessage}`;
        this.executeCallback(options.logLevel, log2, options.containsPii || false);
      }
      /**
       * Execute callback with message.
       */
      executeCallback(level, message, containsPii) {
        if (this.localCallback) {
          this.localCallback(level, message, containsPii);
        }
      }
      /**
       * Logs error messages.
       */
      error(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel2.Error,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs error messages with PII.
       */
      errorPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel2.Error,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs warning messages.
       */
      warning(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel2.Warning,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs warning messages with PII.
       */
      warningPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel2.Warning,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs info messages.
       */
      info(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel2.Info,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs info messages with PII.
       */
      infoPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel2.Info,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs verbose messages.
       */
      verbose(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel2.Verbose,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs verbose messages with PII.
       */
      verbosePii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel2.Verbose,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs trace messages.
       */
      trace(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel2.Trace,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs trace messages with PII.
       */
      tracePii(message, correlationId) {
        this.logMessage(message, {
          logLevel: LogLevel2.Trace,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Returns whether PII Logging is enabled or not.
       */
      isPiiLoggingEnabled() {
        return this.piiLoggingEnabled || false;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/packageMetadata.mjs
var name, version;
var init_packageMetadata = __esm({
  "node_modules/@azure/msal-common/dist/packageMetadata.mjs"() {
    "use strict";
    name = "@azure/msal-common";
    version = "15.13.3";
  }
});

// node_modules/@azure/msal-common/dist/authority/AuthorityOptions.mjs
var AzureCloudInstance;
var init_AuthorityOptions = __esm({
  "node_modules/@azure/msal-common/dist/authority/AuthorityOptions.mjs"() {
    "use strict";
    AzureCloudInstance = {
      // AzureCloudInstance is not specified.
      None: "none",
      // Microsoft Azure public cloud
      AzurePublic: "https://login.microsoftonline.com",
      // Microsoft PPE
      AzurePpe: "https://login.windows-ppe.net",
      // Microsoft Chinese national/regional cloud
      AzureChina: "https://login.chinacloudapi.cn",
      // Microsoft German national/regional cloud ("Black Forest")
      AzureGermany: "https://login.microsoftonline.de",
      // US Government cloud
      AzureUsGovernment: "https://login.microsoftonline.us"
    };
  }
});

// node_modules/@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs
var redirectUriEmpty, claimsRequestParsingError, authorityUriInsecure, urlParseError, urlEmptyError, emptyInputScopesError, invalidClaims, tokenRequestEmpty, logoutRequestEmpty, invalidCodeChallengeMethod, pkceParamsMissing, invalidCloudDiscoveryMetadata, invalidAuthorityMetadata, untrustedAuthority, missingSshJwk, missingSshKid, missingNonceAuthenticationHeader, invalidAuthenticationHeader, cannotSetOIDCOptions, cannotAllowPlatformBroker, authorityMismatch, invalidRequestMethodForEAR, invalidAuthorizePostBodyParameters, invalidPlatformBrokerConfiguration;
var init_ClientConfigurationErrorCodes = __esm({
  "node_modules/@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs"() {
    "use strict";
    redirectUriEmpty = "redirect_uri_empty";
    claimsRequestParsingError = "claims_request_parsing_error";
    authorityUriInsecure = "authority_uri_insecure";
    urlParseError = "url_parse_error";
    urlEmptyError = "empty_url_error";
    emptyInputScopesError = "empty_input_scopes_error";
    invalidClaims = "invalid_claims";
    tokenRequestEmpty = "token_request_empty";
    logoutRequestEmpty = "logout_request_empty";
    invalidCodeChallengeMethod = "invalid_code_challenge_method";
    pkceParamsMissing = "pkce_params_missing";
    invalidCloudDiscoveryMetadata = "invalid_cloud_discovery_metadata";
    invalidAuthorityMetadata = "invalid_authority_metadata";
    untrustedAuthority = "untrusted_authority";
    missingSshJwk = "missing_ssh_jwk";
    missingSshKid = "missing_ssh_kid";
    missingNonceAuthenticationHeader = "missing_nonce_authentication_header";
    invalidAuthenticationHeader = "invalid_authentication_header";
    cannotSetOIDCOptions = "cannot_set_OIDCOptions";
    cannotAllowPlatformBroker = "cannot_allow_platform_broker";
    authorityMismatch = "authority_mismatch";
    invalidRequestMethodForEAR = "invalid_request_method_for_EAR";
    invalidAuthorizePostBodyParameters = "invalid_authorize_post_body_parameters";
    invalidPlatformBrokerConfiguration = "invalid_platform_broker_configuration";
  }
});

// node_modules/@azure/msal-common/dist/error/ClientConfigurationError.mjs
function createClientConfigurationError(errorCode) {
  return new ClientConfigurationError(errorCode);
}
var ClientConfigurationErrorMessages, ClientConfigurationErrorMessage, ClientConfigurationError;
var init_ClientConfigurationError = __esm({
  "node_modules/@azure/msal-common/dist/error/ClientConfigurationError.mjs"() {
    "use strict";
    init_AuthError();
    init_ClientConfigurationErrorCodes();
    ClientConfigurationErrorMessages = {
      [redirectUriEmpty]: "A redirect URI is required for all calls, and none has been set.",
      [claimsRequestParsingError]: "Could not parse the given claims request object.",
      [authorityUriInsecure]: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options",
      [urlParseError]: "URL could not be parsed into appropriate segments.",
      [urlEmptyError]: "URL was empty or null.",
      [emptyInputScopesError]: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token.",
      [invalidClaims]: "Given claims parameter must be a stringified JSON object.",
      [tokenRequestEmpty]: "Token request was empty and not found in cache.",
      [logoutRequestEmpty]: "The logout request was null or undefined.",
      [invalidCodeChallengeMethod]: 'code_challenge_method passed is invalid. Valid values are "plain" and "S256".',
      [pkceParamsMissing]: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request",
      [invalidCloudDiscoveryMetadata]: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields",
      [invalidAuthorityMetadata]: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields.",
      [untrustedAuthority]: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter.",
      [missingSshJwk]: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme.",
      [missingSshKid]: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme.",
      [missingNonceAuthenticationHeader]: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce.",
      [invalidAuthenticationHeader]: "Invalid authentication header provided",
      [cannotSetOIDCOptions]: "Cannot set OIDCOptions parameter. Please change the protocol mode to OIDC or use a non-Microsoft authority.",
      [cannotAllowPlatformBroker]: "Cannot set allowPlatformBroker parameter to true when not in AAD protocol mode.",
      [authorityMismatch]: "Authority mismatch error. Authority provided in login request or PublicClientApplication config does not match the environment of the provided account. Please use a matching account or make an interactive request to login to this authority.",
      [invalidAuthorizePostBodyParameters]: "Invalid authorize post body parameters provided. If you are using authorizePostBodyParameters, the request method must be POST. Please check the request method and parameters.",
      [invalidRequestMethodForEAR]: "Invalid request method for EAR protocol mode. The request method cannot be GET when using EAR protocol mode. Please change the request method to POST.",
      [invalidPlatformBrokerConfiguration]: "Invalid platform broker configuration. `allowPlatformBrokerWithDOM` can only be enabled when `allowPlatformBroker` is enabled."
    };
    ClientConfigurationErrorMessage = {
      redirectUriNotSet: {
        code: redirectUriEmpty,
        desc: ClientConfigurationErrorMessages[redirectUriEmpty]
      },
      claimsRequestParsingError: {
        code: claimsRequestParsingError,
        desc: ClientConfigurationErrorMessages[claimsRequestParsingError]
      },
      authorityUriInsecure: {
        code: authorityUriInsecure,
        desc: ClientConfigurationErrorMessages[authorityUriInsecure]
      },
      urlParseError: {
        code: urlParseError,
        desc: ClientConfigurationErrorMessages[urlParseError]
      },
      urlEmptyError: {
        code: urlEmptyError,
        desc: ClientConfigurationErrorMessages[urlEmptyError]
      },
      emptyScopesError: {
        code: emptyInputScopesError,
        desc: ClientConfigurationErrorMessages[emptyInputScopesError]
      },
      invalidClaimsRequest: {
        code: invalidClaims,
        desc: ClientConfigurationErrorMessages[invalidClaims]
      },
      tokenRequestEmptyError: {
        code: tokenRequestEmpty,
        desc: ClientConfigurationErrorMessages[tokenRequestEmpty]
      },
      logoutRequestEmptyError: {
        code: logoutRequestEmpty,
        desc: ClientConfigurationErrorMessages[logoutRequestEmpty]
      },
      invalidCodeChallengeMethod: {
        code: invalidCodeChallengeMethod,
        desc: ClientConfigurationErrorMessages[invalidCodeChallengeMethod]
      },
      invalidCodeChallengeParams: {
        code: pkceParamsMissing,
        desc: ClientConfigurationErrorMessages[pkceParamsMissing]
      },
      invalidCloudDiscoveryMetadata: {
        code: invalidCloudDiscoveryMetadata,
        desc: ClientConfigurationErrorMessages[invalidCloudDiscoveryMetadata]
      },
      invalidAuthorityMetadata: {
        code: invalidAuthorityMetadata,
        desc: ClientConfigurationErrorMessages[invalidAuthorityMetadata]
      },
      untrustedAuthority: {
        code: untrustedAuthority,
        desc: ClientConfigurationErrorMessages[untrustedAuthority]
      },
      missingSshJwk: {
        code: missingSshJwk,
        desc: ClientConfigurationErrorMessages[missingSshJwk]
      },
      missingSshKid: {
        code: missingSshKid,
        desc: ClientConfigurationErrorMessages[missingSshKid]
      },
      missingNonceAuthenticationHeader: {
        code: missingNonceAuthenticationHeader,
        desc: ClientConfigurationErrorMessages[missingNonceAuthenticationHeader]
      },
      invalidAuthenticationHeader: {
        code: invalidAuthenticationHeader,
        desc: ClientConfigurationErrorMessages[invalidAuthenticationHeader]
      },
      cannotSetOIDCOptions: {
        code: cannotSetOIDCOptions,
        desc: ClientConfigurationErrorMessages[cannotSetOIDCOptions]
      },
      cannotAllowPlatformBroker: {
        code: cannotAllowPlatformBroker,
        desc: ClientConfigurationErrorMessages[cannotAllowPlatformBroker]
      },
      authorityMismatch: {
        code: authorityMismatch,
        desc: ClientConfigurationErrorMessages[authorityMismatch]
      },
      invalidAuthorizePostBodyParameters: {
        code: invalidAuthorizePostBodyParameters,
        desc: ClientConfigurationErrorMessages[invalidAuthorizePostBodyParameters]
      },
      invalidRequestMethodForEAR: {
        code: invalidRequestMethodForEAR,
        desc: ClientConfigurationErrorMessages[invalidRequestMethodForEAR]
      },
      invalidPlatformBrokerConfiguration: {
        code: invalidPlatformBrokerConfiguration,
        desc: ClientConfigurationErrorMessages[invalidPlatformBrokerConfiguration]
      }
    };
    ClientConfigurationError = class _ClientConfigurationError extends AuthError {
      constructor(errorCode) {
        super(errorCode, ClientConfigurationErrorMessages[errorCode]);
        this.name = "ClientConfigurationError";
        Object.setPrototypeOf(this, _ClientConfigurationError.prototype);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/utils/StringUtils.mjs
var StringUtils;
var init_StringUtils = __esm({
  "node_modules/@azure/msal-common/dist/utils/StringUtils.mjs"() {
    "use strict";
    StringUtils = class {
      /**
       * Check if stringified object is empty
       * @param strObj
       */
      static isEmptyObj(strObj) {
        if (strObj) {
          try {
            const obj = JSON.parse(strObj);
            return Object.keys(obj).length === 0;
          } catch (e) {
          }
        }
        return true;
      }
      static startsWith(str2, search) {
        return str2.indexOf(search) === 0;
      }
      static endsWith(str2, search) {
        return str2.length >= search.length && str2.lastIndexOf(search) === str2.length - search.length;
      }
      /**
       * Parses string into an object.
       *
       * @param query
       */
      static queryStringToObject(query) {
        const obj = {};
        const params = query.split("&");
        const decode = (s) => decodeURIComponent(s.replace(/\+/g, " "));
        params.forEach((pair) => {
          if (pair.trim()) {
            const [key2, value] = pair.split(/=(.+)/g, 2);
            if (key2 && value) {
              obj[decode(key2)] = decode(value);
            }
          }
        });
        return obj;
      }
      /**
       * Trims entries in an array.
       *
       * @param arr
       */
      static trimArrayEntries(arr) {
        return arr.map((entry) => entry.trim());
      }
      /**
       * Removes empty strings from array
       * @param arr
       */
      static removeEmptyStringsFromArray(arr) {
        return arr.filter((entry) => {
          return !!entry;
        });
      }
      /**
       * Attempts to parse a string into JSON
       * @param str
       */
      static jsonParseHelper(str2) {
        try {
          return JSON.parse(str2);
        } catch (e) {
          return null;
        }
      }
      /**
       * Tests if a given string matches a given pattern, with support for wildcards and queries.
       * @param pattern Wildcard pattern to string match. Supports "*" for wildcards and "?" for queries
       * @param input String to match against
       */
      static matchPattern(pattern, input) {
        const regex = new RegExp(pattern.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\?"));
        return regex.test(input);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/request/ScopeSet.mjs
var ScopeSet;
var init_ScopeSet = __esm({
  "node_modules/@azure/msal-common/dist/request/ScopeSet.mjs"() {
    "use strict";
    init_ClientConfigurationError();
    init_StringUtils();
    init_ClientAuthError();
    init_Constants();
    init_ClientConfigurationErrorCodes();
    init_ClientAuthErrorCodes();
    ScopeSet = class _ScopeSet {
      constructor(inputScopes) {
        const scopeArr = inputScopes ? StringUtils.trimArrayEntries([...inputScopes]) : [];
        const filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];
        if (!filteredInput || !filteredInput.length) {
          throw createClientConfigurationError(emptyInputScopesError);
        }
        this.scopes = /* @__PURE__ */ new Set();
        filteredInput.forEach((scope) => this.scopes.add(scope));
      }
      /**
       * Factory method to create ScopeSet from space-delimited string
       * @param inputScopeString
       * @param appClientId
       * @param scopesRequired
       */
      static fromString(inputScopeString) {
        const scopeString = inputScopeString || Constants.EMPTY_STRING;
        const inputScopes = scopeString.split(" ");
        return new _ScopeSet(inputScopes);
      }
      /**
       * Creates the set of scopes to search for in cache lookups
       * @param inputScopeString
       * @returns
       */
      static createSearchScopes(inputScopeString) {
        const scopesToUse = inputScopeString && inputScopeString.length > 0 ? inputScopeString : [...OIDC_DEFAULT_SCOPES];
        const scopeSet = new _ScopeSet(scopesToUse);
        if (!scopeSet.containsOnlyOIDCScopes()) {
          scopeSet.removeOIDCScopes();
        } else {
          scopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);
        }
        return scopeSet;
      }
      /**
       * Check if a given scope is present in this set of scopes.
       * @param scope
       */
      containsScope(scope) {
        const lowerCaseScopes = this.printScopesLowerCase().split(" ");
        const lowerCaseScopesSet = new _ScopeSet(lowerCaseScopes);
        return scope ? lowerCaseScopesSet.scopes.has(scope.toLowerCase()) : false;
      }
      /**
       * Check if a set of scopes is present in this set of scopes.
       * @param scopeSet
       */
      containsScopeSet(scopeSet) {
        if (!scopeSet || scopeSet.scopes.size <= 0) {
          return false;
        }
        return this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every((scope) => this.containsScope(scope));
      }
      /**
       * Check if set of scopes contains only the defaults
       */
      containsOnlyOIDCScopes() {
        let defaultScopeCount = 0;
        OIDC_SCOPES.forEach((defaultScope) => {
          if (this.containsScope(defaultScope)) {
            defaultScopeCount += 1;
          }
        });
        return this.scopes.size === defaultScopeCount;
      }
      /**
       * Appends single scope if passed
       * @param newScope
       */
      appendScope(newScope) {
        if (newScope) {
          this.scopes.add(newScope.trim());
        }
      }
      /**
       * Appends multiple scopes if passed
       * @param newScopes
       */
      appendScopes(newScopes) {
        try {
          newScopes.forEach((newScope) => this.appendScope(newScope));
        } catch (e) {
          throw createClientAuthError(cannotAppendScopeSet);
        }
      }
      /**
       * Removes element from set of scopes.
       * @param scope
       */
      removeScope(scope) {
        if (!scope) {
          throw createClientAuthError(cannotRemoveEmptyScope);
        }
        this.scopes.delete(scope.trim());
      }
      /**
       * Removes default scopes from set of scopes
       * Primarily used to prevent cache misses if the default scopes are not returned from the server
       */
      removeOIDCScopes() {
        OIDC_SCOPES.forEach((defaultScope) => {
          this.scopes.delete(defaultScope);
        });
      }
      /**
       * Combines an array of scopes with the current set of scopes.
       * @param otherScopes
       */
      unionScopeSets(otherScopes) {
        if (!otherScopes) {
          throw createClientAuthError(emptyInputScopeSet);
        }
        const unionScopes = /* @__PURE__ */ new Set();
        otherScopes.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
        this.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
        return unionScopes;
      }
      /**
       * Check if scopes intersect between this set and another.
       * @param otherScopes
       */
      intersectingScopeSets(otherScopes) {
        if (!otherScopes) {
          throw createClientAuthError(emptyInputScopeSet);
        }
        if (!otherScopes.containsOnlyOIDCScopes()) {
          otherScopes.removeOIDCScopes();
        }
        const unionScopes = this.unionScopeSets(otherScopes);
        const sizeOtherScopes = otherScopes.getScopeCount();
        const sizeThisScopes = this.getScopeCount();
        const sizeUnionScopes = unionScopes.size;
        return sizeUnionScopes < sizeThisScopes + sizeOtherScopes;
      }
      /**
       * Returns size of set of scopes.
       */
      getScopeCount() {
        return this.scopes.size;
      }
      /**
       * Returns the scopes as an array of string values
       */
      asArray() {
        const array = [];
        this.scopes.forEach((val) => array.push(val));
        return array;
      }
      /**
       * Prints scopes into a space-delimited string
       */
      printScopes() {
        if (this.scopes) {
          const scopeArr = this.asArray();
          return scopeArr.join(" ");
        }
        return Constants.EMPTY_STRING;
      }
      /**
       * Prints scopes into a space-delimited lower-case string (used for caching)
       */
      printScopesLowerCase() {
        return this.printScopes().toLowerCase();
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/account/ClientInfo.mjs
function buildClientInfo(rawClientInfo, base64Decode) {
  if (!rawClientInfo) {
    throw createClientAuthError(clientInfoEmptyError);
  }
  try {
    const decodedClientInfo = base64Decode(rawClientInfo);
    return JSON.parse(decodedClientInfo);
  } catch (e) {
    throw createClientAuthError(clientInfoDecodingError);
  }
}
function buildClientInfoFromHomeAccountId(homeAccountId) {
  if (!homeAccountId) {
    throw createClientAuthError(clientInfoDecodingError);
  }
  const clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
  return {
    uid: clientInfoParts[0],
    utid: clientInfoParts.length < 2 ? Constants.EMPTY_STRING : clientInfoParts[1]
  };
}
var init_ClientInfo = __esm({
  "node_modules/@azure/msal-common/dist/account/ClientInfo.mjs"() {
    "use strict";
    init_ClientAuthError();
    init_Constants();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/account/AccountInfo.mjs
function tenantIdMatchesHomeTenant(tenantId, homeAccountId) {
  return !!tenantId && !!homeAccountId && tenantId === homeAccountId.split(".")[1];
}
function buildTenantProfile(homeAccountId, localAccountId, tenantId, idTokenClaims) {
  if (idTokenClaims) {
    const { oid, sub, tid, name: name3, tfp, acr, preferred_username, upn, login_hint } = idTokenClaims;
    const tenantId2 = tid || tfp || acr || "";
    return {
      tenantId: tenantId2,
      localAccountId: oid || sub || "",
      name: name3,
      username: preferred_username || upn || "",
      loginHint: login_hint,
      isHomeTenant: tenantIdMatchesHomeTenant(tenantId2, homeAccountId)
    };
  } else {
    return {
      tenantId,
      localAccountId,
      username: "",
      isHomeTenant: tenantIdMatchesHomeTenant(tenantId, homeAccountId)
    };
  }
}
function updateAccountTenantProfileData(baseAccountInfo, tenantProfile, idTokenClaims, idTokenSecret) {
  let updatedAccountInfo = baseAccountInfo;
  if (tenantProfile) {
    const { isHomeTenant, ...tenantProfileOverride } = tenantProfile;
    updatedAccountInfo = { ...baseAccountInfo, ...tenantProfileOverride };
  }
  if (idTokenClaims) {
    const { isHomeTenant, ...claimsSourcedTenantProfile } = buildTenantProfile(baseAccountInfo.homeAccountId, baseAccountInfo.localAccountId, baseAccountInfo.tenantId, idTokenClaims);
    updatedAccountInfo = {
      ...updatedAccountInfo,
      ...claimsSourcedTenantProfile,
      idTokenClaims,
      idToken: idTokenSecret
    };
    return updatedAccountInfo;
  }
  return updatedAccountInfo;
}
var init_AccountInfo = __esm({
  "node_modules/@azure/msal-common/dist/account/AccountInfo.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/authority/AuthorityType.mjs
var AuthorityType;
var init_AuthorityType = __esm({
  "node_modules/@azure/msal-common/dist/authority/AuthorityType.mjs"() {
    "use strict";
    AuthorityType = {
      Default: 0,
      Adfs: 1,
      Dsts: 2,
      Ciam: 3
    };
  }
});

// node_modules/@azure/msal-common/dist/account/TokenClaims.mjs
function getTenantIdFromIdTokenClaims(idTokenClaims) {
  if (idTokenClaims) {
    const tenantId = idTokenClaims.tid || idTokenClaims.tfp || idTokenClaims.acr;
    return tenantId || null;
  }
  return null;
}
var init_TokenClaims = __esm({
  "node_modules/@azure/msal-common/dist/account/TokenClaims.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/authority/ProtocolMode.mjs
var ProtocolMode;
var init_ProtocolMode = __esm({
  "node_modules/@azure/msal-common/dist/authority/ProtocolMode.mjs"() {
    "use strict";
    ProtocolMode = {
      /**
       * Auth Code + PKCE with Entra ID (formerly AAD) specific optimizations and features
       */
      AAD: "AAD",
      /**
       * Auth Code + PKCE without Entra ID specific optimizations and features. For use only with non-Microsoft owned authorities.
       * Support is limited for this mode.
       */
      OIDC: "OIDC",
      /**
       * Encrypted Authorize Response (EAR) with Entra ID specific optimizations and features
       */
      EAR: "EAR"
    };
  }
});

// node_modules/@azure/msal-common/dist/cache/entities/AccountEntity.mjs
var AccountEntity;
var init_AccountEntity = __esm({
  "node_modules/@azure/msal-common/dist/cache/entities/AccountEntity.mjs"() {
    "use strict";
    init_Constants();
    init_ClientInfo();
    init_AccountInfo();
    init_ClientAuthError();
    init_AuthorityType();
    init_TokenClaims();
    init_ProtocolMode();
    init_ClientAuthErrorCodes();
    AccountEntity = class _AccountEntity {
      /**
       * Returns the AccountInfo interface for this account.
       */
      static getAccountInfo(accountEntity) {
        return {
          homeAccountId: accountEntity.homeAccountId,
          environment: accountEntity.environment,
          tenantId: accountEntity.realm,
          username: accountEntity.username,
          localAccountId: accountEntity.localAccountId,
          loginHint: accountEntity.loginHint,
          name: accountEntity.name,
          nativeAccountId: accountEntity.nativeAccountId,
          authorityType: accountEntity.authorityType,
          // Deserialize tenant profiles array into a Map
          tenantProfiles: new Map((accountEntity.tenantProfiles || []).map((tenantProfile) => {
            return [tenantProfile.tenantId, tenantProfile];
          })),
          dataBoundary: accountEntity.dataBoundary
        };
      }
      /**
       * Returns true if the account entity is in single tenant format (outdated), false otherwise
       */
      isSingleTenant() {
        return !this.tenantProfiles;
      }
      /**
       * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.
       * @param accountDetails
       */
      static createAccount(accountDetails, authority, base64Decode) {
        const account = new _AccountEntity();
        if (authority.authorityType === AuthorityType.Adfs) {
          account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;
        } else if (authority.protocolMode === ProtocolMode.OIDC) {
          account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;
        } else {
          account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;
        }
        let clientInfo;
        if (accountDetails.clientInfo && base64Decode) {
          clientInfo = buildClientInfo(accountDetails.clientInfo, base64Decode);
          if (clientInfo.xms_tdbr) {
            account.dataBoundary = clientInfo.xms_tdbr === "EU" ? "EU" : "None";
          }
        }
        account.clientInfo = accountDetails.clientInfo;
        account.homeAccountId = accountDetails.homeAccountId;
        account.nativeAccountId = accountDetails.nativeAccountId;
        const env5 = accountDetails.environment || authority && authority.getPreferredCache();
        if (!env5) {
          throw createClientAuthError(invalidCacheEnvironment);
        }
        account.environment = env5;
        account.realm = clientInfo?.utid || getTenantIdFromIdTokenClaims(accountDetails.idTokenClaims) || "";
        account.localAccountId = clientInfo?.uid || accountDetails.idTokenClaims?.oid || accountDetails.idTokenClaims?.sub || "";
        const preferredUsername = accountDetails.idTokenClaims?.preferred_username || accountDetails.idTokenClaims?.upn;
        const email = accountDetails.idTokenClaims?.emails ? accountDetails.idTokenClaims.emails[0] : null;
        account.username = preferredUsername || email || "";
        account.loginHint = accountDetails.idTokenClaims?.login_hint;
        account.name = accountDetails.idTokenClaims?.name || "";
        account.cloudGraphHostName = accountDetails.cloudGraphHostName;
        account.msGraphHost = accountDetails.msGraphHost;
        if (accountDetails.tenantProfiles) {
          account.tenantProfiles = accountDetails.tenantProfiles;
        } else {
          const tenantProfile = buildTenantProfile(accountDetails.homeAccountId, account.localAccountId, account.realm, accountDetails.idTokenClaims);
          account.tenantProfiles = [tenantProfile];
        }
        return account;
      }
      /**
       * Creates an AccountEntity object from AccountInfo
       * @param accountInfo
       * @param cloudGraphHostName
       * @param msGraphHost
       * @returns
       */
      static createFromAccountInfo(accountInfo, cloudGraphHostName, msGraphHost) {
        const account = new _AccountEntity();
        account.authorityType = accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;
        account.homeAccountId = accountInfo.homeAccountId;
        account.localAccountId = accountInfo.localAccountId;
        account.nativeAccountId = accountInfo.nativeAccountId;
        account.realm = accountInfo.tenantId;
        account.environment = accountInfo.environment;
        account.username = accountInfo.username;
        account.name = accountInfo.name;
        account.loginHint = accountInfo.loginHint;
        account.cloudGraphHostName = cloudGraphHostName;
        account.msGraphHost = msGraphHost;
        account.tenantProfiles = Array.from(accountInfo.tenantProfiles?.values() || []);
        account.dataBoundary = accountInfo.dataBoundary;
        return account;
      }
      /**
       * Generate HomeAccountId from server response
       * @param serverClientInfo
       * @param authType
       */
      static generateHomeAccountId(serverClientInfo, authType, logger11, cryptoObj, idTokenClaims) {
        if (!(authType === AuthorityType.Adfs || authType === AuthorityType.Dsts)) {
          if (serverClientInfo) {
            try {
              const clientInfo = buildClientInfo(serverClientInfo, cryptoObj.base64Decode);
              if (clientInfo.uid && clientInfo.utid) {
                return `${clientInfo.uid}.${clientInfo.utid}`;
              }
            } catch (e) {
            }
          }
          logger11.warning("No client info in response");
        }
        return idTokenClaims?.sub || "";
      }
      /**
       * Validates an entity: checks for all expected params
       * @param entity
       */
      static isAccountEntity(entity) {
        if (!entity) {
          return false;
        }
        return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("localAccountId") && entity.hasOwnProperty("username") && entity.hasOwnProperty("authorityType");
      }
      /**
       * Helper function to determine whether 2 accountInfo objects represent the same account
       * @param accountA
       * @param accountB
       * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality
       */
      static accountInfoIsEqual(accountA, accountB, compareClaims) {
        if (!accountA || !accountB) {
          return false;
        }
        let claimsMatch = true;
        if (compareClaims) {
          const accountAClaims = accountA.idTokenClaims || {};
          const accountBClaims = accountB.idTokenClaims || {};
          claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;
        }
        return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.loginHint === accountB.loginHint && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/account/AuthToken.mjs
function extractTokenClaims(encodedToken, base64Decode) {
  const jswPayload = getJWSPayload(encodedToken);
  try {
    const base64Decoded = base64Decode(jswPayload);
    return JSON.parse(base64Decoded);
  } catch (err) {
    throw createClientAuthError(tokenParsingError);
  }
}
function isKmsi(idTokenClaims) {
  if (!idTokenClaims.signin_state) {
    return false;
  }
  const kmsiClaims = ["kmsi", "dvc_dmjd"];
  const kmsi = idTokenClaims.signin_state.some((value) => kmsiClaims.includes(value.trim().toLowerCase()));
  return kmsi;
}
function getJWSPayload(authToken) {
  if (!authToken) {
    throw createClientAuthError(nullOrEmptyToken);
  }
  const tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
  const matches = tokenPartsRegex.exec(authToken);
  if (!matches || matches.length < 4) {
    throw createClientAuthError(tokenParsingError);
  }
  return matches[2];
}
function checkMaxAge(authTime, maxAge) {
  const fiveMinuteSkew = 3e5;
  if (maxAge === 0 || Date.now() - fiveMinuteSkew > authTime + maxAge) {
    throw createClientAuthError(maxAgeTranspired);
  }
}
var init_AuthToken = __esm({
  "node_modules/@azure/msal-common/dist/account/AuthToken.mjs"() {
    "use strict";
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/utils/UrlUtils.mjs
var UrlUtils_exports = {};
__export(UrlUtils_exports, {
  getDeserializedResponse: () => getDeserializedResponse,
  mapToQueryString: () => mapToQueryString,
  normalizeUrlForComparison: () => normalizeUrlForComparison,
  stripLeadingHashOrQuery: () => stripLeadingHashOrQuery
});
function canonicalizeUrl(url2) {
  if (!url2) {
    return url2;
  }
  let lowerCaseUrl = url2.toLowerCase();
  if (StringUtils.endsWith(lowerCaseUrl, "?")) {
    lowerCaseUrl = lowerCaseUrl.slice(0, -1);
  } else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
    lowerCaseUrl = lowerCaseUrl.slice(0, -2);
  }
  if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
    lowerCaseUrl += "/";
  }
  return lowerCaseUrl;
}
function stripLeadingHashOrQuery(responseString) {
  if (responseString.startsWith("#/")) {
    return responseString.substring(2);
  } else if (responseString.startsWith("#") || responseString.startsWith("?")) {
    return responseString.substring(1);
  }
  return responseString;
}
function getDeserializedResponse(responseString) {
  if (!responseString || responseString.indexOf("=") < 0) {
    return null;
  }
  try {
    const normalizedResponse = stripLeadingHashOrQuery(responseString);
    const deserializedHash = Object.fromEntries(new URLSearchParams(normalizedResponse));
    if (deserializedHash.code || deserializedHash.ear_jwe || deserializedHash.error || deserializedHash.error_description || deserializedHash.state) {
      return deserializedHash;
    }
  } catch (e) {
    throw createClientAuthError(hashNotDeserialized);
  }
  return null;
}
function mapToQueryString(parameters, encodeExtraParams = true, extraQueryParameters) {
  const queryParameterArray = new Array();
  parameters.forEach((value, key2) => {
    if (!encodeExtraParams && extraQueryParameters && key2 in extraQueryParameters) {
      queryParameterArray.push(`${key2}=${value}`);
    } else {
      queryParameterArray.push(`${key2}=${encodeURIComponent(value)}`);
    }
  });
  return queryParameterArray.join("&");
}
function normalizeUrlForComparison(url2) {
  if (!url2) {
    return url2;
  }
  const urlWithoutHash = url2.split("#")[0];
  try {
    const urlObj = new URL(urlWithoutHash);
    const normalizedUrl = urlObj.origin + urlObj.pathname + urlObj.search;
    return canonicalizeUrl(normalizedUrl);
  } catch (e) {
    return canonicalizeUrl(urlWithoutHash);
  }
}
var init_UrlUtils = __esm({
  "node_modules/@azure/msal-common/dist/utils/UrlUtils.mjs"() {
    "use strict";
    init_ClientAuthError();
    init_StringUtils();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/url/UrlString.mjs
var UrlString;
var init_UrlString = __esm({
  "node_modules/@azure/msal-common/dist/url/UrlString.mjs"() {
    "use strict";
    init_ClientConfigurationError();
    init_StringUtils();
    init_Constants();
    init_UrlUtils();
    init_ClientConfigurationErrorCodes();
    UrlString = class _UrlString {
      get urlString() {
        return this._urlString;
      }
      constructor(url2) {
        this._urlString = url2;
        if (!this._urlString) {
          throw createClientConfigurationError(urlEmptyError);
        }
        if (!url2.includes("#")) {
          this._urlString = _UrlString.canonicalizeUri(url2);
        }
      }
      /**
       * Ensure urls are lower case and end with a / character.
       * @param url
       */
      static canonicalizeUri(url2) {
        if (url2) {
          let lowerCaseUrl = url2.toLowerCase();
          if (StringUtils.endsWith(lowerCaseUrl, "?")) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -1);
          } else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -2);
          }
          if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
            lowerCaseUrl += "/";
          }
          return lowerCaseUrl;
        }
        return url2;
      }
      /**
       * Throws if urlString passed is not a valid authority URI string.
       */
      validateAsUri() {
        let components;
        try {
          components = this.getUrlComponents();
        } catch (e) {
          throw createClientConfigurationError(urlParseError);
        }
        if (!components.HostNameAndPort || !components.PathSegments) {
          throw createClientConfigurationError(urlParseError);
        }
        if (!components.Protocol || components.Protocol.toLowerCase() !== "https:") {
          throw createClientConfigurationError(authorityUriInsecure);
        }
      }
      /**
       * Given a url and a query string return the url with provided query string appended
       * @param url
       * @param queryString
       */
      static appendQueryString(url2, queryString) {
        if (!queryString) {
          return url2;
        }
        return url2.indexOf("?") < 0 ? `${url2}?${queryString}` : `${url2}&${queryString}`;
      }
      /**
       * Returns a url with the hash removed
       * @param url
       */
      static removeHashFromUrl(url2) {
        return _UrlString.canonicalizeUri(url2.split("#")[0]);
      }
      /**
       * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d
       * @param href The url
       * @param tenantId The tenant id to replace
       */
      replaceTenantPath(tenantId) {
        const urlObject = this.getUrlComponents();
        const pathArray = urlObject.PathSegments;
        if (tenantId && pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {
          pathArray[0] = tenantId;
        }
        return _UrlString.constructAuthorityUriFromObject(urlObject);
      }
      /**
       * Parses out the components from a url string.
       * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.
       */
      getUrlComponents() {
        const regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
        const match = this.urlString.match(regEx);
        if (!match) {
          throw createClientConfigurationError(urlParseError);
        }
        const urlComponents = {
          Protocol: match[1],
          HostNameAndPort: match[4],
          AbsolutePath: match[5],
          QueryString: match[7]
        };
        let pathSegments = urlComponents.AbsolutePath.split("/");
        pathSegments = pathSegments.filter((val) => val && val.length > 0);
        urlComponents.PathSegments = pathSegments;
        if (urlComponents.QueryString && urlComponents.QueryString.endsWith("/")) {
          urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);
        }
        return urlComponents;
      }
      static getDomainFromUrl(url2) {
        const regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");
        const match = url2.match(regEx);
        if (!match) {
          throw createClientConfigurationError(urlParseError);
        }
        return match[2];
      }
      static getAbsoluteUrl(relativeUrl, baseUrl) {
        if (relativeUrl[0] === Constants.FORWARD_SLASH) {
          const url2 = new _UrlString(baseUrl);
          const baseComponents = url2.getUrlComponents();
          return baseComponents.Protocol + "//" + baseComponents.HostNameAndPort + relativeUrl;
        }
        return relativeUrl;
      }
      static constructAuthorityUriFromObject(urlObject) {
        return new _UrlString(urlObject.Protocol + "//" + urlObject.HostNameAndPort + "/" + urlObject.PathSegments.join("/"));
      }
      /**
       * Check if the hash of the URL string contains known properties
       * @deprecated This API will be removed in a future version
       */
      static hashContainsKnownProperties(response) {
        return !!getDeserializedResponse(response);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/authority/AuthorityMetadata.mjs
function getAliasesFromStaticSources(staticAuthorityOptions, logger11) {
  let staticAliases;
  const canonicalAuthority = staticAuthorityOptions.canonicalAuthority;
  if (canonicalAuthority) {
    const authorityHost = new UrlString(canonicalAuthority).getUrlComponents().HostNameAndPort;
    staticAliases = getAliasesFromMetadata(authorityHost, staticAuthorityOptions.cloudDiscoveryMetadata?.metadata, AuthorityMetadataSource.CONFIG, logger11) || getAliasesFromMetadata(authorityHost, InstanceDiscoveryMetadata.metadata, AuthorityMetadataSource.HARDCODED_VALUES, logger11) || staticAuthorityOptions.knownAuthorities;
  }
  return staticAliases || [];
}
function getAliasesFromMetadata(authorityHost, cloudDiscoveryMetadata, source2, logger11) {
  logger11?.trace(`getAliasesFromMetadata called with source: ${source2}`);
  if (authorityHost && cloudDiscoveryMetadata) {
    const metadata = getCloudDiscoveryMetadataFromNetworkResponse(cloudDiscoveryMetadata, authorityHost);
    if (metadata) {
      logger11?.trace(`getAliasesFromMetadata: found cloud discovery metadata in ${source2}, returning aliases`);
      return metadata.aliases;
    } else {
      logger11?.trace(`getAliasesFromMetadata: did not find cloud discovery metadata in ${source2}`);
    }
  }
  return null;
}
function getCloudDiscoveryMetadataFromHardcodedValues(authorityHost) {
  const metadata = getCloudDiscoveryMetadataFromNetworkResponse(InstanceDiscoveryMetadata.metadata, authorityHost);
  return metadata;
}
function getCloudDiscoveryMetadataFromNetworkResponse(response, authorityHost) {
  for (let i = 0; i < response.length; i++) {
    const metadata = response[i];
    if (metadata.aliases.includes(authorityHost)) {
      return metadata;
    }
  }
  return null;
}
var rawMetdataJSON, EndpointMetadata, InstanceDiscoveryMetadata, InstanceDiscoveryMetadataAliases;
var init_AuthorityMetadata = __esm({
  "node_modules/@azure/msal-common/dist/authority/AuthorityMetadata.mjs"() {
    "use strict";
    init_UrlString();
    init_Constants();
    rawMetdataJSON = {
      endpointMetadata: {
        "login.microsoftonline.com": {
          token_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.microsoftonline.com/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.microsoftonline.com/{tenantid}/v2.0",
          authorization_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/logout"
        },
        "login.chinacloudapi.cn": {
          token_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.chinacloudapi.cn/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.partner.microsoftonline.cn/{tenantid}/v2.0",
          authorization_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/logout"
        },
        "login.microsoftonline.us": {
          token_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.microsoftonline.us/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.microsoftonline.us/{tenantid}/v2.0",
          authorization_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/logout"
        }
      },
      instanceDiscoveryMetadata: {
        metadata: [
          {
            preferred_network: "login.microsoftonline.com",
            preferred_cache: "login.windows.net",
            aliases: [
              "login.microsoftonline.com",
              "login.windows.net",
              "login.microsoft.com",
              "sts.windows.net"
            ]
          },
          {
            preferred_network: "login.partner.microsoftonline.cn",
            preferred_cache: "login.partner.microsoftonline.cn",
            aliases: [
              "login.partner.microsoftonline.cn",
              "login.chinacloudapi.cn"
            ]
          },
          {
            preferred_network: "login.microsoftonline.de",
            preferred_cache: "login.microsoftonline.de",
            aliases: ["login.microsoftonline.de"]
          },
          {
            preferred_network: "login.microsoftonline.us",
            preferred_cache: "login.microsoftonline.us",
            aliases: [
              "login.microsoftonline.us",
              "login.usgovcloudapi.net"
            ]
          },
          {
            preferred_network: "login-us.microsoftonline.com",
            preferred_cache: "login-us.microsoftonline.com",
            aliases: ["login-us.microsoftonline.com"]
          }
        ]
      }
    };
    EndpointMetadata = rawMetdataJSON.endpointMetadata;
    InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;
    InstanceDiscoveryMetadataAliases = /* @__PURE__ */ new Set();
    InstanceDiscoveryMetadata.metadata.forEach((metadataEntry) => {
      metadataEntry.aliases.forEach((alias) => {
        InstanceDiscoveryMetadataAliases.add(alias);
      });
    });
  }
});

// node_modules/@azure/msal-common/dist/error/CacheErrorCodes.mjs
var cacheQuotaExceeded, cacheErrorUnknown;
var init_CacheErrorCodes = __esm({
  "node_modules/@azure/msal-common/dist/error/CacheErrorCodes.mjs"() {
    "use strict";
    cacheQuotaExceeded = "cache_quota_exceeded";
    cacheErrorUnknown = "cache_error_unknown";
  }
});

// node_modules/@azure/msal-common/dist/error/CacheError.mjs
function createCacheError(e) {
  if (!(e instanceof Error)) {
    return new CacheError(cacheErrorUnknown);
  }
  if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED" || e.message.includes("exceeded the quota")) {
    return new CacheError(cacheQuotaExceeded);
  } else {
    return new CacheError(e.name, e.message);
  }
}
var CacheErrorMessages, CacheError;
var init_CacheError = __esm({
  "node_modules/@azure/msal-common/dist/error/CacheError.mjs"() {
    "use strict";
    init_AuthError();
    init_CacheErrorCodes();
    CacheErrorMessages = {
      [cacheQuotaExceeded]: "Exceeded cache storage capacity.",
      [cacheErrorUnknown]: "Unexpected error occurred when using cache storage."
    };
    CacheError = class _CacheError extends AuthError {
      constructor(errorCode, errorMessage) {
        const message = errorMessage || (CacheErrorMessages[errorCode] ? CacheErrorMessages[errorCode] : CacheErrorMessages[cacheErrorUnknown]);
        super(`${errorCode}: ${message}`);
        Object.setPrototypeOf(this, _CacheError.prototype);
        this.name = "CacheError";
        this.errorCode = errorCode;
        this.errorMessage = message;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/cache/CacheManager.mjs
var CacheManager, DefaultStorageClass;
var init_CacheManager = __esm({
  "node_modules/@azure/msal-common/dist/cache/CacheManager.mjs"() {
    "use strict";
    init_Constants();
    init_ScopeSet();
    init_AccountEntity();
    init_ClientAuthError();
    init_AccountInfo();
    init_AuthToken();
    init_packageMetadata();
    init_AuthorityMetadata();
    init_CacheError();
    init_AuthError();
    init_ClientAuthErrorCodes();
    CacheManager = class {
      constructor(clientId, cryptoImpl, logger11, performanceClient, staticAuthorityOptions) {
        this.clientId = clientId;
        this.cryptoImpl = cryptoImpl;
        this.commonLogger = logger11.clone(name, version);
        this.staticAuthorityOptions = staticAuthorityOptions;
        this.performanceClient = performanceClient;
      }
      /**
       * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
       * @param accountFilter - (Optional) filter to narrow down the accounts returned
       * @returns Array of AccountInfo objects in cache
       */
      getAllAccounts(accountFilter, correlationId) {
        return this.buildTenantProfiles(this.getAccountsFilteredBy(accountFilter, correlationId), correlationId, accountFilter);
      }
      /**
       * Gets first tenanted AccountInfo object found based on provided filters
       */
      getAccountInfoFilteredBy(accountFilter, correlationId) {
        if (Object.keys(accountFilter).length === 0 || Object.values(accountFilter).every((value) => !value)) {
          this.commonLogger.warning("getAccountInfoFilteredBy: Account filter is empty or invalid, returning null");
          return null;
        }
        const allAccounts = this.getAllAccounts(accountFilter, correlationId);
        if (allAccounts.length > 1) {
          const sortedAccounts = allAccounts.sort((account) => {
            return account.idTokenClaims ? -1 : 1;
          });
          return sortedAccounts[0];
        } else if (allAccounts.length === 1) {
          return allAccounts[0];
        } else {
          return null;
        }
      }
      /**
       * Returns a single matching
       * @param accountFilter
       * @returns
       */
      getBaseAccountInfo(accountFilter, correlationId) {
        const accountEntities = this.getAccountsFilteredBy(accountFilter, correlationId);
        if (accountEntities.length > 0) {
          return AccountEntity.getAccountInfo(accountEntities[0]);
        } else {
          return null;
        }
      }
      /**
       * Matches filtered account entities with cached ID tokens that match the tenant profile-specific account filters
       * and builds the account info objects from the matching ID token's claims
       * @param cachedAccounts
       * @param accountFilter
       * @returns Array of AccountInfo objects that match account and tenant profile filters
       */
      buildTenantProfiles(cachedAccounts, correlationId, accountFilter) {
        return cachedAccounts.flatMap((accountEntity) => {
          return this.getTenantProfilesFromAccountEntity(accountEntity, correlationId, accountFilter?.tenantId, accountFilter);
        });
      }
      getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, correlationId, tenantProfileFilter) {
        let tenantedAccountInfo = null;
        let idTokenClaims;
        if (tenantProfileFilter) {
          if (!this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter)) {
            return null;
          }
        }
        const idToken = this.getIdToken(accountInfo, correlationId, tokenKeys, tenantProfile.tenantId);
        if (idToken) {
          idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);
          if (!this.idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter)) {
            return null;
          }
        }
        tenantedAccountInfo = updateAccountTenantProfileData(accountInfo, tenantProfile, idTokenClaims, idToken?.secret);
        return tenantedAccountInfo;
      }
      getTenantProfilesFromAccountEntity(accountEntity, correlationId, targetTenantId, tenantProfileFilter) {
        const accountInfo = AccountEntity.getAccountInfo(accountEntity);
        let searchTenantProfiles = accountInfo.tenantProfiles || /* @__PURE__ */ new Map();
        const tokenKeys = this.getTokenKeys();
        if (targetTenantId) {
          const tenantProfile = searchTenantProfiles.get(targetTenantId);
          if (tenantProfile) {
            searchTenantProfiles = /* @__PURE__ */ new Map([
              [targetTenantId, tenantProfile]
            ]);
          } else {
            return [];
          }
        }
        const matchingTenantProfiles = [];
        searchTenantProfiles.forEach((tenantProfile) => {
          const tenantedAccountInfo = this.getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, correlationId, tenantProfileFilter);
          if (tenantedAccountInfo) {
            matchingTenantProfiles.push(tenantedAccountInfo);
          }
        });
        return matchingTenantProfiles;
      }
      tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter) {
        if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTenantProfile(tenantProfile, tenantProfileFilter.localAccountId)) {
          return false;
        }
        if (!!tenantProfileFilter.name && !(tenantProfile.name === tenantProfileFilter.name)) {
          return false;
        }
        if (tenantProfileFilter.isHomeTenant !== void 0 && !(tenantProfile.isHomeTenant === tenantProfileFilter.isHomeTenant)) {
          return false;
        }
        return true;
      }
      idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter) {
        if (tenantProfileFilter) {
          if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTokenClaims(idTokenClaims, tenantProfileFilter.localAccountId)) {
            return false;
          }
          if (!!tenantProfileFilter.loginHint && !this.matchLoginHintFromTokenClaims(idTokenClaims, tenantProfileFilter.loginHint)) {
            return false;
          }
          if (!!tenantProfileFilter.username && !this.matchUsername(idTokenClaims.preferred_username, tenantProfileFilter.username)) {
            return false;
          }
          if (!!tenantProfileFilter.name && !this.matchName(idTokenClaims, tenantProfileFilter.name)) {
            return false;
          }
          if (!!tenantProfileFilter.sid && !this.matchSid(idTokenClaims, tenantProfileFilter.sid)) {
            return false;
          }
        }
        return true;
      }
      /**
       * saves a cache record
       * @param cacheRecord {CacheRecord}
       * @param correlationId {?string} correlation id
       * @param kmsi - Keep Me Signed In
       * @param storeInCache {?StoreInCache}
       */
      async saveCacheRecord(cacheRecord, correlationId, kmsi, storeInCache) {
        if (!cacheRecord) {
          throw createClientAuthError(invalidCacheRecord);
        }
        try {
          if (!!cacheRecord.account) {
            await this.setAccount(cacheRecord.account, correlationId, kmsi);
          }
          if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {
            await this.setIdTokenCredential(cacheRecord.idToken, correlationId, kmsi);
          }
          if (!!cacheRecord.accessToken && storeInCache?.accessToken !== false) {
            await this.saveAccessToken(cacheRecord.accessToken, correlationId, kmsi);
          }
          if (!!cacheRecord.refreshToken && storeInCache?.refreshToken !== false) {
            await this.setRefreshTokenCredential(cacheRecord.refreshToken, correlationId, kmsi);
          }
          if (!!cacheRecord.appMetadata) {
            this.setAppMetadata(cacheRecord.appMetadata, correlationId);
          }
        } catch (e) {
          this.commonLogger?.error(`CacheManager.saveCacheRecord: failed`);
          if (e instanceof AuthError) {
            throw e;
          } else {
            throw createCacheError(e);
          }
        }
      }
      /**
       * saves access token credential
       * @param credential
       */
      async saveAccessToken(credential, correlationId, kmsi) {
        const accessTokenFilter = {
          clientId: credential.clientId,
          credentialType: credential.credentialType,
          environment: credential.environment,
          homeAccountId: credential.homeAccountId,
          realm: credential.realm,
          tokenType: credential.tokenType,
          requestedClaimsHash: credential.requestedClaimsHash
        };
        const tokenKeys = this.getTokenKeys();
        const currentScopes = ScopeSet.fromString(credential.target);
        tokenKeys.accessToken.forEach((key2) => {
          if (!this.accessTokenKeyMatchesFilter(key2, accessTokenFilter, false)) {
            return;
          }
          const tokenEntity = this.getAccessTokenCredential(key2, correlationId);
          if (tokenEntity && this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {
            const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
            if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
              this.removeAccessToken(key2, correlationId);
            }
          }
        });
        await this.setAccessTokenCredential(credential, correlationId, kmsi);
      }
      /**
       * Retrieve account entities matching all provided tenant-agnostic filters; if no filter is set, get all account entities in the cache
       * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared
       * @param accountFilter - An object containing Account properties to filter by
       */
      getAccountsFilteredBy(accountFilter, correlationId) {
        const allAccountKeys = this.getAccountKeys();
        const matchingAccounts = [];
        allAccountKeys.forEach((cacheKey) => {
          const entity = this.getAccount(cacheKey, correlationId);
          if (!entity) {
            return;
          }
          if (!!accountFilter.homeAccountId && !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {
            return;
          }
          if (!!accountFilter.username && !this.matchUsername(entity.username, accountFilter.username)) {
            return;
          }
          if (!!accountFilter.environment && !this.matchEnvironment(entity, accountFilter.environment)) {
            return;
          }
          if (!!accountFilter.realm && !this.matchRealm(entity, accountFilter.realm)) {
            return;
          }
          if (!!accountFilter.nativeAccountId && !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {
            return;
          }
          if (!!accountFilter.authorityType && !this.matchAuthorityType(entity, accountFilter.authorityType)) {
            return;
          }
          const tenantProfileFilter = {
            localAccountId: accountFilter?.localAccountId,
            name: accountFilter?.name
          };
          const matchingTenantProfiles = entity.tenantProfiles?.filter((tenantProfile) => {
            return this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter);
          });
          if (matchingTenantProfiles && matchingTenantProfiles.length === 0) {
            return;
          }
          matchingAccounts.push(entity);
        });
        return matchingAccounts;
      }
      /**
       * Returns whether or not the given credential entity matches the filter
       * @param entity
       * @param filter
       * @returns
       */
      credentialMatchesFilter(entity, filter2) {
        if (!!filter2.clientId && !this.matchClientId(entity, filter2.clientId)) {
          return false;
        }
        if (!!filter2.userAssertionHash && !this.matchUserAssertionHash(entity, filter2.userAssertionHash)) {
          return false;
        }
        if (typeof filter2.homeAccountId === "string" && !this.matchHomeAccountId(entity, filter2.homeAccountId)) {
          return false;
        }
        if (!!filter2.environment && !this.matchEnvironment(entity, filter2.environment)) {
          return false;
        }
        if (!!filter2.realm && !this.matchRealm(entity, filter2.realm)) {
          return false;
        }
        if (!!filter2.credentialType && !this.matchCredentialType(entity, filter2.credentialType)) {
          return false;
        }
        if (!!filter2.familyId && !this.matchFamilyId(entity, filter2.familyId)) {
          return false;
        }
        if (!!filter2.target && !this.matchTarget(entity, filter2.target)) {
          return false;
        }
        if (filter2.requestedClaimsHash || entity.requestedClaimsHash) {
          if (entity.requestedClaimsHash !== filter2.requestedClaimsHash) {
            return false;
          }
        }
        if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
          if (!!filter2.tokenType && !this.matchTokenType(entity, filter2.tokenType)) {
            return false;
          }
          if (filter2.tokenType === AuthenticationScheme.SSH) {
            if (filter2.keyId && !this.matchKeyId(entity, filter2.keyId)) {
              return false;
            }
          }
        }
        return true;
      }
      /**
       * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata
       * @param filter
       */
      getAppMetadataFilteredBy(filter2) {
        const allCacheKeys = this.getKeys();
        const matchingAppMetadata = {};
        allCacheKeys.forEach((cacheKey) => {
          if (!this.isAppMetadata(cacheKey)) {
            return;
          }
          const entity = this.getAppMetadata(cacheKey);
          if (!entity) {
            return;
          }
          if (!!filter2.environment && !this.matchEnvironment(entity, filter2.environment)) {
            return;
          }
          if (!!filter2.clientId && !this.matchClientId(entity, filter2.clientId)) {
            return;
          }
          matchingAppMetadata[cacheKey] = entity;
        });
        return matchingAppMetadata;
      }
      /**
       * retrieve authorityMetadata that contains a matching alias
       * @param filter
       */
      getAuthorityMetadataByAlias(host) {
        const allCacheKeys = this.getAuthorityMetadataKeys();
        let matchedEntity = null;
        allCacheKeys.forEach((cacheKey) => {
          if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {
            return;
          }
          const entity = this.getAuthorityMetadata(cacheKey);
          if (!entity) {
            return;
          }
          if (entity.aliases.indexOf(host) === -1) {
            return;
          }
          matchedEntity = entity;
        });
        return matchedEntity;
      }
      /**
       * Removes all accounts and related tokens from cache.
       */
      removeAllAccounts(correlationId) {
        const accounts = this.getAllAccounts({}, correlationId);
        accounts.forEach((account) => {
          this.removeAccount(account, correlationId);
        });
      }
      /**
       * Removes the account and related tokens for a given account key
       * @param account
       */
      removeAccount(account, correlationId) {
        this.removeAccountContext(account, correlationId);
        const accountKeys = this.getAccountKeys();
        const keyFilter = (key2) => {
          return key2.includes(account.homeAccountId) && key2.includes(account.environment);
        };
        accountKeys.filter(keyFilter).forEach((key2) => {
          this.removeItem(key2, correlationId);
          this.performanceClient.incrementFields({ accountsRemoved: 1 }, correlationId);
        });
      }
      /**
       * Removes credentials associated with the provided account
       * @param account
       */
      removeAccountContext(account, correlationId) {
        const allTokenKeys = this.getTokenKeys();
        const keyFilter = (key2) => {
          return key2.includes(account.homeAccountId) && key2.includes(account.environment);
        };
        allTokenKeys.idToken.filter(keyFilter).forEach((key2) => {
          this.removeIdToken(key2, correlationId);
        });
        allTokenKeys.accessToken.filter(keyFilter).forEach((key2) => {
          this.removeAccessToken(key2, correlationId);
        });
        allTokenKeys.refreshToken.filter(keyFilter).forEach((key2) => {
          this.removeRefreshToken(key2, correlationId);
        });
      }
      /**
       * Removes accessToken from the cache
       * @param key
       * @param correlationId
       */
      removeAccessToken(key2, correlationId) {
        const credential = this.getAccessTokenCredential(key2, correlationId);
        this.removeItem(key2, correlationId);
        this.performanceClient.incrementFields({ accessTokensRemoved: 1 }, correlationId);
        if (!credential || credential.credentialType.toLowerCase() !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase() || credential.tokenType !== AuthenticationScheme.POP) {
          return;
        }
        const kid = credential.keyId;
        if (kid) {
          void this.cryptoImpl.removeTokenBindingKey(kid).catch(() => {
            this.commonLogger.error(`Failed to remove token binding key ${kid}`, correlationId);
            this.performanceClient?.incrementFields({ removeTokenBindingKeyFailure: 1 }, correlationId);
          });
        }
      }
      /**
       * Removes all app metadata objects from cache.
       */
      removeAppMetadata(correlationId) {
        const allCacheKeys = this.getKeys();
        allCacheKeys.forEach((cacheKey) => {
          if (this.isAppMetadata(cacheKey)) {
            this.removeItem(cacheKey, correlationId);
          }
        });
        return true;
      }
      /**
       * Retrieve IdTokenEntity from cache
       * @param account {AccountInfo}
       * @param tokenKeys {?TokenKeys}
       * @param targetRealm {?string}
       * @param performanceClient {?IPerformanceClient}
       * @param correlationId {?string}
       */
      getIdToken(account, correlationId, tokenKeys, targetRealm, performanceClient) {
        this.commonLogger.trace("CacheManager - getIdToken called");
        const idTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType: CredentialType.ID_TOKEN,
          clientId: this.clientId,
          realm: targetRealm
        };
        const idTokenMap = this.getIdTokensByFilter(idTokenFilter, correlationId, tokenKeys);
        const numIdTokens = idTokenMap.size;
        if (numIdTokens < 1) {
          this.commonLogger.info("CacheManager:getIdToken - No token found");
          return null;
        } else if (numIdTokens > 1) {
          let tokensToBeRemoved = idTokenMap;
          if (!targetRealm) {
            const homeIdTokenMap = /* @__PURE__ */ new Map();
            idTokenMap.forEach((idToken, key2) => {
              if (idToken.realm === account.tenantId) {
                homeIdTokenMap.set(key2, idToken);
              }
            });
            const numHomeIdTokens = homeIdTokenMap.size;
            if (numHomeIdTokens < 1) {
              this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account but none match account entity tenant id, returning first result");
              return idTokenMap.values().next().value;
            } else if (numHomeIdTokens === 1) {
              this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account, defaulting to home tenant profile");
              return homeIdTokenMap.values().next().value;
            } else {
              tokensToBeRemoved = homeIdTokenMap;
            }
          }
          this.commonLogger.info("CacheManager:getIdToken - Multiple matching ID tokens found, clearing them");
          tokensToBeRemoved.forEach((idToken, key2) => {
            this.removeIdToken(key2, correlationId);
          });
          if (performanceClient && correlationId) {
            performanceClient.addFields({ multiMatchedID: idTokenMap.size }, correlationId);
          }
          return null;
        }
        this.commonLogger.info("CacheManager:getIdToken - Returning ID token");
        return idTokenMap.values().next().value;
      }
      /**
       * Gets all idTokens matching the given filter
       * @param filter
       * @returns
       */
      getIdTokensByFilter(filter2, correlationId, tokenKeys) {
        const idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;
        const idTokens = /* @__PURE__ */ new Map();
        idTokenKeys.forEach((key2) => {
          if (!this.idTokenKeyMatchesFilter(key2, {
            clientId: this.clientId,
            ...filter2
          })) {
            return;
          }
          const idToken = this.getIdTokenCredential(key2, correlationId);
          if (idToken && this.credentialMatchesFilter(idToken, filter2)) {
            idTokens.set(key2, idToken);
          }
        });
        return idTokens;
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       * @returns
       */
      idTokenKeyMatchesFilter(inputKey, filter2) {
        const key2 = inputKey.toLowerCase();
        if (filter2.clientId && key2.indexOf(filter2.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter2.homeAccountId && key2.indexOf(filter2.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        return true;
      }
      /**
       * Removes idToken from the cache
       * @param key
       */
      removeIdToken(key2, correlationId) {
        this.removeItem(key2, correlationId);
      }
      /**
       * Removes refresh token from the cache
       * @param key
       */
      removeRefreshToken(key2, correlationId) {
        this.removeItem(key2, correlationId);
      }
      /**
       * Retrieve AccessTokenEntity from cache
       * @param account {AccountInfo}
       * @param request {BaseAuthRequest}
       * @param correlationId {?string}
       * @param tokenKeys {?TokenKeys}
       * @param performanceClient {?IPerformanceClient}
       */
      getAccessToken(account, request, tokenKeys, targetRealm) {
        const correlationId = request.correlationId;
        this.commonLogger.trace("CacheManager - getAccessToken called", correlationId);
        const scopes = ScopeSet.createSearchScopes(request.scopes);
        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;
        const credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
        const accessTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType,
          clientId: this.clientId,
          realm: targetRealm || account.tenantId,
          target: scopes,
          tokenType: authScheme,
          keyId: request.sshKid,
          requestedClaimsHash: request.requestedClaimsHash
        };
        const accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;
        const accessTokens = [];
        accessTokenKeys.forEach((key2) => {
          if (this.accessTokenKeyMatchesFilter(key2, accessTokenFilter, true)) {
            const accessToken = this.getAccessTokenCredential(key2, correlationId);
            if (accessToken && this.credentialMatchesFilter(accessToken, accessTokenFilter)) {
              accessTokens.push(accessToken);
            }
          }
        });
        const numAccessTokens = accessTokens.length;
        if (numAccessTokens < 1) {
          this.commonLogger.info("CacheManager:getAccessToken - No token found", correlationId);
          return null;
        } else if (numAccessTokens > 1) {
          this.commonLogger.info("CacheManager:getAccessToken - Multiple access tokens found, clearing them", correlationId);
          accessTokens.forEach((accessToken) => {
            this.removeAccessToken(this.generateCredentialKey(accessToken), correlationId);
          });
          this.performanceClient.addFields({ multiMatchedAT: accessTokens.length }, correlationId);
          return null;
        }
        this.commonLogger.info("CacheManager:getAccessToken - Returning access token", correlationId);
        return accessTokens[0];
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       * @param keyMustContainAllScopes
       * @returns
       */
      accessTokenKeyMatchesFilter(inputKey, filter2, keyMustContainAllScopes) {
        const key2 = inputKey.toLowerCase();
        if (filter2.clientId && key2.indexOf(filter2.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter2.homeAccountId && key2.indexOf(filter2.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        if (filter2.realm && key2.indexOf(filter2.realm.toLowerCase()) === -1) {
          return false;
        }
        if (filter2.requestedClaimsHash && key2.indexOf(filter2.requestedClaimsHash.toLowerCase()) === -1) {
          return false;
        }
        if (filter2.target) {
          const scopes = filter2.target.asArray();
          for (let i = 0; i < scopes.length; i++) {
            if (keyMustContainAllScopes && !key2.includes(scopes[i].toLowerCase())) {
              return false;
            } else if (!keyMustContainAllScopes && key2.includes(scopes[i].toLowerCase())) {
              return true;
            }
          }
        }
        return true;
      }
      /**
       * Gets all access tokens matching the filter
       * @param filter
       * @returns
       */
      getAccessTokensByFilter(filter2, correlationId) {
        const tokenKeys = this.getTokenKeys();
        const accessTokens = [];
        tokenKeys.accessToken.forEach((key2) => {
          if (!this.accessTokenKeyMatchesFilter(key2, filter2, true)) {
            return;
          }
          const accessToken = this.getAccessTokenCredential(key2, correlationId);
          if (accessToken && this.credentialMatchesFilter(accessToken, filter2)) {
            accessTokens.push(accessToken);
          }
        });
        return accessTokens;
      }
      /**
       * Helper to retrieve the appropriate refresh token from cache
       * @param account {AccountInfo}
       * @param familyRT {boolean}
       * @param correlationId {?string}
       * @param tokenKeys {?TokenKeys}
       * @param performanceClient {?IPerformanceClient}
       */
      getRefreshToken(account, familyRT, correlationId, tokenKeys, performanceClient) {
        this.commonLogger.trace("CacheManager - getRefreshToken called");
        const id = familyRT ? THE_FAMILY_ID : void 0;
        const refreshTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType: CredentialType.REFRESH_TOKEN,
          clientId: this.clientId,
          familyId: id
        };
        const refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;
        const refreshTokens = [];
        refreshTokenKeys.forEach((key2) => {
          if (this.refreshTokenKeyMatchesFilter(key2, refreshTokenFilter)) {
            const refreshToken = this.getRefreshTokenCredential(key2, correlationId);
            if (refreshToken && this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {
              refreshTokens.push(refreshToken);
            }
          }
        });
        const numRefreshTokens = refreshTokens.length;
        if (numRefreshTokens < 1) {
          this.commonLogger.info("CacheManager:getRefreshToken - No refresh token found.");
          return null;
        }
        if (numRefreshTokens > 1 && performanceClient && correlationId) {
          performanceClient.addFields({ multiMatchedRT: numRefreshTokens }, correlationId);
        }
        this.commonLogger.info("CacheManager:getRefreshToken - returning refresh token");
        return refreshTokens[0];
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       */
      refreshTokenKeyMatchesFilter(inputKey, filter2) {
        const key2 = inputKey.toLowerCase();
        if (filter2.familyId && key2.indexOf(filter2.familyId.toLowerCase()) === -1) {
          return false;
        }
        if (!filter2.familyId && filter2.clientId && key2.indexOf(filter2.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter2.homeAccountId && key2.indexOf(filter2.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        return true;
      }
      /**
       * Retrieve AppMetadataEntity from cache
       */
      readAppMetadataFromCache(environment) {
        const appMetadataFilter = {
          environment,
          clientId: this.clientId
        };
        const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
        const appMetadataEntries = Object.keys(appMetadata).map((key2) => appMetadata[key2]);
        const numAppMetadata = appMetadataEntries.length;
        if (numAppMetadata < 1) {
          return null;
        } else if (numAppMetadata > 1) {
          throw createClientAuthError(multipleMatchingAppMetadata);
        }
        return appMetadataEntries[0];
      }
      /**
       * Return the family_id value associated  with FOCI
       * @param environment
       * @param clientId
       */
      isAppMetadataFOCI(environment) {
        const appMetadata = this.readAppMetadataFromCache(environment);
        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);
      }
      /**
       * helper to match account ids
       * @param value
       * @param homeAccountId
       */
      matchHomeAccountId(entity, homeAccountId) {
        return !!(typeof entity.homeAccountId === "string" && homeAccountId === entity.homeAccountId);
      }
      /**
       * helper to match account ids
       * @param entity
       * @param localAccountId
       * @returns
       */
      matchLocalAccountIdFromTokenClaims(tokenClaims, localAccountId) {
        const idTokenLocalAccountId = tokenClaims.oid || tokenClaims.sub;
        return localAccountId === idTokenLocalAccountId;
      }
      matchLocalAccountIdFromTenantProfile(tenantProfile, localAccountId) {
        return tenantProfile.localAccountId === localAccountId;
      }
      /**
       * helper to match names
       * @param entity
       * @param name
       * @returns true if the downcased name properties are present and match in the filter and the entity
       */
      matchName(claims, name3) {
        return !!(name3.toLowerCase() === claims.name?.toLowerCase());
      }
      /**
       * helper to match usernames
       * @param entity
       * @param username
       * @returns
       */
      matchUsername(cachedUsername, filterUsername) {
        return !!(cachedUsername && typeof cachedUsername === "string" && filterUsername?.toLowerCase() === cachedUsername.toLowerCase());
      }
      /**
       * helper to match assertion
       * @param value
       * @param oboAssertion
       */
      matchUserAssertionHash(entity, userAssertionHash) {
        return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);
      }
      /**
       * helper to match environment
       * @param value
       * @param environment
       */
      matchEnvironment(entity, environment) {
        if (this.staticAuthorityOptions) {
          const staticAliases = getAliasesFromStaticSources(this.staticAuthorityOptions, this.commonLogger);
          if (staticAliases.includes(environment) && staticAliases.includes(entity.environment)) {
            return true;
          }
        }
        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);
        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {
          return true;
        }
        return false;
      }
      /**
       * helper to match credential type
       * @param entity
       * @param credentialType
       */
      matchCredentialType(entity, credentialType) {
        return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();
      }
      /**
       * helper to match client ids
       * @param entity
       * @param clientId
       */
      matchClientId(entity, clientId) {
        return !!(entity.clientId && clientId === entity.clientId);
      }
      /**
       * helper to match family ids
       * @param entity
       * @param familyId
       */
      matchFamilyId(entity, familyId) {
        return !!(entity.familyId && familyId === entity.familyId);
      }
      /**
       * helper to match realm
       * @param entity
       * @param realm
       */
      matchRealm(entity, realm) {
        return !!(entity.realm?.toLowerCase() === realm.toLowerCase());
      }
      /**
       * helper to match nativeAccountId
       * @param entity
       * @param nativeAccountId
       * @returns boolean indicating the match result
       */
      matchNativeAccountId(entity, nativeAccountId) {
        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);
      }
      /**
       * helper to match loginHint which can be either:
       * 1. login_hint ID token claim
       * 2. username in cached account object
       * 3. upn in ID token claims
       * @param entity
       * @param loginHint
       * @returns
       */
      matchLoginHintFromTokenClaims(tokenClaims, loginHint) {
        if (tokenClaims.login_hint === loginHint) {
          return true;
        }
        if (tokenClaims.preferred_username === loginHint) {
          return true;
        }
        if (tokenClaims.upn === loginHint) {
          return true;
        }
        return false;
      }
      /**
       * Helper to match sid
       * @param entity
       * @param sid
       * @returns true if the sid claim is present and matches the filter
       */
      matchSid(idTokenClaims, sid) {
        return idTokenClaims.sid === sid;
      }
      matchAuthorityType(entity, authorityType) {
        return !!(entity.authorityType && authorityType.toLowerCase() === entity.authorityType.toLowerCase());
      }
      /**
       * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.
       * @param entity
       * @param target
       */
      matchTarget(entity, target) {
        const isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
        if (isNotAccessTokenCredential || !entity.target) {
          return false;
        }
        const entityScopeSet = ScopeSet.fromString(entity.target);
        return entityScopeSet.containsScopeSet(target);
      }
      /**
       * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise
       * @param entity
       * @param tokenType
       */
      matchTokenType(entity, tokenType) {
        return !!(entity.tokenType && entity.tokenType === tokenType);
      }
      /**
       * Returns true if the credential's keyId matches the one in the request, false otherwise
       * @param entity
       * @param keyId
       */
      matchKeyId(entity, keyId) {
        return !!(entity.keyId && entity.keyId === keyId);
      }
      /**
       * returns if a given cache entity is of the type appmetadata
       * @param key
       */
      isAppMetadata(key2) {
        return key2.indexOf(APP_METADATA) !== -1;
      }
      /**
       * returns if a given cache entity is of the type authoritymetadata
       * @param key
       */
      isAuthorityMetadata(key2) {
        return key2.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;
      }
      /**
       * returns cache key used for cloud instance metadata
       */
      generateAuthorityMetadataCacheKey(authority) {
        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;
      }
      /**
       * Helper to convert serialized data to object
       * @param obj
       * @param json
       */
      static toObject(obj, json2) {
        for (const propertyName in json2) {
          obj[propertyName] = json2[propertyName];
        }
        return obj;
      }
    };
    DefaultStorageClass = class extends CacheManager {
      async setAccount() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccount() {
        throw createClientAuthError(methodNotImplemented);
      }
      async setIdTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getIdTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      async setAccessTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccessTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      async setRefreshTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getRefreshTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      setAppMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAppMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      setServerTelemetry() {
        throw createClientAuthError(methodNotImplemented);
      }
      getServerTelemetry() {
        throw createClientAuthError(methodNotImplemented);
      }
      setAuthorityMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAuthorityMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAuthorityMetadataKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      setThrottlingCache() {
        throw createClientAuthError(methodNotImplemented);
      }
      getThrottlingCache() {
        throw createClientAuthError(methodNotImplemented);
      }
      removeItem() {
        throw createClientAuthError(methodNotImplemented);
      }
      getKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccountKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      getTokenKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      generateCredentialKey() {
        throw createClientAuthError(methodNotImplemented);
      }
      generateAccountKey() {
        throw createClientAuthError(methodNotImplemented);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs
var PerformanceEvents, PerformanceEventAbbreviations, PerformanceEventStatus;
var init_PerformanceEvent = __esm({
  "node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs"() {
    "use strict";
    PerformanceEvents = {
      /**
       * acquireTokenByCode API (msal-browser and msal-node).
       * Used to acquire tokens by trading an authorization code against the token endpoint.
       */
      AcquireTokenByCode: "acquireTokenByCode",
      /**
       * acquireTokenByRefreshToken API (msal-browser and msal-node).
       * Used to renew an access token using a refresh token against the token endpoint.
       */
      AcquireTokenByRefreshToken: "acquireTokenByRefreshToken",
      /**
       * acquireTokenSilent API (msal-browser and msal-node).
       * Used to silently acquire a new access token (from the cache or the network).
       */
      AcquireTokenSilent: "acquireTokenSilent",
      /**
       * acquireTokenSilentAsync (msal-browser).
       * Internal API for acquireTokenSilent.
       */
      AcquireTokenSilentAsync: "acquireTokenSilentAsync",
      /**
       * acquireTokenPopup (msal-browser).
       * Used to acquire a new access token interactively through pop ups
       */
      AcquireTokenPopup: "acquireTokenPopup",
      /**
       * acquireTokenPreRedirect (msal-browser).
       * First part of the redirect flow.
       * Used to acquire a new access token interactively through redirects.
       */
      AcquireTokenPreRedirect: "acquireTokenPreRedirect",
      /**
       * acquireTokenRedirect (msal-browser).
       * Second part of the redirect flow.
       * Used to acquire a new access token interactively through redirects.
       */
      AcquireTokenRedirect: "acquireTokenRedirect",
      /**
       * getPublicKeyThumbprint API in CryptoOpts class (msal-browser).
       * Used to generate a public/private keypair and generate a public key thumbprint for pop requests.
       */
      CryptoOptsGetPublicKeyThumbprint: "cryptoOptsGetPublicKeyThumbprint",
      /**
       * signJwt API in CryptoOpts class (msal-browser).
       * Used to signed a pop token.
       */
      CryptoOptsSignJwt: "cryptoOptsSignJwt",
      /**
       * acquireToken API in the SilentCacheClient class (msal-browser).
       * Used to read access tokens from the cache.
       */
      SilentCacheClientAcquireToken: "silentCacheClientAcquireToken",
      /**
       * acquireToken API in the SilentIframeClient class (msal-browser).
       * Used to acquire a new set of tokens from the authorize endpoint in a hidden iframe.
       */
      SilentIframeClientAcquireToken: "silentIframeClientAcquireToken",
      AwaitConcurrentIframe: "awaitConcurrentIframe",
      /**
       * acquireToken API in SilentRereshClient (msal-browser).
       * Used to acquire a new set of tokens from the token endpoint using a refresh token.
       */
      SilentRefreshClientAcquireToken: "silentRefreshClientAcquireToken",
      /**
       * ssoSilent API (msal-browser).
       * Used to silently acquire an authorization code and set of tokens using a hidden iframe.
       */
      SsoSilent: "ssoSilent",
      /**
       * getDiscoveredAuthority API in StandardInteractionClient class (msal-browser).
       * Used to load authority metadata for a request.
       */
      StandardInteractionClientGetDiscoveredAuthority: "standardInteractionClientGetDiscoveredAuthority",
      /**
       * acquireToken APIs in msal-browser.
       * Used to make an /authorize endpoint call with native brokering enabled.
       */
      FetchAccountIdWithNativeBroker: "fetchAccountIdWithNativeBroker",
      /**
       * acquireToken API in NativeInteractionClient class (msal-browser).
       * Used to acquire a token from Native component when native brokering is enabled.
       */
      NativeInteractionClientAcquireToken: "nativeInteractionClientAcquireToken",
      /**
       * Time spent creating default headers for requests to token endpoint
       */
      BaseClientCreateTokenRequestHeaders: "baseClientCreateTokenRequestHeaders",
      /**
       * Time spent sending/waiting for the response of a request to the token endpoint
       */
      NetworkClientSendPostRequestAsync: "networkClientSendPostRequestAsync",
      RefreshTokenClientExecutePostToTokenEndpoint: "refreshTokenClientExecutePostToTokenEndpoint",
      AuthorizationCodeClientExecutePostToTokenEndpoint: "authorizationCodeClientExecutePostToTokenEndpoint",
      /**
       * Used to measure the time taken for completing embedded-broker handshake (PW-Broker).
       */
      BrokerHandhshake: "brokerHandshake",
      /**
       * acquireTokenByRefreshToken API in BrokerClientApplication (PW-Broker) .
       */
      AcquireTokenByRefreshTokenInBroker: "acquireTokenByRefreshTokenInBroker",
      /**
       * Time taken for token acquisition by broker
       */
      AcquireTokenByBroker: "acquireTokenByBroker",
      /**
       * Time spent on the network for refresh token acquisition
       */
      RefreshTokenClientExecuteTokenRequest: "refreshTokenClientExecuteTokenRequest",
      /**
       * Time taken for acquiring refresh token , records RT size
       */
      RefreshTokenClientAcquireToken: "refreshTokenClientAcquireToken",
      /**
       * Time taken for acquiring cached refresh token
       */
      RefreshTokenClientAcquireTokenWithCachedRefreshToken: "refreshTokenClientAcquireTokenWithCachedRefreshToken",
      /**
       * acquireTokenByRefreshToken API in RefreshTokenClient (msal-common).
       */
      RefreshTokenClientAcquireTokenByRefreshToken: "refreshTokenClientAcquireTokenByRefreshToken",
      /**
       * Helper function to create token request body in RefreshTokenClient (msal-common).
       */
      RefreshTokenClientCreateTokenRequestBody: "refreshTokenClientCreateTokenRequestBody",
      /**
       * acquireTokenFromCache (msal-browser).
       * Internal API for acquiring token from cache
       */
      AcquireTokenFromCache: "acquireTokenFromCache",
      SilentFlowClientAcquireCachedToken: "silentFlowClientAcquireCachedToken",
      SilentFlowClientGenerateResultFromCacheRecord: "silentFlowClientGenerateResultFromCacheRecord",
      /**
       * acquireTokenBySilentIframe (msal-browser).
       * Internal API for acquiring token by silent Iframe
       */
      AcquireTokenBySilentIframe: "acquireTokenBySilentIframe",
      /**
       * Internal API for initializing base request in BaseInteractionClient (msal-browser)
       */
      InitializeBaseRequest: "initializeBaseRequest",
      /**
       * Internal API for initializing silent request in SilentCacheClient (msal-browser)
       */
      InitializeSilentRequest: "initializeSilentRequest",
      InitializeClientApplication: "initializeClientApplication",
      InitializeCache: "initializeCache",
      /**
       * Helper function in SilentIframeClient class (msal-browser).
       */
      SilentIframeClientTokenHelper: "silentIframeClientTokenHelper",
      /**
       * SilentHandler
       */
      SilentHandlerInitiateAuthRequest: "silentHandlerInitiateAuthRequest",
      SilentHandlerMonitorIframeForHash: "silentHandlerMonitorIframeForHash",
      SilentHandlerLoadFrame: "silentHandlerLoadFrame",
      SilentHandlerLoadFrameSync: "silentHandlerLoadFrameSync",
      /**
       * Helper functions in StandardInteractionClient class (msal-browser)
       */
      StandardInteractionClientCreateAuthCodeClient: "standardInteractionClientCreateAuthCodeClient",
      StandardInteractionClientGetClientConfiguration: "standardInteractionClientGetClientConfiguration",
      StandardInteractionClientInitializeAuthorizationRequest: "standardInteractionClientInitializeAuthorizationRequest",
      /**
       * getAuthCodeUrl API (msal-browser and msal-node).
       */
      GetAuthCodeUrl: "getAuthCodeUrl",
      GetStandardParams: "getStandardParams",
      /**
       * Functions from InteractionHandler (msal-browser)
       */
      HandleCodeResponseFromServer: "handleCodeResponseFromServer",
      HandleCodeResponse: "handleCodeResponse",
      HandleResponseEar: "handleResponseEar",
      HandleResponsePlatformBroker: "handleResponsePlatformBroker",
      HandleResponseCode: "handleResponseCode",
      UpdateTokenEndpointAuthority: "updateTokenEndpointAuthority",
      /**
       * APIs in Authorization Code Client (msal-common)
       */
      AuthClientAcquireToken: "authClientAcquireToken",
      AuthClientExecuteTokenRequest: "authClientExecuteTokenRequest",
      AuthClientCreateTokenRequestBody: "authClientCreateTokenRequestBody",
      /**
       * Generate functions in PopTokenGenerator (msal-common)
       */
      PopTokenGenerateCnf: "popTokenGenerateCnf",
      PopTokenGenerateKid: "popTokenGenerateKid",
      /**
       * handleServerTokenResponse API in ResponseHandler (msal-common)
       */
      HandleServerTokenResponse: "handleServerTokenResponse",
      DeserializeResponse: "deserializeResponse",
      /**
       * Authority functions
       */
      AuthorityFactoryCreateDiscoveredInstance: "authorityFactoryCreateDiscoveredInstance",
      AuthorityResolveEndpointsAsync: "authorityResolveEndpointsAsync",
      AuthorityResolveEndpointsFromLocalSources: "authorityResolveEndpointsFromLocalSources",
      AuthorityGetCloudDiscoveryMetadataFromNetwork: "authorityGetCloudDiscoveryMetadataFromNetwork",
      AuthorityUpdateCloudDiscoveryMetadata: "authorityUpdateCloudDiscoveryMetadata",
      AuthorityGetEndpointMetadataFromNetwork: "authorityGetEndpointMetadataFromNetwork",
      AuthorityUpdateEndpointMetadata: "authorityUpdateEndpointMetadata",
      AuthorityUpdateMetadataWithRegionalInformation: "authorityUpdateMetadataWithRegionalInformation",
      /**
       * Region Discovery functions
       */
      RegionDiscoveryDetectRegion: "regionDiscoveryDetectRegion",
      RegionDiscoveryGetRegionFromIMDS: "regionDiscoveryGetRegionFromIMDS",
      RegionDiscoveryGetCurrentVersion: "regionDiscoveryGetCurrentVersion",
      AcquireTokenByCodeAsync: "acquireTokenByCodeAsync",
      GetEndpointMetadataFromNetwork: "getEndpointMetadataFromNetwork",
      GetCloudDiscoveryMetadataFromNetworkMeasurement: "getCloudDiscoveryMetadataFromNetworkMeasurement",
      HandleRedirectPromiseMeasurement: "handleRedirectPromise",
      HandleNativeRedirectPromiseMeasurement: "handleNativeRedirectPromise",
      UpdateCloudDiscoveryMetadataMeasurement: "updateCloudDiscoveryMetadataMeasurement",
      UsernamePasswordClientAcquireToken: "usernamePasswordClientAcquireToken",
      NativeMessageHandlerHandshake: "nativeMessageHandlerHandshake",
      NativeGenerateAuthResult: "nativeGenerateAuthResult",
      RemoveHiddenIframe: "removeHiddenIframe",
      /**
       * Cache operations
       */
      ClearTokensAndKeysWithClaims: "clearTokensAndKeysWithClaims",
      CacheManagerGetRefreshToken: "cacheManagerGetRefreshToken",
      ImportExistingCache: "importExistingCache",
      SetUserData: "setUserData",
      LocalStorageUpdated: "localStorageUpdated",
      /**
       * Crypto Operations
       */
      GeneratePkceCodes: "generatePkceCodes",
      GenerateCodeVerifier: "generateCodeVerifier",
      GenerateCodeChallengeFromVerifier: "generateCodeChallengeFromVerifier",
      Sha256Digest: "sha256Digest",
      GetRandomValues: "getRandomValues",
      GenerateHKDF: "generateHKDF",
      GenerateBaseKey: "generateBaseKey",
      Base64Decode: "base64Decode",
      UrlEncodeArr: "urlEncodeArr",
      Encrypt: "encrypt",
      Decrypt: "decrypt",
      GenerateEarKey: "generateEarKey",
      DecryptEarResponse: "decryptEarResponse"
    };
    PerformanceEventAbbreviations = /* @__PURE__ */ new Map([
      [PerformanceEvents.AcquireTokenByCode, "ATByCode"],
      [PerformanceEvents.AcquireTokenByRefreshToken, "ATByRT"],
      [PerformanceEvents.AcquireTokenSilent, "ATS"],
      [PerformanceEvents.AcquireTokenSilentAsync, "ATSAsync"],
      [PerformanceEvents.AcquireTokenPopup, "ATPopup"],
      [PerformanceEvents.AcquireTokenRedirect, "ATRedirect"],
      [
        PerformanceEvents.CryptoOptsGetPublicKeyThumbprint,
        "CryptoGetPKThumb"
      ],
      [PerformanceEvents.CryptoOptsSignJwt, "CryptoSignJwt"],
      [PerformanceEvents.SilentCacheClientAcquireToken, "SltCacheClientAT"],
      [PerformanceEvents.SilentIframeClientAcquireToken, "SltIframeClientAT"],
      [PerformanceEvents.SilentRefreshClientAcquireToken, "SltRClientAT"],
      [PerformanceEvents.SsoSilent, "SsoSlt"],
      [
        PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority,
        "StdIntClientGetDiscAuth"
      ],
      [
        PerformanceEvents.FetchAccountIdWithNativeBroker,
        "FetchAccIdWithNtvBroker"
      ],
      [
        PerformanceEvents.NativeInteractionClientAcquireToken,
        "NtvIntClientAT"
      ],
      [
        PerformanceEvents.BaseClientCreateTokenRequestHeaders,
        "BaseClientCreateTReqHead"
      ],
      [
        PerformanceEvents.NetworkClientSendPostRequestAsync,
        "NetClientSendPost"
      ],
      [
        PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint,
        "RTClientExecPost"
      ],
      [
        PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint,
        "AuthCodeClientExecPost"
      ],
      [PerformanceEvents.BrokerHandhshake, "BrokerHandshake"],
      [
        PerformanceEvents.AcquireTokenByRefreshTokenInBroker,
        "ATByRTInBroker"
      ],
      [PerformanceEvents.AcquireTokenByBroker, "ATByBroker"],
      [
        PerformanceEvents.RefreshTokenClientExecuteTokenRequest,
        "RTClientExecTReq"
      ],
      [PerformanceEvents.RefreshTokenClientAcquireToken, "RTClientAT"],
      [
        PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,
        "RTClientATWithCachedRT"
      ],
      [
        PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken,
        "RTClientATByRT"
      ],
      [
        PerformanceEvents.RefreshTokenClientCreateTokenRequestBody,
        "RTClientCreateTReqBody"
      ],
      [PerformanceEvents.AcquireTokenFromCache, "ATFromCache"],
      [
        PerformanceEvents.SilentFlowClientAcquireCachedToken,
        "SltFlowClientATCached"
      ],
      [
        PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord,
        "SltFlowClientGenResFromCache"
      ],
      [PerformanceEvents.AcquireTokenBySilentIframe, "ATBySltIframe"],
      [PerformanceEvents.InitializeBaseRequest, "InitBaseReq"],
      [PerformanceEvents.InitializeSilentRequest, "InitSltReq"],
      [
        PerformanceEvents.InitializeClientApplication,
        "InitClientApplication"
      ],
      [PerformanceEvents.InitializeCache, "InitCache"],
      [PerformanceEvents.ImportExistingCache, "importCache"],
      [PerformanceEvents.SetUserData, "setUserData"],
      [PerformanceEvents.LocalStorageUpdated, "localStorageUpdated"],
      [PerformanceEvents.SilentIframeClientTokenHelper, "SIClientTHelper"],
      [
        PerformanceEvents.SilentHandlerInitiateAuthRequest,
        "SHandlerInitAuthReq"
      ],
      [
        PerformanceEvents.SilentHandlerMonitorIframeForHash,
        "SltHandlerMonitorIframeForHash"
      ],
      [PerformanceEvents.SilentHandlerLoadFrame, "SHandlerLoadFrame"],
      [PerformanceEvents.SilentHandlerLoadFrameSync, "SHandlerLoadFrameSync"],
      [
        PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,
        "StdIntClientCreateAuthCodeClient"
      ],
      [
        PerformanceEvents.StandardInteractionClientGetClientConfiguration,
        "StdIntClientGetClientConf"
      ],
      [
        PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest,
        "StdIntClientInitAuthReq"
      ],
      [PerformanceEvents.GetAuthCodeUrl, "GetAuthCodeUrl"],
      [
        PerformanceEvents.HandleCodeResponseFromServer,
        "HandleCodeResFromServer"
      ],
      [PerformanceEvents.HandleCodeResponse, "HandleCodeResp"],
      [PerformanceEvents.HandleResponseEar, "HandleRespEar"],
      [PerformanceEvents.HandleResponseCode, "HandleRespCode"],
      [
        PerformanceEvents.HandleResponsePlatformBroker,
        "HandleRespPlatBroker"
      ],
      [PerformanceEvents.UpdateTokenEndpointAuthority, "UpdTEndpointAuth"],
      [PerformanceEvents.AuthClientAcquireToken, "AuthClientAT"],
      [PerformanceEvents.AuthClientExecuteTokenRequest, "AuthClientExecTReq"],
      [
        PerformanceEvents.AuthClientCreateTokenRequestBody,
        "AuthClientCreateTReqBody"
      ],
      [PerformanceEvents.PopTokenGenerateCnf, "PopTGenCnf"],
      [PerformanceEvents.PopTokenGenerateKid, "PopTGenKid"],
      [PerformanceEvents.HandleServerTokenResponse, "HandleServerTRes"],
      [PerformanceEvents.DeserializeResponse, "DeserializeRes"],
      [
        PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance,
        "AuthFactCreateDiscInst"
      ],
      [
        PerformanceEvents.AuthorityResolveEndpointsAsync,
        "AuthResolveEndpointsAsync"
      ],
      [
        PerformanceEvents.AuthorityResolveEndpointsFromLocalSources,
        "AuthResolveEndpointsFromLocal"
      ],
      [
        PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork,
        "AuthGetCDMetaFromNet"
      ],
      [
        PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata,
        "AuthUpdCDMeta"
      ],
      [
        PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork,
        "AuthUpdCDMetaFromNet"
      ],
      [
        PerformanceEvents.AuthorityUpdateEndpointMetadata,
        "AuthUpdEndpointMeta"
      ],
      [
        PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation,
        "AuthUpdMetaWithRegInfo"
      ],
      [PerformanceEvents.RegionDiscoveryDetectRegion, "RegDiscDetectReg"],
      [
        PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,
        "RegDiscGetRegFromIMDS"
      ],
      [
        PerformanceEvents.RegionDiscoveryGetCurrentVersion,
        "RegDiscGetCurrentVer"
      ],
      [PerformanceEvents.AcquireTokenByCodeAsync, "ATByCodeAsync"],
      [
        PerformanceEvents.GetEndpointMetadataFromNetwork,
        "GetEndpointMetaFromNet"
      ],
      [
        PerformanceEvents.GetCloudDiscoveryMetadataFromNetworkMeasurement,
        "GetCDMetaFromNet"
      ],
      [
        PerformanceEvents.HandleRedirectPromiseMeasurement,
        "HandleRedirectPromise"
      ],
      [
        PerformanceEvents.HandleNativeRedirectPromiseMeasurement,
        "HandleNtvRedirectPromise"
      ],
      [
        PerformanceEvents.UpdateCloudDiscoveryMetadataMeasurement,
        "UpdateCDMeta"
      ],
      [
        PerformanceEvents.UsernamePasswordClientAcquireToken,
        "UserPassClientAT"
      ],
      [
        PerformanceEvents.NativeMessageHandlerHandshake,
        "NtvMsgHandlerHandshake"
      ],
      [PerformanceEvents.NativeGenerateAuthResult, "NtvGenAuthRes"],
      [PerformanceEvents.RemoveHiddenIframe, "RemoveHiddenIframe"],
      [
        PerformanceEvents.ClearTokensAndKeysWithClaims,
        "ClearTAndKeysWithClaims"
      ],
      [PerformanceEvents.CacheManagerGetRefreshToken, "CacheManagerGetRT"],
      [PerformanceEvents.GeneratePkceCodes, "GenPkceCodes"],
      [PerformanceEvents.GenerateCodeVerifier, "GenCodeVerifier"],
      [
        PerformanceEvents.GenerateCodeChallengeFromVerifier,
        "GenCodeChallengeFromVerifier"
      ],
      [PerformanceEvents.Sha256Digest, "Sha256Digest"],
      [PerformanceEvents.GetRandomValues, "GetRandomValues"],
      [PerformanceEvents.GenerateHKDF, "genHKDF"],
      [PerformanceEvents.GenerateBaseKey, "genBaseKey"],
      [PerformanceEvents.Base64Decode, "b64Decode"],
      [PerformanceEvents.UrlEncodeArr, "urlEncArr"],
      [PerformanceEvents.Encrypt, "encrypt"],
      [PerformanceEvents.Decrypt, "decrypt"],
      [PerformanceEvents.GenerateEarKey, "genEarKey"],
      [PerformanceEvents.DecryptEarResponse, "decryptEarResp"]
    ]);
    PerformanceEventStatus = {
      NotStarted: 0,
      InProgress: 1,
      Completed: 2
    };
  }
});

// node_modules/@azure/msal-common/dist/telemetry/performance/StubPerformanceClient.mjs
var StubPerformanceMeasurement, StubPerformanceClient;
var init_StubPerformanceClient = __esm({
  "node_modules/@azure/msal-common/dist/telemetry/performance/StubPerformanceClient.mjs"() {
    "use strict";
    init_PerformanceEvent();
    StubPerformanceMeasurement = class {
      startMeasurement() {
        return;
      }
      endMeasurement() {
        return;
      }
      flushMeasurement() {
        return null;
      }
    };
    StubPerformanceClient = class {
      generateId() {
        return "callback-id";
      }
      startMeasurement(measureName, correlationId) {
        return {
          end: () => null,
          discard: () => {
          },
          add: () => {
          },
          increment: () => {
          },
          event: {
            eventId: this.generateId(),
            status: PerformanceEventStatus.InProgress,
            authority: "",
            libraryName: "",
            libraryVersion: "",
            clientId: "",
            name: measureName,
            startTimeMs: Date.now(),
            correlationId: correlationId || ""
          },
          measurement: new StubPerformanceMeasurement()
        };
      }
      startPerformanceMeasurement() {
        return new StubPerformanceMeasurement();
      }
      calculateQueuedTime() {
        return 0;
      }
      addQueueMeasurement() {
        return;
      }
      setPreQueueTime() {
        return;
      }
      endMeasurement() {
        return null;
      }
      discardMeasurements() {
        return;
      }
      removePerformanceCallback() {
        return true;
      }
      addPerformanceCallback() {
        return "";
      }
      emitEvents() {
        return;
      }
      addFields() {
        return;
      }
      incrementFields() {
        return;
      }
      cacheEventByCorrelationId() {
        return;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/config/ClientConfiguration.mjs
function buildClientConfiguration({ authOptions: userAuthOptions, systemOptions: userSystemOptions, loggerOptions: userLoggerOption, cacheOptions: userCacheOptions, storageInterface: storageImplementation, networkInterface: networkImplementation, cryptoInterface: cryptoImplementation, clientCredentials, libraryInfo, telemetry, serverTelemetryManager, persistencePlugin, serializableCache }) {
  const loggerOptions = {
    ...DEFAULT_LOGGER_IMPLEMENTATION,
    ...userLoggerOption
  };
  return {
    authOptions: buildAuthOptions(userAuthOptions),
    systemOptions: { ...DEFAULT_SYSTEM_OPTIONS, ...userSystemOptions },
    loggerOptions,
    cacheOptions: { ...DEFAULT_CACHE_OPTIONS, ...userCacheOptions },
    storageInterface: storageImplementation || new DefaultStorageClass(userAuthOptions.clientId, DEFAULT_CRYPTO_IMPLEMENTATION, new Logger(loggerOptions), new StubPerformanceClient()),
    networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
    cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,
    clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,
    libraryInfo: { ...DEFAULT_LIBRARY_INFO, ...libraryInfo },
    telemetry: { ...DEFAULT_TELEMETRY_OPTIONS, ...telemetry },
    serverTelemetryManager: serverTelemetryManager || null,
    persistencePlugin: persistencePlugin || null,
    serializableCache: serializableCache || null
  };
}
function buildAuthOptions(authOptions) {
  return {
    clientCapabilities: [],
    azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS,
    skipAuthorityMetadataCache: false,
    instanceAware: false,
    encodeExtraQueryParams: false,
    ...authOptions
  };
}
function isOidcProtocolMode(config) {
  return config.authOptions.authority.options.protocolMode === ProtocolMode.OIDC;
}
var DEFAULT_SYSTEM_OPTIONS, DEFAULT_LOGGER_IMPLEMENTATION, DEFAULT_CACHE_OPTIONS, DEFAULT_NETWORK_IMPLEMENTATION, DEFAULT_LIBRARY_INFO, DEFAULT_CLIENT_CREDENTIALS, DEFAULT_AZURE_CLOUD_OPTIONS, DEFAULT_TELEMETRY_OPTIONS;
var init_ClientConfiguration = __esm({
  "node_modules/@azure/msal-common/dist/config/ClientConfiguration.mjs"() {
    "use strict";
    init_ICrypto();
    init_Logger();
    init_Constants();
    init_packageMetadata();
    init_AuthorityOptions();
    init_CacheManager();
    init_ProtocolMode();
    init_ClientAuthError();
    init_StubPerformanceClient();
    init_ClientAuthErrorCodes();
    DEFAULT_SYSTEM_OPTIONS = {
      tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
      preventCorsPreflight: false
    };
    DEFAULT_LOGGER_IMPLEMENTATION = {
      loggerCallback: () => {
      },
      piiLoggingEnabled: false,
      logLevel: LogLevel2.Info,
      correlationId: Constants.EMPTY_STRING
    };
    DEFAULT_CACHE_OPTIONS = {
      claimsBasedCachingEnabled: false
    };
    DEFAULT_NETWORK_IMPLEMENTATION = {
      async sendGetRequestAsync() {
        throw createClientAuthError(methodNotImplemented);
      },
      async sendPostRequestAsync() {
        throw createClientAuthError(methodNotImplemented);
      }
    };
    DEFAULT_LIBRARY_INFO = {
      sku: Constants.SKU,
      version,
      cpu: Constants.EMPTY_STRING,
      os: Constants.EMPTY_STRING
    };
    DEFAULT_CLIENT_CREDENTIALS = {
      clientSecret: Constants.EMPTY_STRING,
      clientAssertion: void 0
    };
    DEFAULT_AZURE_CLOUD_OPTIONS = {
      azureCloudInstance: AzureCloudInstance.None,
      tenant: `${Constants.DEFAULT_COMMON_TENANT}`
    };
    DEFAULT_TELEMETRY_OPTIONS = {
      application: {
        appName: "",
        appVersion: ""
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/account/CcsCredential.mjs
var CcsCredentialType;
var init_CcsCredential = __esm({
  "node_modules/@azure/msal-common/dist/account/CcsCredential.mjs"() {
    "use strict";
    CcsCredentialType = {
      HOME_ACCOUNT_ID: "home_account_id",
      UPN: "UPN"
    };
  }
});

// node_modules/@azure/msal-common/dist/constants/AADServerParamKeys.mjs
var AADServerParamKeys_exports = {};
__export(AADServerParamKeys_exports, {
  ACCESS_TOKEN: () => ACCESS_TOKEN,
  BROKER_CLIENT_ID: () => BROKER_CLIENT_ID,
  BROKER_REDIRECT_URI: () => BROKER_REDIRECT_URI,
  CCS_HEADER: () => CCS_HEADER,
  CLAIMS: () => CLAIMS,
  CLIENT_ASSERTION: () => CLIENT_ASSERTION,
  CLIENT_ASSERTION_TYPE: () => CLIENT_ASSERTION_TYPE,
  CLIENT_ID: () => CLIENT_ID,
  CLIENT_INFO: () => CLIENT_INFO2,
  CLIENT_REQUEST_ID: () => CLIENT_REQUEST_ID,
  CLIENT_SECRET: () => CLIENT_SECRET,
  CODE: () => CODE,
  CODE_CHALLENGE: () => CODE_CHALLENGE,
  CODE_CHALLENGE_METHOD: () => CODE_CHALLENGE_METHOD,
  CODE_VERIFIER: () => CODE_VERIFIER,
  DEVICE_CODE: () => DEVICE_CODE,
  DOMAIN_HINT: () => DOMAIN_HINT,
  EAR_JWE_CRYPTO: () => EAR_JWE_CRYPTO,
  EAR_JWK: () => EAR_JWK,
  ERROR: () => ERROR,
  ERROR_DESCRIPTION: () => ERROR_DESCRIPTION,
  EXPIRES_IN: () => EXPIRES_IN,
  FOCI: () => FOCI,
  GRANT_TYPE: () => GRANT_TYPE,
  ID_TOKEN: () => ID_TOKEN,
  ID_TOKEN_HINT: () => ID_TOKEN_HINT,
  INSTANCE_AWARE: () => INSTANCE_AWARE,
  LOGIN_HINT: () => LOGIN_HINT,
  LOGOUT_HINT: () => LOGOUT_HINT,
  NATIVE_BROKER: () => NATIVE_BROKER,
  NONCE: () => NONCE,
  OBO_ASSERTION: () => OBO_ASSERTION,
  ON_BEHALF_OF: () => ON_BEHALF_OF,
  POST_LOGOUT_URI: () => POST_LOGOUT_URI,
  PROMPT: () => PROMPT,
  REDIRECT_URI: () => REDIRECT_URI,
  REFRESH_TOKEN: () => REFRESH_TOKEN,
  REFRESH_TOKEN_EXPIRES_IN: () => REFRESH_TOKEN_EXPIRES_IN,
  REQUESTED_TOKEN_USE: () => REQUESTED_TOKEN_USE,
  REQ_CNF: () => REQ_CNF,
  RESPONSE_MODE: () => RESPONSE_MODE,
  RESPONSE_TYPE: () => RESPONSE_TYPE,
  RETURN_SPA_CODE: () => RETURN_SPA_CODE,
  SCOPE: () => SCOPE,
  SESSION_STATE: () => SESSION_STATE,
  SID: () => SID,
  STATE: () => STATE,
  TOKEN_TYPE: () => TOKEN_TYPE,
  X_APP_NAME: () => X_APP_NAME,
  X_APP_VER: () => X_APP_VER,
  X_CLIENT_CPU: () => X_CLIENT_CPU,
  X_CLIENT_CURR_TELEM: () => X_CLIENT_CURR_TELEM,
  X_CLIENT_EXTRA_SKU: () => X_CLIENT_EXTRA_SKU,
  X_CLIENT_LAST_TELEM: () => X_CLIENT_LAST_TELEM,
  X_CLIENT_OS: () => X_CLIENT_OS,
  X_CLIENT_SKU: () => X_CLIENT_SKU,
  X_CLIENT_VER: () => X_CLIENT_VER,
  X_MS_LIB_CAPABILITY: () => X_MS_LIB_CAPABILITY
});
var CLIENT_ID, REDIRECT_URI, RESPONSE_TYPE, RESPONSE_MODE, GRANT_TYPE, CLAIMS, SCOPE, ERROR, ERROR_DESCRIPTION, ACCESS_TOKEN, ID_TOKEN, REFRESH_TOKEN, EXPIRES_IN, REFRESH_TOKEN_EXPIRES_IN, STATE, NONCE, PROMPT, SESSION_STATE, CLIENT_INFO2, CODE, CODE_CHALLENGE, CODE_CHALLENGE_METHOD, CODE_VERIFIER, CLIENT_REQUEST_ID, X_CLIENT_SKU, X_CLIENT_VER, X_CLIENT_OS, X_CLIENT_CPU, X_CLIENT_CURR_TELEM, X_CLIENT_LAST_TELEM, X_MS_LIB_CAPABILITY, X_APP_NAME, X_APP_VER, POST_LOGOUT_URI, ID_TOKEN_HINT, DEVICE_CODE, CLIENT_SECRET, CLIENT_ASSERTION, CLIENT_ASSERTION_TYPE, TOKEN_TYPE, REQ_CNF, OBO_ASSERTION, REQUESTED_TOKEN_USE, ON_BEHALF_OF, FOCI, CCS_HEADER, RETURN_SPA_CODE, NATIVE_BROKER, LOGOUT_HINT, SID, LOGIN_HINT, DOMAIN_HINT, X_CLIENT_EXTRA_SKU, BROKER_CLIENT_ID, BROKER_REDIRECT_URI, INSTANCE_AWARE, EAR_JWK, EAR_JWE_CRYPTO;
var init_AADServerParamKeys = __esm({
  "node_modules/@azure/msal-common/dist/constants/AADServerParamKeys.mjs"() {
    "use strict";
    CLIENT_ID = "client_id";
    REDIRECT_URI = "redirect_uri";
    RESPONSE_TYPE = "response_type";
    RESPONSE_MODE = "response_mode";
    GRANT_TYPE = "grant_type";
    CLAIMS = "claims";
    SCOPE = "scope";
    ERROR = "error";
    ERROR_DESCRIPTION = "error_description";
    ACCESS_TOKEN = "access_token";
    ID_TOKEN = "id_token";
    REFRESH_TOKEN = "refresh_token";
    EXPIRES_IN = "expires_in";
    REFRESH_TOKEN_EXPIRES_IN = "refresh_token_expires_in";
    STATE = "state";
    NONCE = "nonce";
    PROMPT = "prompt";
    SESSION_STATE = "session_state";
    CLIENT_INFO2 = "client_info";
    CODE = "code";
    CODE_CHALLENGE = "code_challenge";
    CODE_CHALLENGE_METHOD = "code_challenge_method";
    CODE_VERIFIER = "code_verifier";
    CLIENT_REQUEST_ID = "client-request-id";
    X_CLIENT_SKU = "x-client-SKU";
    X_CLIENT_VER = "x-client-VER";
    X_CLIENT_OS = "x-client-OS";
    X_CLIENT_CPU = "x-client-CPU";
    X_CLIENT_CURR_TELEM = "x-client-current-telemetry";
    X_CLIENT_LAST_TELEM = "x-client-last-telemetry";
    X_MS_LIB_CAPABILITY = "x-ms-lib-capability";
    X_APP_NAME = "x-app-name";
    X_APP_VER = "x-app-ver";
    POST_LOGOUT_URI = "post_logout_redirect_uri";
    ID_TOKEN_HINT = "id_token_hint";
    DEVICE_CODE = "device_code";
    CLIENT_SECRET = "client_secret";
    CLIENT_ASSERTION = "client_assertion";
    CLIENT_ASSERTION_TYPE = "client_assertion_type";
    TOKEN_TYPE = "token_type";
    REQ_CNF = "req_cnf";
    OBO_ASSERTION = "assertion";
    REQUESTED_TOKEN_USE = "requested_token_use";
    ON_BEHALF_OF = "on_behalf_of";
    FOCI = "foci";
    CCS_HEADER = "X-AnchorMailbox";
    RETURN_SPA_CODE = "return_spa_code";
    NATIVE_BROKER = "nativebroker";
    LOGOUT_HINT = "logout_hint";
    SID = "sid";
    LOGIN_HINT = "login_hint";
    DOMAIN_HINT = "domain_hint";
    X_CLIENT_EXTRA_SKU = "x-client-xtra-sku";
    BROKER_CLIENT_ID = "brk_client_id";
    BROKER_REDIRECT_URI = "brk_redirect_uri";
    INSTANCE_AWARE = "instance_aware";
    EAR_JWK = "ear_jwk";
    EAR_JWE_CRYPTO = "ear_jwe_crypto";
  }
});

// node_modules/@azure/msal-common/dist/request/RequestParameterBuilder.mjs
var RequestParameterBuilder_exports = {};
__export(RequestParameterBuilder_exports, {
  addApplicationTelemetry: () => addApplicationTelemetry,
  addAuthorizationCode: () => addAuthorizationCode,
  addBrokerParameters: () => addBrokerParameters,
  addCcsOid: () => addCcsOid,
  addCcsUpn: () => addCcsUpn,
  addClaims: () => addClaims,
  addClientAssertion: () => addClientAssertion,
  addClientAssertionType: () => addClientAssertionType,
  addClientCapabilitiesToClaims: () => addClientCapabilitiesToClaims,
  addClientId: () => addClientId,
  addClientInfo: () => addClientInfo,
  addClientSecret: () => addClientSecret,
  addCodeChallengeParams: () => addCodeChallengeParams,
  addCodeVerifier: () => addCodeVerifier,
  addCorrelationId: () => addCorrelationId,
  addDeviceCode: () => addDeviceCode,
  addDomainHint: () => addDomainHint,
  addEARParameters: () => addEARParameters,
  addExtraQueryParameters: () => addExtraQueryParameters,
  addGrantType: () => addGrantType,
  addIdTokenHint: () => addIdTokenHint,
  addInstanceAware: () => addInstanceAware,
  addLibraryInfo: () => addLibraryInfo,
  addLoginHint: () => addLoginHint,
  addLogoutHint: () => addLogoutHint,
  addNativeBroker: () => addNativeBroker,
  addNonce: () => addNonce,
  addOboAssertion: () => addOboAssertion,
  addPassword: () => addPassword,
  addPopToken: () => addPopToken,
  addPostBodyParameters: () => addPostBodyParameters,
  addPostLogoutRedirectUri: () => addPostLogoutRedirectUri,
  addPrompt: () => addPrompt,
  addRedirectUri: () => addRedirectUri,
  addRefreshToken: () => addRefreshToken,
  addRequestTokenUse: () => addRequestTokenUse,
  addResponseMode: () => addResponseMode,
  addResponseType: () => addResponseType,
  addScopes: () => addScopes,
  addServerTelemetry: () => addServerTelemetry,
  addSid: () => addSid,
  addSshJwk: () => addSshJwk,
  addState: () => addState,
  addThrottling: () => addThrottling,
  addUsername: () => addUsername,
  instrumentBrokerParams: () => instrumentBrokerParams
});
function instrumentBrokerParams(parameters, correlationId, performanceClient) {
  if (!correlationId) {
    return;
  }
  const clientId = parameters.get(CLIENT_ID);
  if (clientId && parameters.has(BROKER_CLIENT_ID)) {
    performanceClient?.addFields({
      embeddedClientId: clientId,
      embeddedRedirectUri: parameters.get(REDIRECT_URI)
    }, correlationId);
  }
}
function addResponseType(parameters, responseType) {
  parameters.set(RESPONSE_TYPE, responseType);
}
function addResponseMode(parameters, responseMode) {
  parameters.set(RESPONSE_MODE, responseMode ? responseMode : ResponseMode.QUERY);
}
function addNativeBroker(parameters) {
  parameters.set(NATIVE_BROKER, "1");
}
function addScopes(parameters, scopes, addOidcScopes = true, defaultScopes = OIDC_DEFAULT_SCOPES) {
  if (addOidcScopes && !defaultScopes.includes("openid") && !scopes.includes("openid")) {
    defaultScopes.push("openid");
  }
  const requestScopes = addOidcScopes ? [...scopes || [], ...defaultScopes] : scopes || [];
  const scopeSet = new ScopeSet(requestScopes);
  parameters.set(SCOPE, scopeSet.printScopes());
}
function addClientId(parameters, clientId) {
  parameters.set(CLIENT_ID, clientId);
}
function addRedirectUri(parameters, redirectUri) {
  parameters.set(REDIRECT_URI, redirectUri);
}
function addPostLogoutRedirectUri(parameters, redirectUri) {
  parameters.set(POST_LOGOUT_URI, redirectUri);
}
function addIdTokenHint(parameters, idTokenHint) {
  parameters.set(ID_TOKEN_HINT, idTokenHint);
}
function addDomainHint(parameters, domainHint) {
  parameters.set(DOMAIN_HINT, domainHint);
}
function addLoginHint(parameters, loginHint) {
  parameters.set(LOGIN_HINT, loginHint);
}
function addCcsUpn(parameters, loginHint) {
  parameters.set(HeaderNames.CCS_HEADER, `UPN:${loginHint}`);
}
function addCcsOid(parameters, clientInfo) {
  parameters.set(HeaderNames.CCS_HEADER, `Oid:${clientInfo.uid}@${clientInfo.utid}`);
}
function addSid(parameters, sid) {
  parameters.set(SID, sid);
}
function addClaims(parameters, claims, clientCapabilities) {
  const mergedClaims = addClientCapabilitiesToClaims(claims, clientCapabilities);
  try {
    JSON.parse(mergedClaims);
  } catch (e) {
    throw createClientConfigurationError(invalidClaims);
  }
  parameters.set(CLAIMS, mergedClaims);
}
function addCorrelationId(parameters, correlationId) {
  parameters.set(CLIENT_REQUEST_ID, correlationId);
}
function addLibraryInfo(parameters, libraryInfo) {
  parameters.set(X_CLIENT_SKU, libraryInfo.sku);
  parameters.set(X_CLIENT_VER, libraryInfo.version);
  if (libraryInfo.os) {
    parameters.set(X_CLIENT_OS, libraryInfo.os);
  }
  if (libraryInfo.cpu) {
    parameters.set(X_CLIENT_CPU, libraryInfo.cpu);
  }
}
function addApplicationTelemetry(parameters, appTelemetry) {
  if (appTelemetry?.appName) {
    parameters.set(X_APP_NAME, appTelemetry.appName);
  }
  if (appTelemetry?.appVersion) {
    parameters.set(X_APP_VER, appTelemetry.appVersion);
  }
}
function addPrompt(parameters, prompt) {
  parameters.set(PROMPT, prompt);
}
function addState(parameters, state2) {
  if (state2) {
    parameters.set(STATE, state2);
  }
}
function addNonce(parameters, nonce) {
  parameters.set(NONCE, nonce);
}
function addCodeChallengeParams(parameters, codeChallenge, codeChallengeMethod) {
  if (codeChallenge && codeChallengeMethod) {
    parameters.set(CODE_CHALLENGE, codeChallenge);
    parameters.set(CODE_CHALLENGE_METHOD, codeChallengeMethod);
  } else {
    throw createClientConfigurationError(pkceParamsMissing);
  }
}
function addAuthorizationCode(parameters, code) {
  parameters.set(CODE, code);
}
function addDeviceCode(parameters, code) {
  parameters.set(DEVICE_CODE, code);
}
function addRefreshToken(parameters, refreshToken) {
  parameters.set(REFRESH_TOKEN, refreshToken);
}
function addCodeVerifier(parameters, codeVerifier) {
  parameters.set(CODE_VERIFIER, codeVerifier);
}
function addClientSecret(parameters, clientSecret) {
  parameters.set(CLIENT_SECRET, clientSecret);
}
function addClientAssertion(parameters, clientAssertion) {
  if (clientAssertion) {
    parameters.set(CLIENT_ASSERTION, clientAssertion);
  }
}
function addClientAssertionType(parameters, clientAssertionType) {
  if (clientAssertionType) {
    parameters.set(CLIENT_ASSERTION_TYPE, clientAssertionType);
  }
}
function addOboAssertion(parameters, oboAssertion) {
  parameters.set(OBO_ASSERTION, oboAssertion);
}
function addRequestTokenUse(parameters, tokenUse) {
  parameters.set(REQUESTED_TOKEN_USE, tokenUse);
}
function addGrantType(parameters, grantType) {
  parameters.set(GRANT_TYPE, grantType);
}
function addClientInfo(parameters) {
  parameters.set(CLIENT_INFO, "1");
}
function addInstanceAware(parameters) {
  if (!parameters.has(INSTANCE_AWARE)) {
    parameters.set(INSTANCE_AWARE, "true");
  }
}
function addExtraQueryParameters(parameters, eQParams) {
  Object.entries(eQParams).forEach(([key2, value]) => {
    if (!parameters.has(key2) && value) {
      parameters.set(key2, value);
    }
  });
}
function addClientCapabilitiesToClaims(claims, clientCapabilities) {
  let mergedClaims;
  if (!claims) {
    mergedClaims = {};
  } else {
    try {
      mergedClaims = JSON.parse(claims);
    } catch (e) {
      throw createClientConfigurationError(invalidClaims);
    }
  }
  if (clientCapabilities && clientCapabilities.length > 0) {
    if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
      mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};
    }
    mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] = {
      values: clientCapabilities
    };
  }
  return JSON.stringify(mergedClaims);
}
function addUsername(parameters, username) {
  parameters.set(PasswordGrantConstants.username, username);
}
function addPassword(parameters, password) {
  parameters.set(PasswordGrantConstants.password, password);
}
function addPopToken(parameters, cnfString) {
  if (cnfString) {
    parameters.set(TOKEN_TYPE, AuthenticationScheme.POP);
    parameters.set(REQ_CNF, cnfString);
  }
}
function addSshJwk(parameters, sshJwkString) {
  if (sshJwkString) {
    parameters.set(TOKEN_TYPE, AuthenticationScheme.SSH);
    parameters.set(REQ_CNF, sshJwkString);
  }
}
function addServerTelemetry(parameters, serverTelemetryManager) {
  parameters.set(X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
  parameters.set(X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());
}
function addThrottling(parameters) {
  parameters.set(X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
}
function addLogoutHint(parameters, logoutHint) {
  parameters.set(LOGOUT_HINT, logoutHint);
}
function addBrokerParameters(parameters, brokerClientId, brokerRedirectUri) {
  if (!parameters.has(BROKER_CLIENT_ID)) {
    parameters.set(BROKER_CLIENT_ID, brokerClientId);
  }
  if (!parameters.has(BROKER_REDIRECT_URI)) {
    parameters.set(BROKER_REDIRECT_URI, brokerRedirectUri);
  }
}
function addEARParameters(parameters, jwk) {
  parameters.set(EAR_JWK, encodeURIComponent(jwk));
  const jweCryptoB64Encoded = "eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIn0";
  parameters.set(EAR_JWE_CRYPTO, jweCryptoB64Encoded);
}
function addPostBodyParameters(parameters, bodyParameters) {
  Object.entries(bodyParameters).forEach(([key2, value]) => {
    if (value) {
      parameters.set(key2, value);
    }
  });
}
var init_RequestParameterBuilder = __esm({
  "node_modules/@azure/msal-common/dist/request/RequestParameterBuilder.mjs"() {
    "use strict";
    init_Constants();
    init_AADServerParamKeys();
    init_ScopeSet();
    init_ClientConfigurationError();
    init_ClientConfigurationErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs
function isOpenIdConfigResponse(response) {
  return response.hasOwnProperty("authorization_endpoint") && response.hasOwnProperty("token_endpoint") && response.hasOwnProperty("issuer") && response.hasOwnProperty("jwks_uri");
}
var init_OpenIdConfigResponse = __esm({
  "node_modules/@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs
function isCloudInstanceDiscoveryResponse(response) {
  return response.hasOwnProperty("tenant_discovery_endpoint") && response.hasOwnProperty("metadata");
}
var init_CloudInstanceDiscoveryResponse = __esm({
  "node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs
function isCloudInstanceDiscoveryErrorResponse(response) {
  return response.hasOwnProperty("error") && response.hasOwnProperty("error_description");
}
var init_CloudInstanceDiscoveryErrorResponse = __esm({
  "node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/utils/FunctionWrappers.mjs
var invoke, invokeAsync;
var init_FunctionWrappers = __esm({
  "node_modules/@azure/msal-common/dist/utils/FunctionWrappers.mjs"() {
    "use strict";
    invoke = (callback, eventName, logger11, telemetryClient, correlationId) => {
      return (...args) => {
        logger11.trace(`Executing function ${eventName}`);
        const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);
        if (correlationId) {
          const eventCount = eventName + "CallCount";
          telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);
        }
        try {
          const result = callback(...args);
          inProgressEvent?.end({
            success: true
          });
          logger11.trace(`Returning result from ${eventName}`);
          return result;
        } catch (e) {
          logger11.trace(`Error occurred in ${eventName}`);
          try {
            logger11.trace(JSON.stringify(e));
          } catch (e2) {
            logger11.trace("Unable to print error message.");
          }
          inProgressEvent?.end({
            success: false
          }, e);
          throw e;
        }
      };
    };
    invokeAsync = (callback, eventName, logger11, telemetryClient, correlationId) => {
      return (...args) => {
        logger11.trace(`Executing function ${eventName}`);
        const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);
        if (correlationId) {
          const eventCount = eventName + "CallCount";
          telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);
        }
        telemetryClient?.setPreQueueTime(eventName, correlationId);
        return callback(...args).then((response) => {
          logger11.trace(`Returning result from ${eventName}`);
          inProgressEvent?.end({
            success: true
          });
          return response;
        }).catch((e) => {
          logger11.trace(`Error occurred in ${eventName}`);
          try {
            logger11.trace(JSON.stringify(e));
          } catch (e2) {
            logger11.trace("Unable to print error message.");
          }
          inProgressEvent?.end({
            success: false
          }, e);
          throw e;
        });
      };
    };
  }
});

// node_modules/@azure/msal-common/dist/authority/RegionDiscovery.mjs
var RegionDiscovery;
var init_RegionDiscovery = __esm({
  "node_modules/@azure/msal-common/dist/authority/RegionDiscovery.mjs"() {
    "use strict";
    init_Constants();
    init_PerformanceEvent();
    init_FunctionWrappers();
    RegionDiscovery = class _RegionDiscovery {
      constructor(networkInterface, logger11, performanceClient, correlationId) {
        this.networkInterface = networkInterface;
        this.logger = logger11;
        this.performanceClient = performanceClient;
        this.correlationId = correlationId;
      }
      /**
       * Detect the region from the application's environment.
       *
       * @returns Promise<string | null>
       */
      async detectRegion(environmentRegion, regionDiscoveryMetadata) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);
        let autodetectedRegionName = environmentRegion;
        if (!autodetectedRegionName) {
          const options = _RegionDiscovery.IMDS_OPTIONS;
          try {
            const localIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(Constants.IMDS_VERSION, options);
            if (localIMDSVersionResponse.status === HttpStatus.SUCCESS) {
              autodetectedRegionName = localIMDSVersionResponse.body;
              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
            }
            if (localIMDSVersionResponse.status === HttpStatus.BAD_REQUEST) {
              const currentIMDSVersion = await invokeAsync(this.getCurrentVersion.bind(this), PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.logger, this.performanceClient, this.correlationId)(options);
              if (!currentIMDSVersion) {
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                return null;
              }
              const currentIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(currentIMDSVersion, options);
              if (currentIMDSVersionResponse.status === HttpStatus.SUCCESS) {
                autodetectedRegionName = currentIMDSVersionResponse.body;
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
              }
            }
          } catch (e) {
            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
            return null;
          }
        } else {
          regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;
        }
        if (!autodetectedRegionName) {
          regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
        }
        return autodetectedRegionName || null;
      }
      /**
       * Make the call to the IMDS endpoint
       *
       * @param imdsEndpointUrl
       * @returns Promise<NetworkResponse<string>>
       */
      async getRegionFromIMDS(version3, options) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);
        return this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?api-version=${version3}&format=text`, options, Constants.IMDS_TIMEOUT);
      }
      /**
       * Get the most recent version of the IMDS endpoint available
       *
       * @returns Promise<string | null>
       */
      async getCurrentVersion(options) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);
        try {
          const response = await this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?format=json`, options);
          if (response.status === HttpStatus.BAD_REQUEST && response.body && response.body["newest-versions"] && response.body["newest-versions"].length > 0) {
            return response.body["newest-versions"][0];
          }
          return null;
        } catch (e) {
          return null;
        }
      }
    };
    RegionDiscovery.IMDS_OPTIONS = {
      headers: {
        Metadata: "true"
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/utils/TimeUtils.mjs
var TimeUtils_exports = {};
__export(TimeUtils_exports, {
  delay: () => delay,
  isCacheExpired: () => isCacheExpired,
  isTokenExpired: () => isTokenExpired,
  nowSeconds: () => nowSeconds,
  toDateFromSeconds: () => toDateFromSeconds,
  toSecondsFromDate: () => toSecondsFromDate,
  wasClockTurnedBack: () => wasClockTurnedBack
});
function nowSeconds() {
  return Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
}
function toSecondsFromDate(date) {
  return date.getTime() / 1e3;
}
function toDateFromSeconds(seconds) {
  if (seconds) {
    return new Date(Number(seconds) * 1e3);
  }
  return /* @__PURE__ */ new Date();
}
function isTokenExpired(expiresOn, offset) {
  const expirationSec = Number(expiresOn) || 0;
  const offsetCurrentTimeSec = nowSeconds() + offset;
  return offsetCurrentTimeSec > expirationSec;
}
function isCacheExpired(lastUpdatedAt, cacheRetentionDays) {
  const cacheExpirationTimestamp = Number(lastUpdatedAt) + cacheRetentionDays * 24 * 60 * 60 * 1e3;
  return Date.now() > cacheExpirationTimestamp;
}
function wasClockTurnedBack(cachedAt) {
  const cachedAtSec = Number(cachedAt);
  return cachedAtSec > nowSeconds();
}
function delay(t, value) {
  return new Promise((resolve) => setTimeout(() => resolve(value), t));
}
var init_TimeUtils = __esm({
  "node_modules/@azure/msal-common/dist/utils/TimeUtils.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/cache/utils/CacheHelpers.mjs
var CacheHelpers_exports = {};
__export(CacheHelpers_exports, {
  createAccessTokenEntity: () => createAccessTokenEntity,
  createIdTokenEntity: () => createIdTokenEntity,
  createRefreshTokenEntity: () => createRefreshTokenEntity,
  generateAppMetadataKey: () => generateAppMetadataKey,
  generateAuthorityMetadataExpiresAt: () => generateAuthorityMetadataExpiresAt,
  isAccessTokenEntity: () => isAccessTokenEntity,
  isAppMetadataEntity: () => isAppMetadataEntity,
  isAuthorityMetadataEntity: () => isAuthorityMetadataEntity,
  isAuthorityMetadataExpired: () => isAuthorityMetadataExpired,
  isCredentialEntity: () => isCredentialEntity,
  isIdTokenEntity: () => isIdTokenEntity,
  isRefreshTokenEntity: () => isRefreshTokenEntity,
  isServerTelemetryEntity: () => isServerTelemetryEntity,
  isThrottlingEntity: () => isThrottlingEntity,
  updateAuthorityEndpointMetadata: () => updateAuthorityEndpointMetadata,
  updateCloudDiscoveryMetadata: () => updateCloudDiscoveryMetadata
});
function createIdTokenEntity(homeAccountId, environment, idToken, clientId, tenantId) {
  const idTokenEntity = {
    credentialType: CredentialType.ID_TOKEN,
    homeAccountId,
    environment,
    clientId,
    secret: idToken,
    realm: tenantId,
    lastUpdatedAt: Date.now().toString()
    // Set the last updated time to now
  };
  return idTokenEntity;
}
function createAccessTokenEntity(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, base64Decode, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {
  const atEntity = {
    homeAccountId,
    credentialType: CredentialType.ACCESS_TOKEN,
    secret: accessToken,
    cachedAt: nowSeconds().toString(),
    expiresOn: expiresOn.toString(),
    extendedExpiresOn: extExpiresOn.toString(),
    environment,
    clientId,
    realm: tenantId,
    target: scopes,
    tokenType: tokenType || AuthenticationScheme.BEARER,
    lastUpdatedAt: Date.now().toString()
    // Set the last updated time to now
  };
  if (userAssertionHash) {
    atEntity.userAssertionHash = userAssertionHash;
  }
  if (refreshOn) {
    atEntity.refreshOn = refreshOn.toString();
  }
  if (requestedClaims) {
    atEntity.requestedClaims = requestedClaims;
    atEntity.requestedClaimsHash = requestedClaimsHash;
  }
  if (atEntity.tokenType?.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) {
    atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
    switch (atEntity.tokenType) {
      case AuthenticationScheme.POP:
        const tokenClaims = extractTokenClaims(accessToken, base64Decode);
        if (!tokenClaims?.cnf?.kid) {
          throw createClientAuthError(tokenClaimsCnfRequiredForSignedJwt);
        }
        atEntity.keyId = tokenClaims.cnf.kid;
        break;
      case AuthenticationScheme.SSH:
        atEntity.keyId = keyId;
    }
  }
  return atEntity;
}
function createRefreshTokenEntity(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash, expiresOn) {
  const rtEntity = {
    credentialType: CredentialType.REFRESH_TOKEN,
    homeAccountId,
    environment,
    clientId,
    secret: refreshToken,
    lastUpdatedAt: Date.now().toString()
  };
  if (userAssertionHash) {
    rtEntity.userAssertionHash = userAssertionHash;
  }
  if (familyId) {
    rtEntity.familyId = familyId;
  }
  if (expiresOn) {
    rtEntity.expiresOn = expiresOn.toString();
  }
  return rtEntity;
}
function isCredentialEntity(entity) {
  return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret");
}
function isAccessTokenEntity(entity) {
  if (!entity) {
    return false;
  }
  return isCredentialEntity(entity) && entity.hasOwnProperty("realm") && entity.hasOwnProperty("target") && (entity["credentialType"] === CredentialType.ACCESS_TOKEN || entity["credentialType"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);
}
function isIdTokenEntity(entity) {
  if (!entity) {
    return false;
  }
  return isCredentialEntity(entity) && entity.hasOwnProperty("realm") && entity["credentialType"] === CredentialType.ID_TOKEN;
}
function isRefreshTokenEntity(entity) {
  if (!entity) {
    return false;
  }
  return isCredentialEntity(entity) && entity["credentialType"] === CredentialType.REFRESH_TOKEN;
}
function isServerTelemetryEntity(key2, entity) {
  const validateKey = key2.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
  let validateEntity = true;
  if (entity) {
    validateEntity = entity.hasOwnProperty("failedRequests") && entity.hasOwnProperty("errors") && entity.hasOwnProperty("cacheHits");
  }
  return validateKey && validateEntity;
}
function isThrottlingEntity(key2, entity) {
  let validateKey = false;
  if (key2) {
    validateKey = key2.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;
  }
  let validateEntity = true;
  if (entity) {
    validateEntity = entity.hasOwnProperty("throttleTime");
  }
  return validateKey && validateEntity;
}
function generateAppMetadataKey({ environment, clientId }) {
  const appMetaDataKeyArray = [
    APP_METADATA,
    environment,
    clientId
  ];
  return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
}
function isAppMetadataEntity(key2, entity) {
  if (!entity) {
    return false;
  }
  return key2.indexOf(APP_METADATA) === 0 && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("environment");
}
function isAuthorityMetadataEntity(key2, entity) {
  if (!entity) {
    return false;
  }
  return key2.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 && entity.hasOwnProperty("aliases") && entity.hasOwnProperty("preferred_cache") && entity.hasOwnProperty("preferred_network") && entity.hasOwnProperty("canonical_authority") && entity.hasOwnProperty("authorization_endpoint") && entity.hasOwnProperty("token_endpoint") && entity.hasOwnProperty("issuer") && entity.hasOwnProperty("aliasesFromNetwork") && entity.hasOwnProperty("endpointsFromNetwork") && entity.hasOwnProperty("expiresAt") && entity.hasOwnProperty("jwks_uri");
}
function generateAuthorityMetadataExpiresAt() {
  return nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
}
function updateAuthorityEndpointMetadata(authorityMetadata, updatedValues, fromNetwork) {
  authorityMetadata.authorization_endpoint = updatedValues.authorization_endpoint;
  authorityMetadata.token_endpoint = updatedValues.token_endpoint;
  authorityMetadata.end_session_endpoint = updatedValues.end_session_endpoint;
  authorityMetadata.issuer = updatedValues.issuer;
  authorityMetadata.endpointsFromNetwork = fromNetwork;
  authorityMetadata.jwks_uri = updatedValues.jwks_uri;
}
function updateCloudDiscoveryMetadata(authorityMetadata, updatedValues, fromNetwork) {
  authorityMetadata.aliases = updatedValues.aliases;
  authorityMetadata.preferred_cache = updatedValues.preferred_cache;
  authorityMetadata.preferred_network = updatedValues.preferred_network;
  authorityMetadata.aliasesFromNetwork = fromNetwork;
}
function isAuthorityMetadataExpired(metadata) {
  return metadata.expiresAt <= nowSeconds();
}
var init_CacheHelpers = __esm({
  "node_modules/@azure/msal-common/dist/cache/utils/CacheHelpers.mjs"() {
    "use strict";
    init_AuthToken();
    init_ClientAuthError();
    init_Constants();
    init_TimeUtils();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/authority/Authority.mjs
function getTenantFromAuthorityString(authority) {
  const authorityUrl = new UrlString(authority);
  const authorityUrlComponents = authorityUrl.getUrlComponents();
  const tenantId = authorityUrlComponents.PathSegments.slice(-1)[0]?.toLowerCase();
  switch (tenantId) {
    case AADAuthorityConstants.COMMON:
    case AADAuthorityConstants.ORGANIZATIONS:
    case AADAuthorityConstants.CONSUMERS:
      return void 0;
    default:
      return tenantId;
  }
}
function formatAuthorityUri(authorityUri) {
  return authorityUri.endsWith(Constants.FORWARD_SLASH) ? authorityUri : `${authorityUri}${Constants.FORWARD_SLASH}`;
}
function buildStaticAuthorityOptions(authOptions) {
  const rawCloudDiscoveryMetadata = authOptions.cloudDiscoveryMetadata;
  let cloudDiscoveryMetadata = void 0;
  if (rawCloudDiscoveryMetadata) {
    try {
      cloudDiscoveryMetadata = JSON.parse(rawCloudDiscoveryMetadata);
    } catch (e) {
      throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
    }
  }
  return {
    canonicalAuthority: authOptions.authority ? formatAuthorityUri(authOptions.authority) : void 0,
    knownAuthorities: authOptions.knownAuthorities,
    cloudDiscoveryMetadata
  };
}
var Authority;
var init_Authority = __esm({
  "node_modules/@azure/msal-common/dist/authority/Authority.mjs"() {
    "use strict";
    init_AuthorityType();
    init_OpenIdConfigResponse();
    init_UrlString();
    init_ClientAuthError();
    init_Constants();
    init_AuthorityMetadata();
    init_ClientConfigurationError();
    init_ProtocolMode();
    init_AuthorityOptions();
    init_CloudInstanceDiscoveryResponse();
    init_CloudInstanceDiscoveryErrorResponse();
    init_RegionDiscovery();
    init_AuthError();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_CacheHelpers();
    init_ClientAuthErrorCodes();
    init_ClientConfigurationErrorCodes();
    Authority = class _Authority {
      constructor(authority, networkInterface, cacheManager, authorityOptions, logger11, correlationId, performanceClient, managedIdentity) {
        this.canonicalAuthority = authority;
        this._canonicalAuthority.validateAsUri();
        this.networkInterface = networkInterface;
        this.cacheManager = cacheManager;
        this.authorityOptions = authorityOptions;
        this.regionDiscoveryMetadata = {
          region_used: void 0,
          region_source: void 0,
          region_outcome: void 0
        };
        this.logger = logger11;
        this.performanceClient = performanceClient;
        this.correlationId = correlationId;
        this.managedIdentity = managedIdentity || false;
        this.regionDiscovery = new RegionDiscovery(networkInterface, this.logger, this.performanceClient, this.correlationId);
      }
      /**
       * Get {@link AuthorityType}
       * @param authorityUri {@link IUri}
       * @private
       */
      getAuthorityType(authorityUri) {
        if (authorityUri.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {
          return AuthorityType.Ciam;
        }
        const pathSegments = authorityUri.PathSegments;
        if (pathSegments.length) {
          switch (pathSegments[0].toLowerCase()) {
            case Constants.ADFS:
              return AuthorityType.Adfs;
            case Constants.DSTS:
              return AuthorityType.Dsts;
          }
        }
        return AuthorityType.Default;
      }
      // See above for AuthorityType
      get authorityType() {
        return this.getAuthorityType(this.canonicalAuthorityUrlComponents);
      }
      /**
       * ProtocolMode enum representing the way endpoints are constructed.
       */
      get protocolMode() {
        return this.authorityOptions.protocolMode;
      }
      /**
       * Returns authorityOptions which can be used to reinstantiate a new authority instance
       */
      get options() {
        return this.authorityOptions;
      }
      /**
       * A URL that is the authority set by the developer
       */
      get canonicalAuthority() {
        return this._canonicalAuthority.urlString;
      }
      /**
       * Sets canonical authority.
       */
      set canonicalAuthority(url2) {
        this._canonicalAuthority = new UrlString(url2);
        this._canonicalAuthority.validateAsUri();
        this._canonicalAuthorityUrlComponents = null;
      }
      /**
       * Get authority components.
       */
      get canonicalAuthorityUrlComponents() {
        if (!this._canonicalAuthorityUrlComponents) {
          this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();
        }
        return this._canonicalAuthorityUrlComponents;
      }
      /**
       * Get hostname and port i.e. login.microsoftonline.com
       */
      get hostnameAndPort() {
        return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
      }
      /**
       * Get tenant for authority.
       */
      get tenant() {
        return this.canonicalAuthorityUrlComponents.PathSegments[0];
      }
      /**
       * OAuth /authorize endpoint for requests
       */
      get authorizationEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.authorization_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth /token endpoint for requests
       */
      get tokenEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.token_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      get deviceCodeEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth logout endpoint for requests
       */
      get endSessionEndpoint() {
        if (this.discoveryComplete()) {
          if (!this.metadata.end_session_endpoint) {
            throw createClientAuthError(endSessionEndpointNotSupported);
          }
          return this.replacePath(this.metadata.end_session_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth issuer for requests
       */
      get selfSignedJwtAudience() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.issuer);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Jwks_uri for token signing keys
       */
      get jwksUri() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.jwks_uri);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Returns a flag indicating that tenant name can be replaced in authority {@link IUri}
       * @param authorityUri {@link IUri}
       * @private
       */
      canReplaceTenant(authorityUri) {
        return authorityUri.PathSegments.length === 1 && !_Authority.reservedTenantDomains.has(authorityUri.PathSegments[0]) && this.getAuthorityType(authorityUri) === AuthorityType.Default && this.protocolMode !== ProtocolMode.OIDC;
      }
      /**
       * Replaces tenant in url path with current tenant. Defaults to common.
       * @param urlString
       */
      replaceTenant(urlString) {
        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);
      }
      /**
       * Replaces path such as tenant or policy with the current tenant or policy.
       * @param urlString
       */
      replacePath(urlString) {
        let endpoint = urlString;
        const cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
        const cachedAuthorityUrlComponents = cachedAuthorityUrl.getUrlComponents();
        const cachedAuthorityParts = cachedAuthorityUrlComponents.PathSegments;
        const currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
        currentAuthorityParts.forEach((currentPart, index2) => {
          let cachedPart = cachedAuthorityParts[index2];
          if (index2 === 0 && this.canReplaceTenant(cachedAuthorityUrlComponents)) {
            const tenantId = new UrlString(this.metadata.authorization_endpoint).getUrlComponents().PathSegments[0];
            if (cachedPart !== tenantId) {
              this.logger.verbose(`Replacing tenant domain name ${cachedPart} with id ${tenantId}`);
              cachedPart = tenantId;
            }
          }
          if (currentPart !== cachedPart) {
            endpoint = endpoint.replace(`/${cachedPart}/`, `/${currentPart}/`);
          }
        });
        return this.replaceTenant(endpoint);
      }
      /**
       * The default open id configuration endpoint for any canonical authority.
       */
      get defaultOpenIdConfigurationEndpoint() {
        const canonicalAuthorityHost = this.hostnameAndPort;
        if (this.canonicalAuthority.endsWith("v2.0/") || this.authorityType === AuthorityType.Adfs || this.protocolMode === ProtocolMode.OIDC && !this.isAliasOfKnownMicrosoftAuthority(canonicalAuthorityHost)) {
          return `${this.canonicalAuthority}.well-known/openid-configuration`;
        }
        return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;
      }
      /**
       * Boolean that returns whether or not tenant discovery has been completed.
       */
      discoveryComplete() {
        return !!this.metadata;
      }
      /**
       * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network
       * and the /authorize, /token and logout endpoints.
       */
      async resolveEndpointsAsync() {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityResolveEndpointsAsync, this.correlationId);
        const metadataEntity = this.getCurrentMetadataEntity();
        const cloudDiscoverySource = await invokeAsync(this.updateCloudDiscoveryMetadata.bind(this), PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
        this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);
        const endpointSource = await invokeAsync(this.updateEndpointMetadata.bind(this), PerformanceEvents.AuthorityUpdateEndpointMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
        this.updateCachedMetadata(metadataEntity, cloudDiscoverySource, {
          source: endpointSource
        });
        this.performanceClient?.addFields({
          cloudDiscoverySource,
          authorityEndpointSource: endpointSource
        }, this.correlationId);
      }
      /**
       * Returns metadata entity from cache if it exists, otherwiser returns a new metadata entity built
       * from the configured canonical authority
       * @returns
       */
      getCurrentMetadataEntity() {
        let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
        if (!metadataEntity) {
          metadataEntity = {
            aliases: [],
            preferred_cache: this.hostnameAndPort,
            preferred_network: this.hostnameAndPort,
            canonical_authority: this.canonicalAuthority,
            authorization_endpoint: "",
            token_endpoint: "",
            end_session_endpoint: "",
            issuer: "",
            aliasesFromNetwork: false,
            endpointsFromNetwork: false,
            expiresAt: generateAuthorityMetadataExpiresAt(),
            jwks_uri: ""
          };
        }
        return metadataEntity;
      }
      /**
       * Updates cached metadata based on metadata source and sets the instance's metadata
       * property to the same value
       * @param metadataEntity
       * @param cloudDiscoverySource
       * @param endpointMetadataResult
       */
      updateCachedMetadata(metadataEntity, cloudDiscoverySource, endpointMetadataResult) {
        if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointMetadataResult?.source !== AuthorityMetadataSource.CACHE) {
          metadataEntity.expiresAt = generateAuthorityMetadataExpiresAt();
          metadataEntity.canonical_authority = this.canonicalAuthority;
        }
        const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);
        this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
        this.metadata = metadataEntity;
      }
      /**
       * Update AuthorityMetadataEntity with new endpoints and return where the information came from
       * @param metadataEntity
       */
      async updateEndpointMetadata(metadataEntity) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId);
        const localMetadata = this.updateEndpointMetadataFromLocalSources(metadataEntity);
        if (localMetadata) {
          if (localMetadata.source === AuthorityMetadataSource.HARDCODED_VALUES) {
            if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {
              if (localMetadata.metadata) {
                const hardcodedMetadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(localMetadata.metadata);
                updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
                metadataEntity.canonical_authority = this.canonicalAuthority;
              }
            }
          }
          return localMetadata.source;
        }
        let metadata = await invokeAsync(this.getEndpointMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
        if (metadata) {
          if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {
            metadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(metadata);
          }
          updateAuthorityEndpointMetadata(metadataEntity, metadata, true);
          return AuthorityMetadataSource.NETWORK;
        } else {
          throw createClientAuthError(openIdConfigError, this.defaultOpenIdConfigurationEndpoint);
        }
      }
      /**
       * Updates endpoint metadata from local sources and returns where the information was retrieved from and the metadata config
       * response if the source is hardcoded metadata
       * @param metadataEntity
       * @returns
       */
      updateEndpointMetadataFromLocalSources(metadataEntity) {
        this.logger.verbose("Attempting to get endpoint metadata from authority configuration");
        const configMetadata = this.getEndpointMetadataFromConfig();
        if (configMetadata) {
          this.logger.verbose("Found endpoint metadata in authority configuration");
          updateAuthorityEndpointMetadata(metadataEntity, configMetadata, false);
          return {
            source: AuthorityMetadataSource.CONFIG
          };
        }
        this.logger.verbose("Did not find endpoint metadata in the config... Attempting to get endpoint metadata from the hardcoded values.");
        if (this.authorityOptions.skipAuthorityMetadataCache) {
          this.logger.verbose("Skipping hardcoded metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get endpoint metadata from the network metadata cache.");
        } else {
          const hardcodedMetadata = this.getEndpointMetadataFromHardcodedValues();
          if (hardcodedMetadata) {
            updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
            return {
              source: AuthorityMetadataSource.HARDCODED_VALUES,
              metadata: hardcodedMetadata
            };
          } else {
            this.logger.verbose("Did not find endpoint metadata in hardcoded values... Attempting to get endpoint metadata from the network metadata cache.");
          }
        }
        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntityExpired) {
          this.logger.verbose("Found endpoint metadata in the cache.");
          return { source: AuthorityMetadataSource.CACHE };
        } else if (metadataEntityExpired) {
          this.logger.verbose("The metadata entity is expired.");
        }
        return null;
      }
      /**
       * Compares the number of url components after the domain to determine if the cached
       * authority metadata can be used for the requested authority. Protects against same domain different
       * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy
       * @param metadataEntity
       */
      isAuthoritySameType(metadataEntity) {
        const cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
        const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
        return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;
      }
      /**
       * Parse authorityMetadata config option
       */
      getEndpointMetadataFromConfig() {
        if (this.authorityOptions.authorityMetadata) {
          try {
            return JSON.parse(this.authorityOptions.authorityMetadata);
          } catch (e) {
            throw createClientConfigurationError(invalidAuthorityMetadata);
          }
        }
        return null;
      }
      /**
       * Gets OAuth endpoints from the given OpenID configuration endpoint.
       *
       * @param hasHardcodedMetadata boolean
       */
      async getEndpointMetadataFromNetwork() {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId);
        const options = {};
        const openIdConfigurationEndpoint = this.defaultOpenIdConfigurationEndpoint;
        this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: attempting to retrieve OAuth endpoints from ${openIdConfigurationEndpoint}`);
        try {
          const response = await this.networkInterface.sendGetRequestAsync(openIdConfigurationEndpoint, options);
          const isValidResponse = isOpenIdConfigResponse(response.body);
          if (isValidResponse) {
            return response.body;
          } else {
            this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: could not parse response as OpenID configuration`);
            return null;
          }
        } catch (e) {
          this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: ${e}`);
          return null;
        }
      }
      /**
       * Get OAuth endpoints for common authorities.
       */
      getEndpointMetadataFromHardcodedValues() {
        if (this.hostnameAndPort in EndpointMetadata) {
          return EndpointMetadata[this.hostnameAndPort];
        }
        return null;
      }
      /**
       * Update the retrieved metadata with regional information.
       * User selected Azure region will be used if configured.
       */
      async updateMetadataWithRegionalInformation(metadata) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);
        const userConfiguredAzureRegion = this.authorityOptions.azureRegionConfiguration?.azureRegion;
        if (userConfiguredAzureRegion) {
          if (userConfiguredAzureRegion !== Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {
            this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;
            this.regionDiscoveryMetadata.region_used = userConfiguredAzureRegion;
            return _Authority.replaceWithRegionalInformation(metadata, userConfiguredAzureRegion);
          }
          const autodetectedRegionName = await invokeAsync(this.regionDiscovery.detectRegion.bind(this.regionDiscovery), PerformanceEvents.RegionDiscoveryDetectRegion, this.logger, this.performanceClient, this.correlationId)(this.authorityOptions.azureRegionConfiguration?.environmentRegion, this.regionDiscoveryMetadata);
          if (autodetectedRegionName) {
            this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL;
            this.regionDiscoveryMetadata.region_used = autodetectedRegionName;
            return _Authority.replaceWithRegionalInformation(metadata, autodetectedRegionName);
          }
          this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;
        }
        return metadata;
      }
      /**
       * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache
       * and returns where the information was retrieved from
       * @param metadataEntity
       * @returns AuthorityMetadataSource
       */
      async updateCloudDiscoveryMetadata(metadataEntity) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId);
        const localMetadataSource = this.updateCloudDiscoveryMetadataFromLocalSources(metadataEntity);
        if (localMetadataSource) {
          return localMetadataSource;
        }
        const metadata = await invokeAsync(this.getCloudDiscoveryMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
        if (metadata) {
          updateCloudDiscoveryMetadata(metadataEntity, metadata, true);
          return AuthorityMetadataSource.NETWORK;
        }
        throw createClientConfigurationError(untrustedAuthority);
      }
      updateCloudDiscoveryMetadataFromLocalSources(metadataEntity) {
        this.logger.verbose("Attempting to get cloud discovery metadata  from authority configuration");
        this.logger.verbosePii(`Known Authorities: ${this.authorityOptions.knownAuthorities || Constants.NOT_APPLICABLE}`);
        this.logger.verbosePii(`Authority Metadata: ${this.authorityOptions.authorityMetadata || Constants.NOT_APPLICABLE}`);
        this.logger.verbosePii(`Canonical Authority: ${metadataEntity.canonical_authority || Constants.NOT_APPLICABLE}`);
        const metadata = this.getCloudDiscoveryMetadataFromConfig();
        if (metadata) {
          this.logger.verbose("Found cloud discovery metadata in authority configuration");
          updateCloudDiscoveryMetadata(metadataEntity, metadata, false);
          return AuthorityMetadataSource.CONFIG;
        }
        this.logger.verbose("Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the hardcoded values.");
        if (this.options.skipAuthorityMetadataCache) {
          this.logger.verbose("Skipping hardcoded cloud discovery metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get cloud discovery metadata from the network metadata cache.");
        } else {
          const hardcodedMetadata = getCloudDiscoveryMetadataFromHardcodedValues(this.hostnameAndPort);
          if (hardcodedMetadata) {
            this.logger.verbose("Found cloud discovery metadata from hardcoded values.");
            updateCloudDiscoveryMetadata(metadataEntity, hardcodedMetadata, false);
            return AuthorityMetadataSource.HARDCODED_VALUES;
          }
          this.logger.verbose("Did not find cloud discovery metadata in hardcoded values... Attempting to get cloud discovery metadata from the network metadata cache.");
        }
        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntityExpired) {
          this.logger.verbose("Found cloud discovery metadata in the cache.");
          return AuthorityMetadataSource.CACHE;
        } else if (metadataEntityExpired) {
          this.logger.verbose("The metadata entity is expired.");
        }
        return null;
      }
      /**
       * Parse cloudDiscoveryMetadata config or check knownAuthorities
       */
      getCloudDiscoveryMetadataFromConfig() {
        if (this.authorityType === AuthorityType.Ciam) {
          this.logger.verbose("CIAM authorities do not support cloud discovery metadata, generate the aliases from authority host.");
          return _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        if (this.authorityOptions.cloudDiscoveryMetadata) {
          this.logger.verbose("The cloud discovery metadata has been provided as a network response, in the config.");
          try {
            this.logger.verbose("Attempting to parse the cloud discovery metadata.");
            const parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
            const metadata = getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);
            this.logger.verbose("Parsed the cloud discovery metadata.");
            if (metadata) {
              this.logger.verbose("There is returnable metadata attached to the parsed cloud discovery metadata.");
              return metadata;
            } else {
              this.logger.verbose("There is no metadata attached to the parsed cloud discovery metadata.");
            }
          } catch (e) {
            this.logger.verbose("Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.");
            throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
          }
        }
        if (this.isInKnownAuthorities()) {
          this.logger.verbose("The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.");
          return _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        return null;
      }
      /**
       * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config
       *
       * @param hasHardcodedMetadata boolean
       */
      async getCloudDiscoveryMetadataFromNetwork() {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId);
        const instanceDiscoveryEndpoint = `${Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;
        const options = {};
        let match = null;
        try {
          const response = await this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options);
          let typedResponseBody;
          let metadata;
          if (isCloudInstanceDiscoveryResponse(response.body)) {
            typedResponseBody = response.body;
            metadata = typedResponseBody.metadata;
            this.logger.verbosePii(`tenant_discovery_endpoint is: ${typedResponseBody.tenant_discovery_endpoint}`);
          } else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {
            this.logger.warning(`A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: ${response.status}`);
            typedResponseBody = response.body;
            if (typedResponseBody.error === Constants.INVALID_INSTANCE) {
              this.logger.error("The CloudInstanceDiscoveryErrorResponse error is invalid_instance.");
              return null;
            }
            this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error is ${typedResponseBody.error}`);
            this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error description is ${typedResponseBody.error_description}`);
            this.logger.warning("Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []");
            metadata = [];
          } else {
            this.logger.error("AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse");
            return null;
          }
          this.logger.verbose("Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request.");
          match = getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
        } catch (error) {
          if (error instanceof AuthError) {
            this.logger.error(`There was a network error while attempting to get the cloud discovery instance metadata.
Error: ${error.errorCode}
Error Description: ${error.errorMessage}`);
          } else {
            const typedError = error;
            this.logger.error(`A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.
Error: ${typedError.name}
Error Description: ${typedError.message}`);
          }
          return null;
        }
        if (!match) {
          this.logger.warning("The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request.");
          this.logger.verbose("Creating custom Authority for custom domain scenario.");
          match = _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        return match;
      }
      /**
       * Helper function to determine if this host is included in the knownAuthorities config option
       */
      isInKnownAuthorities() {
        const matches = this.authorityOptions.knownAuthorities.filter((authority) => {
          return authority && UrlString.getDomainFromUrl(authority).toLowerCase() === this.hostnameAndPort;
        });
        return matches.length > 0;
      }
      /**
       * helper function to populate the authority based on azureCloudOptions
       * @param authorityString
       * @param azureCloudOptions
       */
      static generateAuthority(authorityString, azureCloudOptions) {
        let authorityAzureCloudInstance;
        if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {
          const tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;
          authorityAzureCloudInstance = `${azureCloudOptions.azureCloudInstance}/${tenant}/`;
        }
        return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;
      }
      /**
       * Creates cloud discovery metadata object from a given host
       * @param host
       */
      static createCloudDiscoveryMetadataFromHost(host) {
        return {
          preferred_network: host,
          preferred_cache: host,
          aliases: [host]
        };
      }
      /**
       * helper function to generate environment from authority object
       */
      getPreferredCache() {
        if (this.managedIdentity) {
          return Constants.DEFAULT_AUTHORITY_HOST;
        } else if (this.discoveryComplete()) {
          return this.metadata.preferred_cache;
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Returns whether or not the provided host is an alias of this authority instance
       * @param host
       */
      isAlias(host) {
        return this.metadata.aliases.indexOf(host) > -1;
      }
      /**
       * Returns whether or not the provided host is an alias of a known Microsoft authority for purposes of endpoint discovery
       * @param host
       */
      isAliasOfKnownMicrosoftAuthority(host) {
        return InstanceDiscoveryMetadataAliases.has(host);
      }
      /**
       * Checks whether the provided host is that of a public cloud authority
       *
       * @param authority string
       * @returns bool
       */
      static isPublicCloudAuthority(host) {
        return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;
      }
      /**
       * Rebuild the authority string with the region
       *
       * @param host string
       * @param region string
       */
      static buildRegionalAuthorityString(host, region, queryString) {
        const authorityUrlInstance = new UrlString(host);
        authorityUrlInstance.validateAsUri();
        const authorityUrlParts = authorityUrlInstance.getUrlComponents();
        let hostNameAndPort = `${region}.${authorityUrlParts.HostNameAndPort}`;
        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
          hostNameAndPort = `${region}.${Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;
        }
        const url2 = UrlString.constructAuthorityUriFromObject({
          ...authorityUrlInstance.getUrlComponents(),
          HostNameAndPort: hostNameAndPort
        }).urlString;
        if (queryString)
          return `${url2}?${queryString}`;
        return url2;
      }
      /**
       * Replace the endpoints in the metadata object with their regional equivalents.
       *
       * @param metadata OpenIdConfigResponse
       * @param azureRegion string
       */
      static replaceWithRegionalInformation(metadata, azureRegion) {
        const regionalMetadata = { ...metadata };
        regionalMetadata.authorization_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.authorization_endpoint, azureRegion);
        regionalMetadata.token_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.token_endpoint, azureRegion);
        if (regionalMetadata.end_session_endpoint) {
          regionalMetadata.end_session_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.end_session_endpoint, azureRegion);
        }
        return regionalMetadata;
      }
      /**
       * Transform CIAM_AUTHORIY as per the below rules:
       * If no path segments found and it is a CIAM authority (hostname ends with .ciamlogin.com), then transform it
       *
       * NOTE: The transformation path should go away once STS supports CIAM with the format: `tenantIdorDomain.ciamlogin.com`
       * `ciamlogin.com` can also change in the future and we should accommodate the same
       *
       * @param authority
       */
      static transformCIAMAuthority(authority) {
        let ciamAuthority = authority;
        const authorityUrl = new UrlString(authority);
        const authorityUrlComponents = authorityUrl.getUrlComponents();
        if (authorityUrlComponents.PathSegments.length === 0 && authorityUrlComponents.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {
          const tenantIdOrDomain = authorityUrlComponents.HostNameAndPort.split(".")[0];
          ciamAuthority = `${ciamAuthority}${tenantIdOrDomain}${Constants.AAD_TENANT_DOMAIN_SUFFIX}`;
        }
        return ciamAuthority;
      }
    };
    Authority.reservedTenantDomains = /* @__PURE__ */ new Set([
      "{tenant}",
      "{tenantid}",
      AADAuthorityConstants.COMMON,
      AADAuthorityConstants.CONSUMERS,
      AADAuthorityConstants.ORGANIZATIONS
    ]);
  }
});

// node_modules/@azure/msal-common/dist/authority/AuthorityFactory.mjs
var AuthorityFactory_exports = {};
__export(AuthorityFactory_exports, {
  createDiscoveredInstance: () => createDiscoveredInstance
});
async function createDiscoveredInstance(authorityUri, networkClient, cacheManager, authorityOptions, logger11, correlationId, performanceClient) {
  performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, correlationId);
  const authorityUriFinal = Authority.transformCIAMAuthority(formatAuthorityUri(authorityUri));
  const acquireTokenAuthority = new Authority(authorityUriFinal, networkClient, cacheManager, authorityOptions, logger11, correlationId, performanceClient);
  try {
    await invokeAsync(acquireTokenAuthority.resolveEndpointsAsync.bind(acquireTokenAuthority), PerformanceEvents.AuthorityResolveEndpointsAsync, logger11, performanceClient, correlationId)();
    return acquireTokenAuthority;
  } catch (e) {
    throw createClientAuthError(endpointResolutionError);
  }
}
var init_AuthorityFactory = __esm({
  "node_modules/@azure/msal-common/dist/authority/AuthorityFactory.mjs"() {
    "use strict";
    init_Authority();
    init_ClientAuthError();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/error/ServerError.mjs
var ServerError;
var init_ServerError = __esm({
  "node_modules/@azure/msal-common/dist/error/ServerError.mjs"() {
    "use strict";
    init_AuthError();
    ServerError = class _ServerError extends AuthError {
      constructor(errorCode, errorMessage, subError, errorNo, status) {
        super(errorCode, errorMessage, subError);
        this.name = "ServerError";
        this.errorNo = errorNo;
        this.status = status;
        Object.setPrototypeOf(this, _ServerError.prototype);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/network/RequestThumbprint.mjs
function getRequestThumbprint(clientId, request, homeAccountId) {
  return {
    clientId,
    authority: request.authority,
    scopes: request.scopes,
    homeAccountIdentifier: homeAccountId,
    claims: request.claims,
    authenticationScheme: request.authenticationScheme,
    resourceRequestMethod: request.resourceRequestMethod,
    resourceRequestUri: request.resourceRequestUri,
    shrClaims: request.shrClaims,
    sshKid: request.sshKid,
    embeddedClientId: request.embeddedClientId || request.tokenBodyParameters?.clientId
  };
}
var init_RequestThumbprint = __esm({
  "node_modules/@azure/msal-common/dist/network/RequestThumbprint.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/network/ThrottlingUtils.mjs
var ThrottlingUtils;
var init_ThrottlingUtils = __esm({
  "node_modules/@azure/msal-common/dist/network/ThrottlingUtils.mjs"() {
    "use strict";
    init_Constants();
    init_ServerError();
    init_RequestThumbprint();
    ThrottlingUtils = class _ThrottlingUtils {
      /**
       * Prepares a RequestThumbprint to be stored as a key.
       * @param thumbprint
       */
      static generateThrottlingStorageKey(thumbprint) {
        return `${ThrottlingConstants.THROTTLING_PREFIX}.${JSON.stringify(thumbprint)}`;
      }
      /**
       * Performs necessary throttling checks before a network request.
       * @param cacheManager
       * @param thumbprint
       */
      static preProcess(cacheManager, thumbprint, correlationId) {
        const key2 = _ThrottlingUtils.generateThrottlingStorageKey(thumbprint);
        const value = cacheManager.getThrottlingCache(key2);
        if (value) {
          if (value.throttleTime < Date.now()) {
            cacheManager.removeItem(key2, correlationId);
            return;
          }
          throw new ServerError(value.errorCodes?.join(" ") || Constants.EMPTY_STRING, value.errorMessage, value.subError);
        }
      }
      /**
       * Performs necessary throttling checks after a network request.
       * @param cacheManager
       * @param thumbprint
       * @param response
       */
      static postProcess(cacheManager, thumbprint, response, correlationId) {
        if (_ThrottlingUtils.checkResponseStatus(response) || _ThrottlingUtils.checkResponseForRetryAfter(response)) {
          const thumbprintValue = {
            throttleTime: _ThrottlingUtils.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])),
            error: response.body.error,
            errorCodes: response.body.error_codes,
            errorMessage: response.body.error_description,
            subError: response.body.suberror
          };
          cacheManager.setThrottlingCache(_ThrottlingUtils.generateThrottlingStorageKey(thumbprint), thumbprintValue, correlationId);
        }
      }
      /**
       * Checks a NetworkResponse object's status codes against 429 or 5xx
       * @param response
       */
      static checkResponseStatus(response) {
        return response.status === 429 || response.status >= 500 && response.status < 600;
      }
      /**
       * Checks a NetworkResponse object's RetryAfter header
       * @param response
       */
      static checkResponseForRetryAfter(response) {
        if (response.headers) {
          return response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) && (response.status < 200 || response.status >= 300);
        }
        return false;
      }
      /**
       * Calculates the Unix-time value for a throttle to expire given throttleTime in seconds.
       * @param throttleTime
       */
      static calculateThrottleTime(throttleTime) {
        const time = throttleTime <= 0 ? 0 : throttleTime;
        const currentSeconds = Date.now() / 1e3;
        return Math.floor(Math.min(currentSeconds + (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds + ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1e3);
      }
      static removeThrottle(cacheManager, clientId, request, homeAccountIdentifier) {
        const thumbprint = getRequestThumbprint(clientId, request, homeAccountIdentifier);
        const key2 = this.generateThrottlingStorageKey(thumbprint);
        cacheManager.removeItem(key2, request.correlationId);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/error/NetworkError.mjs
var NetworkError;
var init_NetworkError = __esm({
  "node_modules/@azure/msal-common/dist/error/NetworkError.mjs"() {
    "use strict";
    init_AuthError();
    NetworkError = class _NetworkError extends AuthError {
      constructor(error, httpStatus, responseHeaders) {
        super(error.errorCode, error.errorMessage, error.subError);
        Object.setPrototypeOf(this, _NetworkError.prototype);
        this.name = "NetworkError";
        this.error = error;
        this.httpStatus = httpStatus;
        this.responseHeaders = responseHeaders;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/client/BaseClient.mjs
var BaseClient;
var init_BaseClient = __esm({
  "node_modules/@azure/msal-common/dist/client/BaseClient.mjs"() {
    "use strict";
    init_ClientConfiguration();
    init_Logger();
    init_Constants();
    init_packageMetadata();
    init_CcsCredential();
    init_ClientInfo();
    init_RequestParameterBuilder();
    init_UrlUtils();
    init_AuthorityFactory();
    init_PerformanceEvent();
    init_ThrottlingUtils();
    init_AuthError();
    init_ClientAuthError();
    init_NetworkError();
    init_FunctionWrappers();
    init_ClientAuthErrorCodes();
    BaseClient = class {
      constructor(configuration, performanceClient) {
        this.config = buildClientConfiguration(configuration);
        this.logger = new Logger(this.config.loggerOptions, name, version);
        this.cryptoUtils = this.config.cryptoInterface;
        this.cacheManager = this.config.storageInterface;
        this.networkClient = this.config.networkInterface;
        this.serverTelemetryManager = this.config.serverTelemetryManager;
        this.authority = this.config.authOptions.authority;
        this.performanceClient = performanceClient;
      }
      /**
       * Creates default headers for requests to token endpoint
       */
      createTokenRequestHeaders(ccsCred) {
        const headers = {};
        headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
        if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
          switch (ccsCred.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                headers[HeaderNames.CCS_HEADER] = `Oid:${clientInfo.uid}@${clientInfo.utid}`;
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case CcsCredentialType.UPN:
              headers[HeaderNames.CCS_HEADER] = `UPN: ${ccsCred.credential}`;
              break;
          }
        }
        return headers;
      }
      /**
       * Http post to token endpoint
       * @param tokenEndpoint
       * @param queryString
       * @param headers
       * @param thumbprint
       */
      async executePostToTokenEndpoint(tokenEndpoint, queryString, headers, thumbprint, correlationId, queuedEvent) {
        if (queuedEvent) {
          this.performanceClient?.addQueueMeasurement(queuedEvent, correlationId);
        }
        const response = await this.sendPostRequest(thumbprint, tokenEndpoint, { body: queryString, headers }, correlationId);
        if (this.config.serverTelemetryManager && response.status < 500 && response.status !== 429) {
          this.config.serverTelemetryManager.clearTelemetryCache();
        }
        return response;
      }
      /**
       * Wraps sendPostRequestAsync with necessary preflight and postflight logic
       * @param thumbprint - Request thumbprint for throttling
       * @param tokenEndpoint - Endpoint to make the POST to
       * @param options - Body and Headers to include on the POST request
       * @param correlationId - CorrelationId for telemetry
       */
      async sendPostRequest(thumbprint, tokenEndpoint, options, correlationId) {
        ThrottlingUtils.preProcess(this.cacheManager, thumbprint, correlationId);
        let response;
        try {
          response = await invokeAsync(this.networkClient.sendPostRequestAsync.bind(this.networkClient), PerformanceEvents.NetworkClientSendPostRequestAsync, this.logger, this.performanceClient, correlationId)(tokenEndpoint, options);
          const responseHeaders = response.headers || {};
          this.performanceClient?.addFields({
            refreshTokenSize: response.body.refresh_token?.length || 0,
            httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",
            requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || ""
          }, correlationId);
        } catch (e) {
          if (e instanceof NetworkError) {
            const responseHeaders = e.responseHeaders;
            if (responseHeaders) {
              this.performanceClient?.addFields({
                httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",
                requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || "",
                contentTypeHeader: responseHeaders[HeaderNames.CONTENT_TYPE] || void 0,
                contentLengthHeader: responseHeaders[HeaderNames.CONTENT_LENGTH] || void 0,
                httpStatus: e.httpStatus
              }, correlationId);
            }
            throw e.error;
          }
          if (e instanceof AuthError) {
            throw e;
          } else {
            throw createClientAuthError(networkError);
          }
        }
        ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response, correlationId);
        return response;
      }
      /**
       * Updates the authority object of the client. Endpoint discovery must be completed.
       * @param updatedAuthority
       */
      async updateAuthority(cloudInstanceHostname, correlationId) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.UpdateTokenEndpointAuthority, correlationId);
        const cloudInstanceAuthorityUri = `https://${cloudInstanceHostname}/${this.authority.tenant}/`;
        const cloudInstanceAuthority = await createDiscoveredInstance(cloudInstanceAuthorityUri, this.networkClient, this.cacheManager, this.authority.options, this.logger, correlationId, this.performanceClient);
        this.authority = cloudInstanceAuthority;
      }
      /**
       * Creates query string for the /token request
       * @param request
       */
      createTokenQueryParameters(request) {
        const parameters = /* @__PURE__ */ new Map();
        if (request.embeddedClientId) {
          addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
        }
        if (request.tokenQueryParameters) {
          addExtraQueryParameters(parameters, request.tokenQueryParameters);
        }
        addCorrelationId(parameters, request.correlationId);
        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
        return mapToQueryString(parameters);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs
var noTokensFound, nativeAccountUnavailable, refreshTokenExpired, uxNotAllowed, interactionRequired, consentRequired, loginRequired, badToken;
var init_InteractionRequiredAuthErrorCodes = __esm({
  "node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs"() {
    "use strict";
    noTokensFound = "no_tokens_found";
    nativeAccountUnavailable = "native_account_unavailable";
    refreshTokenExpired = "refresh_token_expired";
    uxNotAllowed = "ux_not_allowed";
    interactionRequired = "interaction_required";
    consentRequired = "consent_required";
    loginRequired = "login_required";
    badToken = "bad_token";
  }
});

// node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs
function isInteractionRequiredError(errorCode, errorString, subError) {
  const isInteractionRequiredErrorCode = !!errorCode && InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
  const isInteractionRequiredSubError = !!subError && InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
  const isInteractionRequiredErrorDesc = !!errorString && InteractionRequiredServerErrorMessage.some((irErrorCode) => {
    return errorString.indexOf(irErrorCode) > -1;
  });
  return isInteractionRequiredErrorCode || isInteractionRequiredErrorDesc || isInteractionRequiredSubError;
}
function createInteractionRequiredAuthError(errorCode) {
  return new InteractionRequiredAuthError(errorCode, InteractionRequiredAuthErrorMessages[errorCode]);
}
var InteractionRequiredServerErrorMessage, InteractionRequiredAuthSubErrorMessage, InteractionRequiredAuthErrorMessages, InteractionRequiredAuthErrorMessage, InteractionRequiredAuthError;
var init_InteractionRequiredAuthError = __esm({
  "node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs"() {
    "use strict";
    init_Constants();
    init_AuthError();
    init_InteractionRequiredAuthErrorCodes();
    InteractionRequiredServerErrorMessage = [
      interactionRequired,
      consentRequired,
      loginRequired,
      badToken,
      uxNotAllowed
    ];
    InteractionRequiredAuthSubErrorMessage = [
      "message_only",
      "additional_action",
      "basic_action",
      "user_password_expired",
      "consent_required",
      "bad_token"
    ];
    InteractionRequiredAuthErrorMessages = {
      [noTokensFound]: "No refresh token found in the cache. Please sign-in.",
      [nativeAccountUnavailable]: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API.",
      [refreshTokenExpired]: "Refresh token has expired.",
      [badToken]: "Identity provider returned bad_token due to an expired or invalid refresh token. Please invoke an interactive API to resolve.",
      [uxNotAllowed]: "`canShowUI` flag in Edge was set to false. User interaction required on web page. Please invoke an interactive API to resolve."
    };
    InteractionRequiredAuthErrorMessage = {
      noTokensFoundError: {
        code: noTokensFound,
        desc: InteractionRequiredAuthErrorMessages[noTokensFound]
      },
      native_account_unavailable: {
        code: nativeAccountUnavailable,
        desc: InteractionRequiredAuthErrorMessages[nativeAccountUnavailable]
      },
      bad_token: {
        code: badToken,
        desc: InteractionRequiredAuthErrorMessages[badToken]
      }
    };
    InteractionRequiredAuthError = class _InteractionRequiredAuthError extends AuthError {
      constructor(errorCode, errorMessage, subError, timestamp2, traceId, correlationId, claims, errorNo) {
        super(errorCode, errorMessage, subError);
        Object.setPrototypeOf(this, _InteractionRequiredAuthError.prototype);
        this.timestamp = timestamp2 || Constants.EMPTY_STRING;
        this.traceId = traceId || Constants.EMPTY_STRING;
        this.correlationId = correlationId || Constants.EMPTY_STRING;
        this.claims = claims || Constants.EMPTY_STRING;
        this.name = "InteractionRequiredAuthError";
        this.errorNo = errorNo;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/utils/ProtocolUtils.mjs
var ProtocolUtils;
var init_ProtocolUtils = __esm({
  "node_modules/@azure/msal-common/dist/utils/ProtocolUtils.mjs"() {
    "use strict";
    init_Constants();
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
    ProtocolUtils = class _ProtocolUtils {
      /**
       * Appends user state with random guid, or returns random guid.
       * @param userState
       * @param randomGuid
       */
      static setRequestState(cryptoObj, userState, meta) {
        const libraryState = _ProtocolUtils.generateLibraryState(cryptoObj, meta);
        return userState ? `${libraryState}${Constants.RESOURCE_DELIM}${userState}` : libraryState;
      }
      /**
       * Generates the state value used by the common library.
       * @param randomGuid
       * @param cryptoObj
       */
      static generateLibraryState(cryptoObj, meta) {
        if (!cryptoObj) {
          throw createClientAuthError(noCryptoObject);
        }
        const stateObj = {
          id: cryptoObj.createNewGuid()
        };
        if (meta) {
          stateObj.meta = meta;
        }
        const stateString = JSON.stringify(stateObj);
        return cryptoObj.base64Encode(stateString);
      }
      /**
       * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.
       * @param state
       * @param cryptoObj
       */
      static parseRequestState(cryptoObj, state2) {
        if (!cryptoObj) {
          throw createClientAuthError(noCryptoObject);
        }
        if (!state2) {
          throw createClientAuthError(invalidState);
        }
        try {
          const splitState = state2.split(Constants.RESOURCE_DELIM);
          const libraryState = splitState[0];
          const userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : Constants.EMPTY_STRING;
          const libraryStateString = cryptoObj.base64Decode(libraryState);
          const libraryStateObj = JSON.parse(libraryStateString);
          return {
            userRequestState: userState || Constants.EMPTY_STRING,
            libraryState: libraryStateObj
          };
        } catch (e) {
          throw createClientAuthError(invalidState);
        }
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/crypto/PopTokenGenerator.mjs
var KeyLocation, PopTokenGenerator;
var init_PopTokenGenerator = __esm({
  "node_modules/@azure/msal-common/dist/crypto/PopTokenGenerator.mjs"() {
    "use strict";
    init_TimeUtils();
    init_UrlString();
    init_PerformanceEvent();
    init_FunctionWrappers();
    KeyLocation = {
      SW: "sw"
    };
    PopTokenGenerator = class {
      constructor(cryptoUtils, performanceClient) {
        this.cryptoUtils = cryptoUtils;
        this.performanceClient = performanceClient;
      }
      /**
       * Generates the req_cnf validated at the RP in the POP protocol for SHR parameters
       * and returns an object containing the keyid, the full req_cnf string and the req_cnf string hash
       * @param request
       * @returns
       */
      async generateCnf(request, logger11) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);
        const reqCnf = await invokeAsync(this.generateKid.bind(this), PerformanceEvents.PopTokenGenerateCnf, logger11, this.performanceClient, request.correlationId)(request);
        const reqCnfString = this.cryptoUtils.base64UrlEncode(JSON.stringify(reqCnf));
        return {
          kid: reqCnf.kid,
          reqCnfString
        };
      }
      /**
       * Generates key_id for a SHR token request
       * @param request
       * @returns
       */
      async generateKid(request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.PopTokenGenerateKid, request.correlationId);
        const kidThumbprint = await this.cryptoUtils.getPublicKeyThumbprint(request);
        return {
          kid: kidThumbprint,
          xms_ksl: KeyLocation.SW
        };
      }
      /**
       * Signs the POP access_token with the local generated key-pair
       * @param accessToken
       * @param request
       * @returns
       */
      async signPopToken(accessToken, keyId, request) {
        return this.signPayload(accessToken, keyId, request);
      }
      /**
       * Utility function to generate the signed JWT for an access_token
       * @param payload
       * @param kid
       * @param request
       * @param claims
       * @returns
       */
      async signPayload(payload, keyId, request, claims) {
        const { resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, shrOptions } = request;
        const resourceUrlString = resourceRequestUri ? new UrlString(resourceRequestUri) : void 0;
        const resourceUrlComponents = resourceUrlString?.getUrlComponents();
        return this.cryptoUtils.signJwt({
          at: payload,
          ts: nowSeconds(),
          m: resourceRequestMethod?.toUpperCase(),
          u: resourceUrlComponents?.HostNameAndPort,
          nonce: shrNonce || this.cryptoUtils.createNewGuid(),
          p: resourceUrlComponents?.AbsolutePath,
          q: resourceUrlComponents?.QueryString ? [[], resourceUrlComponents.QueryString] : void 0,
          client_claims: shrClaims || void 0,
          ...claims
        }, keyId, shrOptions, request.correlationId);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs
var TokenCacheContext;
var init_TokenCacheContext = __esm({
  "node_modules/@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs"() {
    "use strict";
    TokenCacheContext = class {
      constructor(tokenCache, hasChanged) {
        this.cache = tokenCache;
        this.hasChanged = hasChanged;
      }
      /**
       * boolean which indicates the changes in cache
       */
      get cacheHasChanged() {
        return this.hasChanged;
      }
      /**
       * function to retrieve the token cache
       */
      get tokenCache() {
        return this.cache;
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/response/ResponseHandler.mjs
function buildAccountToCache(cacheStorage, authority, homeAccountId, base64Decode, correlationId, idTokenClaims, clientInfo, environment, claimsTenantId, authCodePayload, nativeAccountId, logger11) {
  logger11?.verbose("setCachedAccount called");
  const accountKeys = cacheStorage.getAccountKeys();
  const baseAccountKey = accountKeys.find((accountKey) => {
    return accountKey.startsWith(homeAccountId);
  });
  let cachedAccount = null;
  if (baseAccountKey) {
    cachedAccount = cacheStorage.getAccount(baseAccountKey, correlationId);
  }
  const baseAccount = cachedAccount || AccountEntity.createAccount({
    homeAccountId,
    idTokenClaims,
    clientInfo,
    environment,
    cloudGraphHostName: authCodePayload?.cloud_graph_host_name,
    msGraphHost: authCodePayload?.msgraph_host,
    nativeAccountId
  }, authority, base64Decode);
  const tenantProfiles = baseAccount.tenantProfiles || [];
  const tenantId = claimsTenantId || baseAccount.realm;
  if (tenantId && !tenantProfiles.find((tenantProfile) => {
    return tenantProfile.tenantId === tenantId;
  })) {
    const newTenantProfile = buildTenantProfile(homeAccountId, baseAccount.localAccountId, tenantId, idTokenClaims);
    tenantProfiles.push(newTenantProfile);
  }
  baseAccount.tenantProfiles = tenantProfiles;
  return baseAccount;
}
var ResponseHandler;
var init_ResponseHandler = __esm({
  "node_modules/@azure/msal-common/dist/response/ResponseHandler.mjs"() {
    "use strict";
    init_ClientAuthError();
    init_ServerError();
    init_ScopeSet();
    init_AccountEntity();
    init_InteractionRequiredAuthError();
    init_ProtocolUtils();
    init_Constants();
    init_PopTokenGenerator();
    init_TokenCacheContext();
    init_PerformanceEvent();
    init_AuthToken();
    init_TokenClaims();
    init_AccountInfo();
    init_CacheHelpers();
    init_TimeUtils();
    init_ClientAuthErrorCodes();
    ResponseHandler = class _ResponseHandler {
      constructor(clientId, cacheStorage, cryptoObj, logger11, serializableCache, persistencePlugin, performanceClient) {
        this.clientId = clientId;
        this.cacheStorage = cacheStorage;
        this.cryptoObj = cryptoObj;
        this.logger = logger11;
        this.serializableCache = serializableCache;
        this.persistencePlugin = persistencePlugin;
        this.performanceClient = performanceClient;
      }
      /**
       * Function which validates server authorization token response.
       * @param serverResponse
       * @param refreshAccessToken
       */
      validateTokenResponse(serverResponse, refreshAccessToken) {
        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
          const errString = `Error(s): ${serverResponse.error_codes || Constants.NOT_AVAILABLE} - Timestamp: ${serverResponse.timestamp || Constants.NOT_AVAILABLE} - Description: ${serverResponse.error_description || Constants.NOT_AVAILABLE} - Correlation ID: ${serverResponse.correlation_id || Constants.NOT_AVAILABLE} - Trace ID: ${serverResponse.trace_id || Constants.NOT_AVAILABLE}`;
          const serverErrorNo = serverResponse.error_codes?.length ? serverResponse.error_codes[0] : void 0;
          const serverError = new ServerError(serverResponse.error, errString, serverResponse.suberror, serverErrorNo, serverResponse.status);
          if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START && serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END) {
            this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.
${serverError}`);
            return;
          } else if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START && serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END) {
            this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.
${serverError}`);
            return;
          }
          if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
            throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING, serverErrorNo);
          }
          throw serverError;
        }
      }
      /**
       * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.
       * @param serverTokenResponse
       * @param authority
       */
      async handleServerTokenResponse(serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);
        let idTokenClaims;
        if (serverTokenResponse.id_token) {
          idTokenClaims = extractTokenClaims(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj.base64Decode);
          if (authCodePayload && authCodePayload.nonce) {
            if (idTokenClaims.nonce !== authCodePayload.nonce) {
              throw createClientAuthError(nonceMismatch);
            }
          }
          if (request.maxAge || request.maxAge === 0) {
            const authTime = idTokenClaims.auth_time;
            if (!authTime) {
              throw createClientAuthError(authTimeNotFound);
            }
            checkMaxAge(authTime, request.maxAge);
          }
        }
        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);
        let requestStateObj;
        if (!!authCodePayload && !!authCodePayload.state) {
          requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);
        }
        serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || void 0;
        const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload);
        let cacheContext;
        try {
          if (this.persistencePlugin && this.serializableCache) {
            this.logger.verbose("Persistence enabled, calling beforeCacheAccess");
            cacheContext = new TokenCacheContext(this.serializableCache, true);
            await this.persistencePlugin.beforeCacheAccess(cacheContext);
          }
          if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {
            const key2 = this.cacheStorage.generateAccountKey(AccountEntity.getAccountInfo(cacheRecord.account));
            const account = this.cacheStorage.getAccount(key2, request.correlationId);
            if (!account) {
              this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");
              return await _ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, void 0, serverRequestId);
            }
          }
          await this.cacheStorage.saveCacheRecord(cacheRecord, request.correlationId, isKmsi(idTokenClaims || {}), request.storeInCache);
        } finally {
          if (this.persistencePlugin && this.serializableCache && cacheContext) {
            this.logger.verbose("Persistence enabled, calling afterCacheAccess");
            await this.persistencePlugin.afterCacheAccess(cacheContext);
          }
        }
        return _ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, serverTokenResponse, serverRequestId);
      }
      /**
       * Generates CacheRecord
       * @param serverTokenResponse
       * @param idTokenObj
       * @param authority
       */
      generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload) {
        const env5 = authority.getPreferredCache();
        if (!env5) {
          throw createClientAuthError(invalidCacheEnvironment);
        }
        const claimsTenantId = getTenantIdFromIdTokenClaims(idTokenClaims);
        let cachedIdToken;
        let cachedAccount;
        if (serverTokenResponse.id_token && !!idTokenClaims) {
          cachedIdToken = createIdTokenEntity(this.homeAccountIdentifier, env5, serverTokenResponse.id_token, this.clientId, claimsTenantId || "");
          cachedAccount = buildAccountToCache(
            this.cacheStorage,
            authority,
            this.homeAccountIdentifier,
            this.cryptoObj.base64Decode,
            request.correlationId,
            idTokenClaims,
            serverTokenResponse.client_info,
            env5,
            claimsTenantId,
            authCodePayload,
            void 0,
            // nativeAccountId
            this.logger
          );
        }
        let cachedAccessToken = null;
        if (serverTokenResponse.access_token) {
          const responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);
          const expiresIn = (typeof serverTokenResponse.expires_in === "string" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;
          const extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;
          const refreshIn = (typeof serverTokenResponse.refresh_in === "string" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || void 0;
          const tokenExpirationSeconds = reqTimestamp + expiresIn;
          const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
          const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : void 0;
          cachedAccessToken = createAccessTokenEntity(this.homeAccountIdentifier, env5, serverTokenResponse.access_token, this.clientId, claimsTenantId || authority.tenant || "", responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj.base64Decode, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);
        }
        let cachedRefreshToken = null;
        if (serverTokenResponse.refresh_token) {
          let rtExpiresOn;
          if (serverTokenResponse.refresh_token_expires_in) {
            const rtExpiresIn = typeof serverTokenResponse.refresh_token_expires_in === "string" ? parseInt(serverTokenResponse.refresh_token_expires_in, 10) : serverTokenResponse.refresh_token_expires_in;
            rtExpiresOn = reqTimestamp + rtExpiresIn;
          }
          cachedRefreshToken = createRefreshTokenEntity(this.homeAccountIdentifier, env5, serverTokenResponse.refresh_token, this.clientId, serverTokenResponse.foci, userAssertionHash, rtExpiresOn);
        }
        let cachedAppMetadata = null;
        if (serverTokenResponse.foci) {
          cachedAppMetadata = {
            clientId: this.clientId,
            environment: env5,
            familyId: serverTokenResponse.foci
          };
        }
        return {
          account: cachedAccount,
          idToken: cachedIdToken,
          accessToken: cachedAccessToken,
          refreshToken: cachedRefreshToken,
          appMetadata: cachedAppMetadata
        };
      }
      /**
       * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.
       *
       * Optionally takes a state string that is set as-is in the response.
       *
       * @param cacheRecord
       * @param idTokenObj
       * @param fromTokenCache
       * @param stateString
       */
      static async generateAuthenticationResult(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenClaims, requestState, serverTokenResponse, requestId) {
        let accessToken = Constants.EMPTY_STRING;
        let responseScopes = [];
        let expiresOn = null;
        let extExpiresOn;
        let refreshOn;
        let familyId = Constants.EMPTY_STRING;
        if (cacheRecord.accessToken) {
          if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP && !request.popKid) {
            const popTokenGenerator = new PopTokenGenerator(cryptoObj);
            const { secret, keyId } = cacheRecord.accessToken;
            if (!keyId) {
              throw createClientAuthError(keyIdMissing);
            }
            accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);
          } else {
            accessToken = cacheRecord.accessToken.secret;
          }
          responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
          expiresOn = toDateFromSeconds(cacheRecord.accessToken.expiresOn);
          extExpiresOn = toDateFromSeconds(cacheRecord.accessToken.extendedExpiresOn);
          if (cacheRecord.accessToken.refreshOn) {
            refreshOn = toDateFromSeconds(cacheRecord.accessToken.refreshOn);
          }
        }
        if (cacheRecord.appMetadata) {
          familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : "";
        }
        const uid = idTokenClaims?.oid || idTokenClaims?.sub || "";
        const tid = idTokenClaims?.tid || "";
        if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {
          cacheRecord.account.nativeAccountId = serverTokenResponse?.spa_accountid;
        }
        const accountInfo = cacheRecord.account ? updateAccountTenantProfileData(
          AccountEntity.getAccountInfo(cacheRecord.account),
          void 0,
          // tenantProfile optional
          idTokenClaims,
          cacheRecord.idToken?.secret
        ) : null;
        return {
          authority: authority.canonicalAuthority,
          uniqueId: uid,
          tenantId: tid,
          scopes: responseScopes,
          account: accountInfo,
          idToken: cacheRecord?.idToken?.secret || "",
          idTokenClaims: idTokenClaims || {},
          accessToken,
          fromCache: fromTokenCache,
          expiresOn,
          extExpiresOn,
          refreshOn,
          correlationId: request.correlationId,
          requestId: requestId || Constants.EMPTY_STRING,
          familyId,
          tokenType: cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,
          state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,
          cloudGraphHostName: cacheRecord.account?.cloudGraphHostName || Constants.EMPTY_STRING,
          msGraphHost: cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,
          code: serverTokenResponse?.spa_code,
          fromNativeBroker: false
        };
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/utils/ClientAssertionUtils.mjs
async function getClientAssertion(clientAssertion, clientId, tokenEndpoint) {
  if (typeof clientAssertion === "string") {
    return clientAssertion;
  } else {
    const config = {
      clientId,
      tokenEndpoint
    };
    return clientAssertion(config);
  }
}
var init_ClientAssertionUtils = __esm({
  "node_modules/@azure/msal-common/dist/utils/ClientAssertionUtils.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-common/dist/client/AuthorizationCodeClient.mjs
var AuthorizationCodeClient;
var init_AuthorizationCodeClient = __esm({
  "node_modules/@azure/msal-common/dist/client/AuthorizationCodeClient.mjs"() {
    "use strict";
    init_BaseClient();
    init_RequestParameterBuilder();
    init_UrlUtils();
    init_Constants();
    init_AADServerParamKeys();
    init_ClientConfiguration();
    init_ResponseHandler();
    init_StringUtils();
    init_ClientAuthError();
    init_UrlString();
    init_PopTokenGenerator();
    init_TimeUtils();
    init_ClientInfo();
    init_CcsCredential();
    init_ClientConfigurationError();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_ClientAssertionUtils();
    init_RequestThumbprint();
    init_ClientAuthErrorCodes();
    init_ClientConfigurationErrorCodes();
    AuthorizationCodeClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
        this.includeRedirectUri = true;
        this.oidcDefaultScopes = this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;
      }
      /**
       * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the
       * authorization_code_grant
       * @param request
       */
      async acquireToken(request, authCodePayload) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);
        if (!request.code) {
          throw createClientAuthError(requestCannotBeMade);
        }
        const reqTimestamp = nowSeconds();
        const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.AuthClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(this.authority, request);
        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);
        responseHandler.validateTokenResponse(response.body);
        return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, authCodePayload, void 0, void 0, void 0, requestId);
      }
      /**
       * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.
       * Default behaviour is to redirect the user to `window.location.href`.
       * @param authorityUri
       */
      getLogoutUri(logoutRequest) {
        if (!logoutRequest) {
          throw createClientConfigurationError(logoutRequestEmpty);
        }
        const queryString = this.createLogoutUrlQueryString(logoutRequest);
        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);
      }
      /**
       * Executes POST request to token endpoint
       * @param authority
       * @param request
       */
      async executeTokenRequest(authority, request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
        const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.AuthClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);
        let ccsCredential = void 0;
        if (request.clientInfo) {
          try {
            const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
            ccsCredential = {
              credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
              type: CcsCredentialType.HOME_ACCOUNT_ID
            };
          } catch (e) {
            this.logger.verbose("Could not parse client info for CCS Header: " + e);
          }
        }
        const headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);
        const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
        return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint);
      }
      /**
       * Generates a map for all the params to be sent to the service
       * @param request
       */
      async createTokenRequestBody(request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);
        const parameters = /* @__PURE__ */ new Map();
        addClientId(parameters, request.embeddedClientId || request.tokenBodyParameters?.[CLIENT_ID] || this.config.authOptions.clientId);
        if (!this.includeRedirectUri) {
          if (!request.redirectUri) {
            throw createClientConfigurationError(redirectUriEmpty);
          }
        } else {
          addRedirectUri(parameters, request.redirectUri);
        }
        addScopes(parameters, request.scopes, true, this.oidcDefaultScopes);
        addAuthorizationCode(parameters, request.code);
        addLibraryInfo(parameters, this.config.libraryInfo);
        addApplicationTelemetry(parameters, this.config.telemetry.application);
        addThrottling(parameters);
        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
          addServerTelemetry(parameters, this.serverTelemetryManager);
        }
        if (request.codeVerifier) {
          addCodeVerifier(parameters, request.codeVerifier);
        }
        if (this.config.clientCredentials.clientSecret) {
          addClientSecret(parameters, this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
          const clientAssertion = this.config.clientCredentials.clientAssertion;
          addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
          addClientAssertionType(parameters, clientAssertion.assertionType);
        }
        addGrantType(parameters, GrantType.AUTHORIZATION_CODE_GRANT);
        addClientInfo(parameters);
        if (request.authenticationScheme === AuthenticationScheme.POP) {
          const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
          let reqCnfData;
          if (!request.popKid) {
            const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);
            reqCnfData = generatedReqCnfData.reqCnfString;
          } else {
            reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
          }
          addPopToken(parameters, reqCnfData);
        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {
          if (request.sshJwk) {
            addSshJwk(parameters, request.sshJwk);
          } else {
            throw createClientConfigurationError(missingSshJwk);
          }
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        let ccsCred = void 0;
        if (request.clientInfo) {
          try {
            const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
            ccsCred = {
              credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
              type: CcsCredentialType.HOME_ACCOUNT_ID
            };
          } catch (e) {
            this.logger.verbose("Could not parse client info for CCS Header: " + e);
          }
        } else {
          ccsCred = request.ccsCredential;
        }
        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
          switch (ccsCred.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                addCcsOid(parameters, clientInfo);
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case CcsCredentialType.UPN:
              addCcsUpn(parameters, ccsCred.credential);
              break;
          }
        }
        if (request.embeddedClientId) {
          addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
        }
        if (request.tokenBodyParameters) {
          addExtraQueryParameters(parameters, request.tokenBodyParameters);
        }
        if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[RETURN_SPA_CODE])) {
          addExtraQueryParameters(parameters, {
            [RETURN_SPA_CODE]: "1"
          });
        }
        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
        return mapToQueryString(parameters);
      }
      /**
       * This API validates the `EndSessionRequest` and creates a URL
       * @param request
       */
      createLogoutUrlQueryString(request) {
        const parameters = /* @__PURE__ */ new Map();
        if (request.postLogoutRedirectUri) {
          addPostLogoutRedirectUri(parameters, request.postLogoutRedirectUri);
        }
        if (request.correlationId) {
          addCorrelationId(parameters, request.correlationId);
        }
        if (request.idTokenHint) {
          addIdTokenHint(parameters, request.idTokenHint);
        }
        if (request.state) {
          addState(parameters, request.state);
        }
        if (request.logoutHint) {
          addLogoutHint(parameters, request.logoutHint);
        }
        if (request.extraQueryParameters) {
          addExtraQueryParameters(parameters, request.extraQueryParameters);
        }
        if (this.config.authOptions.instanceAware) {
          addInstanceAware(parameters);
        }
        return mapToQueryString(parameters, this.config.authOptions.encodeExtraQueryParams, request.extraQueryParameters);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/client/RefreshTokenClient.mjs
var DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS, RefreshTokenClient;
var init_RefreshTokenClient = __esm({
  "node_modules/@azure/msal-common/dist/client/RefreshTokenClient.mjs"() {
    "use strict";
    init_ClientConfiguration();
    init_BaseClient();
    init_RequestParameterBuilder();
    init_UrlUtils();
    init_Constants();
    init_AADServerParamKeys();
    init_ResponseHandler();
    init_PopTokenGenerator();
    init_StringUtils();
    init_ClientConfigurationError();
    init_ClientAuthError();
    init_ServerError();
    init_TimeUtils();
    init_UrlString();
    init_CcsCredential();
    init_ClientInfo();
    init_InteractionRequiredAuthError();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_ClientAssertionUtils();
    init_RequestThumbprint();
    init_InteractionRequiredAuthErrorCodes();
    init_ClientConfigurationErrorCodes();
    init_ClientAuthErrorCodes();
    DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS = 300;
    RefreshTokenClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
      }
      async acquireToken(request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);
        const reqTimestamp = nowSeconds();
        const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.RefreshTokenClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(request, this.authority);
        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
        responseHandler.validateTokenResponse(response.body);
        return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, void 0, void 0, true, request.forceCache, requestId);
      }
      /**
       * Gets cached refresh token and attaches to request, then calls acquireToken API
       * @param request
       */
      async acquireTokenByRefreshToken(request) {
        if (!request) {
          throw createClientConfigurationError(tokenRequestEmpty);
        }
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, request.correlationId);
        if (!request.account) {
          throw createClientAuthError(noAccountInSilentRequest);
        }
        const isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment);
        if (isFOCI) {
          try {
            return await invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, true);
          } catch (e) {
            const noFamilyRTInCache = e instanceof InteractionRequiredAuthError && e.errorCode === noTokensFound;
            const clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;
            if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
              return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false);
            } else {
              throw e;
            }
          }
        }
        return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false);
      }
      /**
       * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached
       * @param request
       */
      async acquireTokenWithCachedRefreshToken(request, foci) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);
        const refreshToken = invoke(this.cacheManager.getRefreshToken.bind(this.cacheManager), PerformanceEvents.CacheManagerGetRefreshToken, this.logger, this.performanceClient, request.correlationId)(request.account, foci, request.correlationId, void 0, this.performanceClient);
        if (!refreshToken) {
          throw createInteractionRequiredAuthError(noTokensFound);
        }
        if (refreshToken.expiresOn && isTokenExpired(refreshToken.expiresOn, request.refreshTokenExpirationOffsetSeconds || DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS)) {
          this.performanceClient?.addFields({ rtExpiresOnMs: Number(refreshToken.expiresOn) }, request.correlationId);
          throw createInteractionRequiredAuthError(refreshTokenExpired);
        }
        const refreshTokenRequest = {
          ...request,
          refreshToken: refreshToken.secret,
          authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,
          ccsCredential: {
            credential: request.account.homeAccountId,
            type: CcsCredentialType.HOME_ACCOUNT_ID
          }
        };
        try {
          return await invokeAsync(this.acquireToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(refreshTokenRequest);
        } catch (e) {
          if (e instanceof InteractionRequiredAuthError) {
            this.performanceClient?.addFields({ rtExpiresOnMs: Number(refreshToken.expiresOn) }, request.correlationId);
            if (e.subError === badToken) {
              this.logger.verbose("acquireTokenWithRefreshToken: bad refresh token, removing from cache");
              const badRefreshTokenKey = this.cacheManager.generateCredentialKey(refreshToken);
              this.cacheManager.removeRefreshToken(badRefreshTokenKey, request.correlationId);
            }
          }
          throw e;
        }
      }
      /**
       * Constructs the network message and makes a NW call to the underlying secure token service
       * @param request
       * @param authority
       */
      async executeTokenRequest(request, authority) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
        const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);
        const headers = this.createTokenRequestHeaders(request.ccsCredential);
        const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
        return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint);
      }
      /**
       * Helper function to create the token request body
       * @param request
       */
      async createTokenRequestBody(request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request.correlationId);
        const parameters = /* @__PURE__ */ new Map();
        addClientId(parameters, request.embeddedClientId || request.tokenBodyParameters?.[CLIENT_ID] || this.config.authOptions.clientId);
        if (request.redirectUri) {
          addRedirectUri(parameters, request.redirectUri);
        }
        addScopes(parameters, request.scopes, true, this.config.authOptions.authority.options.OIDCOptions?.defaultScopes);
        addGrantType(parameters, GrantType.REFRESH_TOKEN_GRANT);
        addClientInfo(parameters);
        addLibraryInfo(parameters, this.config.libraryInfo);
        addApplicationTelemetry(parameters, this.config.telemetry.application);
        addThrottling(parameters);
        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
          addServerTelemetry(parameters, this.serverTelemetryManager);
        }
        addRefreshToken(parameters, request.refreshToken);
        if (this.config.clientCredentials.clientSecret) {
          addClientSecret(parameters, this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
          const clientAssertion = this.config.clientCredentials.clientAssertion;
          addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
          addClientAssertionType(parameters, clientAssertion.assertionType);
        }
        if (request.authenticationScheme === AuthenticationScheme.POP) {
          const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
          let reqCnfData;
          if (!request.popKid) {
            const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);
            reqCnfData = generatedReqCnfData.reqCnfString;
          } else {
            reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
          }
          addPopToken(parameters, reqCnfData);
        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {
          if (request.sshJwk) {
            addSshJwk(parameters, request.sshJwk);
          } else {
            throw createClientConfigurationError(missingSshJwk);
          }
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        if (this.config.systemOptions.preventCorsPreflight && request.ccsCredential) {
          switch (request.ccsCredential.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);
                addCcsOid(parameters, clientInfo);
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case CcsCredentialType.UPN:
              addCcsUpn(parameters, request.ccsCredential.credential);
              break;
          }
        }
        if (request.embeddedClientId) {
          addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
        }
        if (request.tokenBodyParameters) {
          addExtraQueryParameters(parameters, request.tokenBodyParameters);
        }
        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
        return mapToQueryString(parameters);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/client/SilentFlowClient.mjs
var SilentFlowClient;
var init_SilentFlowClient = __esm({
  "node_modules/@azure/msal-common/dist/client/SilentFlowClient.mjs"() {
    "use strict";
    init_BaseClient();
    init_TimeUtils();
    init_ClientAuthError();
    init_ResponseHandler();
    init_Constants();
    init_StringUtils();
    init_AuthToken();
    init_PerformanceEvent();
    init_FunctionWrappers();
    init_Authority();
    init_ClientAuthErrorCodes();
    SilentFlowClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
      }
      /**
       * Retrieves token from cache or throws an error if it must be refreshed.
       * @param request
       */
      async acquireCachedToken(request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientAcquireCachedToken, request.correlationId);
        let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;
        if (request.forceRefresh || !this.config.cacheOptions.claimsBasedCachingEnabled && !StringUtils.isEmptyObj(request.claims)) {
          this.setCacheOutcome(CacheOutcome.FORCE_REFRESH_OR_CLAIMS, request.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        }
        if (!request.account) {
          throw createClientAuthError(noAccountInSilentRequest);
        }
        const requestTenantId = request.account.tenantId || getTenantFromAuthorityString(request.authority);
        const tokenKeys = this.cacheManager.getTokenKeys();
        const cachedAccessToken = this.cacheManager.getAccessToken(request.account, request, tokenKeys, requestTenantId);
        if (!cachedAccessToken) {
          this.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN, request.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        } else if (wasClockTurnedBack(cachedAccessToken.cachedAt) || isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
          this.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED, request.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        } else if (cachedAccessToken.refreshOn && isTokenExpired(cachedAccessToken.refreshOn, 0)) {
          lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;
        }
        const environment = request.authority || this.authority.getPreferredCache();
        const cacheRecord = {
          account: this.cacheManager.getAccount(this.cacheManager.generateAccountKey(request.account), request.correlationId),
          accessToken: cachedAccessToken,
          idToken: this.cacheManager.getIdToken(request.account, request.correlationId, tokenKeys, requestTenantId, this.performanceClient),
          refreshToken: null,
          appMetadata: this.cacheManager.readAppMetadataFromCache(environment)
        };
        this.setCacheOutcome(lastCacheOutcome, request.correlationId);
        if (this.config.serverTelemetryManager) {
          this.config.serverTelemetryManager.incrementCacheHits();
        }
        return [
          await invokeAsync(this.generateResultFromCacheRecord.bind(this), PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, this.logger, this.performanceClient, request.correlationId)(cacheRecord, request),
          lastCacheOutcome
        ];
      }
      setCacheOutcome(cacheOutcome, correlationId) {
        this.serverTelemetryManager?.setCacheOutcome(cacheOutcome);
        this.performanceClient?.addFields({
          cacheOutcome
        }, correlationId);
        if (cacheOutcome !== CacheOutcome.NOT_APPLICABLE) {
          this.logger.info(`Token refresh is required due to cache outcome: ${cacheOutcome}`);
        }
      }
      /**
       * Helper function to build response object from the CacheRecord
       * @param cacheRecord
       */
      async generateResultFromCacheRecord(cacheRecord, request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, request.correlationId);
        let idTokenClaims;
        if (cacheRecord.idToken) {
          idTokenClaims = extractTokenClaims(cacheRecord.idToken.secret, this.config.cryptoInterface.base64Decode);
        }
        if (request.maxAge || request.maxAge === 0) {
          const authTime = idTokenClaims?.auth_time;
          if (!authTime) {
            throw createClientAuthError(authTimeNotFound);
          }
          checkMaxAge(authTime, request.maxAge);
        }
        return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenClaims);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/protocol/Authorize.mjs
var Authorize_exports = {};
__export(Authorize_exports, {
  getAuthorizationCodePayload: () => getAuthorizationCodePayload,
  getAuthorizeUrl: () => getAuthorizeUrl,
  getStandardAuthorizeRequestParameters: () => getStandardAuthorizeRequestParameters,
  validateAuthorizationResponse: () => validateAuthorizationResponse
});
function getStandardAuthorizeRequestParameters(authOptions, request, logger11, performanceClient) {
  const correlationId = request.correlationId;
  const parameters = /* @__PURE__ */ new Map();
  addClientId(parameters, request.embeddedClientId || request.extraQueryParameters?.[CLIENT_ID] || authOptions.clientId);
  const requestScopes = [
    ...request.scopes || [],
    ...request.extraScopesToConsent || []
  ];
  addScopes(parameters, requestScopes, true, authOptions.authority.options.OIDCOptions?.defaultScopes);
  addRedirectUri(parameters, request.redirectUri);
  addCorrelationId(parameters, correlationId);
  addResponseMode(parameters, request.responseMode);
  addClientInfo(parameters);
  if (request.prompt) {
    addPrompt(parameters, request.prompt);
    performanceClient?.addFields({ prompt: request.prompt }, correlationId);
  }
  if (request.domainHint) {
    addDomainHint(parameters, request.domainHint);
    performanceClient?.addFields({ domainHintFromRequest: true }, correlationId);
  }
  if (request.prompt !== PromptValue.SELECT_ACCOUNT) {
    if (request.sid && request.prompt === PromptValue.NONE) {
      logger11.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");
      addSid(parameters, request.sid);
      performanceClient?.addFields({ sidFromRequest: true }, correlationId);
    } else if (request.account) {
      const accountSid = extractAccountSid(request.account);
      let accountLoginHintClaim = extractLoginHint(request.account);
      if (accountLoginHintClaim && request.domainHint) {
        logger11.warning(`AuthorizationCodeClient.createAuthCodeUrlQueryString: "domainHint" param is set, skipping opaque "login_hint" claim. Please consider not passing domainHint`);
        accountLoginHintClaim = null;
      }
      if (accountLoginHintClaim) {
        logger11.verbose("createAuthCodeUrlQueryString: login_hint claim present on account");
        addLoginHint(parameters, accountLoginHintClaim);
        performanceClient?.addFields({ loginHintFromClaim: true }, correlationId);
        try {
          const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
          addCcsOid(parameters, clientInfo);
        } catch (e) {
          logger11.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
        }
      } else if (accountSid && request.prompt === PromptValue.NONE) {
        logger11.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");
        addSid(parameters, accountSid);
        performanceClient?.addFields({ sidFromClaim: true }, correlationId);
        try {
          const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
          addCcsOid(parameters, clientInfo);
        } catch (e) {
          logger11.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
        }
      } else if (request.loginHint) {
        logger11.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");
        addLoginHint(parameters, request.loginHint);
        addCcsUpn(parameters, request.loginHint);
        performanceClient?.addFields({ loginHintFromRequest: true }, correlationId);
      } else if (request.account.username) {
        logger11.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");
        addLoginHint(parameters, request.account.username);
        performanceClient?.addFields({ loginHintFromUpn: true }, correlationId);
        try {
          const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
          addCcsOid(parameters, clientInfo);
        } catch (e) {
          logger11.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
        }
      }
    } else if (request.loginHint) {
      logger11.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");
      addLoginHint(parameters, request.loginHint);
      addCcsUpn(parameters, request.loginHint);
      performanceClient?.addFields({ loginHintFromRequest: true }, correlationId);
    }
  } else {
    logger11.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
  }
  if (request.nonce) {
    addNonce(parameters, request.nonce);
  }
  if (request.state) {
    addState(parameters, request.state);
  }
  if (request.claims || authOptions.clientCapabilities && authOptions.clientCapabilities.length > 0) {
    addClaims(parameters, request.claims, authOptions.clientCapabilities);
  }
  if (request.embeddedClientId) {
    addBrokerParameters(parameters, authOptions.clientId, authOptions.redirectUri);
  }
  if (authOptions.instanceAware && (!request.extraQueryParameters || !Object.keys(request.extraQueryParameters).includes(INSTANCE_AWARE))) {
    addInstanceAware(parameters);
  }
  return parameters;
}
function getAuthorizeUrl(authority, requestParameters, encodeParams, extraQueryParameters) {
  const queryString = mapToQueryString(requestParameters, encodeParams, extraQueryParameters);
  return UrlString.appendQueryString(authority.authorizationEndpoint, queryString);
}
function getAuthorizationCodePayload(serverParams, cachedState) {
  validateAuthorizationResponse(serverParams, cachedState);
  if (!serverParams.code) {
    throw createClientAuthError(authorizationCodeMissingFromServerResponse);
  }
  return serverParams;
}
function validateAuthorizationResponse(serverResponse, requestState) {
  if (!serverResponse.state || !requestState) {
    throw serverResponse.state ? createClientAuthError(stateNotFound, "Cached State") : createClientAuthError(stateNotFound, "Server State");
  }
  let decodedServerResponseState;
  let decodedRequestState;
  try {
    decodedServerResponseState = decodeURIComponent(serverResponse.state);
  } catch (e) {
    throw createClientAuthError(invalidState, serverResponse.state);
  }
  try {
    decodedRequestState = decodeURIComponent(requestState);
  } catch (e) {
    throw createClientAuthError(invalidState, serverResponse.state);
  }
  if (decodedServerResponseState !== decodedRequestState) {
    throw createClientAuthError(stateMismatch);
  }
  if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
    const serverErrorNo = parseServerErrorNo(serverResponse);
    if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
      throw new InteractionRequiredAuthError(serverResponse.error || "", serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || "", serverResponse.trace_id || "", serverResponse.correlation_id || "", serverResponse.claims || "", serverErrorNo);
    }
    throw new ServerError(serverResponse.error || "", serverResponse.error_description, serverResponse.suberror, serverErrorNo);
  }
}
function parseServerErrorNo(serverResponse) {
  const errorCodePrefix = "code=";
  const errorCodePrefixIndex = serverResponse.error_uri?.lastIndexOf(errorCodePrefix);
  return errorCodePrefixIndex && errorCodePrefixIndex >= 0 ? serverResponse.error_uri?.substring(errorCodePrefixIndex + errorCodePrefix.length) : void 0;
}
function extractAccountSid(account) {
  return account.idTokenClaims?.sid || null;
}
function extractLoginHint(account) {
  return account.loginHint || account.idTokenClaims?.login_hint || null;
}
var init_Authorize = __esm({
  "node_modules/@azure/msal-common/dist/protocol/Authorize.mjs"() {
    "use strict";
    init_RequestParameterBuilder();
    init_AADServerParamKeys();
    init_Constants();
    init_ClientInfo();
    init_UrlUtils();
    init_UrlString();
    init_ClientAuthError();
    init_InteractionRequiredAuthError();
    init_ServerError();
    init_ClientAuthErrorCodes();
  }
});

// node_modules/@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs
function makeExtraSkuString(params) {
  const { skus, libraryName, libraryVersion, extensionName, extensionVersion } = params;
  const skuMap = /* @__PURE__ */ new Map([
    [0, [libraryName, libraryVersion]],
    [2, [extensionName, extensionVersion]]
  ]);
  let skuArr = [];
  if (skus?.length) {
    skuArr = skus.split(skuGroupSeparator);
    if (skuArr.length < 4) {
      return skus;
    }
  } else {
    skuArr = Array.from({ length: 4 }, () => skuValueSeparator);
  }
  skuMap.forEach((value, key2) => {
    if (value.length === 2 && value[0]?.length && value[1]?.length) {
      setSku({
        skuArr,
        index: key2,
        skuName: value[0],
        skuVersion: value[1]
      });
    }
  });
  return skuArr.join(skuGroupSeparator);
}
function setSku(params) {
  const { skuArr, index: index2, skuName, skuVersion } = params;
  if (index2 >= skuArr.length) {
    return;
  }
  skuArr[index2] = [skuName, skuVersion].join(skuValueSeparator);
}
var skuGroupSeparator, skuValueSeparator, ServerTelemetryManager;
var init_ServerTelemetryManager = __esm({
  "node_modules/@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs"() {
    "use strict";
    init_Constants();
    init_AuthError();
    skuGroupSeparator = ",";
    skuValueSeparator = "|";
    ServerTelemetryManager = class _ServerTelemetryManager {
      constructor(telemetryRequest, cacheManager) {
        this.cacheOutcome = CacheOutcome.NOT_APPLICABLE;
        this.cacheManager = cacheManager;
        this.apiId = telemetryRequest.apiId;
        this.correlationId = telemetryRequest.correlationId;
        this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;
        this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;
        this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId;
      }
      /**
       * API to add MSER Telemetry to request
       */
      generateCurrentRequestHeaderValue() {
        const request = `${this.apiId}${SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR}${this.cacheOutcome}`;
        const platformFieldsArr = [this.wrapperSKU, this.wrapperVer];
        const nativeBrokerErrorCode = this.getNativeBrokerErrorCode();
        if (nativeBrokerErrorCode?.length) {
          platformFieldsArr.push(`broker_error=${nativeBrokerErrorCode}`);
        }
        const platformFields = platformFieldsArr.join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const regionDiscoveryFields = this.getRegionDiscoveryFields();
        const requestWithRegionDiscoveryFields = [
          request,
          regionDiscoveryFields
        ].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [
          SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
          requestWithRegionDiscoveryFields,
          platformFields
        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
      }
      /**
       * API to add MSER Telemetry for the last failed request
       */
      generateLastRequestHeaderValue() {
        const lastRequests = this.getLastRequests();
        const maxErrors = _ServerTelemetryManager.maxErrorsToSend(lastRequests);
        const failedRequests = lastRequests.failedRequests.slice(0, 2 * maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const errors = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const errorCount = lastRequests.errors.length;
        const overflow = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
        const platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [
          SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
          lastRequests.cacheHits,
          failedRequests,
          errors,
          platformFields
        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
      }
      /**
       * API to cache token failures for MSER data capture
       * @param error
       */
      cacheFailedRequest(error) {
        const lastRequests = this.getLastRequests();
        if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
          lastRequests.failedRequests.shift();
          lastRequests.failedRequests.shift();
          lastRequests.errors.shift();
        }
        lastRequests.failedRequests.push(this.apiId, this.correlationId);
        if (error instanceof Error && !!error && error.toString()) {
          if (error instanceof AuthError) {
            if (error.subError) {
              lastRequests.errors.push(error.subError);
            } else if (error.errorCode) {
              lastRequests.errors.push(error.errorCode);
            } else {
              lastRequests.errors.push(error.toString());
            }
          } else {
            lastRequests.errors.push(error.toString());
          }
        } else {
          lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);
        }
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
        return;
      }
      /**
       * Update server telemetry cache entry by incrementing cache hit counter
       */
      incrementCacheHits() {
        const lastRequests = this.getLastRequests();
        lastRequests.cacheHits += 1;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
        return lastRequests.cacheHits;
      }
      /**
       * Get the server telemetry entity from cache or initialize a new one
       */
      getLastRequests() {
        const initialValue = {
          failedRequests: [],
          errors: [],
          cacheHits: 0
        };
        const lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
        return lastRequests || initialValue;
      }
      /**
       * Remove server telemetry cache entry
       */
      clearTelemetryCache() {
        const lastRequests = this.getLastRequests();
        const numErrorsFlushed = _ServerTelemetryManager.maxErrorsToSend(lastRequests);
        const errorCount = lastRequests.errors.length;
        if (numErrorsFlushed === errorCount) {
          this.cacheManager.removeItem(this.telemetryCacheKey, this.correlationId);
        } else {
          const serverTelemEntity = {
            failedRequests: lastRequests.failedRequests.slice(numErrorsFlushed * 2),
            errors: lastRequests.errors.slice(numErrorsFlushed),
            cacheHits: 0
          };
          this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity, this.correlationId);
        }
      }
      /**
       * Returns the maximum number of errors that can be flushed to the server in the next network request
       * @param serverTelemetryEntity
       */
      static maxErrorsToSend(serverTelemetryEntity) {
        let i;
        let maxErrors = 0;
        let dataSize = 0;
        const errorCount = serverTelemetryEntity.errors.length;
        for (i = 0; i < errorCount; i++) {
          const apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants.EMPTY_STRING;
          const correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] || Constants.EMPTY_STRING;
          const errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;
          dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;
          if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
            maxErrors += 1;
          } else {
            break;
          }
        }
        return maxErrors;
      }
      /**
       * Get the region discovery fields
       *
       * @returns string
       */
      getRegionDiscoveryFields() {
        const regionDiscoveryFields = [];
        regionDiscoveryFields.push(this.regionUsed || Constants.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionSource || Constants.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionOutcome || Constants.EMPTY_STRING);
        return regionDiscoveryFields.join(",");
      }
      /**
       * Update the region discovery metadata
       *
       * @param regionDiscoveryMetadata
       * @returns void
       */
      updateRegionDiscoveryMetadata(regionDiscoveryMetadata) {
        this.regionUsed = regionDiscoveryMetadata.region_used;
        this.regionSource = regionDiscoveryMetadata.region_source;
        this.regionOutcome = regionDiscoveryMetadata.region_outcome;
      }
      /**
       * Set cache outcome
       */
      setCacheOutcome(cacheOutcome) {
        this.cacheOutcome = cacheOutcome;
      }
      setNativeBrokerErrorCode(errorCode) {
        const lastRequests = this.getLastRequests();
        lastRequests.nativeBrokerErrorCode = errorCode;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
      }
      getNativeBrokerErrorCode() {
        return this.getLastRequests().nativeBrokerErrorCode;
      }
      clearNativeBrokerErrorCode() {
        const lastRequests = this.getLastRequests();
        delete lastRequests.nativeBrokerErrorCode;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
      }
      static makeExtraSkuString(params) {
        return makeExtraSkuString(params);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/index-node.mjs
var init_index_node = __esm({
  "node_modules/@azure/msal-common/dist/index-node.mjs"() {
    "use strict";
    init_AuthorizationCodeClient();
    init_RefreshTokenClient();
    init_SilentFlowClient();
    init_BaseClient();
    init_CcsCredential();
    init_Authority();
    init_AuthorityOptions();
    init_ProtocolMode();
    init_CacheManager();
    init_AccountEntity();
    init_UrlString();
    init_Authorize();
    init_RequestParameterBuilder();
    init_ResponseHandler();
    init_Logger();
    init_AuthError();
    init_AuthErrorCodes();
    init_ServerError();
    init_ClientAuthError();
    init_ClientAuthErrorCodes();
    init_Constants();
    init_StringUtils();
    init_ServerTelemetryManager();
    init_AuthorityFactory();
    init_CacheHelpers();
    init_TimeUtils();
    init_UrlUtils();
    init_AADServerParamKeys();
    init_TokenCacheContext();
    init_ClientAssertionUtils();
  }
});

// node_modules/@azure/msal-node/dist/cache/serializer/Deserializer.mjs
var Deserializer;
var init_Deserializer = __esm({
  "node_modules/@azure/msal-node/dist/cache/serializer/Deserializer.mjs"() {
    "use strict";
    init_index_node();
    Deserializer = class {
      /**
       * Parse the JSON blob in memory and deserialize the content
       * @param cachedJson - JSON blob cache
       */
      static deserializeJSONBlob(jsonFile) {
        const deserializedCache = !jsonFile ? {} : JSON.parse(jsonFile);
        return deserializedCache;
      }
      /**
       * Deserializes accounts to AccountEntity objects
       * @param accounts - accounts of type SerializedAccountEntity
       */
      static deserializeAccounts(accounts) {
        const accountObjects = {};
        if (accounts) {
          Object.keys(accounts).map(function(key2) {
            const serializedAcc = accounts[key2];
            const mappedAcc = {
              homeAccountId: serializedAcc.home_account_id,
              environment: serializedAcc.environment,
              realm: serializedAcc.realm,
              localAccountId: serializedAcc.local_account_id,
              username: serializedAcc.username,
              authorityType: serializedAcc.authority_type,
              name: serializedAcc.name,
              clientInfo: serializedAcc.client_info,
              lastModificationTime: serializedAcc.last_modification_time,
              lastModificationApp: serializedAcc.last_modification_app,
              tenantProfiles: serializedAcc.tenantProfiles?.map((serializedTenantProfile) => {
                return JSON.parse(serializedTenantProfile);
              }),
              lastUpdatedAt: Date.now().toString()
            };
            const account = new AccountEntity();
            CacheManager.toObject(account, mappedAcc);
            accountObjects[key2] = account;
          });
        }
        return accountObjects;
      }
      /**
       * Deserializes id tokens to IdTokenEntity objects
       * @param idTokens - credentials of type SerializedIdTokenEntity
       */
      static deserializeIdTokens(idTokens) {
        const idObjects = {};
        if (idTokens) {
          Object.keys(idTokens).map(function(key2) {
            const serializedIdT = idTokens[key2];
            const idToken = {
              homeAccountId: serializedIdT.home_account_id,
              environment: serializedIdT.environment,
              credentialType: serializedIdT.credential_type,
              clientId: serializedIdT.client_id,
              secret: serializedIdT.secret,
              realm: serializedIdT.realm,
              lastUpdatedAt: Date.now().toString()
            };
            idObjects[key2] = idToken;
          });
        }
        return idObjects;
      }
      /**
       * Deserializes access tokens to AccessTokenEntity objects
       * @param accessTokens - access tokens of type SerializedAccessTokenEntity
       */
      static deserializeAccessTokens(accessTokens) {
        const atObjects = {};
        if (accessTokens) {
          Object.keys(accessTokens).map(function(key2) {
            const serializedAT = accessTokens[key2];
            const accessToken = {
              homeAccountId: serializedAT.home_account_id,
              environment: serializedAT.environment,
              credentialType: serializedAT.credential_type,
              clientId: serializedAT.client_id,
              secret: serializedAT.secret,
              realm: serializedAT.realm,
              target: serializedAT.target,
              cachedAt: serializedAT.cached_at,
              expiresOn: serializedAT.expires_on,
              extendedExpiresOn: serializedAT.extended_expires_on,
              refreshOn: serializedAT.refresh_on,
              keyId: serializedAT.key_id,
              tokenType: serializedAT.token_type,
              requestedClaims: serializedAT.requestedClaims,
              requestedClaimsHash: serializedAT.requestedClaimsHash,
              userAssertionHash: serializedAT.userAssertionHash,
              lastUpdatedAt: Date.now().toString()
            };
            atObjects[key2] = accessToken;
          });
        }
        return atObjects;
      }
      /**
       * Deserializes refresh tokens to RefreshTokenEntity objects
       * @param refreshTokens - refresh tokens of type SerializedRefreshTokenEntity
       */
      static deserializeRefreshTokens(refreshTokens) {
        const rtObjects = {};
        if (refreshTokens) {
          Object.keys(refreshTokens).map(function(key2) {
            const serializedRT = refreshTokens[key2];
            const refreshToken = {
              homeAccountId: serializedRT.home_account_id,
              environment: serializedRT.environment,
              credentialType: serializedRT.credential_type,
              clientId: serializedRT.client_id,
              secret: serializedRT.secret,
              familyId: serializedRT.family_id,
              target: serializedRT.target,
              realm: serializedRT.realm,
              lastUpdatedAt: Date.now().toString()
            };
            rtObjects[key2] = refreshToken;
          });
        }
        return rtObjects;
      }
      /**
       * Deserializes appMetadata to AppMetaData objects
       * @param appMetadata - app metadata of type SerializedAppMetadataEntity
       */
      static deserializeAppMetadata(appMetadata) {
        const appMetadataObjects = {};
        if (appMetadata) {
          Object.keys(appMetadata).map(function(key2) {
            const serializedAmdt = appMetadata[key2];
            appMetadataObjects[key2] = {
              clientId: serializedAmdt.client_id,
              environment: serializedAmdt.environment,
              familyId: serializedAmdt.family_id
            };
          });
        }
        return appMetadataObjects;
      }
      /**
       * Deserialize an inMemory Cache
       * @param jsonCache - JSON blob cache
       */
      static deserializeAllCache(jsonCache) {
        return {
          accounts: jsonCache.Account ? this.deserializeAccounts(jsonCache.Account) : {},
          idTokens: jsonCache.IdToken ? this.deserializeIdTokens(jsonCache.IdToken) : {},
          accessTokens: jsonCache.AccessToken ? this.deserializeAccessTokens(jsonCache.AccessToken) : {},
          refreshTokens: jsonCache.RefreshToken ? this.deserializeRefreshTokens(jsonCache.RefreshToken) : {},
          appMetadata: jsonCache.AppMetadata ? this.deserializeAppMetadata(jsonCache.AppMetadata) : {}
        };
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/internals.mjs
var init_internals = __esm({
  "node_modules/@azure/msal-node/dist/internals.mjs"() {
    "use strict";
    init_Serializer();
    init_Deserializer();
  }
});

// node_modules/@azure/msal-node/dist/utils/Constants.mjs
var MANAGED_IDENTITY_DEFAULT_TENANT, DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY, ManagedIdentityQueryParameters, ManagedIdentityEnvironmentVariableNames, ManagedIdentitySourceNames, ManagedIdentityIdType, HttpMethod2, ProxyStatus, RANDOM_OCTET_SIZE, Hash, CharSet, CACHE, Constants2, ApiId, JwtConstants, LOOPBACK_SERVER_CONSTANTS;
var init_Constants2 = __esm({
  "node_modules/@azure/msal-node/dist/utils/Constants.mjs"() {
    "use strict";
    init_index_node();
    MANAGED_IDENTITY_DEFAULT_TENANT = "managed_identity";
    DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY = `https://login.microsoftonline.com/${MANAGED_IDENTITY_DEFAULT_TENANT}/`;
    ManagedIdentityQueryParameters = {
      API_VERSION: "api-version",
      RESOURCE: "resource",
      SHA256_TOKEN_TO_REFRESH: "token_sha256_to_refresh",
      XMS_CC: "xms_cc"
    };
    ManagedIdentityEnvironmentVariableNames = {
      AZURE_POD_IDENTITY_AUTHORITY_HOST: "AZURE_POD_IDENTITY_AUTHORITY_HOST",
      DEFAULT_IDENTITY_CLIENT_ID: "DEFAULT_IDENTITY_CLIENT_ID",
      IDENTITY_ENDPOINT: "IDENTITY_ENDPOINT",
      IDENTITY_HEADER: "IDENTITY_HEADER",
      IDENTITY_SERVER_THUMBPRINT: "IDENTITY_SERVER_THUMBPRINT",
      IMDS_ENDPOINT: "IMDS_ENDPOINT",
      MSI_ENDPOINT: "MSI_ENDPOINT",
      MSI_SECRET: "MSI_SECRET"
    };
    ManagedIdentitySourceNames = {
      APP_SERVICE: "AppService",
      AZURE_ARC: "AzureArc",
      CLOUD_SHELL: "CloudShell",
      DEFAULT_TO_IMDS: "DefaultToImds",
      IMDS: "Imds",
      MACHINE_LEARNING: "MachineLearning",
      SERVICE_FABRIC: "ServiceFabric"
    };
    ManagedIdentityIdType = {
      SYSTEM_ASSIGNED: "system-assigned",
      USER_ASSIGNED_CLIENT_ID: "user-assigned-client-id",
      USER_ASSIGNED_RESOURCE_ID: "user-assigned-resource-id",
      USER_ASSIGNED_OBJECT_ID: "user-assigned-object-id"
    };
    HttpMethod2 = {
      GET: "get",
      POST: "post"
    };
    ProxyStatus = {
      SUCCESS_RANGE_START: HttpStatus.SUCCESS_RANGE_START,
      SUCCESS_RANGE_END: HttpStatus.SUCCESS_RANGE_END,
      SERVER_ERROR: HttpStatus.SERVER_ERROR
    };
    RANDOM_OCTET_SIZE = 32;
    Hash = {
      SHA256: "sha256"
    };
    CharSet = {
      CV_CHARSET: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
    };
    CACHE = {
      KEY_SEPARATOR: "-"
    };
    Constants2 = {
      MSAL_SKU: "msal.js.node",
      JWT_BEARER_ASSERTION_TYPE: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
      AUTHORIZATION_PENDING: "authorization_pending",
      HTTP_PROTOCOL: "http://",
      LOCALHOST: "localhost"
    };
    ApiId = {
      acquireTokenSilent: 62,
      acquireTokenByUsernamePassword: 371,
      acquireTokenByDeviceCode: 671,
      acquireTokenByClientCredential: 771,
      acquireTokenByCode: 871,
      acquireTokenByRefreshToken: 872
    };
    JwtConstants = {
      RSA_256: "RS256",
      PSS_256: "PS256",
      X5T_256: "x5t#S256",
      X5T: "x5t",
      X5C: "x5c",
      AUDIENCE: "aud",
      EXPIRATION_TIME: "exp",
      ISSUER: "iss",
      SUBJECT: "sub",
      NOT_BEFORE: "nbf",
      JWT_ID: "jti"
    };
    LOOPBACK_SERVER_CONSTANTS = {
      INTERVAL_MS: 100,
      TIMEOUT_MS: 5e3
    };
  }
});

// node_modules/@azure/msal-node/dist/utils/NetworkUtils.mjs
var NetworkUtils;
var init_NetworkUtils = __esm({
  "node_modules/@azure/msal-node/dist/utils/NetworkUtils.mjs"() {
    "use strict";
    NetworkUtils = class {
      static getNetworkResponse(headers, body, statusCode) {
        return {
          headers,
          body,
          status: statusCode
        };
      }
      /*
       * Utility function that converts a URL object into an ordinary options object as expected by the
       * http.request and https.request APIs.
       * https://github.com/nodejs/node/blob/main/lib/internal/url.js#L1090
       */
      static urlToHttpOptions(url2) {
        const options = {
          protocol: url2.protocol,
          hostname: url2.hostname && url2.hostname.startsWith("[") ? url2.hostname.slice(1, -1) : url2.hostname,
          hash: url2.hash,
          search: url2.search,
          pathname: url2.pathname,
          path: `${url2.pathname || ""}${url2.search || ""}`,
          href: url2.href
        };
        if (url2.port !== "") {
          options.port = Number(url2.port);
        }
        if (url2.username || url2.password) {
          options.auth = `${decodeURIComponent(url2.username)}:${decodeURIComponent(url2.password)}`;
        }
        return options;
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/packageMetadata.mjs
var name2, version2;
var init_packageMetadata2 = __esm({
  "node_modules/@azure/msal-node/dist/packageMetadata.mjs"() {
    "use strict";
    name2 = "@azure/msal-node";
    version2 = "3.8.4";
  }
});

// node_modules/@azure/msal-node/dist/network/HttpClient.mjs
var import_http4, import_https2, HttpClient;
var init_HttpClient = __esm({
  "node_modules/@azure/msal-node/dist/network/HttpClient.mjs"() {
    "use strict";
    init_index_node();
    init_Constants2();
    init_NetworkUtils();
    init_packageMetadata2();
    import_http4 = __toESM(require("http"), 1);
    import_https2 = __toESM(require("https"), 1);
    HttpClient = class {
      constructor(proxyUrl, customAgentOptions, loggerOptions) {
        this.networkRequestViaProxy = (httpMethod, destinationUrlString, options, timeout) => {
          const destinationUrl = new URL(destinationUrlString);
          const proxyUrl2 = new URL(this.proxyUrl);
          const headers = options?.headers || {};
          const tunnelRequestOptions = {
            host: proxyUrl2.hostname,
            port: proxyUrl2.port,
            method: "CONNECT",
            path: destinationUrl.hostname,
            headers
          };
          if (this.customAgentOptions && Object.keys(this.customAgentOptions).length) {
            tunnelRequestOptions.agent = new import_http4.default.Agent(this.customAgentOptions);
          }
          let postRequestStringContent = "";
          if (httpMethod === HttpMethod2.POST) {
            const body = options?.body || "";
            postRequestStringContent = `Content-Type: application/x-www-form-urlencoded\r
Content-Length: ${body.length}\r
\r
${body}`;
          } else {
            if (timeout) {
              tunnelRequestOptions.timeout = timeout;
            }
          }
          const outgoingRequestString = `${httpMethod.toUpperCase()} ${destinationUrl.href} HTTP/1.1\r
Host: ${destinationUrl.host}\r
Connection: close\r
` + postRequestStringContent + "\r\n";
          return new Promise((resolve, reject) => {
            const request = import_http4.default.request(tunnelRequestOptions);
            if (timeout) {
              request.on("timeout", () => {
                this.logUrlWithPiiAwareness(`Request timeout after ${timeout}ms for URL`, destinationUrlString);
                request.destroy();
                reject(new Error(`Request time out after ${timeout}ms`));
              });
            }
            request.end();
            request.on("connect", (response, socket) => {
              const proxyStatusCode = response?.statusCode || ProxyStatus.SERVER_ERROR;
              if (proxyStatusCode < ProxyStatus.SUCCESS_RANGE_START || proxyStatusCode > ProxyStatus.SUCCESS_RANGE_END) {
                request.destroy();
                socket.destroy();
                reject(new Error(`Error connecting to proxy. Http status code: ${response.statusCode}. Http status message: ${response?.statusMessage || "Unknown"}`));
              }
              socket.write(outgoingRequestString);
              const data = [];
              socket.on("data", (chunk) => {
                data.push(chunk);
              });
              socket.on("end", () => {
                const dataString = Buffer.concat([...data]).toString();
                const dataStringArray = dataString.split("\r\n");
                const httpStatusCode = parseInt(dataStringArray[0].split(" ")[1]);
                const statusMessage = dataStringArray[0].split(" ").slice(2).join(" ");
                const body = dataStringArray[dataStringArray.length - 1];
                const headersArray = dataStringArray.slice(1, dataStringArray.length - 2);
                const entries = /* @__PURE__ */ new Map();
                headersArray.forEach((header) => {
                  const headerKeyValue = header.split(new RegExp(/:\s(.*)/s));
                  const headerKey = headerKeyValue[0];
                  let headerValue = headerKeyValue[1];
                  try {
                    const object = JSON.parse(headerValue);
                    if (object && typeof object === "object") {
                      headerValue = object;
                    }
                  } catch (e) {
                  }
                  entries.set(headerKey, headerValue);
                });
                const headers2 = Object.fromEntries(entries);
                const parsedHeaders = headers2;
                const networkResponse = NetworkUtils.getNetworkResponse(parsedHeaders, this.parseBody(httpStatusCode, statusMessage, parsedHeaders, body), httpStatusCode);
                if (this.shouldDestroyRequest(httpStatusCode, networkResponse)) {
                  request.destroy();
                }
                resolve(networkResponse);
              });
              socket.on("error", (chunk) => {
                request.destroy();
                socket.destroy();
                reject(new Error(chunk.toString()));
              });
            });
            request.on("error", (chunk) => {
              this.logger.error(`HttpClient - Proxy request error: ${chunk.toString()}`, "");
              this.logUrlWithPiiAwareness("Destination URL", destinationUrlString);
              this.logUrlWithPiiAwareness("Proxy URL", this.proxyUrl);
              this.logger.error(`HttpClient - Method: ${httpMethod}`, "");
              this.logger.errorPii(`HttpClient - Headers: ${JSON.stringify(headers)}`, "");
              request.destroy();
              reject(new Error(chunk.toString()));
            });
          });
        };
        this.networkRequestViaHttps = (httpMethod, urlString, options, timeout) => {
          const isPostRequest = httpMethod === HttpMethod2.POST;
          const body = options?.body || "";
          const url2 = new URL(urlString);
          const headers = options?.headers || {};
          const customOptions = {
            method: httpMethod,
            headers,
            ...NetworkUtils.urlToHttpOptions(url2)
          };
          if (this.customAgentOptions && Object.keys(this.customAgentOptions).length) {
            customOptions.agent = new import_https2.default.Agent(this.customAgentOptions);
          }
          if (isPostRequest) {
            customOptions.headers = {
              ...customOptions.headers,
              "Content-Length": body.length
            };
          } else {
            if (timeout) {
              customOptions.timeout = timeout;
            }
          }
          return new Promise((resolve, reject) => {
            let request;
            if (customOptions.protocol === "http:") {
              request = import_http4.default.request(customOptions);
            } else {
              request = import_https2.default.request(customOptions);
            }
            if (isPostRequest) {
              request.write(body);
            }
            if (timeout) {
              request.on("timeout", () => {
                this.logUrlWithPiiAwareness(`HTTPS request timeout after ${timeout}ms for URL`, urlString);
                request.destroy();
                reject(new Error(`Request time out after ${timeout}ms`));
              });
            }
            request.end();
            request.on("response", (response) => {
              const headers2 = response.headers;
              const statusCode = response.statusCode;
              const statusMessage = response.statusMessage;
              const data = [];
              response.on("data", (chunk) => {
                data.push(chunk);
              });
              response.on("end", () => {
                const body2 = Buffer.concat([...data]).toString();
                const parsedHeaders = headers2;
                const networkResponse = NetworkUtils.getNetworkResponse(parsedHeaders, this.parseBody(statusCode, statusMessage, parsedHeaders, body2), statusCode);
                if (this.shouldDestroyRequest(statusCode, networkResponse)) {
                  request.destroy();
                }
                resolve(networkResponse);
              });
            });
            request.on("error", (chunk) => {
              this.logger.error(`HttpClient - HTTPS request error: ${chunk.toString()}`, "");
              this.logUrlWithPiiAwareness("URL", urlString);
              this.logger.error(`HttpClient - Method: ${httpMethod}`, "");
              this.logger.errorPii(`HttpClient - Headers: ${JSON.stringify(headers)}`, "");
              request.destroy();
              reject(new Error(chunk.toString()));
            });
          });
        };
        this.parseBody = (statusCode, statusMessage, headers, body) => {
          let parsedBody;
          try {
            parsedBody = JSON.parse(body);
          } catch (error) {
            let errorType;
            let errorDescriptionHelper;
            if (statusCode >= HttpStatus.CLIENT_ERROR_RANGE_START && statusCode <= HttpStatus.CLIENT_ERROR_RANGE_END) {
              errorType = "client_error";
              errorDescriptionHelper = "A client";
            } else if (statusCode >= HttpStatus.SERVER_ERROR_RANGE_START && statusCode <= HttpStatus.SERVER_ERROR_RANGE_END) {
              errorType = "server_error";
              errorDescriptionHelper = "A server";
            } else {
              errorType = "unknown_error";
              errorDescriptionHelper = "An unknown";
            }
            parsedBody = {
              error: errorType,
              error_description: `${errorDescriptionHelper} error occured.
Http status code: ${statusCode}
Http status message: ${statusMessage || "Unknown"}
Headers: ${JSON.stringify(headers)}`
            };
          }
          return parsedBody;
        };
        this.logUrlWithPiiAwareness = (label, urlString) => {
          if (this.isPiiEnabled) {
            this.logger.errorPii(`HttpClient - ${label}: ${urlString}`, "");
          } else {
            let urlHelper;
            try {
              const url2 = new URL(urlString);
              urlHelper = `${url2.protocol}//${url2.host}${url2.pathname}`;
            } catch {
              urlHelper = urlString.split("?")[0] || "unknown";
            }
            this.logger.error(`HttpClient - ${label}: ${urlHelper} [Enable PII logging to see additional details]`, "");
          }
        };
        this.shouldDestroyRequest = (statusCode, networkResponse) => {
          return (statusCode < HttpStatus.SUCCESS_RANGE_START || statusCode > HttpStatus.SUCCESS_RANGE_END) && // do not destroy the request for the device code flow
          !(networkResponse.body && typeof networkResponse.body === "object" && "error" in networkResponse.body && networkResponse.body.error === Constants2.AUTHORIZATION_PENDING);
        };
        this.proxyUrl = proxyUrl || "";
        this.customAgentOptions = customAgentOptions || {};
        this.logger = new Logger(loggerOptions || {}, name2, version2);
        this.isPiiEnabled = this.logger.isPiiLoggingEnabled();
      }
      /**
       * Http Get request
       * @param url
       * @param options
       */
      async sendGetRequestAsync(url2, options, timeout) {
        if (this.proxyUrl) {
          return this.networkRequestViaProxy(HttpMethod2.GET, url2, options, timeout);
        } else {
          return this.networkRequestViaHttps(HttpMethod2.GET, url2, options, timeout);
        }
      }
      /**
       * Http Post request
       * @param url
       * @param options
       */
      async sendPostRequestAsync(url2, options) {
        if (this.proxyUrl) {
          return this.networkRequestViaProxy(HttpMethod2.POST, url2, options);
        } else {
          return this.networkRequestViaHttps(HttpMethod2.POST, url2, options);
        }
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/error/ManagedIdentityErrorCodes.mjs
var invalidFileExtension, invalidFilePath, invalidManagedIdentityIdType, invalidSecret, missingId, networkUnavailable, platformNotSupported, unableToCreateAzureArc, unableToCreateCloudShell, unableToCreateSource, unableToReadSecretFile, userAssignedNotAvailableAtRuntime, wwwAuthenticateHeaderMissing, wwwAuthenticateHeaderUnsupportedFormat, MsiEnvironmentVariableUrlMalformedErrorCodes;
var init_ManagedIdentityErrorCodes = __esm({
  "node_modules/@azure/msal-node/dist/error/ManagedIdentityErrorCodes.mjs"() {
    "use strict";
    init_Constants2();
    invalidFileExtension = "invalid_file_extension";
    invalidFilePath = "invalid_file_path";
    invalidManagedIdentityIdType = "invalid_managed_identity_id_type";
    invalidSecret = "invalid_secret";
    missingId = "missing_client_id";
    networkUnavailable = "network_unavailable";
    platformNotSupported = "platform_not_supported";
    unableToCreateAzureArc = "unable_to_create_azure_arc";
    unableToCreateCloudShell = "unable_to_create_cloud_shell";
    unableToCreateSource = "unable_to_create_source";
    unableToReadSecretFile = "unable_to_read_secret_file";
    userAssignedNotAvailableAtRuntime = "user_assigned_not_available_at_runtime";
    wwwAuthenticateHeaderMissing = "www_authenticate_header_missing";
    wwwAuthenticateHeaderUnsupportedFormat = "www_authenticate_header_unsupported_format";
    MsiEnvironmentVariableUrlMalformedErrorCodes = {
      [ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST]: "azure_pod_identity_authority_host_url_malformed",
      [ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT]: "identity_endpoint_url_malformed",
      [ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT]: "imds_endpoint_url_malformed",
      [ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT]: "msi_endpoint_url_malformed"
    };
  }
});

// node_modules/@azure/msal-node/dist/error/ManagedIdentityError.mjs
function createManagedIdentityError(errorCode) {
  return new ManagedIdentityError(errorCode);
}
var ManagedIdentityErrorMessages, ManagedIdentityError;
var init_ManagedIdentityError = __esm({
  "node_modules/@azure/msal-node/dist/error/ManagedIdentityError.mjs"() {
    "use strict";
    init_index_node();
    init_ManagedIdentityErrorCodes();
    init_Constants2();
    ManagedIdentityErrorMessages = {
      [invalidFileExtension]: "The file path in the WWW-Authenticate header does not contain a .key file.",
      [invalidFilePath]: "The file path in the WWW-Authenticate header is not in a valid Windows or Linux Format.",
      [invalidManagedIdentityIdType]: "More than one ManagedIdentityIdType was provided.",
      [invalidSecret]: "The secret in the file on the file path in the WWW-Authenticate header is greater than 4096 bytes.",
      [platformNotSupported]: "The platform is not supported by Azure Arc. Azure Arc only supports Windows and Linux.",
      [missingId]: "A ManagedIdentityId id was not provided.",
      [MsiEnvironmentVariableUrlMalformedErrorCodes.AZURE_POD_IDENTITY_AUTHORITY_HOST]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST}' environment variable is malformed.`,
      [MsiEnvironmentVariableUrlMalformedErrorCodes.IDENTITY_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' environment variable is malformed.`,
      [MsiEnvironmentVariableUrlMalformedErrorCodes.IMDS_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT}' environment variable is malformed.`,
      [MsiEnvironmentVariableUrlMalformedErrorCodes.MSI_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT}' environment variable is malformed.`,
      [networkUnavailable]: "Authentication unavailable. The request to the managed identity endpoint timed out.",
      [unableToCreateAzureArc]: "Azure Arc Managed Identities can only be system assigned.",
      [unableToCreateCloudShell]: "Cloud Shell Managed Identities can only be system assigned.",
      [unableToCreateSource]: "Unable to create a Managed Identity source based on environment variables.",
      [unableToReadSecretFile]: "Unable to read the secret file.",
      [userAssignedNotAvailableAtRuntime]: "Service Fabric user assigned managed identity ClientId or ResourceId is not configurable at runtime.",
      [wwwAuthenticateHeaderMissing]: "A 401 response was received form the Azure Arc Managed Identity, but the www-authenticate header is missing.",
      [wwwAuthenticateHeaderUnsupportedFormat]: "A 401 response was received form the Azure Arc Managed Identity, but the www-authenticate header is in an unsupported format."
    };
    ManagedIdentityError = class _ManagedIdentityError extends AuthError {
      constructor(errorCode) {
        super(errorCode, ManagedIdentityErrorMessages[errorCode]);
        this.name = "ManagedIdentityError";
        Object.setPrototypeOf(this, _ManagedIdentityError.prototype);
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/config/ManagedIdentityId.mjs
var init_ManagedIdentityId = __esm({
  "node_modules/@azure/msal-node/dist/config/ManagedIdentityId.mjs"() {
    "use strict";
    init_ManagedIdentityError();
    init_Constants2();
    init_ManagedIdentityErrorCodes();
  }
});

// node_modules/@azure/msal-node/dist/error/NodeAuthError.mjs
var NodeAuthErrorMessage, NodeAuthError;
var init_NodeAuthError = __esm({
  "node_modules/@azure/msal-node/dist/error/NodeAuthError.mjs"() {
    "use strict";
    init_index_node();
    NodeAuthErrorMessage = {
      invalidLoopbackAddressType: {
        code: "invalid_loopback_server_address_type",
        desc: "Loopback server address is not type string. This is unexpected."
      },
      unableToLoadRedirectUri: {
        code: "unable_to_load_redirectUrl",
        desc: "Loopback server callback was invoked without a url. This is unexpected."
      },
      noAuthCodeInResponse: {
        code: "no_auth_code_in_response",
        desc: "No auth code found in the server response. Please check your network trace to determine what happened."
      },
      noLoopbackServerExists: {
        code: "no_loopback_server_exists",
        desc: "No loopback server exists yet."
      },
      loopbackServerAlreadyExists: {
        code: "loopback_server_already_exists",
        desc: "Loopback server already exists. Cannot create another."
      },
      loopbackServerTimeout: {
        code: "loopback_server_timeout",
        desc: "Timed out waiting for auth code listener to be registered."
      },
      stateNotFoundError: {
        code: "state_not_found",
        desc: "State not found. Please verify that the request originated from msal."
      },
      thumbprintMissing: {
        code: "thumbprint_missing_from_client_certificate",
        desc: "Client certificate does not contain a SHA-1 or SHA-256 thumbprint."
      },
      redirectUriNotSupported: {
        code: "redirect_uri_not_supported",
        desc: "RedirectUri is not supported in this scenario. Please remove redirectUri from the request."
      }
    };
    NodeAuthError = class _NodeAuthError extends AuthError {
      constructor(errorCode, errorMessage) {
        super(errorCode, errorMessage);
        this.name = "NodeAuthError";
      }
      /**
       * Creates an error thrown if loopback server address is of type string.
       */
      static createInvalidLoopbackAddressTypeError() {
        return new _NodeAuthError(NodeAuthErrorMessage.invalidLoopbackAddressType.code, `${NodeAuthErrorMessage.invalidLoopbackAddressType.desc}`);
      }
      /**
       * Creates an error thrown if the loopback server is unable to get a url.
       */
      static createUnableToLoadRedirectUrlError() {
        return new _NodeAuthError(NodeAuthErrorMessage.unableToLoadRedirectUri.code, `${NodeAuthErrorMessage.unableToLoadRedirectUri.desc}`);
      }
      /**
       * Creates an error thrown if the server response does not contain an auth code.
       */
      static createNoAuthCodeInResponseError() {
        return new _NodeAuthError(NodeAuthErrorMessage.noAuthCodeInResponse.code, `${NodeAuthErrorMessage.noAuthCodeInResponse.desc}`);
      }
      /**
       * Creates an error thrown if the loopback server has not been spun up yet.
       */
      static createNoLoopbackServerExistsError() {
        return new _NodeAuthError(NodeAuthErrorMessage.noLoopbackServerExists.code, `${NodeAuthErrorMessage.noLoopbackServerExists.desc}`);
      }
      /**
       * Creates an error thrown if a loopback server already exists when attempting to create another one.
       */
      static createLoopbackServerAlreadyExistsError() {
        return new _NodeAuthError(NodeAuthErrorMessage.loopbackServerAlreadyExists.code, `${NodeAuthErrorMessage.loopbackServerAlreadyExists.desc}`);
      }
      /**
       * Creates an error thrown if the loopback server times out registering the auth code listener.
       */
      static createLoopbackServerTimeoutError() {
        return new _NodeAuthError(NodeAuthErrorMessage.loopbackServerTimeout.code, `${NodeAuthErrorMessage.loopbackServerTimeout.desc}`);
      }
      /**
       * Creates an error thrown when the state is not present.
       */
      static createStateNotFoundError() {
        return new _NodeAuthError(NodeAuthErrorMessage.stateNotFoundError.code, NodeAuthErrorMessage.stateNotFoundError.desc);
      }
      /**
       * Creates an error thrown when client certificate was provided, but neither the SHA-1 or SHA-256 thumbprints were provided
       */
      static createThumbprintMissingError() {
        return new _NodeAuthError(NodeAuthErrorMessage.thumbprintMissing.code, NodeAuthErrorMessage.thumbprintMissing.desc);
      }
      /**
       * Creates an error thrown when redirectUri is provided in an unsupported scenario
       */
      static createRedirectUriNotSupportedError() {
        return new _NodeAuthError(NodeAuthErrorMessage.redirectUriNotSupported.code, NodeAuthErrorMessage.redirectUriNotSupported.desc);
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/config/Configuration.mjs
function buildAppConfiguration({ auth, broker, cache, system, telemetry }) {
  const systemOptions = {
    ...DEFAULT_SYSTEM_OPTIONS2,
    networkClient: new HttpClient(system?.proxyUrl, system?.customAgentOptions),
    loggerOptions: system?.loggerOptions || DEFAULT_LOGGER_OPTIONS,
    disableInternalRetries: system?.disableInternalRetries || false
  };
  if (!!auth.clientCertificate && !!!auth.clientCertificate.thumbprint && !!!auth.clientCertificate.thumbprintSha256) {
    throw NodeAuthError.createStateNotFoundError();
  }
  return {
    auth: { ...DEFAULT_AUTH_OPTIONS, ...auth },
    broker: { ...broker },
    cache: { ...DEFAULT_CACHE_OPTIONS2, ...cache },
    system: { ...systemOptions, ...system },
    telemetry: { ...DEFAULT_TELEMETRY_OPTIONS2, ...telemetry }
  };
}
var DEFAULT_AUTH_OPTIONS, DEFAULT_CACHE_OPTIONS2, DEFAULT_LOGGER_OPTIONS, DEFAULT_SYSTEM_OPTIONS2, DEFAULT_TELEMETRY_OPTIONS2;
var init_Configuration = __esm({
  "node_modules/@azure/msal-node/dist/config/Configuration.mjs"() {
    "use strict";
    init_index_node();
    init_HttpClient();
    init_ManagedIdentityId();
    init_NodeAuthError();
    DEFAULT_AUTH_OPTIONS = {
      clientId: Constants.EMPTY_STRING,
      authority: Constants.DEFAULT_AUTHORITY,
      clientSecret: Constants.EMPTY_STRING,
      clientAssertion: Constants.EMPTY_STRING,
      clientCertificate: {
        thumbprint: Constants.EMPTY_STRING,
        thumbprintSha256: Constants.EMPTY_STRING,
        privateKey: Constants.EMPTY_STRING,
        x5c: Constants.EMPTY_STRING
      },
      knownAuthorities: [],
      cloudDiscoveryMetadata: Constants.EMPTY_STRING,
      authorityMetadata: Constants.EMPTY_STRING,
      clientCapabilities: [],
      protocolMode: ProtocolMode.AAD,
      azureCloudOptions: {
        azureCloudInstance: AzureCloudInstance.None,
        tenant: Constants.EMPTY_STRING
      },
      skipAuthorityMetadataCache: false,
      encodeExtraQueryParams: false
    };
    DEFAULT_CACHE_OPTIONS2 = {
      claimsBasedCachingEnabled: false
    };
    DEFAULT_LOGGER_OPTIONS = {
      loggerCallback: () => {
      },
      piiLoggingEnabled: false,
      logLevel: LogLevel2.Info
    };
    DEFAULT_SYSTEM_OPTIONS2 = {
      loggerOptions: DEFAULT_LOGGER_OPTIONS,
      networkClient: new HttpClient(),
      proxyUrl: Constants.EMPTY_STRING,
      customAgentOptions: {},
      disableInternalRetries: false
    };
    DEFAULT_TELEMETRY_OPTIONS2 = {
      application: {
        appName: Constants.EMPTY_STRING,
        appVersion: Constants.EMPTY_STRING
      }
    };
  }
});

// node_modules/uuid/dist/esm-node/rng.js
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto2.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_crypto2, rnds8Pool, poolPtr;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-node/rng.js"() {
    import_crypto2 = __toESM(require("crypto"));
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-node/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate3 = __esm({
  "node_modules/uuid/dist/esm-node/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/uuid/dist/esm-node/stringify.js
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-node/stringify.js"() {
    init_validate3();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-node/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-node/index.js
var init_esm_node = __esm({
  "node_modules/uuid/dist/esm-node/index.js"() {
    init_v4();
  }
});

// node_modules/@azure/msal-node/dist/crypto/GuidGenerator.mjs
var GuidGenerator;
var init_GuidGenerator = __esm({
  "node_modules/@azure/msal-node/dist/crypto/GuidGenerator.mjs"() {
    "use strict";
    init_esm_node();
    GuidGenerator = class {
      /**
       *
       * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.
       * uuidv4 generates guids from cryprtographically-string random
       */
      generateGuid() {
        return v4_default();
      }
      /**
       * verifies if a string is  GUID
       * @param guid
       */
      isGuid(guid) {
        const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return regexGuid.test(guid);
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/utils/EncodingUtils.mjs
var EncodingUtils;
var init_EncodingUtils = __esm({
  "node_modules/@azure/msal-node/dist/utils/EncodingUtils.mjs"() {
    "use strict";
    init_index_node();
    EncodingUtils = class _EncodingUtils {
      /**
       * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
       * 'base64': Base64 encoding.
       *
       * @param str text
       */
      static base64Encode(str2, encoding) {
        return Buffer.from(str2, encoding).toString(EncodingTypes.BASE64);
      }
      /**
       * encode a URL
       * @param str
       */
      static base64EncodeUrl(str2, encoding) {
        return _EncodingUtils.base64Encode(str2, encoding).replace(/=/g, Constants.EMPTY_STRING).replace(/\+/g, "-").replace(/\//g, "_");
      }
      /**
       * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
       * 'base64': Base64 encoding.
       *
       * @param base64Str Base64 encoded text
       */
      static base64Decode(base64Str) {
        return Buffer.from(base64Str, EncodingTypes.BASE64).toString("utf8");
      }
      /**
       * @param base64Str Base64 encoded Url
       */
      static base64DecodeUrl(base64Str) {
        let str2 = base64Str.replace(/-/g, "+").replace(/_/g, "/");
        while (str2.length % 4) {
          str2 += "=";
        }
        return _EncodingUtils.base64Decode(str2);
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/crypto/HashUtils.mjs
var import_crypto3, HashUtils;
var init_HashUtils = __esm({
  "node_modules/@azure/msal-node/dist/crypto/HashUtils.mjs"() {
    "use strict";
    init_Constants2();
    import_crypto3 = __toESM(require("crypto"), 1);
    HashUtils = class {
      /**
       * generate 'SHA256' hash
       * @param buffer
       */
      sha256(buffer) {
        return import_crypto3.default.createHash(Hash.SHA256).update(buffer).digest();
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/crypto/PkceGenerator.mjs
var import_crypto4, PkceGenerator;
var init_PkceGenerator = __esm({
  "node_modules/@azure/msal-node/dist/crypto/PkceGenerator.mjs"() {
    "use strict";
    init_index_node();
    init_Constants2();
    init_EncodingUtils();
    init_HashUtils();
    import_crypto4 = __toESM(require("crypto"), 1);
    PkceGenerator = class {
      constructor() {
        this.hashUtils = new HashUtils();
      }
      /**
       * generates the codeVerfier and the challenge from the codeVerfier
       * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2
       */
      async generatePkceCodes() {
        const verifier = this.generateCodeVerifier();
        const challenge = this.generateCodeChallengeFromVerifier(verifier);
        return { verifier, challenge };
      }
      /**
       * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1
       */
      generateCodeVerifier() {
        const charArr = [];
        const maxNumber = 256 - 256 % CharSet.CV_CHARSET.length;
        while (charArr.length <= RANDOM_OCTET_SIZE) {
          const byte = import_crypto4.default.randomBytes(1)[0];
          if (byte >= maxNumber) {
            continue;
          }
          const index2 = byte % CharSet.CV_CHARSET.length;
          charArr.push(CharSet.CV_CHARSET[index2]);
        }
        const verifier = charArr.join(Constants.EMPTY_STRING);
        return EncodingUtils.base64EncodeUrl(verifier);
      }
      /**
       * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2
       * @param codeVerifier
       */
      generateCodeChallengeFromVerifier(codeVerifier) {
        return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(codeVerifier).toString(EncodingTypes.BASE64), EncodingTypes.BASE64);
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/crypto/CryptoProvider.mjs
var CryptoProvider;
var init_CryptoProvider = __esm({
  "node_modules/@azure/msal-node/dist/crypto/CryptoProvider.mjs"() {
    "use strict";
    init_index_node();
    init_GuidGenerator();
    init_EncodingUtils();
    init_PkceGenerator();
    init_HashUtils();
    CryptoProvider = class {
      constructor() {
        this.pkceGenerator = new PkceGenerator();
        this.guidGenerator = new GuidGenerator();
        this.hashUtils = new HashUtils();
      }
      /**
       * base64 URL safe encoded string
       */
      base64UrlEncode() {
        throw new Error("Method not implemented.");
      }
      /**
       * Stringifies and base64Url encodes input public key
       * @param inputKid - public key id
       * @returns Base64Url encoded public key
       */
      encodeKid() {
        throw new Error("Method not implemented.");
      }
      /**
       * Creates a new random GUID - used to populate state and nonce.
       * @returns string (GUID)
       */
      createNewGuid() {
        return this.guidGenerator.generateGuid();
      }
      /**
       * Encodes input string to base64.
       * @param input - string to be encoded
       */
      base64Encode(input) {
        return EncodingUtils.base64Encode(input);
      }
      /**
       * Decodes input string from base64.
       * @param input - string to be decoded
       */
      base64Decode(input) {
        return EncodingUtils.base64Decode(input);
      }
      /**
       * Generates PKCE codes used in Authorization Code Flow.
       */
      generatePkceCodes() {
        return this.pkceGenerator.generatePkceCodes();
      }
      /**
       * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node
       */
      getPublicKeyThumbprint() {
        throw new Error("Method not implemented.");
      }
      /**
       * Removes cryptographic keypair from key store matching the keyId passed in
       * @param kid - public key id
       */
      removeTokenBindingKey() {
        throw new Error("Method not implemented.");
      }
      /**
       * Removes all cryptographic keys from Keystore
       */
      clearKeystore() {
        throw new Error("Method not implemented.");
      }
      /**
       * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node
       */
      signJwt() {
        throw new Error("Method not implemented.");
      }
      /**
       * Returns the SHA-256 hash of an input string
       */
      async hashString(plainText) {
        return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(plainText).toString(EncodingTypes.BASE64), EncodingTypes.BASE64);
      }
    };
  }
});

// node_modules/@azure/msal-common/dist/index.mjs
var init_dist = __esm({
  "node_modules/@azure/msal-common/dist/index.mjs"() {
    "use strict";
    init_Constants();
    init_StubPerformanceClient();
  }
});

// node_modules/@azure/msal-node/dist/cache/CacheHelpers.mjs
function generateCredentialKey(credential) {
  const familyId = credential.credentialType === CredentialType.REFRESH_TOKEN && credential.familyId || credential.clientId;
  const scheme = credential.tokenType && credential.tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? credential.tokenType.toLowerCase() : "";
  const credentialKey = [
    credential.homeAccountId,
    credential.environment,
    credential.credentialType,
    familyId,
    credential.realm || "",
    credential.target || "",
    credential.requestedClaimsHash || "",
    scheme
  ];
  return credentialKey.join(CACHE.KEY_SEPARATOR).toLowerCase();
}
function generateAccountKey(account) {
  const homeTenantId = account.homeAccountId.split(".")[1];
  const accountKey = [
    account.homeAccountId,
    account.environment,
    homeTenantId || account.tenantId || ""
  ];
  return accountKey.join(CACHE.KEY_SEPARATOR).toLowerCase();
}
var init_CacheHelpers2 = __esm({
  "node_modules/@azure/msal-node/dist/cache/CacheHelpers.mjs"() {
    "use strict";
    init_index_node();
    init_Constants2();
  }
});

// node_modules/@azure/msal-node/dist/cache/NodeStorage.mjs
var NodeStorage;
var init_NodeStorage = __esm({
  "node_modules/@azure/msal-node/dist/cache/NodeStorage.mjs"() {
    "use strict";
    init_index_node();
    init_Deserializer();
    init_Serializer();
    init_dist();
    init_CacheHelpers2();
    NodeStorage = class extends CacheManager {
      constructor(logger11, clientId, cryptoImpl, staticAuthorityOptions) {
        super(clientId, cryptoImpl, logger11, new StubPerformanceClient(), staticAuthorityOptions);
        this.cache = {};
        this.changeEmitters = [];
        this.logger = logger11;
      }
      /**
       * Queue up callbacks
       * @param func - a callback function for cache change indication
       */
      registerChangeEmitter(func) {
        this.changeEmitters.push(func);
      }
      /**
       * Invoke the callback when cache changes
       */
      emitChange() {
        this.changeEmitters.forEach((func) => func.call(null));
      }
      /**
       * Converts cacheKVStore to InMemoryCache
       * @param cache - key value store
       */
      cacheToInMemoryCache(cache) {
        const inMemoryCache = {
          accounts: {},
          idTokens: {},
          accessTokens: {},
          refreshTokens: {},
          appMetadata: {}
        };
        for (const key2 in cache) {
          const value = cache[key2];
          if (typeof value !== "object") {
            continue;
          }
          if (value instanceof AccountEntity) {
            inMemoryCache.accounts[key2] = value;
          } else if (CacheHelpers_exports.isIdTokenEntity(value)) {
            inMemoryCache.idTokens[key2] = value;
          } else if (CacheHelpers_exports.isAccessTokenEntity(value)) {
            inMemoryCache.accessTokens[key2] = value;
          } else if (CacheHelpers_exports.isRefreshTokenEntity(value)) {
            inMemoryCache.refreshTokens[key2] = value;
          } else if (CacheHelpers_exports.isAppMetadataEntity(key2, value)) {
            inMemoryCache.appMetadata[key2] = value;
          } else {
            continue;
          }
        }
        return inMemoryCache;
      }
      /**
       * converts inMemoryCache to CacheKVStore
       * @param inMemoryCache - kvstore map for inmemory
       */
      inMemoryCacheToCache(inMemoryCache) {
        let cache = this.getCache();
        cache = {
          ...cache,
          ...inMemoryCache.accounts,
          ...inMemoryCache.idTokens,
          ...inMemoryCache.accessTokens,
          ...inMemoryCache.refreshTokens,
          ...inMemoryCache.appMetadata
        };
        return cache;
      }
      /**
       * gets the current in memory cache for the client
       */
      getInMemoryCache() {
        this.logger.trace("Getting in-memory cache");
        const inMemoryCache = this.cacheToInMemoryCache(this.getCache());
        return inMemoryCache;
      }
      /**
       * sets the current in memory cache for the client
       * @param inMemoryCache - key value map in memory
       */
      setInMemoryCache(inMemoryCache) {
        this.logger.trace("Setting in-memory cache");
        const cache = this.inMemoryCacheToCache(inMemoryCache);
        this.setCache(cache);
        this.emitChange();
      }
      /**
       * get the current cache key-value store
       */
      getCache() {
        this.logger.trace("Getting cache key-value store");
        return this.cache;
      }
      /**
       * sets the current cache (key value store)
       * @param cacheMap - key value map
       */
      setCache(cache) {
        this.logger.trace("Setting cache key value store");
        this.cache = cache;
        this.emitChange();
      }
      /**
       * Gets cache item with given key.
       * @param key - lookup key for the cache entry
       */
      getItem(key2) {
        this.logger.tracePii(`Item key: ${key2}`);
        const cache = this.getCache();
        return cache[key2];
      }
      /**
       * Gets cache item with given key-value
       * @param key - lookup key for the cache entry
       * @param value - value of the cache entry
       */
      setItem(key2, value) {
        this.logger.tracePii(`Item key: ${key2}`);
        const cache = this.getCache();
        cache[key2] = value;
        this.setCache(cache);
      }
      generateCredentialKey(credential) {
        return generateCredentialKey(credential);
      }
      generateAccountKey(account) {
        return generateAccountKey(account);
      }
      getAccountKeys() {
        const inMemoryCache = this.getInMemoryCache();
        const accountKeys = Object.keys(inMemoryCache.accounts);
        return accountKeys;
      }
      getTokenKeys() {
        const inMemoryCache = this.getInMemoryCache();
        const tokenKeys = {
          idToken: Object.keys(inMemoryCache.idTokens),
          accessToken: Object.keys(inMemoryCache.accessTokens),
          refreshToken: Object.keys(inMemoryCache.refreshTokens)
        };
        return tokenKeys;
      }
      /**
       * Reads account from cache, builds it into an account entity and returns it.
       * @param accountKey - lookup key to fetch cache type AccountEntity
       * @returns
       */
      getAccount(accountKey) {
        const cachedAccount = this.getItem(accountKey);
        return cachedAccount ? Object.assign(new AccountEntity(), this.getItem(accountKey)) : null;
      }
      /**
       * set account entity
       * @param account - cache value to be set of type AccountEntity
       */
      async setAccount(account) {
        const accountKey = this.generateAccountKey(AccountEntity.getAccountInfo(account));
        this.setItem(accountKey, account);
      }
      /**
       * fetch the idToken credential
       * @param idTokenKey - lookup key to fetch cache type IdTokenEntity
       */
      getIdTokenCredential(idTokenKey) {
        const idToken = this.getItem(idTokenKey);
        if (CacheHelpers_exports.isIdTokenEntity(idToken)) {
          return idToken;
        }
        return null;
      }
      /**
       * set idToken credential
       * @param idToken - cache value to be set of type IdTokenEntity
       */
      async setIdTokenCredential(idToken) {
        const idTokenKey = this.generateCredentialKey(idToken);
        this.setItem(idTokenKey, idToken);
      }
      /**
       * fetch the accessToken credential
       * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity
       */
      getAccessTokenCredential(accessTokenKey) {
        const accessToken = this.getItem(accessTokenKey);
        if (CacheHelpers_exports.isAccessTokenEntity(accessToken)) {
          return accessToken;
        }
        return null;
      }
      /**
       * set accessToken credential
       * @param accessToken -  cache value to be set of type AccessTokenEntity
       */
      async setAccessTokenCredential(accessToken) {
        const accessTokenKey = this.generateCredentialKey(accessToken);
        this.setItem(accessTokenKey, accessToken);
      }
      /**
       * fetch the refreshToken credential
       * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity
       */
      getRefreshTokenCredential(refreshTokenKey) {
        const refreshToken = this.getItem(refreshTokenKey);
        if (CacheHelpers_exports.isRefreshTokenEntity(refreshToken)) {
          return refreshToken;
        }
        return null;
      }
      /**
       * set refreshToken credential
       * @param refreshToken - cache value to be set of type RefreshTokenEntity
       */
      async setRefreshTokenCredential(refreshToken) {
        const refreshTokenKey = this.generateCredentialKey(refreshToken);
        this.setItem(refreshTokenKey, refreshToken);
      }
      /**
       * fetch appMetadata entity from the platform cache
       * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity
       */
      getAppMetadata(appMetadataKey) {
        const appMetadata = this.getItem(appMetadataKey);
        if (CacheHelpers_exports.isAppMetadataEntity(appMetadataKey, appMetadata)) {
          return appMetadata;
        }
        return null;
      }
      /**
       * set appMetadata entity to the platform cache
       * @param appMetadata - cache value to be set of type AppMetadataEntity
       */
      setAppMetadata(appMetadata) {
        const appMetadataKey = CacheHelpers_exports.generateAppMetadataKey(appMetadata);
        this.setItem(appMetadataKey, appMetadata);
      }
      /**
       * fetch server telemetry entity from the platform cache
       * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity
       */
      getServerTelemetry(serverTelemetrykey) {
        const serverTelemetryEntity = this.getItem(serverTelemetrykey);
        if (serverTelemetryEntity && CacheHelpers_exports.isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {
          return serverTelemetryEntity;
        }
        return null;
      }
      /**
       * set server telemetry entity to the platform cache
       * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity
       * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity
       */
      setServerTelemetry(serverTelemetryKey, serverTelemetry) {
        this.setItem(serverTelemetryKey, serverTelemetry);
      }
      /**
       * fetch authority metadata entity from the platform cache
       * @param key - lookup key to fetch cache type AuthorityMetadataEntity
       */
      getAuthorityMetadata(key2) {
        const authorityMetadataEntity = this.getItem(key2);
        if (authorityMetadataEntity && CacheHelpers_exports.isAuthorityMetadataEntity(key2, authorityMetadataEntity)) {
          return authorityMetadataEntity;
        }
        return null;
      }
      /**
       * Get all authority metadata keys
       */
      getAuthorityMetadataKeys() {
        return this.getKeys().filter((key2) => {
          return this.isAuthorityMetadata(key2);
        });
      }
      /**
       * set authority metadata entity to the platform cache
       * @param key - lookup key to fetch cache type AuthorityMetadataEntity
       * @param metadata - cache value to be set of type AuthorityMetadataEntity
       */
      setAuthorityMetadata(key2, metadata) {
        this.setItem(key2, metadata);
      }
      /**
       * fetch throttling entity from the platform cache
       * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
       */
      getThrottlingCache(throttlingCacheKey) {
        const throttlingCache = this.getItem(throttlingCacheKey);
        if (throttlingCache && CacheHelpers_exports.isThrottlingEntity(throttlingCacheKey, throttlingCache)) {
          return throttlingCache;
        }
        return null;
      }
      /**
       * set throttling entity to the platform cache
       * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
       * @param throttlingCache - cache value to be set of type ThrottlingEntity
       */
      setThrottlingCache(throttlingCacheKey, throttlingCache) {
        this.setItem(throttlingCacheKey, throttlingCache);
      }
      /**
       * Removes the cache item from memory with the given key.
       * @param key - lookup key to remove a cache entity
       * @param inMemory - key value map of the cache
       */
      removeItem(key2) {
        this.logger.tracePii(`Item key: ${key2}`);
        let result = false;
        const cache = this.getCache();
        if (!!cache[key2]) {
          delete cache[key2];
          result = true;
        }
        if (result) {
          this.setCache(cache);
          this.emitChange();
        }
        return result;
      }
      /**
       * Remove account entity from the platform cache if it's outdated
       * @param accountKey - lookup key to fetch cache type AccountEntity
       */
      removeOutdatedAccount(accountKey) {
        this.removeItem(accountKey);
      }
      /**
       * Checks whether key is in cache.
       * @param key - look up key for a cache entity
       */
      containsKey(key2) {
        return this.getKeys().includes(key2);
      }
      /**
       * Gets all keys in window.
       */
      getKeys() {
        this.logger.trace("Retrieving all cache keys");
        const cache = this.getCache();
        return [...Object.keys(cache)];
      }
      /**
       * Clears all cache entries created by MSAL (except tokens).
       */
      clear() {
        this.logger.trace("Clearing cache entries created by MSAL");
        const cacheKeys = this.getKeys();
        cacheKeys.forEach((key2) => {
          this.removeItem(key2);
        });
        this.emitChange();
      }
      /**
       * Initialize in memory cache from an exisiting cache vault
       * @param cache - blob formatted cache (JSON)
       */
      static generateInMemoryCache(cache) {
        return Deserializer.deserializeAllCache(Deserializer.deserializeJSONBlob(cache));
      }
      /**
       * retrieves the final JSON
       * @param inMemoryCache - itemised cache read from the JSON
       */
      static generateJsonCache(inMemoryCache) {
        return Serializer.serializeAllCache(inMemoryCache);
      }
      /**
       * Updates a credential's cache key if the current cache key is outdated
       */
      updateCredentialCacheKey(currentCacheKey, credential) {
        const updatedCacheKey = this.generateCredentialKey(credential);
        if (currentCacheKey !== updatedCacheKey) {
          const cacheItem = this.getItem(currentCacheKey);
          if (cacheItem) {
            this.removeItem(currentCacheKey);
            this.setItem(updatedCacheKey, cacheItem);
            this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);
            return updatedCacheKey;
          } else {
            this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);
          }
        }
        return currentCacheKey;
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/cache/TokenCache.mjs
var defaultSerializedCache, TokenCache;
var init_TokenCache = __esm({
  "node_modules/@azure/msal-node/dist/cache/TokenCache.mjs"() {
    "use strict";
    init_NodeStorage();
    init_index_node();
    init_Deserializer();
    init_Serializer();
    init_CryptoProvider();
    init_GuidGenerator();
    defaultSerializedCache = {
      Account: {},
      IdToken: {},
      AccessToken: {},
      RefreshToken: {},
      AppMetadata: {}
    };
    TokenCache = class {
      constructor(storage, logger11, cachePlugin) {
        this.cacheHasChanged = false;
        this.storage = storage;
        this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));
        if (cachePlugin) {
          this.persistence = cachePlugin;
        }
        this.logger = logger11;
      }
      /**
       * Set to true if cache state has changed since last time serialize or writeToPersistence was called
       */
      hasChanged() {
        return this.cacheHasChanged;
      }
      /**
       * Serializes in memory cache to JSON
       */
      serialize() {
        this.logger.trace("Serializing in-memory cache");
        let finalState = Serializer.serializeAllCache(this.storage.getInMemoryCache());
        if (this.cacheSnapshot) {
          this.logger.trace("Reading cache snapshot from disk");
          finalState = this.mergeState(JSON.parse(this.cacheSnapshot), finalState);
        } else {
          this.logger.trace("No cache snapshot to merge");
        }
        this.cacheHasChanged = false;
        return JSON.stringify(finalState);
      }
      /**
       * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format
       * @param cache - blob formatted cache
       */
      deserialize(cache) {
        this.logger.trace("Deserializing JSON to in-memory cache");
        this.cacheSnapshot = cache;
        if (this.cacheSnapshot) {
          this.logger.trace("Reading cache snapshot from disk");
          const deserializedCache = Deserializer.deserializeAllCache(this.overlayDefaults(JSON.parse(this.cacheSnapshot)));
          this.storage.setInMemoryCache(deserializedCache);
        } else {
          this.logger.trace("No cache snapshot to deserialize");
        }
      }
      /**
       * Fetches the cache key-value map
       */
      getKVStore() {
        return this.storage.getCache();
      }
      /**
       * Gets cache snapshot in CacheKVStore format
       */
      getCacheSnapshot() {
        const deserializedPersistentStorage = NodeStorage.generateInMemoryCache(this.cacheSnapshot);
        return this.storage.inMemoryCacheToCache(deserializedPersistentStorage);
      }
      /**
       * API that retrieves all accounts currently in cache to the user
       */
      async getAllAccounts(correlationId = new CryptoProvider().createNewGuid()) {
        this.logger.trace("getAllAccounts called");
        let cacheContext;
        try {
          if (this.persistence) {
            cacheContext = new TokenCacheContext(this, false);
            await this.persistence.beforeCacheAccess(cacheContext);
          }
          return this.storage.getAllAccounts({}, correlationId);
        } finally {
          if (this.persistence && cacheContext) {
            await this.persistence.afterCacheAccess(cacheContext);
          }
        }
      }
      /**
       * Returns the signed in account matching homeAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param homeAccountId - unique identifier for an account (uid.utid)
       */
      async getAccountByHomeId(homeAccountId) {
        const allAccounts = await this.getAllAccounts();
        if (homeAccountId && allAccounts && allAccounts.length) {
          return allAccounts.filter((accountObj) => accountObj.homeAccountId === homeAccountId)[0] || null;
        } else {
          return null;
        }
      }
      /**
       * Returns the signed in account matching localAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)
       */
      async getAccountByLocalId(localAccountId) {
        const allAccounts = await this.getAllAccounts();
        if (localAccountId && allAccounts && allAccounts.length) {
          return allAccounts.filter((accountObj) => accountObj.localAccountId === localAccountId)[0] || null;
        } else {
          return null;
        }
      }
      /**
       * API to remove a specific account and the relevant data from cache
       * @param account - AccountInfo passed by the user
       */
      async removeAccount(account, correlationId) {
        this.logger.trace("removeAccount called");
        let cacheContext;
        try {
          if (this.persistence) {
            cacheContext = new TokenCacheContext(this, true);
            await this.persistence.beforeCacheAccess(cacheContext);
          }
          this.storage.removeAccount(account, correlationId || new GuidGenerator().generateGuid());
        } finally {
          if (this.persistence && cacheContext) {
            await this.persistence.afterCacheAccess(cacheContext);
          }
        }
      }
      /**
       * Overwrites in-memory cache with persistent cache
       */
      async overwriteCache() {
        if (!this.persistence) {
          this.logger.info("No persistence layer specified, cache cannot be overwritten");
          return;
        }
        this.logger.info("Overwriting in-memory cache with persistent cache");
        this.storage.clear();
        const cacheContext = new TokenCacheContext(this, false);
        await this.persistence.beforeCacheAccess(cacheContext);
        const cacheSnapshot = this.getCacheSnapshot();
        this.storage.setCache(cacheSnapshot);
        await this.persistence.afterCacheAccess(cacheContext);
      }
      /**
       * Called when the cache has changed state.
       */
      handleChangeEvent() {
        this.cacheHasChanged = true;
      }
      /**
       * Merge in memory cache with the cache snapshot.
       * @param oldState - cache before changes
       * @param currentState - current cache state in the library
       */
      mergeState(oldState, currentState) {
        this.logger.trace("Merging in-memory cache with cache snapshot");
        const stateAfterRemoval = this.mergeRemovals(oldState, currentState);
        return this.mergeUpdates(stateAfterRemoval, currentState);
      }
      /**
       * Deep update of oldState based on newState values
       * @param oldState - cache before changes
       * @param newState - updated cache
       */
      mergeUpdates(oldState, newState) {
        Object.keys(newState).forEach((newKey) => {
          const newValue = newState[newKey];
          if (!oldState.hasOwnProperty(newKey)) {
            if (newValue !== null) {
              oldState[newKey] = newValue;
            }
          } else {
            const newValueNotNull = newValue !== null;
            const newValueIsObject = typeof newValue === "object";
            const newValueIsNotArray = !Array.isArray(newValue);
            const oldStateNotUndefinedOrNull = typeof oldState[newKey] !== "undefined" && oldState[newKey] !== null;
            if (newValueNotNull && newValueIsObject && newValueIsNotArray && oldStateNotUndefinedOrNull) {
              this.mergeUpdates(oldState[newKey], newValue);
            } else {
              oldState[newKey] = newValue;
            }
          }
        });
        return oldState;
      }
      /**
       * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of
       * oldState that are not recognized, they are left untouched.
       * @param oldState - cache before changes
       * @param newState - updated cache
       */
      mergeRemovals(oldState, newState) {
        this.logger.trace("Remove updated entries in cache");
        const accounts = oldState.Account ? this.mergeRemovalsDict(oldState.Account, newState.Account) : oldState.Account;
        const accessTokens = oldState.AccessToken ? this.mergeRemovalsDict(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;
        const refreshTokens = oldState.RefreshToken ? this.mergeRemovalsDict(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;
        const idTokens = oldState.IdToken ? this.mergeRemovalsDict(oldState.IdToken, newState.IdToken) : oldState.IdToken;
        const appMetadata = oldState.AppMetadata ? this.mergeRemovalsDict(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;
        return {
          ...oldState,
          Account: accounts,
          AccessToken: accessTokens,
          RefreshToken: refreshTokens,
          IdToken: idTokens,
          AppMetadata: appMetadata
        };
      }
      /**
       * Helper to merge new cache with the old one
       * @param oldState - cache before changes
       * @param newState - updated cache
       */
      mergeRemovalsDict(oldState, newState) {
        const finalState = { ...oldState };
        Object.keys(oldState).forEach((oldKey) => {
          if (!newState || !newState.hasOwnProperty(oldKey)) {
            delete finalState[oldKey];
          }
        });
        return finalState;
      }
      /**
       * Helper to overlay as a part of cache merge
       * @param passedInCache - cache read from the blob
       */
      overlayDefaults(passedInCache) {
        this.logger.trace("Overlaying input cache with the default cache");
        return {
          Account: {
            ...defaultSerializedCache.Account,
            ...passedInCache.Account
          },
          IdToken: {
            ...defaultSerializedCache.IdToken,
            ...passedInCache.IdToken
          },
          AccessToken: {
            ...defaultSerializedCache.AccessToken,
            ...passedInCache.AccessToken
          },
          RefreshToken: {
            ...defaultSerializedCache.RefreshToken,
            ...passedInCache.RefreshToken
          },
          AppMetadata: {
            ...defaultSerializedCache.AppMetadata,
            ...passedInCache.AppMetadata
          }
        };
      }
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key2 in src) {
        dst[key2] = src[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "node_modules/jws/lib/data-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream = require("stream");
    var util3 = require("util");
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util3.inherits(DataStream, Stream);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module2.exports = DataStream;
  }
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports2, module2) {
    "use strict";
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module2.exports = getParamBytesForAlg;
  }
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer2.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module2.exports = {
      derToJose,
      joseToDer
    };
  }
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "node_modules/buffer-equal-constant-time/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    var SlowBuffer = require("buffer").SlowBuffer;
    module2.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// node_modules/jwa/index.js
var require_jwa = __commonJS({
  "node_modules/jwa/index.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto6 = require("crypto");
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util3 = require("util");
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto6.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key2) {
      if (Buffer2.isBuffer(key2)) {
        return;
      }
      if (typeof key2 === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key2 !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key2.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key2.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key2.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key2) {
      if (Buffer2.isBuffer(key2)) {
        return;
      }
      if (typeof key2 === "string") {
        return;
      }
      if (typeof key2 === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key2) {
      if (Buffer2.isBuffer(key2)) {
        return;
      }
      if (typeof key2 === "string") {
        return key2;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key2 !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key2.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key2.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util3.format.bind(util3, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto6.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    var bufferEqual;
    var timingSafeEqual = "timingSafeEqual" in crypto6 ? function timingSafeEqual2(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      return crypto6.timingSafeEqual(a, b);
    } : function timingSafeEqual2(a, b) {
      if (!bufferEqual) {
        bufferEqual = require_buffer_equal_constant_time();
      }
      return bufferEqual(a, b);
    };
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return timingSafeEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto6.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto6.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto6.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto6.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto6.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto6.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto6.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto6.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module2.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "node_modules/jws/lib/tostring.js"(exports2, module2) {
    var Buffer2 = require("buffer").Buffer;
    module2.exports = function toString4(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
  }
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "node_modules/jws/lib/sign-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString4 = require_tostring();
    var util3 = require("util");
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString4(header), "binary");
      var encodedPayload = base64url(toString4(payload), encoding);
      return util3.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util3.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret;
      secret = secret == null ? opts.privateKey : secret;
      secret = secret == null ? opts.key : secret;
      if (/^hs/i.test(opts.header.alg) === true && secret == null) {
        throw new TypeError("secret must be a string or buffer or a KeyObject");
      }
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    util3.inherits(SignStream, Stream);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module2.exports = SignStream;
  }
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "node_modules/jws/lib/verify-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString4 = require_tostring();
    var util3 = require("util");
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject3(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject3(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString4(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString4(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret;
      secretOrKey = secretOrKey == null ? opts.publicKey : secretOrKey;
      secretOrKey = secretOrKey == null ? opts.key : secretOrKey;
      if (/^hs/i.test(opts.algorithm) === true && secretOrKey == null) {
        throw new TypeError("secret must be a string or buffer or a KeyObject");
      }
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    util3.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module2.exports = VerifyStream;
  }
});

// node_modules/jws/index.js
var require_jws = __commonJS({
  "node_modules/jws/index.js"(exports2) {
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports2.ALGORITHMS = ALGORITHMS;
    exports2.sign = SignStream.sign;
    exports2.verify = VerifyStream.verify;
    exports2.decode = VerifyStream.decode;
    exports2.isValid = VerifyStream.isValid;
    exports2.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports2.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "node_modules/jsonwebtoken/decode.js"(exports2, module2) {
    var jws = require_jws();
    module2.exports = function(jwt2, options) {
      options = options || {};
      var decoded = jws.decode(jwt2, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports2, module2) {
    var JsonWebTokenError = function(message, error) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error) this.inner = error;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module2.exports = JsonWebTokenError;
  }
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function(message, date) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module2.exports = NotBeforeError;
  }
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module2.exports = TokenExpiredError;
  }
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "node_modules/jsonwebtoken/lib/timespan.js"(exports2, module2) {
    var ms = require_ms();
    module2.exports = function(time, iat) {
      var timestamp2 = iat || Math.floor(Date.now() / 1e3);
      if (typeof time === "string") {
        var milliseconds = ms(time);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp2 + milliseconds / 1e3);
      } else if (typeof time === "number") {
        return timestamp2 + time;
      } else {
        return;
      }
    };
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug2 = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug2();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name3, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index2 = R++;
      debug(name3, index2, value);
      t[name3] = index2;
      src[index2] = value;
      safeSrc[index2] = safe;
      re[index2] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      if (typeof a === "number" && typeof b === "number") {
        return a === b ? 0 : a < b ? -1 : 1;
      }
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    var debug = require_debug2();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version3, options) {
        options = parseOptions(options);
        if (version3 instanceof _SemVer) {
          if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease) {
            return version3;
          } else {
            version3 = version3.version;
          }
        } else if (typeof version3 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version3}".`);
        }
        if (version3.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version3, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version3.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version3}`);
        }
        this.raw = version3;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.major < other.major) {
          return -1;
        }
        if (this.major > other.major) {
          return 1;
        }
        if (this.minor < other.minor) {
          return -1;
        }
        if (this.minor > other.minor) {
          return 1;
        }
        if (this.patch < other.patch) {
          return -1;
        }
        if (this.patch > other.patch) {
          return 1;
        }
        return 0;
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse = (version3, options, throwErrors = false) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      try {
        return new SemVer(version3, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var valid = (version3, options) => {
      const v = parse(version3, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var clean = (version3, options) => {
      const s = parse(version3.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version3, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version3 instanceof SemVer ? version3.version : version3,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var diff = (version1, version22) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version22, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var prerelease = (version3, options) => {
      const parsed = parse(version3, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version3, options) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 === "number") {
        version3 = String(version3);
      }
      if (typeof version3 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version3.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next2;
        while ((next2 = coerceRtlRegex.exec(version3)) && (!match || match.index + match[0].length !== version3.length)) {
          if (!match || next2.index + next2[0].length !== match.index + match[0].length) {
            match = next2;
          }
          coerceRtlRegex.lastIndex = next2.index + next2[1].length + next2[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports2, module2) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key2) {
        const value = this.map.get(key2);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key2);
          this.map.set(key2, value);
          return value;
        }
      }
      delete(key2) {
        return this.map.delete(key2);
      }
      set(key2, value) {
        const deleted = this.delete(key2);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key2, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range2 = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version3) {
        if (!version3) {
          return false;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version3, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug2();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      comp = comp.replace(re[t.BUILD], "");
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set3, version3, options) => {
      for (let i = 0; i < set3.length; i++) {
        if (!set3[i].test(version3)) {
          return false;
        }
      }
      if (version3.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set3.length; i++) {
          debug(set3[i].semver);
          if (set3[i].semver === Comparator.ANY) {
            continue;
          }
          if (set3[i].semver.prerelease.length > 0) {
            const allowed = set3[i].semver;
            if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    var ANY = /* @__PURE__ */ Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version3) {
        debug("Comparator.test", version3, this.options.loose);
        if (this.semver === ANY || version3 === ANY) {
          return true;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version3, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug2();
    var SemVer = require_semver();
    var Range = require_range2();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    var Range = require_range2();
    var satisfies = (version3, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version3);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    var Range = require_range2();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range2();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range2();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range2();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    var Range = require_range2();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range2();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version3, range, hilo, options) => {
      version3 = new SemVer(version3, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version3, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version3, range, options) => outside(version3, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version3, range, options) => outside(version3, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    var Range = require_range2();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set3 = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version3 of v) {
        const included = satisfies(version3, range, options);
        if (included) {
          prev = version3;
          if (!first) {
            first = version3;
          }
        } else {
          if (prev) {
            set3.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set3.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set3) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    var Range = require_range2();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range2();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js"(exports2, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, ">=15.7.0");
  }
});

// node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js"(exports2, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, ">=16.9.0");
  }
});

// node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS({
  "node_modules/jsonwebtoken/lib/validateAsymmetricKey.js"(exports2, module2) {
    var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
    var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
    var allowedAlgorithmsForKeys = {
      "ec": ["ES256", "ES384", "ES512"],
      "rsa": ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
      "rsa-pss": ["PS256", "PS384", "PS512"]
    };
    var allowedCurves = {
      ES256: "prime256v1",
      ES384: "secp384r1",
      ES512: "secp521r1"
    };
    module2.exports = function(algorithm, key2) {
      if (!algorithm || !key2) return;
      const keyType = key2.asymmetricKeyType;
      if (!keyType) return;
      const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
      if (!allowedAlgorithms) {
        throw new Error(`Unknown key type "${keyType}".`);
      }
      if (!allowedAlgorithms.includes(algorithm)) {
        throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
      }
      if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
        switch (keyType) {
          case "ec":
            const keyCurve = key2.asymmetricKeyDetails.namedCurve;
            const allowedCurve = allowedCurves[algorithm];
            if (keyCurve !== allowedCurve) {
              throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
            }
            break;
          case "rsa-pss":
            if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
              const length = parseInt(algorithm.slice(-3), 10);
              const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key2.asymmetricKeyDetails;
              if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
              }
              if (saltLength !== void 0 && saltLength > length >> 3) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
              }
            }
            break;
        }
      }
    };
  }
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/psSupported.js"(exports2, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  "node_modules/jsonwebtoken/verify.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var { KeyObject, createSecretKey, createPublicKey } = require("crypto");
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    }
    module2.exports = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      let done;
      if (callback) {
        done = callback;
      } else {
        done = function(err, data) {
          if (err) throw err;
          return data;
        };
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      if (options.allowInvalidAsymmetricKeyTypes !== void 0 && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
        return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
      }
      const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      const parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      let decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      const header = decodedToken.header;
      let getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        };
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        const hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
          return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
        }
        if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
          try {
            secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
          } catch (_) {
            try {
              secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
            } catch (_2) {
              return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
            }
          }
        }
        if (!options.algorithms) {
          if (secretOrPublicKey2.type === "secret") {
            options.algorithms = HS_ALGS;
          } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
            options.algorithms = RSA_KEY_ALGS;
          } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
            options.algorithms = EC_KEY_ALGS;
          } else {
            options.algorithms = PUB_KEY_ALGS;
          }
        }
        if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
        } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInvalidAsymmetricKeyTypes) {
          try {
            validateAsymmetricKey(header.alg, secretOrPublicKey2);
          } catch (e) {
            return done(e);
          }
        }
        let valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        const payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          const match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options.issuer) {
          const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          const signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.includes/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array ? array.length : 0, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key2) {
        return object[key2];
      });
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key2 in value) {
        if ((inherited || hasOwnProperty2.call(value, key2)) && !(skipIndexes && (key2 == "length" || isIndex(key2, length)))) {
          result.push(key2);
        }
      }
      return result;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key2 in Object(object)) {
        if (hasOwnProperty2.call(object, key2) && key2 != "constructor") {
          result.push(key2);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction3(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction3(value) {
      var tag2 = isObject3(value) ? objectToString.call(value) : "";
      return tag2 == funcTag || tag2 == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject3(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString2(value) {
      return typeof value == "string" || !isArray2(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary2 = reIsBinary.test(value);
      return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    module2.exports = includes;
  }
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.isboolean/index.js"(exports2, module2) {
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean3(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = isBoolean3;
  }
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.isinteger/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger2(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    function isObject3(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary2 = reIsBinary.test(value);
      return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = isInteger2;
  }
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.isnumber/index.js"(exports2, module2) {
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isNumber2(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    module2.exports = isNumber2;
  }
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash.isplainobject/index.js"(exports2, module2) {
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject2(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject2;
  }
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS({
  "node_modules/lodash.isstring/index.js"(exports2, module2) {
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray2 = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString2(value) {
      return typeof value == "string" || !isArray2(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    module2.exports = isString2;
  }
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS({
  "node_modules/lodash.once/index.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once2(func) {
      return before(2, func);
    }
    function isObject3(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary2 = reIsBinary.test(value);
      return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = once2;
  }
});

// node_modules/jsonwebtoken/sign.js
var require_sign2 = __commonJS({
  "node_modules/jsonwebtoken/sign.js"(exports2, module2) {
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var jws = require_jws();
    var includes = require_lodash();
    var isBoolean3 = require_lodash2();
    var isInteger2 = require_lodash3();
    var isNumber2 = require_lodash4();
    var isPlainObject2 = require_lodash5();
    var isString2 = require_lodash6();
    var once2 = require_lodash7();
    var { KeyObject, createSecretKey, createPrivateKey } = require("crypto");
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: function(value) {
        return isInteger2(value) || isString2(value) && value;
      }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: function(value) {
        return isInteger2(value) || isString2(value) && value;
      }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: function(value) {
        return isString2(value) || Array.isArray(value);
      }, message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject2, message: '"header" must be an object' },
      encoding: { isValid: isString2, message: '"encoding" must be a string' },
      issuer: { isValid: isString2, message: '"issuer" must be a string' },
      subject: { isValid: isString2, message: '"subject" must be a string' },
      jwtid: { isValid: isString2, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean3, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString2, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean3, message: '"mutatePayload" must be a boolean' },
      allowInsecureKeySizes: { isValid: isBoolean3, message: '"allowInsecureKeySizes" must be a boolean' },
      allowInvalidAsymmetricKeyTypes: { isValid: isBoolean3, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber2, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber2, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber2, message: '"nbf" should be a number of seconds' }
    };
    function validate2(schema2, allowUnknown, object, parameterName) {
      if (!isPlainObject2(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function(key2) {
        const validator = schema2[key2];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key2 + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object[key2])) {
          throw new Error(validator.message);
        }
      });
    }
    function validateOptions(options) {
      return validate2(sign_options_schema, false, options, "options");
    }
    function validatePayload(payload) {
      return validate2(registered_claims_schema, true, payload, "payload");
    }
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module2.exports = function(payload, secretOrPrivateKey, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      const header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options.keyid
      }, options.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
        try {
          secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
        } catch (_) {
          try {
            secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
          } catch (_2) {
            return failure(new Error("secretOrPrivateKey is not valid key material"));
          }
        }
      }
      if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
        return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
        if (secretOrPrivateKey.type !== "private") {
          return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
        secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
          return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error) {
          return failure(error);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        const invalid_options = options_for_objects.filter(function(opt) {
          return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options);
      } catch (error) {
        return failure(error);
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPrivateKey);
        } catch (error) {
          return failure(error);
        }
      }
      const timestamp2 = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp2;
      }
      if (typeof options.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options.notBefore, timestamp2);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options.expiresIn, timestamp2);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key2) {
        const claim = options_to_payload[key2];
        if (typeof options[key2] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key2 + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options[key2];
        }
      });
      const encoding = options.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once2(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
            return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
          }
          callback(null, signature);
        });
      } else {
        let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
        }
        return signature;
      }
    };
  }
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "node_modules/jsonwebtoken/index.js"(exports2, module2) {
    module2.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign2(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// node_modules/@azure/msal-node/dist/client/ClientAssertion.mjs
var import_jsonwebtoken, ClientAssertion;
var init_ClientAssertion = __esm({
  "node_modules/@azure/msal-node/dist/client/ClientAssertion.mjs"() {
    "use strict";
    import_jsonwebtoken = __toESM(require_jsonwebtoken(), 1);
    init_index_node();
    init_EncodingUtils();
    init_Constants2();
    ClientAssertion = class _ClientAssertion {
      /**
       * Initialize the ClientAssertion class from the clientAssertion passed by the user
       * @param assertion - refer https://tools.ietf.org/html/rfc7521
       */
      static fromAssertion(assertion) {
        const clientAssertion = new _ClientAssertion();
        clientAssertion.jwt = assertion;
        return clientAssertion;
      }
      /**
       * @deprecated Use fromCertificateWithSha256Thumbprint instead, with a SHA-256 thumprint
       * Initialize the ClientAssertion class from the certificate passed by the user
       * @param thumbprint - identifier of a certificate
       * @param privateKey - secret key
       * @param publicCertificate - electronic document provided to prove the ownership of the public key
       */
      static fromCertificate(thumbprint, privateKey, publicCertificate) {
        const clientAssertion = new _ClientAssertion();
        clientAssertion.privateKey = privateKey;
        clientAssertion.thumbprint = thumbprint;
        clientAssertion.useSha256 = false;
        if (publicCertificate) {
          clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);
        }
        return clientAssertion;
      }
      /**
       * Initialize the ClientAssertion class from the certificate passed by the user
       * @param thumbprint - identifier of a certificate
       * @param privateKey - secret key
       * @param publicCertificate - electronic document provided to prove the ownership of the public key
       */
      static fromCertificateWithSha256Thumbprint(thumbprint, privateKey, publicCertificate) {
        const clientAssertion = new _ClientAssertion();
        clientAssertion.privateKey = privateKey;
        clientAssertion.thumbprint = thumbprint;
        clientAssertion.useSha256 = true;
        if (publicCertificate) {
          clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);
        }
        return clientAssertion;
      }
      /**
       * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is
       * @param cryptoProvider - library's crypto helper
       * @param issuer - iss claim
       * @param jwtAudience - aud claim
       */
      getJwt(cryptoProvider, issuer, jwtAudience) {
        if (this.privateKey && this.thumbprint) {
          if (this.jwt && !this.isExpired() && issuer === this.issuer && jwtAudience === this.jwtAudience) {
            return this.jwt;
          }
          return this.createJwt(cryptoProvider, issuer, jwtAudience);
        }
        if (this.jwt) {
          return this.jwt;
        }
        throw createClientAuthError(ClientAuthErrorCodes_exports.invalidAssertion);
      }
      /**
       * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3
       */
      createJwt(cryptoProvider, issuer, jwtAudience) {
        this.issuer = issuer;
        this.jwtAudience = jwtAudience;
        const issuedAt = TimeUtils_exports.nowSeconds();
        this.expirationTime = issuedAt + 600;
        const algorithm = this.useSha256 ? JwtConstants.PSS_256 : JwtConstants.RSA_256;
        const header = {
          alg: algorithm
        };
        const thumbprintHeader = this.useSha256 ? JwtConstants.X5T_256 : JwtConstants.X5T;
        Object.assign(header, {
          [thumbprintHeader]: EncodingUtils.base64EncodeUrl(this.thumbprint, EncodingTypes.HEX)
        });
        if (this.publicCertificate) {
          Object.assign(header, {
            [JwtConstants.X5C]: this.publicCertificate
          });
        }
        const payload = {
          [JwtConstants.AUDIENCE]: this.jwtAudience,
          [JwtConstants.EXPIRATION_TIME]: this.expirationTime,
          [JwtConstants.ISSUER]: this.issuer,
          [JwtConstants.SUBJECT]: this.issuer,
          [JwtConstants.NOT_BEFORE]: issuedAt,
          [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid()
        };
        this.jwt = import_jsonwebtoken.default.sign(payload, this.privateKey, { header });
        return this.jwt;
      }
      /**
       * Utility API to check expiration
       */
      isExpired() {
        return this.expirationTime < TimeUtils_exports.nowSeconds();
      }
      /**
       * Extracts the raw certs from a given certificate string and returns them in an array.
       * @param publicCertificate - electronic document provided to prove the ownership of the public key
       */
      static parseCertificate(publicCertificate) {
        const regexToFindCerts = /-----BEGIN CERTIFICATE-----\r*\n(.+?)\r*\n-----END CERTIFICATE-----/gs;
        const certs = [];
        let matches;
        while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {
          certs.push(matches[1].replace(/\r*\n/g, Constants.EMPTY_STRING));
        }
        return certs;
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/UsernamePasswordClient.mjs
var UsernamePasswordClient;
var init_UsernamePasswordClient = __esm({
  "node_modules/@azure/msal-node/dist/client/UsernamePasswordClient.mjs"() {
    "use strict";
    init_index_node();
    UsernamePasswordClient = class extends BaseClient {
      constructor(configuration) {
        super(configuration);
      }
      /**
       * API to acquire a token by passing the username and password to the service in exchage of credentials
       * password_grant
       * @param request - CommonUsernamePasswordRequest
       */
      async acquireToken(request) {
        this.logger.info("in acquireToken call in username-password client");
        const reqTimestamp = TimeUtils_exports.nowSeconds();
        const response = await this.executeTokenRequest(this.authority, request);
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
        responseHandler.validateTokenResponse(response.body);
        const tokenResponse = responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request);
        return tokenResponse;
      }
      /**
       * Executes POST request to token endpoint
       * @param authority - authority object
       * @param request - CommonUsernamePasswordRequest provided by the developer
       */
      async executeTokenRequest(authority, request) {
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
        const requestBody = await this.createTokenRequestBody(request);
        const headers = this.createTokenRequestHeaders({
          credential: request.username,
          type: CcsCredentialType.UPN
        });
        const thumbprint = {
          clientId: this.config.authOptions.clientId,
          authority: authority.canonicalAuthority,
          scopes: request.scopes,
          claims: request.claims,
          authenticationScheme: request.authenticationScheme,
          resourceRequestMethod: request.resourceRequestMethod,
          resourceRequestUri: request.resourceRequestUri,
          shrClaims: request.shrClaims,
          sshKid: request.sshKid
        };
        return this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);
      }
      /**
       * Generates a map for all the params to be sent to the service
       * @param request - CommonUsernamePasswordRequest provided by the developer
       */
      async createTokenRequestBody(request) {
        const parameters = /* @__PURE__ */ new Map();
        RequestParameterBuilder_exports.addClientId(parameters, this.config.authOptions.clientId);
        RequestParameterBuilder_exports.addUsername(parameters, request.username);
        RequestParameterBuilder_exports.addPassword(parameters, request.password);
        RequestParameterBuilder_exports.addScopes(parameters, request.scopes);
        RequestParameterBuilder_exports.addResponseType(parameters, OAuthResponseType.IDTOKEN_TOKEN);
        RequestParameterBuilder_exports.addGrantType(parameters, GrantType.RESOURCE_OWNER_PASSWORD_GRANT);
        RequestParameterBuilder_exports.addClientInfo(parameters);
        RequestParameterBuilder_exports.addLibraryInfo(parameters, this.config.libraryInfo);
        RequestParameterBuilder_exports.addApplicationTelemetry(parameters, this.config.telemetry.application);
        RequestParameterBuilder_exports.addThrottling(parameters);
        if (this.serverTelemetryManager) {
          RequestParameterBuilder_exports.addServerTelemetry(parameters, this.serverTelemetryManager);
        }
        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        RequestParameterBuilder_exports.addCorrelationId(parameters, correlationId);
        if (this.config.clientCredentials.clientSecret) {
          RequestParameterBuilder_exports.addClientSecret(parameters, this.config.clientCredentials.clientSecret);
        }
        const clientAssertion = this.config.clientCredentials.clientAssertion;
        if (clientAssertion) {
          RequestParameterBuilder_exports.addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
          RequestParameterBuilder_exports.addClientAssertionType(parameters, clientAssertion.assertionType);
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          RequestParameterBuilder_exports.addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        if (this.config.systemOptions.preventCorsPreflight && request.username) {
          RequestParameterBuilder_exports.addCcsUpn(parameters, request.username);
        }
        return UrlUtils_exports.mapToQueryString(parameters);
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/protocol/Authorize.mjs
function getAuthCodeRequestUrl(config, authority, request, logger11) {
  const parameters = Authorize_exports.getStandardAuthorizeRequestParameters({
    ...config.auth,
    authority,
    redirectUri: request.redirectUri || ""
  }, request, logger11);
  RequestParameterBuilder_exports.addLibraryInfo(parameters, {
    sku: Constants2.MSAL_SKU,
    version: version2,
    cpu: process.arch || "",
    os: process.platform || ""
  });
  if (config.auth.protocolMode !== ProtocolMode.OIDC) {
    RequestParameterBuilder_exports.addApplicationTelemetry(parameters, config.telemetry.application);
  }
  RequestParameterBuilder_exports.addResponseType(parameters, OAuthResponseType.CODE);
  if (request.codeChallenge && request.codeChallengeMethod) {
    RequestParameterBuilder_exports.addCodeChallengeParams(parameters, request.codeChallenge, request.codeChallengeMethod);
  }
  RequestParameterBuilder_exports.addExtraQueryParameters(parameters, request.extraQueryParameters || {});
  return Authorize_exports.getAuthorizeUrl(authority, parameters, config.auth.encodeExtraQueryParams, request.extraQueryParameters);
}
var init_Authorize2 = __esm({
  "node_modules/@azure/msal-node/dist/protocol/Authorize.mjs"() {
    "use strict";
    init_index_node();
    init_Constants2();
    init_packageMetadata2();
  }
});

// node_modules/@azure/msal-node/dist/client/ClientApplication.mjs
var ClientApplication;
var init_ClientApplication = __esm({
  "node_modules/@azure/msal-node/dist/client/ClientApplication.mjs"() {
    "use strict";
    init_index_node();
    init_Configuration();
    init_CryptoProvider();
    init_NodeStorage();
    init_Constants2();
    init_TokenCache();
    init_ClientAssertion();
    init_packageMetadata2();
    init_NodeAuthError();
    init_UsernamePasswordClient();
    init_Authorize2();
    ClientApplication = class {
      /**
       * Constructor for the ClientApplication
       */
      constructor(configuration) {
        this.config = buildAppConfiguration(configuration);
        this.cryptoProvider = new CryptoProvider();
        this.logger = new Logger(this.config.system.loggerOptions, name2, version2);
        this.storage = new NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider, buildStaticAuthorityOptions(this.config.auth));
        this.tokenCache = new TokenCache(this.storage, this.logger, this.config.cache.cachePlugin);
      }
      /**
       * Creates the URL of the authorization request, letting the user input credentials and consent to the
       * application. The URL targets the /authorize endpoint of the authority configured in the
       * application object.
       *
       * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI
       * sent in the request and should contain an authorization code, which can then be used to acquire tokens via
       * `acquireTokenByCode(AuthorizationCodeRequest)`.
       */
      async getAuthCodeUrl(request) {
        this.logger.info("getAuthCodeUrl called", request.correlationId);
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request),
          responseMode: request.responseMode || ResponseMode.QUERY,
          authenticationScheme: AuthenticationScheme.BEARER,
          state: request.state || "",
          nonce: request.nonce || ""
        };
        const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
        return getAuthCodeRequestUrl(this.config, discoveredAuthority, validRequest, this.logger);
      }
      /**
       * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0
       * Authorization Code flow.
       *
       * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0
       * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and
       * AuthorizationCodeRequest are the same.
       */
      async acquireTokenByCode(request, authCodePayLoad) {
        this.logger.info("acquireTokenByCode called");
        if (request.state && authCodePayLoad) {
          this.logger.info("acquireTokenByCode - validating state");
          this.validateState(request.state, authCodePayLoad.state || "");
          authCodePayLoad = { ...authCodePayLoad, state: "" };
        }
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request),
          authenticationScheme: AuthenticationScheme.BEARER
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId);
        try {
          const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
          const authClientConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, validRequest.redirectUri, serverTelemetryManager);
          const authorizationCodeClient = new AuthorizationCodeClient(authClientConfig);
          this.logger.verbose("Auth code client created", validRequest.correlationId);
          return await authorizationCodeClient.acquireToken(validRequest, authCodePayLoad);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires a token by exchanging the refresh token provided for a new set of tokens.
       *
       * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is
       * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will
       * handle the caching and refreshing of tokens automatically.
       */
      async acquireTokenByRefreshToken(request) {
        this.logger.info("acquireTokenByRefreshToken called", request.correlationId);
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request),
          authenticationScheme: AuthenticationScheme.BEARER
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);
        try {
          const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
          const refreshTokenClientConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, validRequest.redirectUri || "", serverTelemetryManager);
          const refreshTokenClient = new RefreshTokenClient(refreshTokenClientConfig);
          this.logger.verbose("Refresh token client created", validRequest.correlationId);
          return await refreshTokenClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires a token silently when a user specifies the account the token is requested for.
       *
       * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.
       * There is also an optional "forceRefresh" boolean the user can send to bypass the cache for access_token and id_token.
       * In case the refresh_token is expired or not found, an error is thrown
       * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).
       */
      async acquireTokenSilent(request) {
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request),
          forceRefresh: request.forceRefresh || false
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);
        try {
          const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
          const clientConfiguration = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, validRequest.redirectUri || "", serverTelemetryManager);
          const silentFlowClient = new SilentFlowClient(clientConfiguration);
          this.logger.verbose("Silent flow client created", validRequest.correlationId);
          try {
            await this.tokenCache.overwriteCache();
            return await this.acquireCachedTokenSilent(validRequest, silentFlowClient, clientConfiguration);
          } catch (error) {
            if (error instanceof ClientAuthError && error.errorCode === ClientAuthErrorCodes_exports.tokenRefreshRequired) {
              const refreshTokenClient = new RefreshTokenClient(clientConfiguration);
              return refreshTokenClient.acquireTokenByRefreshToken(validRequest);
            }
            throw error;
          }
        } catch (error) {
          if (error instanceof AuthError) {
            error.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(error);
          throw error;
        }
      }
      async acquireCachedTokenSilent(validRequest, silentFlowClient, clientConfiguration) {
        const [authResponse, cacheOutcome] = await silentFlowClient.acquireCachedToken({
          ...validRequest,
          scopes: validRequest.scopes?.length ? validRequest.scopes : [...OIDC_DEFAULT_SCOPES]
        });
        if (cacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {
          this.logger.info("ClientApplication:acquireCachedTokenSilent - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.");
          const refreshTokenClient = new RefreshTokenClient(clientConfiguration);
          try {
            await refreshTokenClient.acquireTokenByRefreshToken(validRequest);
          } catch {
          }
        }
        return authResponse;
      }
      /**
       * Acquires tokens with password grant by exchanging client applications username and password for credentials
       *
       * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.
       * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4
       * Microsoft's documentation and recommendations are at:
       * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword
       *
       * @param request - UsenamePasswordRequest
       * @deprecated - Use a more secure flow instead
       */
      async acquireTokenByUsernamePassword(request) {
        this.logger.info("acquireTokenByUsernamePassword called", request.correlationId);
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request)
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId);
        try {
          const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
          const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", serverTelemetryManager);
          const usernamePasswordClient = new UsernamePasswordClient(usernamePasswordClientConfig);
          this.logger.verbose("Username password client created", validRequest.correlationId);
          return await usernamePasswordClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Gets the token cache for the application.
       */
      getTokenCache() {
        this.logger.info("getTokenCache called");
        return this.tokenCache;
      }
      /**
       * Validates OIDC state by comparing the user cached state with the state received from the server.
       *
       * This API is provided for scenarios where you would use OAuth2.0 state parameter to mitigate against
       * CSRF attacks.
       * For more information about state, visit https://datatracker.ietf.org/doc/html/rfc6819#section-3.6.
       * @param state - Unique GUID generated by the user that is cached by the user and sent to the server during the first leg of the flow
       * @param cachedState - This string is sent back by the server with the authorization code
       */
      validateState(state2, cachedState) {
        if (!state2) {
          throw NodeAuthError.createStateNotFoundError();
        }
        if (state2 !== cachedState) {
          throw createClientAuthError(ClientAuthErrorCodes_exports.stateMismatch);
        }
      }
      /**
       * Returns the logger instance
       */
      getLogger() {
        return this.logger;
      }
      /**
       * Replaces the default logger set in configurations with new Logger with new configurations
       * @param logger - Logger instance
       */
      setLogger(logger11) {
        this.logger = logger11;
      }
      /**
       * Builds the common configuration to be passed to the common component based on the platform configurarion
       * @param authority - user passed authority in configuration
       * @param serverTelemetryManager - initializes servertelemetry if passed
       */
      async buildOauthClientConfiguration(discoveredAuthority, requestCorrelationId, redirectUri, serverTelemetryManager) {
        this.logger.verbose("buildOauthClientConfiguration called", requestCorrelationId);
        this.logger.info(`Building oauth client configuration with the following authority: ${discoveredAuthority.tokenEndpoint}.`, requestCorrelationId);
        serverTelemetryManager?.updateRegionDiscoveryMetadata(discoveredAuthority.regionDiscoveryMetadata);
        const clientConfiguration = {
          authOptions: {
            clientId: this.config.auth.clientId,
            authority: discoveredAuthority,
            clientCapabilities: this.config.auth.clientCapabilities,
            redirectUri
          },
          loggerOptions: {
            logLevel: this.config.system.loggerOptions.logLevel,
            loggerCallback: this.config.system.loggerOptions.loggerCallback,
            piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,
            correlationId: requestCorrelationId
          },
          cacheOptions: {
            claimsBasedCachingEnabled: this.config.cache.claimsBasedCachingEnabled
          },
          cryptoInterface: this.cryptoProvider,
          networkInterface: this.config.system.networkClient,
          storageInterface: this.storage,
          serverTelemetryManager,
          clientCredentials: {
            clientSecret: this.clientSecret,
            clientAssertion: await this.getClientAssertion(discoveredAuthority)
          },
          libraryInfo: {
            sku: Constants2.MSAL_SKU,
            version: version2,
            cpu: process.arch || Constants.EMPTY_STRING,
            os: process.platform || Constants.EMPTY_STRING
          },
          telemetry: this.config.telemetry,
          persistencePlugin: this.config.cache.cachePlugin,
          serializableCache: this.tokenCache
        };
        return clientConfiguration;
      }
      async getClientAssertion(authority) {
        if (this.developerProvidedClientAssertion) {
          this.clientAssertion = ClientAssertion.fromAssertion(await getClientAssertion(this.developerProvidedClientAssertion, this.config.auth.clientId, authority.tokenEndpoint));
        }
        return this.clientAssertion && {
          assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),
          assertionType: Constants2.JWT_BEARER_ASSERTION_TYPE
        };
      }
      /**
       * Generates a request with the default scopes & generates a correlationId.
       * @param authRequest - BaseAuthRequest for initialization
       */
      async initializeBaseRequest(authRequest) {
        this.logger.verbose("initializeRequestScopes called", authRequest.correlationId);
        if (authRequest.authenticationScheme && authRequest.authenticationScheme === AuthenticationScheme.POP) {
          this.logger.verbose("Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request", authRequest.correlationId);
        }
        authRequest.authenticationScheme = AuthenticationScheme.BEARER;
        if (this.config.cache.claimsBasedCachingEnabled && authRequest.claims && // Checks for empty stringified object "{}" which doesn't qualify as requested claims
        !StringUtils.isEmptyObj(authRequest.claims)) {
          authRequest.requestedClaimsHash = await this.cryptoProvider.hashString(authRequest.claims);
        }
        return {
          ...authRequest,
          scopes: [
            ...authRequest && authRequest.scopes || [],
            ...OIDC_DEFAULT_SCOPES
          ],
          correlationId: authRequest && authRequest.correlationId || this.cryptoProvider.createNewGuid(),
          authority: authRequest.authority || this.config.auth.authority
        };
      }
      /**
       * Initializes the server telemetry payload
       * @param apiId - Id for a specific request
       * @param correlationId - GUID
       * @param forceRefresh - boolean to indicate network call
       */
      initializeServerTelemetryManager(apiId, correlationId, forceRefresh) {
        const telemetryPayload = {
          clientId: this.config.auth.clientId,
          correlationId,
          apiId,
          forceRefresh: forceRefresh || false
        };
        return new ServerTelemetryManager(telemetryPayload, this.storage);
      }
      /**
       * Create authority instance. If authority not passed in request, default to authority set on the application
       * object. If no authority set in application object, then default to common authority.
       * @param authorityString - authority from user configuration
       */
      async createAuthority(authorityString, requestCorrelationId, azureRegionConfiguration, azureCloudOptions) {
        this.logger.verbose("createAuthority called", requestCorrelationId);
        const authorityUrl = Authority.generateAuthority(authorityString, azureCloudOptions || this.config.auth.azureCloudOptions);
        const authorityOptions = {
          protocolMode: this.config.auth.protocolMode,
          knownAuthorities: this.config.auth.knownAuthorities,
          cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
          authorityMetadata: this.config.auth.authorityMetadata,
          azureRegionConfiguration,
          skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
        };
        return AuthorityFactory_exports.createDiscoveredInstance(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.logger, requestCorrelationId);
      }
      /**
       * Clear the cache
       */
      clearCache() {
        this.storage.clear();
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/network/LoopbackClient.mjs
var import_http5, LoopbackClient;
var init_LoopbackClient = __esm({
  "node_modules/@azure/msal-node/dist/network/LoopbackClient.mjs"() {
    "use strict";
    init_index_node();
    import_http5 = __toESM(require("http"), 1);
    init_NodeAuthError();
    init_Constants2();
    LoopbackClient = class {
      /**
       * Spins up a loopback server which returns the server response when the localhost redirectUri is hit
       * @param successTemplate
       * @param errorTemplate
       * @returns
       */
      async listenForAuthCode(successTemplate, errorTemplate) {
        if (this.server) {
          throw NodeAuthError.createLoopbackServerAlreadyExistsError();
        }
        return new Promise((resolve, reject) => {
          this.server = import_http5.default.createServer((req, res) => {
            const url2 = req.url;
            if (!url2) {
              res.end(errorTemplate || "Error occurred loading redirectUrl");
              reject(NodeAuthError.createUnableToLoadRedirectUrlError());
              return;
            } else if (url2 === Constants.FORWARD_SLASH) {
              res.end(successTemplate || "Auth code was successfully acquired. You can close this window now.");
              return;
            }
            const redirectUri = this.getRedirectUri();
            const parsedUrl = new URL(url2, redirectUri);
            const authCodeResponse = UrlUtils_exports.getDeserializedResponse(parsedUrl.search) || {};
            if (authCodeResponse.code) {
              res.writeHead(HttpStatus.REDIRECT, {
                location: redirectUri
              });
              res.end();
            }
            if (authCodeResponse.error) {
              res.end(errorTemplate || `Error occurred: ${authCodeResponse.error}`);
            }
            resolve(authCodeResponse);
          });
          this.server.listen(0, "127.0.0.1");
        });
      }
      /**
       * Get the port that the loopback server is running on
       * @returns
       */
      getRedirectUri() {
        if (!this.server || !this.server.listening) {
          throw NodeAuthError.createNoLoopbackServerExistsError();
        }
        const address = this.server.address();
        if (!address || typeof address === "string" || !address.port) {
          this.closeServer();
          throw NodeAuthError.createInvalidLoopbackAddressTypeError();
        }
        const port = address && address.port;
        return `${Constants2.HTTP_PROTOCOL}${Constants2.LOCALHOST}:${port}`;
      }
      /**
       * Close the loopback server
       */
      closeServer() {
        if (this.server) {
          this.server.close();
          if (typeof this.server.closeAllConnections === "function") {
            this.server.closeAllConnections();
          }
          this.server.unref();
          this.server = void 0;
        }
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/DeviceCodeClient.mjs
var DeviceCodeClient;
var init_DeviceCodeClient = __esm({
  "node_modules/@azure/msal-node/dist/client/DeviceCodeClient.mjs"() {
    "use strict";
    init_index_node();
    DeviceCodeClient = class extends BaseClient {
      constructor(configuration) {
        super(configuration);
      }
      /**
       * Gets device code from device code endpoint, calls back to with device code response, and
       * polls token endpoint to exchange device code for tokens
       * @param request - developer provided CommonDeviceCodeRequest
       */
      async acquireToken(request) {
        const deviceCodeResponse = await this.getDeviceCode(request);
        request.deviceCodeCallback(deviceCodeResponse);
        const reqTimestamp = TimeUtils_exports.nowSeconds();
        const response = await this.acquireTokenWithDeviceCode(request, deviceCodeResponse);
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
        responseHandler.validateTokenResponse(response);
        return responseHandler.handleServerTokenResponse(response, this.authority, reqTimestamp, request);
      }
      /**
       * Creates device code request and executes http GET
       * @param request - developer provided CommonDeviceCodeRequest
       */
      async getDeviceCode(request) {
        const queryParametersString = this.createExtraQueryParameters(request);
        const endpoint = UrlString.appendQueryString(this.authority.deviceCodeEndpoint, queryParametersString);
        const queryString = this.createQueryString(request);
        const headers = this.createTokenRequestHeaders();
        const thumbprint = {
          clientId: this.config.authOptions.clientId,
          authority: request.authority,
          scopes: request.scopes,
          claims: request.claims,
          authenticationScheme: request.authenticationScheme,
          resourceRequestMethod: request.resourceRequestMethod,
          resourceRequestUri: request.resourceRequestUri,
          shrClaims: request.shrClaims,
          sshKid: request.sshKid
        };
        return this.executePostRequestToDeviceCodeEndpoint(endpoint, queryString, headers, thumbprint, request.correlationId);
      }
      /**
       * Creates query string for the device code request
       * @param request - developer provided CommonDeviceCodeRequest
       */
      createExtraQueryParameters(request) {
        const parameters = /* @__PURE__ */ new Map();
        if (request.extraQueryParameters) {
          RequestParameterBuilder_exports.addExtraQueryParameters(parameters, request.extraQueryParameters);
        }
        return UrlUtils_exports.mapToQueryString(parameters);
      }
      /**
       * Executes POST request to device code endpoint
       * @param deviceCodeEndpoint - token endpoint
       * @param queryString - string to be used in the body of the request
       * @param headers - headers for the request
       * @param thumbprint - unique request thumbprint
       * @param correlationId - correlation id to be used in the request
       */
      async executePostRequestToDeviceCodeEndpoint(deviceCodeEndpoint, queryString, headers, thumbprint, correlationId) {
        const { body: { user_code: userCode, device_code: deviceCode, verification_uri: verificationUri, expires_in: expiresIn, interval, message } } = await this.sendPostRequest(thumbprint, deviceCodeEndpoint, {
          body: queryString,
          headers
        }, correlationId);
        return {
          userCode,
          deviceCode,
          verificationUri,
          expiresIn,
          interval,
          message
        };
      }
      /**
       * Create device code endpoint query parameters and returns string
       * @param request - developer provided CommonDeviceCodeRequest
       */
      createQueryString(request) {
        const parameters = /* @__PURE__ */ new Map();
        RequestParameterBuilder_exports.addScopes(parameters, request.scopes);
        RequestParameterBuilder_exports.addClientId(parameters, this.config.authOptions.clientId);
        if (request.extraQueryParameters) {
          RequestParameterBuilder_exports.addExtraQueryParameters(parameters, request.extraQueryParameters);
        }
        if (request.claims || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          RequestParameterBuilder_exports.addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        return UrlUtils_exports.mapToQueryString(parameters);
      }
      /**
       * Breaks the polling with specific conditions
       * @param deviceCodeExpirationTime - expiration time for the device code request
       * @param userSpecifiedTimeout - developer provided timeout, to be compared against deviceCodeExpirationTime
       * @param userSpecifiedCancelFlag - boolean indicating the developer would like to cancel the request
       */
      continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, userSpecifiedCancelFlag) {
        if (userSpecifiedCancelFlag) {
          this.logger.error("Token request cancelled by setting DeviceCodeRequest.cancel = true");
          throw createClientAuthError(ClientAuthErrorCodes_exports.deviceCodePollingCancelled);
        } else if (userSpecifiedTimeout && userSpecifiedTimeout < deviceCodeExpirationTime && TimeUtils_exports.nowSeconds() > userSpecifiedTimeout) {
          this.logger.error(`User defined timeout for device code polling reached. The timeout was set for ${userSpecifiedTimeout}`);
          throw createClientAuthError(ClientAuthErrorCodes_exports.userTimeoutReached);
        } else if (TimeUtils_exports.nowSeconds() > deviceCodeExpirationTime) {
          if (userSpecifiedTimeout) {
            this.logger.verbose(`User specified timeout ignored as the device code has expired before the timeout elapsed. The user specified timeout was set for ${userSpecifiedTimeout}`);
          }
          this.logger.error(`Device code expired. Expiration time of device code was ${deviceCodeExpirationTime}`);
          throw createClientAuthError(ClientAuthErrorCodes_exports.deviceCodeExpired);
        }
        return true;
      }
      /**
       * Creates token request with device code response and polls token endpoint at interval set by the device code response
       * @param request - developer provided CommonDeviceCodeRequest
       * @param deviceCodeResponse - DeviceCodeResponse returned by the security token service device code endpoint
       */
      async acquireTokenWithDeviceCode(request, deviceCodeResponse) {
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(this.authority.tokenEndpoint, queryParametersString);
        const requestBody = this.createTokenRequestBody(request, deviceCodeResponse);
        const headers = this.createTokenRequestHeaders();
        const userSpecifiedTimeout = request.timeout ? TimeUtils_exports.nowSeconds() + request.timeout : void 0;
        const deviceCodeExpirationTime = TimeUtils_exports.nowSeconds() + deviceCodeResponse.expiresIn;
        const pollingIntervalMilli = deviceCodeResponse.interval * 1e3;
        while (this.continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, request.cancel)) {
          const thumbprint = {
            clientId: this.config.authOptions.clientId,
            authority: request.authority,
            scopes: request.scopes,
            claims: request.claims,
            authenticationScheme: request.authenticationScheme,
            resourceRequestMethod: request.resourceRequestMethod,
            resourceRequestUri: request.resourceRequestUri,
            shrClaims: request.shrClaims,
            sshKid: request.sshKid
          };
          const response = await this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);
          if (response.body && response.body.error) {
            if (response.body.error === Constants.AUTHORIZATION_PENDING) {
              this.logger.info("Authorization pending. Continue polling.");
              await TimeUtils_exports.delay(pollingIntervalMilli);
            } else {
              this.logger.info("Unexpected error in polling from the server");
              throw createAuthError(AuthErrorCodes_exports.postRequestFailed, response.body.error);
            }
          } else {
            this.logger.verbose("Authorization completed successfully. Polling stopped.");
            return response.body;
          }
        }
        this.logger.error("Polling stopped for unknown reasons.");
        throw createClientAuthError(ClientAuthErrorCodes_exports.deviceCodeUnknownError);
      }
      /**
       * Creates query parameters and converts to string.
       * @param request - developer provided CommonDeviceCodeRequest
       * @param deviceCodeResponse - DeviceCodeResponse returned by the security token service device code endpoint
       */
      createTokenRequestBody(request, deviceCodeResponse) {
        const parameters = /* @__PURE__ */ new Map();
        RequestParameterBuilder_exports.addScopes(parameters, request.scopes);
        RequestParameterBuilder_exports.addClientId(parameters, this.config.authOptions.clientId);
        RequestParameterBuilder_exports.addGrantType(parameters, GrantType.DEVICE_CODE_GRANT);
        RequestParameterBuilder_exports.addDeviceCode(parameters, deviceCodeResponse.deviceCode);
        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        RequestParameterBuilder_exports.addCorrelationId(parameters, correlationId);
        RequestParameterBuilder_exports.addClientInfo(parameters);
        RequestParameterBuilder_exports.addLibraryInfo(parameters, this.config.libraryInfo);
        RequestParameterBuilder_exports.addApplicationTelemetry(parameters, this.config.telemetry.application);
        RequestParameterBuilder_exports.addThrottling(parameters);
        if (this.serverTelemetryManager) {
          RequestParameterBuilder_exports.addServerTelemetry(parameters, this.serverTelemetryManager);
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          RequestParameterBuilder_exports.addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        return UrlUtils_exports.mapToQueryString(parameters);
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/PublicClientApplication.mjs
var PublicClientApplication;
var init_PublicClientApplication = __esm({
  "node_modules/@azure/msal-node/dist/client/PublicClientApplication.mjs"() {
    "use strict";
    init_Constants2();
    init_index_node();
    init_ClientApplication();
    init_NodeAuthError();
    init_LoopbackClient();
    init_DeviceCodeClient();
    init_packageMetadata2();
    PublicClientApplication = class extends ClientApplication {
      /**
       * Important attributes in the Configuration object for auth are:
       * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal.
       * - authority: the authority URL for your application.
       *
       * AAD authorities are of the form https://login.microsoftonline.com/\{Enter_the_Tenant_Info_Here\}.
       * - If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
       * - If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
       * - If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
       * - To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
       *
       * Azure B2C authorities are of the form https://\{instance\}/\{tenant\}/\{policy\}. Each policy is considered
       * its own authority. You will have to set the all of the knownAuthorities at the time of the client application
       * construction.
       *
       * ADFS authorities are of the form https://\{instance\}/adfs.
       */
      constructor(configuration) {
        super(configuration);
        if (this.config.broker.nativeBrokerPlugin) {
          if (this.config.broker.nativeBrokerPlugin.isBrokerAvailable) {
            this.nativeBrokerPlugin = this.config.broker.nativeBrokerPlugin;
            this.nativeBrokerPlugin.setLogger(this.config.system.loggerOptions);
          } else {
            this.logger.warning("NativeBroker implementation was provided but the broker is unavailable.");
          }
        }
        this.skus = ServerTelemetryManager.makeExtraSkuString({
          libraryName: Constants2.MSAL_SKU,
          libraryVersion: version2
        });
      }
      /**
       * Acquires a token from the authority using OAuth2.0 device code flow.
       * This flow is designed for devices that do not have access to a browser or have input constraints.
       * The authorization server issues a DeviceCode object with a verification code, an end-user code,
       * and the end-user verification URI. The DeviceCode object is provided through a callback, and the end-user should be
       * instructed to use another device to navigate to the verification URI to input credentials.
       * Since the client cannot receive incoming requests, it polls the authorization server repeatedly
       * until the end-user completes input of credentials.
       */
      async acquireTokenByDeviceCode(request) {
        this.logger.info("acquireTokenByDeviceCode called", request.correlationId);
        const validRequest = Object.assign(request, await this.initializeBaseRequest(request));
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByDeviceCode, validRequest.correlationId);
        try {
          const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
          const deviceCodeConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", serverTelemetryManager);
          const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);
          this.logger.verbose("Device code client created", validRequest.correlationId);
          return await deviceCodeClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires a token interactively via the browser by requesting an authorization code then exchanging it for a token.
       */
      async acquireTokenInteractive(request) {
        const correlationId = request.correlationId || this.cryptoProvider.createNewGuid();
        this.logger.trace("acquireTokenInteractive called", correlationId);
        const { openBrowser, successTemplate, errorTemplate, windowHandle, loopbackClient: customLoopbackClient, ...remainingProperties } = request;
        if (this.nativeBrokerPlugin) {
          const brokerRequest = {
            ...remainingProperties,
            clientId: this.config.auth.clientId,
            scopes: request.scopes || OIDC_DEFAULT_SCOPES,
            redirectUri: request.redirectUri || "",
            authority: request.authority || this.config.auth.authority,
            correlationId,
            extraParameters: {
              ...remainingProperties.extraQueryParameters,
              ...remainingProperties.tokenQueryParameters,
              [AADServerParamKeys_exports.X_CLIENT_EXTRA_SKU]: this.skus
            },
            accountId: remainingProperties.account?.nativeAccountId
          };
          return this.nativeBrokerPlugin.acquireTokenInteractive(brokerRequest, windowHandle);
        }
        if (request.redirectUri) {
          if (!this.config.broker.nativeBrokerPlugin) {
            throw NodeAuthError.createRedirectUriNotSupportedError();
          }
          request.redirectUri = "";
        }
        const { verifier, challenge } = await this.cryptoProvider.generatePkceCodes();
        const loopbackClient = customLoopbackClient || new LoopbackClient();
        let authCodeResponse = {};
        let authCodeListenerError = null;
        try {
          const authCodeListener = loopbackClient.listenForAuthCode(successTemplate, errorTemplate).then((response) => {
            authCodeResponse = response;
          }).catch((e) => {
            authCodeListenerError = e;
          });
          const redirectUri = await this.waitForRedirectUri(loopbackClient);
          const validRequest = {
            ...remainingProperties,
            correlationId,
            scopes: request.scopes || OIDC_DEFAULT_SCOPES,
            redirectUri,
            responseMode: ResponseMode.QUERY,
            codeChallenge: challenge,
            codeChallengeMethod: CodeChallengeMethodValues.S256
          };
          const authCodeUrl = await this.getAuthCodeUrl(validRequest);
          await openBrowser(authCodeUrl);
          await authCodeListener;
          if (authCodeListenerError) {
            throw authCodeListenerError;
          }
          if (authCodeResponse.error) {
            throw new ServerError(authCodeResponse.error, authCodeResponse.error_description, authCodeResponse.suberror);
          } else if (!authCodeResponse.code) {
            throw NodeAuthError.createNoAuthCodeInResponseError();
          }
          const clientInfo = authCodeResponse.client_info;
          const tokenRequest = {
            code: authCodeResponse.code,
            codeVerifier: verifier,
            clientInfo: clientInfo || Constants.EMPTY_STRING,
            ...validRequest
          };
          return await this.acquireTokenByCode(tokenRequest);
        } finally {
          loopbackClient.closeServer();
        }
      }
      /**
       * Returns a token retrieved either from the cache or by exchanging the refresh token for a fresh access token. If brokering is enabled the token request will be serviced by the broker.
       * @param request - developer provided SilentFlowRequest
       * @returns
       */
      async acquireTokenSilent(request) {
        const correlationId = request.correlationId || this.cryptoProvider.createNewGuid();
        this.logger.trace("acquireTokenSilent called", correlationId);
        if (this.nativeBrokerPlugin) {
          const brokerRequest = {
            ...request,
            clientId: this.config.auth.clientId,
            scopes: request.scopes || OIDC_DEFAULT_SCOPES,
            redirectUri: request.redirectUri || "",
            authority: request.authority || this.config.auth.authority,
            correlationId,
            extraParameters: {
              ...request.tokenQueryParameters,
              [AADServerParamKeys_exports.X_CLIENT_EXTRA_SKU]: this.skus
            },
            accountId: request.account.nativeAccountId,
            forceRefresh: request.forceRefresh || false
          };
          return this.nativeBrokerPlugin.acquireTokenSilent(brokerRequest);
        }
        if (request.redirectUri) {
          if (!this.config.broker.nativeBrokerPlugin) {
            throw NodeAuthError.createRedirectUriNotSupportedError();
          }
          request.redirectUri = "";
        }
        return super.acquireTokenSilent(request);
      }
      /**
       * Removes cache artifacts associated with the given account
       * @param request - developer provided SignOutRequest
       * @returns
       */
      async signOut(request) {
        if (this.nativeBrokerPlugin && request.account.nativeAccountId) {
          const signoutRequest = {
            clientId: this.config.auth.clientId,
            accountId: request.account.nativeAccountId,
            correlationId: request.correlationId || this.cryptoProvider.createNewGuid()
          };
          await this.nativeBrokerPlugin.signOut(signoutRequest);
        }
        await this.getTokenCache().removeAccount(request.account, request.correlationId);
      }
      /**
       * Returns all cached accounts for this application. If brokering is enabled this request will be serviced by the broker.
       * @returns
       */
      async getAllAccounts() {
        if (this.nativeBrokerPlugin) {
          const correlationId = this.cryptoProvider.createNewGuid();
          return this.nativeBrokerPlugin.getAllAccounts(this.config.auth.clientId, correlationId);
        }
        return this.getTokenCache().getAllAccounts();
      }
      /**
       * Attempts to retrieve the redirectUri from the loopback server. If the loopback server does not start listening for requests within the timeout this will throw.
       * @param loopbackClient - developer provided custom loopback server implementation
       * @returns
       */
      async waitForRedirectUri(loopbackClient) {
        return new Promise((resolve, reject) => {
          let ticks = 0;
          const id = setInterval(() => {
            if (LOOPBACK_SERVER_CONSTANTS.TIMEOUT_MS / LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS < ticks) {
              clearInterval(id);
              reject(NodeAuthError.createLoopbackServerTimeoutError());
              return;
            }
            try {
              const r = loopbackClient.getRedirectUri();
              clearInterval(id);
              resolve(r);
              return;
            } catch (e) {
              if (e instanceof AuthError && e.errorCode === NodeAuthErrorMessage.noLoopbackServerExists.code) {
                ticks++;
                return;
              }
              clearInterval(id);
              reject(e);
              return;
            }
          }, LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS);
        });
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/ClientCredentialClient.mjs
var init_ClientCredentialClient = __esm({
  "node_modules/@azure/msal-node/dist/client/ClientCredentialClient.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-node/dist/client/OnBehalfOfClient.mjs
var init_OnBehalfOfClient = __esm({
  "node_modules/@azure/msal-node/dist/client/OnBehalfOfClient.mjs"() {
    "use strict";
    init_EncodingUtils();
  }
});

// node_modules/@azure/msal-node/dist/client/ConfidentialClientApplication.mjs
var init_ConfidentialClientApplication = __esm({
  "node_modules/@azure/msal-node/dist/client/ConfidentialClientApplication.mjs"() {
    "use strict";
    init_ClientApplication();
    init_ClientAssertion();
    init_Constants2();
    init_ClientCredentialClient();
    init_OnBehalfOfClient();
  }
});

// node_modules/@azure/msal-node/dist/utils/TimeUtils.mjs
function isIso8601(dateString) {
  if (typeof dateString !== "string") {
    return false;
  }
  const date = new Date(dateString);
  return !isNaN(date.getTime()) && date.toISOString() === dateString;
}
var init_TimeUtils2 = __esm({
  "node_modules/@azure/msal-node/dist/utils/TimeUtils.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-node/dist/network/HttpClientWithRetries.mjs
var HttpClientWithRetries;
var init_HttpClientWithRetries = __esm({
  "node_modules/@azure/msal-node/dist/network/HttpClientWithRetries.mjs"() {
    "use strict";
    init_index_node();
    init_Constants2();
    HttpClientWithRetries = class {
      constructor(httpClientNoRetries, retryPolicy, logger11) {
        this.httpClientNoRetries = httpClientNoRetries;
        this.retryPolicy = retryPolicy;
        this.logger = logger11;
      }
      async sendNetworkRequestAsyncHelper(httpMethod, url2, options) {
        if (httpMethod === HttpMethod2.GET) {
          return this.httpClientNoRetries.sendGetRequestAsync(url2, options);
        } else {
          return this.httpClientNoRetries.sendPostRequestAsync(url2, options);
        }
      }
      async sendNetworkRequestAsync(httpMethod, url2, options) {
        let response = await this.sendNetworkRequestAsyncHelper(httpMethod, url2, options);
        if ("isNewRequest" in this.retryPolicy) {
          this.retryPolicy.isNewRequest = true;
        }
        let currentRetry = 0;
        while (await this.retryPolicy.pauseForRetry(response.status, currentRetry, this.logger, response.headers[HeaderNames.RETRY_AFTER])) {
          response = await this.sendNetworkRequestAsyncHelper(httpMethod, url2, options);
          currentRetry++;
        }
        return response;
      }
      async sendGetRequestAsync(url2, options) {
        return this.sendNetworkRequestAsync(HttpMethod2.GET, url2, options);
      }
      async sendPostRequestAsync(url2, options) {
        return this.sendNetworkRequestAsync(HttpMethod2.POST, url2, options);
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/BaseManagedIdentitySource.mjs
var ManagedIdentityUserAssignedIdQueryParameterNames, BaseManagedIdentitySource;
var init_BaseManagedIdentitySource = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/BaseManagedIdentitySource.mjs"() {
    "use strict";
    init_index_node();
    init_Constants2();
    init_ManagedIdentityError();
    init_TimeUtils2();
    init_HttpClientWithRetries();
    init_ManagedIdentityErrorCodes();
    ManagedIdentityUserAssignedIdQueryParameterNames = {
      MANAGED_IDENTITY_CLIENT_ID_2017: "clientid",
      MANAGED_IDENTITY_CLIENT_ID: "client_id",
      MANAGED_IDENTITY_OBJECT_ID: "object_id",
      MANAGED_IDENTITY_RESOURCE_ID_IMDS: "msi_res_id",
      MANAGED_IDENTITY_RESOURCE_ID_NON_IMDS: "mi_res_id"
    };
    BaseManagedIdentitySource = class {
      /**
       * Creates an instance of BaseManagedIdentitySource.
       *
       * @param logger - Logger instance for diagnostic information
       * @param nodeStorage - Storage interface for caching tokens
       * @param networkClient - Network client for making HTTP requests
       * @param cryptoProvider - Cryptographic provider for token operations
       * @param disableInternalRetries - Whether to disable automatic retry logic
       */
      constructor(logger11, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {
        this.logger = logger11;
        this.nodeStorage = nodeStorage;
        this.networkClient = networkClient;
        this.cryptoProvider = cryptoProvider;
        this.disableInternalRetries = disableInternalRetries;
      }
      /**
       * Processes the network response and converts it to a standardized server token response.
       * This async version allows for source-specific response processing logic while maintaining
       * backward compatibility with the synchronous version.
       *
       * @param response - The network response containing the managed identity token
       * @param _networkClient - Network client used for the request (unused in base implementation)
       * @param _networkRequest - The original network request parameters (unused in base implementation)
       * @param _networkRequestOptions - The network request options (unused in base implementation)
       *
       * @returns Promise resolving to a standardized server authorization token response
       */
      async getServerTokenResponseAsync(response, _networkClient, _networkRequest, _networkRequestOptions) {
        return this.getServerTokenResponse(response);
      }
      /**
       * Converts a managed identity token response to a standardized server authorization token response.
       * Handles time format conversion, expiration calculation, and error mapping to ensure
       * compatibility with the MSAL response handling pipeline.
       *
       * @param response - The network response containing the managed identity token
       *
       * @returns Standardized server authorization token response with normalized fields
       */
      getServerTokenResponse(response) {
        let refreshIn, expiresIn;
        if (response.body.expires_on) {
          if (isIso8601(response.body.expires_on)) {
            response.body.expires_on = new Date(response.body.expires_on).getTime() / 1e3;
          }
          expiresIn = response.body.expires_on - TimeUtils_exports.nowSeconds();
          if (expiresIn > 2 * 3600) {
            refreshIn = expiresIn / 2;
          }
        }
        const serverTokenResponse = {
          status: response.status,
          // success
          access_token: response.body.access_token,
          expires_in: expiresIn,
          scope: response.body.resource,
          token_type: response.body.token_type,
          refresh_in: refreshIn,
          // error
          correlation_id: response.body.correlation_id || response.body.correlationId,
          error: typeof response.body.error === "string" ? response.body.error : response.body.error?.code,
          error_description: response.body.message || (typeof response.body.error === "string" ? response.body.error_description : response.body.error?.message),
          error_codes: response.body.error_codes,
          timestamp: response.body.timestamp,
          trace_id: response.body.trace_id
        };
        return serverTokenResponse;
      }
      /**
       * Acquires an access token using the managed identity endpoint for the specified resource.
       * This is the primary method for token acquisition, handling the complete flow from
       * request creation through response processing and token caching.
       *
       * @param managedIdentityRequest - The managed identity request containing resource and optional parameters
       * @param managedIdentityId - The managed identity configuration (system or user-assigned)
       * @param fakeAuthority - Authority instance used for token caching (managed identity uses a placeholder authority)
       * @param refreshAccessToken - Whether this is a token refresh operation
       *
       * @returns Promise resolving to an authentication result containing the access token and metadata
       *
       * @throws {AuthError} When network requests fail or token validation fails
       * @throws {ClientAuthError} When network errors occur during the request
       */
      async acquireTokenWithManagedIdentity(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken) {
        const networkRequest = this.createRequest(managedIdentityRequest.resource, managedIdentityId);
        if (managedIdentityRequest.revokedTokenSha256Hash) {
          this.logger.info(`[Managed Identity] The following claims are present in the request: ${managedIdentityRequest.claims}`);
          networkRequest.queryParameters[ManagedIdentityQueryParameters.SHA256_TOKEN_TO_REFRESH] = managedIdentityRequest.revokedTokenSha256Hash;
        }
        if (managedIdentityRequest.clientCapabilities?.length) {
          const clientCapabilities = managedIdentityRequest.clientCapabilities.toString();
          this.logger.info(`[Managed Identity] The following client capabilities are present in the request: ${clientCapabilities}`);
          networkRequest.queryParameters[ManagedIdentityQueryParameters.XMS_CC] = clientCapabilities;
        }
        const headers = networkRequest.headers;
        headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
        const networkRequestOptions = { headers };
        if (Object.keys(networkRequest.bodyParameters).length) {
          networkRequestOptions.body = networkRequest.computeParametersBodyString();
        }
        const networkClientHelper = this.disableInternalRetries ? this.networkClient : new HttpClientWithRetries(this.networkClient, networkRequest.retryPolicy, this.logger);
        const reqTimestamp = TimeUtils_exports.nowSeconds();
        let response;
        try {
          if (networkRequest.httpMethod === HttpMethod2.POST) {
            response = await networkClientHelper.sendPostRequestAsync(networkRequest.computeUri(), networkRequestOptions);
          } else {
            response = await networkClientHelper.sendGetRequestAsync(networkRequest.computeUri(), networkRequestOptions);
          }
        } catch (error) {
          if (error instanceof AuthError) {
            throw error;
          } else {
            throw createClientAuthError(ClientAuthErrorCodes_exports.networkError);
          }
        }
        const responseHandler = new ResponseHandler(managedIdentityId.id, this.nodeStorage, this.cryptoProvider, this.logger, null, null);
        const serverTokenResponse = await this.getServerTokenResponseAsync(response, networkClientHelper, networkRequest, networkRequestOptions);
        responseHandler.validateTokenResponse(serverTokenResponse, refreshAccessToken);
        return responseHandler.handleServerTokenResponse(serverTokenResponse, fakeAuthority, reqTimestamp, managedIdentityRequest);
      }
      /**
       * Determines the appropriate query parameter name for user-assigned managed identity
       * based on the identity type, API version, and endpoint characteristics.
       * Different Azure services and API versions use different parameter names for the same identity types.
       *
       * @param managedIdentityIdType - The type of user-assigned managed identity (client ID, object ID, or resource ID)
       * @param isImds - Whether the request is being made to the IMDS (Instance Metadata Service) endpoint
       * @param usesApi2017 - Whether the endpoint uses the 2017-09-01 API version (affects client ID parameter name)
       *
       * @returns The correct query parameter name for the specified identity type and endpoint
       *
       * @throws {ManagedIdentityError} When an invalid managed identity ID type is provided
       */
      getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityIdType, isImds, usesApi2017) {
        switch (managedIdentityIdType) {
          case ManagedIdentityIdType.USER_ASSIGNED_CLIENT_ID:
            this.logger.info(`[Managed Identity] [API version ${usesApi2017 ? "2017+" : "2019+"}] Adding user assigned client id to the request.`);
            return usesApi2017 ? ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID_2017 : ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID;
          case ManagedIdentityIdType.USER_ASSIGNED_RESOURCE_ID:
            this.logger.info("[Managed Identity] Adding user assigned resource id to the request.");
            return isImds ? ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_RESOURCE_ID_IMDS : ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_RESOURCE_ID_NON_IMDS;
          case ManagedIdentityIdType.USER_ASSIGNED_OBJECT_ID:
            this.logger.info("[Managed Identity] Adding user assigned object id to the request.");
            return ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_OBJECT_ID;
          default:
            throw createManagedIdentityError(invalidManagedIdentityIdType);
        }
      }
    };
    BaseManagedIdentitySource.getValidatedEnvVariableUrlString = (envVariableStringName, envVariable, sourceName, logger11) => {
      try {
        return new UrlString(envVariable).urlString;
      } catch (error) {
        logger11.info(`[Managed Identity] ${sourceName} managed identity is unavailable because the '${envVariableStringName}' environment variable is malformed.`);
        throw createManagedIdentityError(MsiEnvironmentVariableUrlMalformedErrorCodes[envVariableStringName]);
      }
    };
  }
});

// node_modules/@azure/msal-node/dist/retry/LinearRetryStrategy.mjs
var init_LinearRetryStrategy = __esm({
  "node_modules/@azure/msal-node/dist/retry/LinearRetryStrategy.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-node/dist/retry/DefaultManagedIdentityRetryPolicy.mjs
var DEFAULT_MANAGED_IDENTITY_HTTP_STATUS_CODES_TO_RETRY_ON;
var init_DefaultManagedIdentityRetryPolicy = __esm({
  "node_modules/@azure/msal-node/dist/retry/DefaultManagedIdentityRetryPolicy.mjs"() {
    "use strict";
    init_dist();
    init_LinearRetryStrategy();
    DEFAULT_MANAGED_IDENTITY_HTTP_STATUS_CODES_TO_RETRY_ON = [
      HttpStatus.NOT_FOUND,
      HttpStatus.REQUEST_TIMEOUT,
      HttpStatus.TOO_MANY_REQUESTS,
      HttpStatus.SERVER_ERROR,
      HttpStatus.SERVICE_UNAVAILABLE,
      HttpStatus.GATEWAY_TIMEOUT
    ];
  }
});

// node_modules/@azure/msal-node/dist/config/ManagedIdentityRequestParameters.mjs
var init_ManagedIdentityRequestParameters = __esm({
  "node_modules/@azure/msal-node/dist/config/ManagedIdentityRequestParameters.mjs"() {
    "use strict";
    init_DefaultManagedIdentityRetryPolicy();
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/AppService.mjs
var init_AppService = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/AppService.mjs"() {
    "use strict";
    init_BaseManagedIdentitySource();
    init_Constants2();
    init_ManagedIdentityRequestParameters();
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/AzureArc.mjs
var SUPPORTED_AZURE_ARC_PLATFORMS, AZURE_ARC_FILE_DETECTION;
var init_AzureArc = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/AzureArc.mjs"() {
    "use strict";
    init_ManagedIdentityRequestParameters();
    init_BaseManagedIdentitySource();
    init_ManagedIdentityError();
    init_Constants2();
    init_ManagedIdentityErrorCodes();
    SUPPORTED_AZURE_ARC_PLATFORMS = {
      win32: `${process.env["ProgramData"]}\\AzureConnectedMachineAgent\\Tokens\\`,
      linux: "/var/opt/azcmagent/tokens/"
    };
    AZURE_ARC_FILE_DETECTION = {
      win32: `${process.env["ProgramFiles"]}\\AzureConnectedMachineAgent\\himds.exe`,
      linux: "/opt/azcmagent/bin/himds"
    };
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/CloudShell.mjs
var init_CloudShell = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/CloudShell.mjs"() {
    "use strict";
    init_ManagedIdentityRequestParameters();
    init_BaseManagedIdentitySource();
    init_Constants2();
    init_ManagedIdentityError();
    init_ManagedIdentityErrorCodes();
  }
});

// node_modules/@azure/msal-node/dist/retry/ExponentialRetryStrategy.mjs
var init_ExponentialRetryStrategy = __esm({
  "node_modules/@azure/msal-node/dist/retry/ExponentialRetryStrategy.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-node/dist/retry/ImdsRetryPolicy.mjs
var HTTP_STATUS_400_CODES_FOR_EXPONENTIAL_STRATEGY, HTTP_STATUS_GONE_RETRY_AFTER_MS;
var init_ImdsRetryPolicy = __esm({
  "node_modules/@azure/msal-node/dist/retry/ImdsRetryPolicy.mjs"() {
    "use strict";
    init_dist();
    init_ExponentialRetryStrategy();
    HTTP_STATUS_400_CODES_FOR_EXPONENTIAL_STRATEGY = [
      HttpStatus.NOT_FOUND,
      HttpStatus.REQUEST_TIMEOUT,
      HttpStatus.GONE,
      HttpStatus.TOO_MANY_REQUESTS
    ];
    HTTP_STATUS_GONE_RETRY_AFTER_MS = 10 * 1e3;
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/Imds.mjs
var IMDS_TOKEN_PATH, DEFAULT_IMDS_ENDPOINT;
var init_Imds = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/Imds.mjs"() {
    "use strict";
    init_ManagedIdentityRequestParameters();
    init_BaseManagedIdentitySource();
    init_Constants2();
    init_ImdsRetryPolicy();
    IMDS_TOKEN_PATH = "/metadata/identity/oauth2/token";
    DEFAULT_IMDS_ENDPOINT = `http://169.254.169.254${IMDS_TOKEN_PATH}`;
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/ServiceFabric.mjs
var init_ServiceFabric = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/ServiceFabric.mjs"() {
    "use strict";
    init_ManagedIdentityRequestParameters();
    init_BaseManagedIdentitySource();
    init_Constants2();
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/MachineLearning.mjs
var MANAGED_IDENTITY_MACHINE_LEARNING_UNSUPPORTED_ID_TYPE_ERROR;
var init_MachineLearning = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/MachineLearning.mjs"() {
    "use strict";
    init_BaseManagedIdentitySource();
    init_Constants2();
    init_ManagedIdentityRequestParameters();
    MANAGED_IDENTITY_MACHINE_LEARNING_UNSUPPORTED_ID_TYPE_ERROR = `Only client id is supported for user-assigned managed identity in ${ManagedIdentitySourceNames.MACHINE_LEARNING}.`;
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentityClient.mjs
var init_ManagedIdentityClient = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentityClient.mjs"() {
    "use strict";
    init_AppService();
    init_AzureArc();
    init_CloudShell();
    init_Imds();
    init_ServiceFabric();
    init_ManagedIdentityError();
    init_Constants2();
    init_MachineLearning();
    init_ManagedIdentityErrorCodes();
  }
});

// node_modules/@azure/msal-node/dist/client/ManagedIdentityApplication.mjs
var SOURCES_THAT_SUPPORT_TOKEN_REVOCATION;
var init_ManagedIdentityApplication = __esm({
  "node_modules/@azure/msal-node/dist/client/ManagedIdentityApplication.mjs"() {
    "use strict";
    init_Configuration();
    init_packageMetadata2();
    init_CryptoProvider();
    init_ClientCredentialClient();
    init_ManagedIdentityClient();
    init_NodeStorage();
    init_Constants2();
    init_HashUtils();
    SOURCES_THAT_SUPPORT_TOKEN_REVOCATION = [ManagedIdentitySourceNames.SERVICE_FABRIC];
  }
});

// node_modules/@azure/msal-node/dist/cache/distributed/DistributedCachePlugin.mjs
var init_DistributedCachePlugin = __esm({
  "node_modules/@azure/msal-node/dist/cache/distributed/DistributedCachePlugin.mjs"() {
    "use strict";
  }
});

// node_modules/@azure/msal-node/dist/index.mjs
var init_dist2 = __esm({
  "node_modules/@azure/msal-node/dist/index.mjs"() {
    "use strict";
    init_internals();
    init_PublicClientApplication();
    init_ConfidentialClientApplication();
    init_ClientApplication();
    init_ClientCredentialClient();
    init_DeviceCodeClient();
    init_OnBehalfOfClient();
    init_ManagedIdentityApplication();
    init_UsernamePasswordClient();
    init_ClientAssertion();
    init_TokenCache();
    init_DistributedCachePlugin();
    init_Constants2();
    init_CryptoProvider();
    init_index_node();
    init_packageMetadata2();
  }
});

// src/services/auth/tokenCache.ts
function isTokenExpired2(token) {
  try {
    const parts = token.split(".");
    if (parts.length !== 3) return true;
    const payload = JSON.parse(Buffer.from(parts[1], "base64").toString());
    const now = Math.floor(Date.now() / 1e3);
    return payload.exp < now + 300;
  } catch {
    return true;
  }
}
function resolveScopes(customScopes) {
  const scopes = /* @__PURE__ */ new Set();
  (customScopes ?? [AZURE_DEVOPS_SCOPE]).forEach((scope) => {
    if (scope && typeof scope === "string") {
      const trimmed = scope.trim();
      if (trimmed.length > 0) scopes.add(trimmed);
    }
  });
  scopes.add(OFFLINE_ACCESS_SCOPE);
  return Array.from(scopes);
}
async function tryGetCachedToken(context, searchKeys, targetKey) {
  for (const key2 of searchKeys) {
    const cachedToken = await context.secrets.get(key2);
    if (cachedToken && !isTokenExpired2(cachedToken)) {
      if (key2 !== targetKey) {
        await context.secrets.store(targetKey, cachedToken);
      }
      return cachedToken;
    }
  }
  return void 0;
}
function formatAuthError(error) {
  if (!error) return "Unknown error";
  const parts = [];
  const knownFields = [
    error.errorCode,
    error.subError,
    error.statusCode,
    error.message,
    error.errorMessage,
    error.correlationId
  ].filter(Boolean).map((v) => `${v}`);
  parts.push(...knownFields);
  const responseBody = error?.responseBody || error?.body || error?.response?.body;
  if (responseBody) {
    const bodyString = typeof responseBody === "string" ? responseBody : JSON.stringify(responseBody);
    parts.push(`body=${bodyString}`);
  }
  if (error?.stack) {
    parts.push(`stack=${error.stack}`);
  }
  return parts.filter(Boolean).join(" | ");
}
var init_tokenCache = __esm({
  "src/services/auth/tokenCache.ts"() {
    "use strict";
    init_constants();
  }
});

// src/services/auth/deviceCodeHelpers.ts
function pickFirstString(...values) {
  return values.find((value) => typeof value === "string" && value.length > 0);
}
function extractUserCodeFromMessage(message) {
  if (!message) return void 0;
  const direct = message.match(/code[:\s]+([A-Z0-9-]{4,})/i)?.[1];
  if (direct) return direct.toUpperCase();
  const looseCandidate = message.match(/([A-Z0-9]{6,})/g)?.find((c) => c.length >= 6);
  return looseCandidate ? looseCandidate.toUpperCase() : void 0;
}
function extractUserCodeFromUri(uri) {
  if (!uri) return void 0;
  try {
    const url2 = new URL(uri);
    const paramKeys = ["user_code", "usercode", "code", "otc"];
    for (const key2 of paramKeys) {
      const value = url2.searchParams.get(key2);
      if (value) return value.toUpperCase();
    }
    const looseCandidate = uri.match(/([A-Z0-9]{6,})/g)?.find((c) => c.length >= 6);
    return looseCandidate ? looseCandidate.toUpperCase() : void 0;
  } catch {
    return void 0;
  }
}
function resolveMessage(response) {
  return typeof response?.message === "string" ? response.message : void 0;
}
function resolveUserCode(response, rawMessage) {
  return (pickFirstString(response?.userCode, response?.user_code) || extractUserCodeFromMessage(rawMessage) || extractUserCodeFromUri(response?.verificationUriComplete || response?.verification_uri_complete))?.toUpperCase();
}
function resolveVerificationUri(response) {
  return pickFirstString(
    response?.verificationUri,
    response?.verification_uri,
    response?.verificationUriComplete,
    response?.verification_uri_complete
  ) || "https://microsoft.com/devicelogin";
}
function resolveVerificationUriComplete(response, verificationUri, userCode) {
  const explicit = pickFirstString(
    response?.verificationUriComplete,
    response?.verification_uri_complete
  );
  if (explicit) return explicit;
  return userCode ? `${verificationUri}?user_code=${userCode}` : void 0;
}
function resolveExpiresInSeconds(response) {
  return response?.expiresIn || response?.expiresInSeconds || response?.expires_in || 900;
}
function normalizeDeviceCodeResponse(response) {
  if (!response) return void 0;
  const rawMessage = resolveMessage(response);
  const userCode = resolveUserCode(response, rawMessage);
  const verificationUri = resolveVerificationUri(response);
  const verificationUriComplete = resolveVerificationUriComplete(
    response,
    verificationUri,
    userCode
  );
  const expiresInSeconds = resolveExpiresInSeconds(response);
  return {
    userCode,
    verificationUri,
    verificationUriComplete,
    expiresInSeconds,
    message: rawMessage
  };
}
function ensureMessage(response, normalized) {
  if (response?.message) return response.message;
  const code = normalized?.userCode;
  if (!code) return normalized?.message;
  const uri = normalized?.verificationUri ?? "https://microsoft.com/devicelogin";
  return `To sign in, use a web browser to open ${uri} and enter the code ${code}`;
}
function enrichDeviceCodeResponse(response) {
  const normalized = normalizeDeviceCodeResponse(response);
  const userCode = normalized?.userCode ?? resolveUserCode(response, response?.message);
  const verificationUri = normalized?.verificationUri ?? resolveVerificationUri(response);
  const verificationUriComplete = normalized?.verificationUriComplete ?? resolveVerificationUriComplete(response, verificationUri, userCode);
  return {
    ...response ?? {},
    userCode,
    user_code: userCode,
    verificationUri,
    verification_uri: verificationUri,
    verificationUriComplete,
    verification_uri_complete: verificationUriComplete,
    message: ensureMessage(response, normalized),
    __normalized: normalized
  };
}
var init_deviceCodeHelpers = __esm({
  "src/services/auth/deviceCodeHelpers.ts"() {
    "use strict";
  }
});

// src/services/auth/deviceCodeFlow.ts
function normalizeDeviceCodeResponse2(response) {
  const enriched = enrichDeviceCodeResponse(response);
  const userCode = enriched.userCode ?? enriched.__normalized?.userCode;
  const verificationUri = enriched.verificationUri ?? enriched.__normalized?.verificationUri ?? "https://microsoft.com/devicelogin";
  const expiresInSeconds = enriched.__normalized?.expiresInSeconds ?? response?.expiresIn ?? response?.expires_in ?? 900;
  return {
    userCode,
    verificationUri,
    verificationUriComplete: enriched.verificationUriComplete ?? enriched.__normalized?.verificationUriComplete,
    expiresInSeconds,
    message: enriched.message
  };
}
async function copyDeviceCodeToClipboard(userCode) {
  if (!userCode) return;
  try {
    await vscode6.env.clipboard.writeText(userCode);
  } catch (error) {
    logger5.warn("[copyDeviceCodeToClipboard] Failed to copy device code", { meta: error });
  }
}
async function openBrowserForDeviceCode(info) {
  const target = info.verificationUriComplete || info.verificationUri;
  try {
    await vscode6.env.openExternal(vscode6.Uri.parse(target));
  } catch (error) {
    logger5.warn("[openBrowserForDeviceCode] Failed to open browser", { meta: error });
    vscode6.window.showErrorMessage("Failed to open browser. Please open it manually.");
  }
}
async function notifyDeviceCode(info, options) {
  if (!info.userCode || info.userCode.trim() === "") {
    logger5.warn("[notifyDeviceCode] Device code is missing", {
      meta: { hasVerificationUri: !!info.verificationUri }
    });
    vscode6.window.showErrorMessage("Device code is not available. Please try signing in again.");
    return;
  }
  await copyDeviceCodeToClipboard(info.userCode);
  const label = options.connectionLabel || options.connectionId || "Microsoft Entra ID";
  const message = `To sign in to ${label}, use a web browser to open ${info.verificationUri} and enter the code ${info.userCode} to authenticate.`;
  const openInBrowser = "Open in Browser";
  void vscode6.window.showInformationMessage(message, openInBrowser).then(async (action2) => {
    if (action2 !== openInBrowser) return;
    vscode6.window.showInformationMessage(
      `Device code ${info.userCode} copied to clipboard. Paste it into the browser to finish signing in.`
    );
    await openBrowserForDeviceCode(info);
  }).then(void 0, (error) => {
    logger5.warn("[notifyDeviceCode] Notification error", { meta: error });
  });
  if (info.userCode && typeof options.onDeviceCode === "function") {
    Promise.resolve(
      options.onDeviceCode({
        userCode: info.userCode,
        verificationUri: info.verificationUri,
        verificationUriComplete: info.verificationUriComplete,
        expiresInSeconds: info.expiresInSeconds
      })
    ).catch((error) => {
      logger5.error("[notifyDeviceCode] Error in onDeviceCode callback", { meta: error });
    });
  }
}
var vscode6, logger5;
var init_deviceCodeFlow = __esm({
  "src/services/auth/deviceCodeFlow.ts"() {
    "use strict";
    vscode6 = __toESM(require("vscode"), 1);
    init_deviceCodeHelpers();
    init_unifiedLogger();
    logger5 = createLogger("auth-device-code");
  }
});

// src/config/authConfig.ts
var authConfig_exports = {};
__export(authConfig_exports, {
  getAuthConfig: () => getAuthConfig,
  shouldUseAuthCodeFlow: () => shouldUseAuthCodeFlow
});
function getAuthConfig() {
  const config = vscode7.workspace.getConfiguration("azureDevOpsIntegration.auth");
  const useAuthCodeFlow = config.get("useAuthCodeFlow", true);
  const flowPreference = config.get("flow", "auto");
  return {
    useAuthCodeFlow: useAuthCodeFlow || flowPreference === "auth-code",
    flowPreference
  };
}
function shouldUseAuthCodeFlow(authMethod, _connectionId) {
  if (authMethod !== "entra") {
    return false;
  }
  const config = getAuthConfig();
  if (config.flowPreference === "auth-code") {
    return true;
  }
  if (config.flowPreference === "device-code") {
    return false;
  }
  return config.useAuthCodeFlow !== false;
}
var vscode7;
var init_authConfig = __esm({
  "src/config/authConfig.ts"() {
    "use strict";
    vscode7 = __toESM(require("vscode"), 1);
  }
});

// src/services/auth/pkceUtils.ts
function generatePKCEParams() {
  const codeVerifier = generateCodeVerifier();
  const codeChallenge = generateCodeChallenge(codeVerifier);
  return {
    codeVerifier,
    codeChallenge,
    codeChallengeMethod: "S256"
  };
}
function generateCodeVerifier() {
  const randomBytes2 = crypto5.randomBytes(32);
  return base64URLEncode(randomBytes2);
}
function generateCodeChallenge(verifier) {
  const hash2 = crypto5.createHash("sha256").update(verifier).digest();
  return base64URLEncode(hash2);
}
function base64URLEncode(buffer) {
  return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function generateState() {
  return base64URLEncode(crypto5.randomBytes(32));
}
function isValidCodeVerifier(verifier) {
  if (verifier.length < 43 || verifier.length > 128) {
    return false;
  }
  return /^[A-Za-z0-9\-_.~]+$/.test(verifier);
}
var crypto5;
var init_pkceUtils = __esm({
  "src/services/auth/pkceUtils.ts"() {
    "use strict";
    crypto5 = __toESM(require("crypto"), 1);
  }
});

// src/services/auth/authorizationCodeProvider.ts
var vscode8, componentLogger2, AZURE_DEVOPS_RESOURCE_ID, DEFAULT_SCOPES, AUTH_TIMEOUT_MS, AuthorizationCodeFlowProvider;
var init_authorizationCodeProvider = __esm({
  "src/services/auth/authorizationCodeProvider.ts"() {
    "use strict";
    init_dist2();
    vscode8 = __toESM(require("vscode"), 1);
    init_pkceUtils();
    init_ComponentLogger();
    componentLogger2 = createComponentLogger("AUTH" /* AUTH */, "AuthorizationCodeFlowProvider");
    AZURE_DEVOPS_RESOURCE_ID = "499b84ac-1321-427f-aa17-267ca6975798";
    DEFAULT_SCOPES = [`${AZURE_DEVOPS_RESOURCE_ID}/.default`, "offline_access"];
    AUTH_TIMEOUT_MS = 15 * 60 * 1e3;
    AuthorizationCodeFlowProvider = class {
      msalClient;
      secretStorage;
      connectionId;
      redirectUri;
      config;
      pkceParams;
      pendingAuthState;
      authStartTime;
      resolveAuthPromise;
      rejectAuthPromise;
      authTimeout;
      onStatusUpdate;
      constructor(options) {
        this.config = options.config;
        this.secretStorage = options.secretStorage;
        this.connectionId = options.connectionId;
        this.redirectUri = options.redirectUri;
        this.onStatusUpdate = options.onStatusUpdate;
        const tenantId = this.config.tenantId || "organizations";
        const authority = `https://login.microsoftonline.com/${tenantId}`;
        const msalConfig = {
          auth: {
            clientId: this.config.clientId,
            authority
          },
          cache: {
            cachePlugin: this.createCachePlugin()
          },
          system: {
            loggerOptions: {
              loggerCallback: (level, message, containsPii) => {
                if (containsPii) return;
                componentLogger2.debug(`MSAL ${level}: ${message}`);
              },
              piiLoggingEnabled: false,
              logLevel: LogLevel2.Warning
            }
          }
        };
        this.msalClient = new PublicClientApplication(msalConfig);
      }
      /**
       * Create cache plugin for MSAL token cache persistence
       */
      createCachePlugin() {
        const cacheKey = `azureDevOpsInt.entra.tokenCache.${this.connectionId}`;
        return {
          beforeCacheAccess: async (context) => {
            try {
              const serialized = await this.secretStorage.get(cacheKey);
              if (serialized) {
                context.tokenCache.deserialize(serialized);
              }
            } catch (error) {
              componentLogger2.error(`Failed to load token cache: ${error}`);
            }
          },
          afterCacheAccess: async (context) => {
            if (!context.cacheHasChanged) {
              return;
            }
            try {
              const serialized = context.tokenCache.serialize();
              await this.secretStorage.store(cacheKey, serialized);
            } catch (error) {
              componentLogger2.error(`Failed to persist token cache: ${error}`);
            }
          }
        };
      }
      /**
       * Get authority URL
       */
      getAuthority() {
        const tenantId = this.config.tenantId || "organizations";
        return `https://login.microsoftonline.com/${tenantId}`;
      }
      /**
       * Resolve scopes, ensuring offline_access is included
       */
      resolveScopes() {
        const configuredScopes = this.config.scopes && this.config.scopes.length > 0 ? this.config.scopes : DEFAULT_SCOPES;
        const scopeSet = /* @__PURE__ */ new Set();
        for (const scope of configuredScopes) {
          if (typeof scope === "string" && scope.trim().length > 0) {
            scopeSet.add(scope.trim());
          }
        }
        scopeSet.add("offline_access");
        return Array.from(scopeSet);
      }
      /**
       * Build authorization URL with PKCE parameters
       */
      buildAuthorizationUrl(codeChallenge, state2) {
        const tenantId = this.config.tenantId || "organizations";
        const scopes = this.resolveScopes();
        const params = new URLSearchParams({
          client_id: this.config.clientId,
          response_type: "code",
          redirect_uri: this.redirectUri,
          response_mode: "query",
          scope: scopes.join(" "),
          code_challenge: codeChallenge,
          code_challenge_method: "S256",
          state: state2
        });
        return `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/authorize?${params.toString()}`;
      }
      /**
       * Try silent authentication first
       */
      async trySilentAuthentication(scopes) {
        try {
          const accounts = await this.msalClient.getTokenCache().getAllAccounts();
          if (accounts.length === 0) {
            return { success: false, error: "No cached account found" };
          }
          const account = accounts[0];
          const silentRequest = {
            account,
            scopes,
            forceRefresh: false
          };
          const response = await this.msalClient.acquireTokenSilent(silentRequest);
          if (response && response.accessToken) {
            componentLogger2.info("Silent authentication successful");
            return {
              success: true,
              accessToken: response.accessToken,
              expiresAt: response.expiresOn || void 0
            };
          }
          return { success: false, error: "Silent authentication returned no token" };
        } catch (error) {
          componentLogger2.debug(`Silent authentication failed: ${error.message}`);
          return { success: false, error: error.message || "Silent authentication failed" };
        }
      }
      /**
       * Initiate authorization code flow with PKCE
       */
      async authenticate(forceInteractive = false) {
        try {
          const scopes = this.resolveScopes();
          if (!forceInteractive) {
            const silentResult = await this.trySilentAuthentication(scopes);
            if (silentResult.success) {
              return silentResult;
            }
          }
          this.pkceParams = generatePKCEParams();
          this.pendingAuthState = generateState();
          this.authStartTime = Date.now();
          const authorizationUrl = this.buildAuthorizationUrl(
            this.pkceParams.codeChallenge,
            this.pendingAuthState
          );
          this.onStatusUpdate?.(this.connectionId, {
            type: "auth_code_flow_started",
            authorizationUrl,
            expiresInSeconds: Math.floor(AUTH_TIMEOUT_MS / 1e3)
          });
          await vscode8.env.openExternal(vscode8.Uri.parse(authorizationUrl));
          componentLogger2.info("Authorization URL opened in browser", {
            connectionId: this.connectionId,
            authorizationUrl: authorizationUrl.substring(0, 100) + "..."
          });
          return await this.waitForRedirect();
        } catch (error) {
          componentLogger2.error(`Authentication failed: ${error.message}`, {
            connectionId: this.connectionId,
            error
          });
          this.cleanup();
          return {
            success: false,
            error: error.message || "Authentication failed"
          };
        }
      }
      /**
       * Wait for redirect URI handler to complete authentication
       */
      waitForRedirect() {
        return new Promise((resolve, reject) => {
          this.resolveAuthPromise = resolve;
          this.rejectAuthPromise = reject;
          this.authTimeout = setTimeout(() => {
            this.cleanup();
            reject(new Error(`Authentication timeout after ${AUTH_TIMEOUT_MS / 1e3} seconds`));
          }, AUTH_TIMEOUT_MS);
        });
      }
      /**
       * Handle redirect URI with authorization code
       * Called by URI handler in activation.ts
       */
      async handleRedirectUri(uri) {
        try {
          const params = new URLSearchParams(uri.query);
          const authorizationCode = params.get("code");
          const state2 = params.get("state");
          const error = params.get("error");
          const errorDescription = params.get("error_description");
          if (error) {
            const errorMsg = errorDescription || error;
            componentLogger2.error(`Authorization error: ${errorMsg}`);
            this.cleanup();
            return {
              success: false,
              error: errorMsg
            };
          }
          if (!authorizationCode) {
            throw new Error("Authorization code not found in redirect URI");
          }
          if (!state2) {
            throw new Error("State parameter not found in redirect URI");
          }
          if (state2 !== this.pendingAuthState) {
            throw new Error("State parameter mismatch - possible CSRF attack");
          }
          if (!this.pkceParams) {
            throw new Error("PKCE parameters not found - authentication session expired");
          }
          if (!isValidCodeVerifier(this.pkceParams.codeVerifier)) {
            throw new Error("Invalid code verifier format");
          }
          componentLogger2.info("Exchanging authorization code for token", {
            connectionId: this.connectionId
          });
          const tokenRequest = {
            code: authorizationCode,
            codeVerifier: this.pkceParams.codeVerifier,
            redirectUri: this.redirectUri,
            scopes: this.resolveScopes()
          };
          const response = await this.msalClient.acquireTokenByCode(tokenRequest);
          if (!response || !response.accessToken) {
            throw new Error("Token exchange returned no access token");
          }
          const tokenKey = `entra:${this.config.tenantId || "organizations"}:${this.config.clientId}`;
          await this.secretStorage.store(tokenKey, response.accessToken);
          if (response.account) {
            await this.storeAccount(response.account);
          }
          componentLogger2.info("Authentication successful", {
            connectionId: this.connectionId,
            expiresAt: response.expiresOn?.toISOString()
          });
          this.onStatusUpdate?.(this.connectionId, {
            type: "auth_code_flow_completed"
          });
          const result = {
            success: true,
            accessToken: response.accessToken,
            expiresAt: response.expiresOn || void 0
          };
          this.cleanup();
          if (this.resolveAuthPromise) {
            this.resolveAuthPromise(result);
          }
          return result;
        } catch (error) {
          componentLogger2.error(`Redirect handling failed: ${error.message}`, {
            connectionId: this.connectionId,
            error
          });
          this.onStatusUpdate?.(this.connectionId, {
            type: "auth_code_flow_failed",
            error: error.message || "Authentication failed"
          });
          this.cleanup();
          if (this.rejectAuthPromise) {
            this.rejectAuthPromise(error);
          }
          return {
            success: false,
            error: error.message || "Redirect handling failed"
          };
        }
      }
      /**
       * Store account information for future silent authentication
       */
      async storeAccount(account) {
        try {
          const accountKey = `azureDevOpsInt.entra.account.${this.connectionId}`;
          await this.secretStorage.store(
            accountKey,
            JSON.stringify({
              homeAccountId: account.homeAccountId,
              environment: account.environment,
              username: account.username,
              localAccountId: account.localAccountId
            })
          );
        } catch (error) {
          componentLogger2.warn(`Failed to store account info: ${error}`);
        }
      }
      /**
       * Cleanup pending authentication state
       */
      cleanup() {
        if (this.authTimeout) {
          clearTimeout(this.authTimeout);
          this.authTimeout = void 0;
        }
        this.pkceParams = void 0;
        this.pendingAuthState = void 0;
        this.authStartTime = void 0;
        this.resolveAuthPromise = void 0;
        this.rejectAuthPromise = void 0;
      }
      /**
       * Get access token (for IAuthProvider interface compatibility)
       */
      async getAccessToken() {
        try {
          const accounts = await this.msalClient.getTokenCache().getAllAccounts();
          if (accounts.length === 0) {
            return void 0;
          }
          const account = accounts[0];
          const scopes = this.resolveScopes();
          const silentRequest = {
            account,
            scopes,
            forceRefresh: false
          };
          const response = await this.msalClient.acquireTokenSilent(silentRequest);
          return response?.accessToken;
        } catch (error) {
          componentLogger2.debug(`Failed to get access token: ${error}`);
          return void 0;
        }
      }
      /**
       * Refresh access token
       */
      async refreshAccessToken() {
        try {
          const accounts = await this.msalClient.getTokenCache().getAllAccounts();
          if (accounts.length === 0) {
            return { success: false, error: "No account found for token refresh" };
          }
          const account = accounts[0];
          const scopes = this.resolveScopes();
          const silentRequest = {
            account,
            scopes,
            forceRefresh: true
          };
          const response = await this.msalClient.acquireTokenSilent(silentRequest);
          if (response && response.accessToken) {
            return {
              success: true,
              accessToken: response.accessToken,
              expiresAt: response.expiresOn || void 0
            };
          }
          return { success: false, error: "Token refresh returned no token" };
        } catch (error) {
          return { success: false, error: error.message || "Token refresh failed" };
        }
      }
      /**
       * Sign out
       */
      async signOut() {
        try {
          const accounts = await this.msalClient.getTokenCache().getAllAccounts();
          for (const account of accounts) {
            await this.msalClient.getTokenCache().removeAccount(account);
          }
          const tokenKey = `entra:${this.config.tenantId || "organizations"}:${this.config.clientId}`;
          await this.secretStorage.delete(tokenKey);
          const accountKey = `azureDevOpsInt.entra.account.${this.connectionId}`;
          await this.secretStorage.delete(accountKey);
          this.cleanup();
        } catch (error) {
          componentLogger2.error(`Sign out failed: ${error}`);
        }
      }
      /**
       * Reset token (clear cache)
       */
      async resetToken() {
        await this.signOut();
      }
      /**
       * Check if authenticated
       */
      async isAuthenticated() {
        const token = await this.getAccessToken();
        return !!token;
      }
      /**
       * Get PKCE params for external storage (used by URI handler)
       */
      getPendingPKCEParams() {
        return this.pkceParams;
      }
      /**
       * Get pending auth state
       */
      getPendingAuthState() {
        return this.pendingAuthState;
      }
    };
  }
});

// src/services/auth/authCodeFlowHelpers.ts
var authCodeFlowHelpers_exports = {};
__export(authCodeFlowHelpers_exports, {
  attemptAuthCodeFlow: () => attemptAuthCodeFlow
});
async function attemptAuthCodeFlow(context, options) {
  const useAuthCodeFlow = shouldUseAuthCodeFlow("entra", options.connectionId);
  if (!useAuthCodeFlow) {
    return { success: false };
  }
  try {
    const redirectUri = `vscode-azuredevops-int://auth/callback`;
    const resolvedClientId = options.clientId?.trim() || DEFAULT_ENTRA_CLIENT_ID3;
    const authorityTenant = options.tenantId || DEFAULT_ENTRA_TENANT2;
    const provider2 = new AuthorizationCodeFlowProvider({
      config: {
        clientId: resolvedClientId,
        tenantId: authorityTenant,
        scopes: options.scopes
      },
      secretStorage: context.secrets,
      connectionId: options.connectionId,
      redirectUri,
      onStatusUpdate: async (connId, status) => {
        if (typeof globalThis.__dispatchApplicationEvent === "function") {
          globalThis.__dispatchApplicationEvent({
            type: status.type === "auth_code_flow_started" ? "AUTH_CODE_FLOW_STARTED" : status.type === "auth_code_flow_completed" ? "AUTH_CODE_FLOW_COMPLETED" : "AUTH_CODE_FLOW_FAILED",
            connectionId: connId,
            authorizationUrl: status.authorizationUrl,
            expiresInSeconds: status.expiresInSeconds,
            error: status.error
          });
        }
      }
    });
    if (!globalThis.__pendingAuthProviders) {
      globalThis.__pendingAuthProviders = /* @__PURE__ */ new Map();
    }
    globalThis.__pendingAuthProviders.set(options.connectionId, provider2);
    const result = await provider2.authenticate(options.force);
    if (result.success && result.accessToken) {
      globalThis.__pendingAuthProviders?.delete(options.connectionId);
      return { success: true, accessToken: result.accessToken };
    } else {
      return { success: false, error: result.error || "Authentication failed" };
    }
  } catch (error) {
    logger6.warn("Auth code flow failed, falling back to device code", {
      meta: { error: error.message, connectionId: options.connectionId }
    });
    return { success: false, error: error.message };
  }
}
var logger6, DEFAULT_ENTRA_CLIENT_ID3, DEFAULT_ENTRA_TENANT2;
var init_authCodeFlowHelpers = __esm({
  "src/services/auth/authCodeFlowHelpers.ts"() {
    "use strict";
    init_authorizationCodeProvider();
    init_authConfig();
    init_unifiedLogger();
    logger6 = createLogger("auth-code-flow-helpers");
    DEFAULT_ENTRA_CLIENT_ID3 = "c6c01810-2fff-45f0-861b-2ba02ae00ddc";
    DEFAULT_ENTRA_TENANT2 = "organizations";
  }
});

// src/services/auth/authentication.ts
var authentication_exports = {};
__export(authentication_exports, {
  clearEntraIdToken: () => clearEntraIdToken,
  clearPendingAuthCodeFlowProvider: () => clearPendingAuthCodeFlowProvider,
  getEntraIdToken: () => getEntraIdToken,
  getPat: () => getPat,
  getPendingAuthCodeFlowProvider: () => getPendingAuthCodeFlowProvider
});
async function getPat(context, patKey) {
  if (!patKey) {
    throw new Error("PAT key is not defined for this connection.");
  }
  const pat = await context.secrets.get(patKey);
  if (!pat) {
    throw new Error(`PAT not found in secret storage for key: ${patKey}`);
  }
  return pat;
}
async function clearEntraIdToken(context, tenantId, clientId) {
  if (!tenantId) return;
  const keys = /* @__PURE__ */ new Set();
  const clientKey = clientId ?? DEFAULT_ENTRA_CLIENT_ID;
  keys.add(`entra:${tenantId}:${clientKey}`);
  keys.add(`entra:${tenantId}:${AZURE_CLI_CLIENT_ID}`);
  keys.add(`entra:${tenantId}`);
  for (const key2 of keys) {
    await context.secrets.delete(key2);
  }
}
async function attemptDeviceCodeFlow(context, resolvedClientId, authorityTenant, resolvedTenantId, scopes, options) {
  const legacyKey = `entra:${resolvedTenantId}`;
  const pca = new PublicClientApplication({
    auth: {
      clientId: resolvedClientId,
      authority: `https://login.microsoftonline.com/${authorityTenant}`
    }
  });
  const targetKey = `entra:${resolvedTenantId}:${resolvedClientId}`;
  const deviceCodeRequest = {
    deviceCodeCallback: async (response) => {
      try {
        const info = normalizeDeviceCodeResponse2(response);
        if (!info || !info.userCode || info.userCode.trim() === "") {
          activationLogger.error("[getEntraIdToken] Invalid device code response", {
            meta: { response, hasUserCode: !!info?.userCode }
          });
          return;
        }
        await notifyDeviceCode(info, options);
      } catch (error) {
        activationLogger.error("[getEntraIdToken] Error in deviceCodeCallback", {
          meta: { error, response }
        });
      }
    },
    scopes
  };
  const tokenResponse = await pca.acquireTokenByDeviceCode(deviceCodeRequest);
  if (tokenResponse && tokenResponse.accessToken) {
    await context.secrets.store(targetKey, tokenResponse.accessToken);
    if (legacyKey !== targetKey) {
      await context.secrets.delete(legacyKey);
    }
    return tokenResponse.accessToken;
  }
  throw new Error("Failed to acquire Entra ID token.");
}
async function getEntraIdToken(context, tenantId, options = {}) {
  const resolvedClientId = options.clientId?.trim() || DEFAULT_ENTRA_CLIENT_ID;
  const authorityTenant = tenantId || DEFAULT_ENTRA_TENANT;
  const resolvedTenantId = tenantId || DEFAULT_ENTRA_TENANT;
  const secretKey = `entra:${resolvedTenantId}:${resolvedClientId}`;
  const legacyKey = `entra:${resolvedTenantId}`;
  const scopes = resolveScopes(options.scopes);
  const connectionId = options.connectionId || "default";
  if (!options.force) {
    const cachedToken = await tryGetCachedToken(context, [secretKey, legacyKey], secretKey);
    if (cachedToken) return cachedToken;
  }
  const { shouldUseAuthCodeFlow: shouldUseAuthCodeFlow2 } = await Promise.resolve().then(() => (init_authConfig(), authConfig_exports));
  const useAuthCodeFlow = shouldUseAuthCodeFlow2("entra", connectionId);
  if (useAuthCodeFlow) {
    const { attemptAuthCodeFlow: attemptAuthCodeFlow2 } = await Promise.resolve().then(() => (init_authCodeFlowHelpers(), authCodeFlowHelpers_exports));
    const authCodeResult = await attemptAuthCodeFlow2(context, {
      connectionId,
      clientId: resolvedClientId,
      tenantId: authorityTenant,
      scopes,
      force: options.force
    });
    if (authCodeResult.success && authCodeResult.accessToken) {
      await context.secrets.store(secretKey, authCodeResult.accessToken);
      if (legacyKey !== secretKey) {
        await context.secrets.delete(legacyKey);
      }
      return authCodeResult.accessToken;
    }
    throw new Error(
      authCodeResult.error || 'Authorization code flow failed. If you need device code flow, set azureDevOpsIntegration.auth.flow to "device-code"'
    );
  }
  const errors = [];
  try {
    return await attemptDeviceCodeFlow(context, resolvedClientId, authorityTenant, resolvedTenantId, scopes, options);
  } catch (error) {
    const formatted = formatAuthError(error);
    errors.push(`clientId=${resolvedClientId}: ${formatted}`);
  }
  throw new Error(`Entra ID token acquisition failed: ${errors.join(" || ")}`);
}
function getPendingAuthCodeFlowProvider(connectionId) {
  const providers = globalThis.__pendingAuthProviders;
  return providers?.get(connectionId);
}
function clearPendingAuthCodeFlowProvider(connectionId) {
  globalThis.__pendingAuthProviders?.delete(connectionId);
}
var activationLogger;
var init_authentication = __esm({
  "src/services/auth/authentication.ts"() {
    "use strict";
    init_dist2();
    init_unifiedLogger();
    init_tokenCache();
    init_constants();
    init_deviceCodeFlow();
    activationLogger = createLogger("auth-authentication");
  }
});

// src/services/connection/authFlowHelpers.ts
var authFlowHelpers_exports = {};
__export(authFlowHelpers_exports, {
  setupAuthCodeFlow: () => setupAuthCodeFlow
});
async function setupAuthCodeFlow(manager, config, context, dispatchDeviceCodeEvent2, force) {
  const useAuthCodeFlow = shouldUseAuthCodeFlow(config.authMethod, config.id);
  if (!useAuthCodeFlow) {
    return { success: false };
  }
  try {
    const redirectUri = `vscode-azuredevops-int://auth/callback`;
    const provider2 = new AuthorizationCodeFlowProvider({
      config: {
        clientId: config.clientId || "c6c01810-2fff-45f0-861b-2ba02ae00ddc",
        tenantId: config.tenantId,
        scopes: void 0
        // Use defaults
      },
      secretStorage: context.secrets,
      connectionId: config.id,
      redirectUri,
      onStatusUpdate: async (connId, status) => {
        await dispatchDeviceCodeEvent2({
          type: status.type === "auth_code_flow_started" ? "AUTH_CODE_FLOW_STARTED" : status.type === "auth_code_flow_completed" ? "AUTH_CODE_FLOW_COMPLETED" : "AUTH_CODE_FLOW_FAILED",
          connectionId: connId,
          authorizationUrl: status.authorizationUrl,
          expiresInSeconds: status.expiresInSeconds,
          error: status.error
        });
      }
    });
    if (!globalThis.__pendingAuthProviders) {
      globalThis.__pendingAuthProviders = /* @__PURE__ */ new Map();
    }
    globalThis.__pendingAuthProviders.set(config.id, provider2);
    await dispatchDeviceCodeEvent2({
      type: "AUTH_CODE_FLOW_STARTED",
      connectionId: config.id,
      authorizationUrl: "",
      // Will be set by provider
      expiresInSeconds: 900
      // 15 minutes
    });
    const result = await provider2.authenticate(force);
    if (result.success && result.accessToken) {
      const expiresAt = result.expiresAt ? result.expiresAt.getTime() : void 0;
      await dispatchDeviceCodeEvent2({
        type: "AUTH_CODE_FLOW_COMPLETED",
        connectionId: config.id,
        success: true
      });
      globalThis.__pendingAuthProviders?.delete(config.id);
      return {
        success: true,
        token: result.accessToken,
        expiresAt
      };
    } else {
      return {
        success: false,
        error: result.error || "Authentication failed"
      };
    }
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}
var init_authFlowHelpers = __esm({
  "src/services/connection/authFlowHelpers.ts"() {
    "use strict";
    init_authorizationCodeProvider();
    init_authConfig();
  }
});

// src/services/connection/connectionManagerHelpers.ts
async function dispatchDeviceCodeEvent(event2) {
  try {
    if (!cachedDispatchApplicationEvent) {
      const activation = await import("../../../activation.js");
      cachedDispatchApplicationEvent = activation.dispatchApplicationEvent;
    }
    cachedDispatchApplicationEvent?.(event2);
  } catch {
  }
}
async function performAuthentication(manager, config, context, force, onDeviceCode) {
  try {
    let token;
    let expiresAt;
    let deviceCodeStarted = false;
    if (config.authMethod === "entra") {
      const { setupAuthCodeFlow: setupAuthCodeFlow2 } = await Promise.resolve().then(() => (init_authFlowHelpers(), authFlowHelpers_exports));
      const { shouldUseAuthCodeFlow: shouldUseAuthCodeFlow2 } = await Promise.resolve().then(() => (init_authConfig(), authConfig_exports));
      const useAuthCodeFlow = shouldUseAuthCodeFlow2("entra", config.id);
      if (useAuthCodeFlow) {
        const authCodeResult = await setupAuthCodeFlow2(
          manager,
          config,
          context,
          dispatchDeviceCodeEvent,
          force
        );
        if (authCodeResult.success && authCodeResult.token) {
          token = authCodeResult.token;
          expiresAt = authCodeResult.expiresAt;
        } else {
          throw new Error(
            authCodeResult.error || 'Authorization code flow failed. If you need device code flow, set azureDevOpsIntegration.auth.flow to "device-code"'
          );
        }
      } else {
        token = await getEntraIdToken(context, config.tenantId, {
          force,
          connectionId: config.id,
          connectionLabel: config.label,
          clientId: config.clientId,
          onDeviceCode: async (info) => {
            try {
              deviceCodeStarted = true;
              await dispatchDeviceCodeEvent({
                type: "DEVICE_CODE_STARTED",
                connectionId: config.id,
                userCode: info.userCode,
                verificationUri: info.verificationUri,
                expiresInSeconds: info.expiresInSeconds
              });
              if (onDeviceCode) {
                Promise.resolve(onDeviceCode(info)).catch((error) => {
                });
              }
            } catch (error) {
            }
          }
        });
        expiresAt = Date.now() + 3600 * 1e3;
      }
    } else {
      token = await getPat(context, config.patKey);
    }
    manager.authenticated(token, expiresAt);
    if (deviceCodeStarted) {
      await dispatchDeviceCodeEvent({
        type: "DEVICE_CODE_COMPLETED",
        connectionId: config.id
      });
    }
  } catch (error) {
    await dispatchDeviceCodeEvent({
      type: "DEVICE_CODE_COMPLETED",
      connectionId: config.id
    });
    manager.authFailed(error instanceof Error ? error.message : String(error));
  }
}
async function createClient(manager, config, credential, onAuthFailure) {
  try {
    const client2 = new AzureDevOpsIntClient(config.organization, config.project, credential, {
      authType: config.authMethod === "entra" ? "bearer" : "pat",
      onAuthFailure
    });
    manager.clientCreated(client2);
  } catch (error) {
    manager.clientFailed(error instanceof Error ? error.message : String(error));
  }
}
async function createProvider(manager, config, client2) {
  try {
    const { forwardProviderMessage: forwardProviderMessage3 } = await import("../../../activation.js");
    const postMessage = (msg) => {
      forwardProviderMessage3(config.id, msg);
    };
    const provider2 = new WorkItemsProvider(config.id, client2, postMessage);
    manager.providerCreated(provider2);
  } catch (error) {
    manager.providerFailed(error instanceof Error ? error.message : String(error));
  }
}
var cachedDispatchApplicationEvent;
var init_connectionManagerHelpers = __esm({
  "src/services/connection/connectionManagerHelpers.ts"() {
    "use strict";
    init_azureClient2();
    init_provider2();
    init_authentication();
  }
});

// src/praxis/connection/driver.ts
var ConnectionDriver;
var init_driver = __esm({
  "src/praxis/connection/driver.ts"() {
    "use strict";
    init_connectionManagerHelpers();
    init_authentication();
    ConnectionDriver = class {
      constructor(context, onStatusBarUpdate, onTokenExpired) {
        this.context = context;
        this.onStatusBarUpdate = onStatusBarUpdate;
        this.onTokenExpired = onTokenExpired;
      }
      /**
       * Wait for connection to complete or fail
       */
      async waitForConnection(manager, config, timeoutMs, forceInteractive, onDeviceCode) {
        let authStarted = false;
        let clientStarted = false;
        let providerStarted = false;
        return new Promise((resolve) => {
          const timeout = setTimeout(() => {
            resolve({
              success: false,
              error: `Connection timeout (${timeoutMs / 1e3}s)`
            });
          }, timeoutMs);
          const pollInterval = setInterval(() => {
            const state2 = manager.getConnectionState();
            const data = manager.getConnectionData();
            if (state2 === "authenticating" && !authStarted) {
              authStarted = true;
              if (this.context) {
                performAuthentication(manager, config, this.context, forceInteractive, onDeviceCode).catch((err) => {
                });
              } else {
                manager.authFailed("Extension context not set");
              }
            } else if (state2 === "creating_client" && !clientStarted && data.credential) {
              clientStarted = true;
              createClient(manager, config, data.credential, () => {
                if (this.context && config.authMethod === "entra") {
                  clearEntraIdToken(this.context, config.tenantId, config.clientId).catch((err) => {
                  }).finally(() => {
                    this.onTokenExpired(config.id);
                  });
                } else {
                  this.onTokenExpired(config.id);
                }
              }).catch((err) => {
              });
            } else if (state2 === "creating_provider" && !providerStarted && data.client) {
              providerStarted = true;
              createProvider(manager, config, data.client).catch((err) => {
              });
            }
            if (state2 === "connected") {
              clearTimeout(timeout);
              clearInterval(pollInterval);
              resolve({
                success: true,
                client: data.client,
                provider: data.provider,
                state: data
              });
              this.onStatusBarUpdate();
            } else if (["auth_failed", "client_failed", "provider_failed", "connection_error"].includes(state2)) {
              clearTimeout(timeout);
              clearInterval(pollInterval);
              resolve({
                success: false,
                error: data.lastError || "Connection failed",
                state: data
              });
              this.onStatusBarUpdate();
            }
          }, 100);
        });
      }
    };
  }
});

// src/praxis/connection/service.ts
var service_exports = {};
__export(service_exports, {
  ConnectionService: () => ConnectionService
});
var logger7, ConnectionService;
var init_service = __esm({
  "src/praxis/connection/service.ts"() {
    "use strict";
    init_manager();
    init_ComponentLogger();
    init_driver();
    logger7 = createComponentLogger("CONNECTION" /* CONNECTION */, "ConnectionService");
    ConnectionService = class _ConnectionService {
      static instance;
      connectionManagers = /* @__PURE__ */ new Map();
      context;
      constructor() {
      }
      static getInstance() {
        if (!_ConnectionService.instance) {
          _ConnectionService.instance = new _ConnectionService();
        }
        return _ConnectionService.instance;
      }
      setContext(context) {
        this.context = context;
      }
      getConnectionManager(connectionId) {
        return this.connectionManagers.get(connectionId);
      }
      async connect(config, options = {}) {
        let manager = this.connectionManagers.get(config.id);
        if (!manager) {
          manager = new PraxisConnectionManager(config);
          manager.start();
          this.connectionManagers.set(config.id, manager);
        }
        return this.connectWithManager(manager, options);
      }
      async connectWithManager(manager, options = {}) {
        const currentState = manager.getConnectionState();
        const failedStates = ["auth_failed", "client_failed", "provider_failed", "connection_error"];
        if (failedStates.includes(currentState)) {
          logger7.info(`Resetting failed connection state before reconnect`, {
            connectionId: manager.getConnectionData().config.id,
            previousState: currentState
          });
          manager.reset();
        }
        const config = manager.getConnectionData().config;
        const forceInteractive = options?.interactive === true;
        logger7.info(`Connecting to ${config.id}...`, {
          connectionId: config.id,
          authMethod: config.authMethod,
          interactive: options?.interactive,
          forceInteractive
        });
        manager.connect({ forceInteractive });
        logger7.logEvent("CONNECT", "connecting", "praxisConnectionManager", {
          connectionId: config.id,
          forceInteractive
        });
        const isEntraAuth = config.authMethod === "entra";
        const isInteractiveAuth = options?.interactive || forceInteractive || isEntraAuth;
        const timeoutMs = isInteractiveAuth ? 9e5 : 3e4;
        const driver = new ConnectionDriver(
          this.context,
          () => this.updateStatusBar(),
          (id) => this.handleTokenExpired(id)
        );
        return driver.waitForConnection(
          manager,
          config,
          timeoutMs,
          forceInteractive,
          options.onDeviceCode
        );
      }
      handleTokenExpired(connectionId) {
        const manager = this.connectionManagers.get(connectionId);
        if (manager) {
          manager.tokenExpired();
        }
      }
      updateStatusBar() {
        setImmediate(() => {
          const globalRef = globalThis.__updateAuthStatusBar;
          if (typeof globalRef === "function") {
            globalRef().catch((err) => {
              logger7.warn(
                `Failed to update status bar: ${err instanceof Error ? err.message : String(err)}`
              );
            });
          } else {
            Promise.resolve().then(() => (init_activation(), activation_exports)).then(({ updateAuthStatusBar: updateAuthStatusBar2 }) => {
              updateAuthStatusBar2().catch((err) => {
                logger7.warn(
                  `Failed to update status bar: ${err instanceof Error ? err.message : String(err)}`
                );
              });
            }).catch((err) => {
              logger7.warn(
                `Failed to import updateAuthStatusBar: ${err instanceof Error ? err.message : String(err)}`
              );
            });
          }
        });
      }
      disconnect(connectionId) {
        const manager = this.connectionManagers.get(connectionId);
        if (manager) {
          manager.disconnect();
        }
      }
    };
  }
});

// src/features/commands/diagnosticHelpers.ts
var diagnosticHelpers_exports = {};
__export(diagnosticHelpers_exports, {
  checkActiveConnectionState: () => checkActiveConnectionState,
  checkActiveQuery: () => checkActiveQuery,
  checkConnections: () => checkConnections,
  checkErrors: () => checkErrors,
  checkWorkItemsState: () => checkWorkItemsState,
  generateRecommendations: () => generateRecommendations,
  testConnection: () => testConnection
});
function checkConnections(context) {
  logLine("1. Checking Connections...");
  logLine(`   Found ${context.connections.length} connection(s)`);
  if (context.connections.length === 0) {
    logLine("   \u274C ERROR: No connections configured");
    logLine('   \u2192 Run "Azure DevOps Int: Setup Wizard" to configure a connection');
    return false;
  }
  logLine(`   Active connection: ${context.activeConnectionId || "None"}`);
  if (!context.activeConnectionId) {
    logLine("   \u26A0\uFE0F  WARNING: No active connection selected");
    logLine("   \u2192 Select a connection in the webview");
  }
  return true;
}
async function checkActiveConnectionState(context) {
  if (!context.activeConnectionId) {
    return false;
  }
  logLine("");
  logLine("2. Checking Active Connection State...");
  const connection = context.connections.find((c) => c.id === context.activeConnectionId);
  if (!connection) {
    logLine(
      `   \u274C ERROR: Active connection ${context.activeConnectionId} not found in connections list`
    );
    return false;
  }
  logLine(`   Connection ID: ${connection.id}`);
  logLine(`   Organization: ${connection.organization || "Not set"}`);
  logLine(`   Project: ${connection.project || "Not set"}`);
  logLine(`   Auth Method: ${connection.authMethod || "pat"}`);
  logLine(`   Base URL: ${connection.baseUrl || connection.apiBaseUrl || "Not set"}`);
  const connectionStates3 = context.snapshot?.context?.connectionStates;
  const connState = connectionStates3?.get?.(context.activeConnectionId);
  const isConnected = connState?.isConnected === true;
  logLine(`   Connection Status: ${isConnected ? "\u2705 Connected" : "\u274C Not Connected"}`);
  try {
    const { ConnectionService: ConnectionService2 } = await Promise.resolve().then(() => (init_service(), service_exports));
    const connectionService = ConnectionService2.getInstance();
    const manager = connectionService.getConnectionManager(context.activeConnectionId);
    if (manager) {
      const state2 = manager.getConnectionState();
      logLine(`   Connection Manager State: ${state2 || "Unknown"}`);
      const data = manager.getConnectionData();
      if (data.lastError) {
        logLine(`   \u274C Last Error: ${data.lastError}`);
      }
    }
  } catch (error) {
    logLine(`   \u26A0\uFE0F  Could not check connection manager: ${error.message}`);
  }
  return isConnected;
}
function checkWorkItemsState(context) {
  logLine("");
  logLine("3. Checking Work Items State...");
  const pendingWorkItems = context.snapshot?.context?.pendingWorkItems;
  const connectionWorkItems = context.snapshot?.context?.connectionWorkItems;
  if (pendingWorkItems) {
    const count = Array.isArray(pendingWorkItems.workItems) ? pendingWorkItems.workItems.length : 0;
    logLine(`   Pending Work Items: ${count} item(s)`);
    logLine(`   Connection ID: ${pendingWorkItems.connectionId || "None"}`);
    logLine(`   Query: ${pendingWorkItems.query || "Not set"}`);
  } else {
    logLine("   \u26A0\uFE0F  No pending work items found");
  }
  if (connectionWorkItems && context.activeConnectionId) {
    const connWorkItems = connectionWorkItems.get?.(context.activeConnectionId);
    if (connWorkItems) {
      const count = Array.isArray(connWorkItems.workItems) ? connWorkItems.workItems.length : 0;
      logLine(`   Connection Work Items: ${count} item(s) for active connection`);
    } else {
      logLine("   \u26A0\uFE0F  No work items found for active connection");
    }
  }
}
function checkActiveQuery(context) {
  logLine("");
  logLine("4. Checking Active Query...");
  const activeQuery = context.snapshot?.context?.activeQuery;
  logLine(`   Active Query: ${activeQuery || "Not set"}`);
  if (!activeQuery) {
    logLine("   \u26A0\uFE0F  WARNING: No active query selected");
    logLine("   \u2192 Select a query in the webview");
  }
  return activeQuery;
}
function checkErrors(context) {
  logLine("");
  logLine("5. Checking for Errors...");
  const workItemsError = context.snapshot?.context?.workItemsError;
  const lastError2 = context.snapshot?.context?.lastError;
  if (workItemsError) {
    logLine(`   \u274C Work Items Error: ${workItemsError}`);
    logLine(
      `   Connection ID: ${context.snapshot?.context?.workItemsErrorConnectionId || "Unknown"}`
    );
  } else {
    logLine("   \u2705 No work items errors found");
  }
  if (lastError2) {
    logLine(`   \u274C Last Application Error: ${lastError2.message || lastError2}`);
    if (lastError2.stack) {
      logLine(`   Stack: ${lastError2.stack}`);
    }
  }
  return workItemsError;
}
async function testConnection(context) {
  logLine("");
  logLine("6. Testing Connection...");
  if (!context.activeConnectionId) {
    logLine("   \u26A0\uFE0F  Skipped: No active connection");
    return;
  }
  try {
    const { ConnectionService: ConnectionService2 } = await Promise.resolve().then(() => (init_service(), service_exports));
    const connectionService = ConnectionService2.getInstance();
    const manager = connectionService.getConnectionManager(context.activeConnectionId);
    if (!manager) {
      logLine("   \u26A0\uFE0F  Connection manager not found");
      return;
    }
    const data = manager.getConnectionData();
    if (data.client && data.provider) {
      logLine("   \u2705 Client and Provider available");
      try {
        if (typeof data.provider.getWorkItemTypeOptions === "function") {
          const types = data.provider.getWorkItemTypeOptions();
          logLine(
            `   \u2705 Work Item Types: ${Array.isArray(types) ? types.length : 0} type(s) available`
          );
        }
      } catch (error) {
        logLine(`   \u26A0\uFE0F  Could not fetch work item types: ${error.message}`);
      }
    } else {
      logLine("   \u274C Client or Provider not available");
      logLine(`   Has Client: ${!!data.client}`);
      logLine(`   Has Provider: ${!!data.provider}`);
    }
  } catch (error) {
    logLine(`   \u274C Connection test failed: ${error.message}`);
  }
}
function generateRecommendations(context, isConnected, activeQuery, workItemsError) {
  logLine("");
  logLine("7. Recommendations...");
  if (!context.activeConnectionId) {
    logLine("   \u2192 Select a connection in the webview");
  } else if (!isConnected) {
    logLine('   \u2192 Run "Azure DevOps Int: Sign In with Microsoft Entra ID" to authenticate');
  } else if (!activeQuery) {
    logLine('   \u2192 Select a query in the webview (e.g., "My Activity", "All Active")');
  } else if (workItemsError) {
    logLine("   \u2192 Check authentication and permissions");
    logLine('   \u2192 Verify PAT scopes include "Work Items (Read & Write)"');
    logLine("   \u2192 Verify you have access to the project");
  } else {
    logLine("   \u2705 Configuration looks good");
    logLine("   \u2192 If work items still don't appear, check the query scope");
    logLine('   \u2192 Try switching to a different query (e.g., "All Active")');
  }
}
var init_diagnosticHelpers = __esm({
  "src/features/commands/diagnosticHelpers.ts"() {
    "use strict";
    init_logging();
  }
});

// src/features/commands/handlers.ts
async function loadConnectionsFromConfig(context) {
  const { loadConnectionsFromConfig: loadConnections } = await Promise.resolve().then(() => (init_activation(), activation_exports));
  return loadConnections(context);
}
async function signInWithEntra(context, connectionId) {
  try {
    const { getApplicationStoreActor: getApplicationStoreActor2 } = await Promise.resolve().then(() => (init_activation(), activation_exports));
    const actor = getApplicationStoreActor2();
    const snapshot2 = actor?.getSnapshot?.();
    const activeConnectionId3 = connectionId || snapshot2?.context?.activeConnectionId;
    if (!activeConnectionId3) {
      vscode9.window.showWarningMessage("No active connection to sign in with.");
      return;
    }
    const connections3 = snapshot2?.context?.connections || [];
    const connection = connections3.find((c) => c.id === activeConnectionId3);
    if (!connection) {
      vscode9.window.showWarningMessage("Connection not found.");
      return;
    }
    if (connection.authMethod !== "entra") {
      vscode9.window.showInformationMessage("This connection does not use Entra ID authentication.");
      return;
    }
    const { clearSignedOutFlag: clearSignedOutFlag2 } = await Promise.resolve().then(() => (init_activation(), activation_exports));
    if (typeof clearSignedOutFlag2 === "function") {
      clearSignedOutFlag2(activeConnectionId3);
    }
    dispatchApplicationEvent({
      type: "SIGN_IN_ENTRA",
      connectionId: activeConnectionId3,
      forceInteractive: true
    });
    const { ConnectionService: ConnectionService2 } = await Promise.resolve().then(() => (init_service(), service_exports));
    const connectionService = ConnectionService2.getInstance();
    connectionService.disconnect(activeConnectionId3);
    const { clearEntraIdToken: clearEntraIdToken2 } = await Promise.resolve().then(() => (init_authentication(), authentication_exports));
    await clearEntraIdToken2(context, connection.tenantId, connection.clientId);
    connectionService.setContext(context);
    await connectionService.connect(connection, {
      refresh: true,
      interactive: true
    });
  } catch (error) {
    logger8.error("signInWithEntra error", { meta: error });
    vscode9.window.showErrorMessage(`Sign in failed: ${error.message || String(error)}`);
  }
}
async function disconnectAndClearConnection(activeConnectionId3) {
  const { ConnectionService: ConnectionService2 } = await Promise.resolve().then(() => (init_service(), service_exports));
  const connectionService = ConnectionService2.getInstance();
  logger8.info("[signOutEntra] Disconnecting connection", { connectionId: activeConnectionId3 });
  connectionService.disconnect(activeConnectionId3);
  logger8.info("[signOutEntra] Connection disconnected", { connectionId: activeConnectionId3 });
  try {
    const { clearConnectionState: clearConnectionState2 } = await Promise.resolve().then(() => (init_activation(), activation_exports));
    if (typeof clearConnectionState2 === "function") {
      clearConnectionState2(activeConnectionId3);
      logger8.info("[signOutEntra] Connection state cleared", { connectionId: activeConnectionId3 });
    }
  } catch {
  }
}
async function clearAllEntraTokens(context, connection) {
  const { clearEntraIdToken: clearEntraIdToken2 } = await Promise.resolve().then(() => (init_authentication(), authentication_exports));
  const tenantId = connection.tenantId || "organizations";
  await clearEntraIdToken2(context, tenantId, connection.clientId || AZURE_DEVOPS_CLIENT_ID);
  await clearEntraIdToken2(context, tenantId, AZURE_DEVOPS_CLIENT_ID);
  await clearEntraIdToken2(context, tenantId, AZURE_CLI_CLIENT_ID);
  await clearEntraIdToken2(context, "organizations", AZURE_DEVOPS_CLIENT_ID);
  await clearEntraIdToken2(context, "organizations", AZURE_CLI_CLIENT_ID);
  await clearEntraIdToken2(context, "organizations", void 0);
}
async function clearAuthProviders(activeConnectionId3) {
  const pendingAuthProviders = globalThis.__pendingAuthProviders;
  if (pendingAuthProviders) {
    const provider2 = pendingAuthProviders.get(activeConnectionId3);
    if (provider2 && typeof provider2.signOut === "function") {
      await provider2.signOut();
    }
    pendingAuthProviders.delete(activeConnectionId3);
  }
  try {
    const { clearPendingAuthCodeFlowProvider: clearPendingAuthCodeFlowProvider2 } = await Promise.resolve().then(() => (init_authentication(), authentication_exports));
    clearPendingAuthCodeFlowProvider2(activeConnectionId3);
  } catch {
  }
}
async function markAsSignedOut(activeConnectionId3) {
  const { markConnectionSignedOut: markConnectionSignedOut2 } = await Promise.resolve().then(() => (init_activation(), activation_exports));
  if (typeof markConnectionSignedOut2 === "function") {
    logger8.info("[signOutEntra] Marking connection as signed out", { connectionId: activeConnectionId3 });
    markConnectionSignedOut2(activeConnectionId3);
    logger8.info("[signOutEntra] Connection marked as signed out", { connectionId: activeConnectionId3 });
  } else {
    logger8.warn("[signOutEntra] markConnectionSignedOut function not available");
  }
}
async function signOutEntra(context, connectionId) {
  let activeConnectionId3;
  try {
    logger8.info("[signOutEntra] Starting sign out", { connectionId });
    const { getApplicationStoreActor: getApplicationStoreActor2 } = await Promise.resolve().then(() => (init_activation(), activation_exports));
    const actor = getApplicationStoreActor2();
    const snapshot2 = actor?.getSnapshot?.();
    activeConnectionId3 = connectionId || snapshot2?.context?.activeConnectionId;
    logger8.info("signOutEntra: Active connection ID", { activeConnectionId: activeConnectionId3 });
    if (!activeConnectionId3) {
      logger8.warn("signOutEntra: No active connection found");
      vscode9.window.showWarningMessage("No active connection to sign out from.");
      return;
    }
    const connections3 = snapshot2?.context?.connections || [];
    const connection = connections3.find((c) => c.id === activeConnectionId3);
    if (!connection) {
      vscode9.window.showWarningMessage("Connection not found.");
      return;
    }
    if (connection.authMethod !== "entra") {
      vscode9.window.showInformationMessage("This connection does not use Entra ID authentication.");
      return;
    }
    await disconnectAndClearConnection(activeConnectionId3);
    await clearAllEntraTokens(context, connection);
    await clearAuthProviders(activeConnectionId3);
    await markAsSignedOut(activeConnectionId3);
    dispatchApplicationEvent({ type: "SIGN_OUT_ENTRA", connectionId: activeConnectionId3 });
    const { updateAuthStatusBar: updateAuthStatusBar2 } = await Promise.resolve().then(() => (init_activation(), activation_exports));
    if (typeof updateAuthStatusBar2 === "function") {
      await updateAuthStatusBar2();
    }
    vscode9.window.showInformationMessage("Signed out successfully.");
    logger8.info("Sign out completed", { connectionId: activeConnectionId3 });
  } catch (error) {
    logger8.error("signOutEntra error", {
      error: error?.message || String(error),
      stack: error?.stack,
      name: error?.name,
      code: error?.code,
      connectionId: activeConnectionId3 || connectionId
    });
    vscode9.window.showErrorMessage(`Sign out failed: ${error.message || String(error)}`);
  }
}
async function setOpenAIApiKey(context) {
  try {
    const apiKey = await vscode9.window.showInputBox({
      prompt: "Enter your OpenAI API Key",
      password: true,
      placeHolder: "sk-...",
      validateInput: (value) => {
        if (!value || value.trim().length === 0) {
          return "API key cannot be empty";
        }
        if (!value.startsWith("sk-")) {
          return 'OpenAI API keys typically start with "sk-"';
        }
        return null;
      }
    });
    if (apiKey) {
      const SECRET_KEY = "azureDevOpsInt.openai.apiKey";
      await context.secrets.store(SECRET_KEY, apiKey);
      vscode9.window.showInformationMessage("OpenAI API Key saved successfully.");
      logger8.info("OpenAI API key stored in secrets");
    }
  } catch (error) {
    logger8.error("setOpenAIApiKey error", { meta: error });
    vscode9.window.showErrorMessage(`Failed to save API key: ${error.message || String(error)}`);
  }
}
async function cycleAuthSignIn(context) {
  try {
    const { getApplicationStoreActor: getApplicationStoreActor2 } = await Promise.resolve().then(() => (init_activation(), activation_exports));
    const actor = getApplicationStoreActor2();
    const snapshot2 = actor?.getSnapshot?.();
    const connections3 = snapshot2?.context?.connections || [];
    const pendingConnections = connections3.filter((conn) => {
      if (conn.authMethod !== "entra") return false;
      const connectionStates3 = snapshot2?.context?.connectionStates;
      const connState = connectionStates3?.get?.(conn.id);
      const isConnected = connState?.isConnected === true;
      return !isConnected;
    });
    if (pendingConnections.length === 0) {
      const activeConnectionId3 = snapshot2?.context?.activeConnectionId;
      if (activeConnectionId3) {
        await signInWithEntra(context, activeConnectionId3);
      } else if (connections3.length > 0) {
        await signInWithEntra(context, connections3[0].id);
      } else {
        vscode9.window.showWarningMessage("No connections configured.");
      }
      return;
    }
    const now = Date.now();
    const cycleIndex = Math.floor(now / 1e3 % pendingConnections.length);
    const targetConnection = pendingConnections[cycleIndex];
    await signInWithEntra(context, targetConnection.id);
    vscode9.window.showInformationMessage(
      `Signing in to ${targetConnection.label || targetConnection.id}...`
    );
  } catch (error) {
    logger8.error("cycleAuthSignIn error", { meta: error });
    vscode9.window.showErrorMessage(`Cycle sign in failed: ${error.message || String(error)}`);
  }
}
async function diagnoseWorkItemsIssue(_context) {
  try {
    const channel = getOutputChannel() || vscode9.window.createOutputChannel("Azure DevOps Integration");
    setOutputChannel(channel);
    channel.show(true);
    logLine("=== Work Items Diagnostic ===");
    logLine(`Started at: ${(/* @__PURE__ */ new Date()).toISOString()}`);
    logLine("");
    const { getApplicationStoreActor: getApplicationStoreActor2 } = await Promise.resolve().then(() => (init_activation(), activation_exports));
    const actor = getApplicationStoreActor2();
    const snapshot2 = actor?.getSnapshot?.();
    const {
      checkConnections: checkConnections2,
      checkActiveConnectionState: checkActiveConnectionState2,
      checkWorkItemsState: checkWorkItemsState2,
      checkActiveQuery: checkActiveQuery2,
      checkErrors: checkErrors2,
      testConnection: testConnection2,
      generateRecommendations: generateRecommendations2
    } = await Promise.resolve().then(() => (init_diagnosticHelpers(), diagnosticHelpers_exports));
    const diagnosticContext = {
      connections: snapshot2?.context?.connections || [],
      activeConnectionId: snapshot2?.context?.activeConnectionId,
      snapshot: snapshot2
    };
    if (!checkConnections2(diagnosticContext)) {
      return;
    }
    const isConnected = await checkActiveConnectionState2(diagnosticContext);
    checkWorkItemsState2(diagnosticContext);
    const activeQuery = checkActiveQuery2(diagnosticContext);
    const workItemsError = checkErrors2(diagnosticContext);
    await testConnection2(diagnosticContext);
    generateRecommendations2(diagnosticContext, isConnected, activeQuery, workItemsError);
    logLine("");
    logLine("=== Diagnostic Complete ===");
    logLine("Check the output above for issues and recommendations.");
    vscode9.window.showInformationMessage(
      "Work items diagnostic complete. Check the output channel for details."
    );
  } catch (error) {
    logger8.error("diagnoseWorkItemsIssue error", { meta: error });
    vscode9.window.showErrorMessage(`Diagnostic failed: ${error.message || String(error)}`);
  }
}
function getConfig() {
  return vscode9.workspace.getConfiguration("azureDevOpsIntegration");
}
var vscode9, logger8, setupCommand, signInWithEntraCommand, signOutEntraCommand, openLogsCommand, copyLogsToClipboardCommand, openLogsFolderCommand, diagnoseWorkItemsCommand, focusWorkItemsViewCommand, setDefaultElapsedLimitCommand, showWorkItemsCommand, refreshWorkItemsCommand, createWorkItemCommand, startTimerCommand, pauseTimerCommand, resumeTimerCommand, stopTimerCommand, showTimeReportCommand, createBranchCommand, createPullRequestCommand, showPullRequestsCommand, showBuildStatusCommand, toggleKanbanViewCommand, toggleDebugViewCommand, selectTeamCommand, resetPreferredRepositoriesCommand, selfTestWebviewCommand, clearPerformanceDataCommand, forceGCCommand, bulkAssignCommand, setOpenAIApiKeyCommand, generateCopilotPromptCommand, cycleAuthSignInCommand;
var init_handlers = __esm({
  "src/features/commands/handlers.ts"() {
    "use strict";
    vscode9 = __toESM(require("vscode"), 1);
    init_unifiedLogger();
    init_constants();
    init_setupService();
    init_logging();
    init_performance();
    init_activation();
    logger8 = createLogger("commands-handlers");
    setupCommand = async (ctx, options) => {
      const setupService = new FSMSetupService(ctx.context);
      const setupOptions = options && typeof options === "object" ? options : void 0;
      const result = await setupService.startSetup(setupOptions);
      await loadConnectionsFromConfig(ctx.context);
      return result;
    };
    signInWithEntraCommand = async (_ctx, target) => {
      return signInWithEntra(_ctx.context, typeof target === "string" ? target : target?.id);
    };
    signOutEntraCommand = async (_ctx, target) => {
      logger8.info("[signOutEntraCommand] Command invoked", { target, hasContext: !!_ctx.context });
      try {
        logger8.info("[signOutEntraCommand] Calling signOutEntra function");
        await signOutEntra(_ctx.context, typeof target === "string" ? target : target?.id);
        logger8.info("[signOutEntraCommand] signOutEntra completed successfully");
      } catch (error) {
        logger8.error("[signOutEntraCommand] Command failed", { meta: error });
        throw error;
      }
    };
    openLogsCommand = async (_ctx) => {
      try {
        let channel = getOutputChannel();
        if (!channel) {
          channel = vscode9.window.createOutputChannel("Azure DevOps Integration");
          setOutputChannel(channel);
          logLine("[logs] Output channel created on demand");
        }
        channel.show(true);
        const currentConfig = getConfig();
        if (!currentConfig.get("debugLogging")) {
          const pick = await vscode9.window.showInformationMessage(
            "Verbose logging is currently disabled. Enable it to capture more diagnostics?",
            "Enable",
            "Skip"
          );
          if (pick === "Enable") {
            await currentConfig.update("debugLogging", true, vscode9.ConfigurationTarget.Global);
            logLine("[logs] Debug logging enabled");
          }
        }
      } catch (err) {
        logger8.error("openLogs error", { meta: err });
      }
    };
    copyLogsToClipboardCommand = async (_ctx) => {
      try {
        const version3 = _ctx.context.extension.packageJSON.version || "dev";
        const buffer = getLogBufferSnapshot();
        const header = `Azure DevOps Integration Logs
Version: ${version3}
Timestamp: ${(/* @__PURE__ */ new Date()).toISOString()}
Lines: ${buffer.length}
---
`;
        const body = buffer.join("\n");
        const text2 = header + body + (body.endsWith("\n") ? "" : "\n");
        await vscode9.env.clipboard.writeText(text2);
        vscode9.window.showInformationMessage("Copied extension logs to clipboard.");
      } catch (err) {
        logger8.error("copyLogsToClipboard error", { meta: err });
      }
    };
    openLogsFolderCommand = async (_ctx) => {
      try {
        await vscode9.commands.executeCommand("workbench.action.openLogsFolder");
      } catch {
        try {
          await vscode9.env.openExternal(vscode9.env.logUri ?? vscode9.Uri.file(""));
        } catch (e) {
          vscode9.window.showErrorMessage("Failed to open logs folder: " + (e?.message || String(e)));
        }
      }
    };
    diagnoseWorkItemsCommand = async (_ctx) => {
      try {
        await diagnoseWorkItemsIssue(_ctx.context);
      } catch (e) {
        vscode9.window.showErrorMessage("Diagnostic failed: " + (e?.message || String(e)));
      }
    };
    focusWorkItemsViewCommand = (_ctx) => {
      vscode9.commands.executeCommand("azureDevOpsInt.workItemsView.focus");
    };
    setDefaultElapsedLimitCommand = async (_ctx) => {
      const limit = await vscode9.window.showInputBox({
        prompt: "Enter default elapsed time limit (in minutes)",
        value: "480",
        // 8 hours default
        validateInput: (value) => {
          const num = parseInt(value);
          if (isNaN(num) || num <= 0) {
            return "Please enter a valid positive number";
          }
          return null;
        }
      });
      if (limit) {
        const config = getConfig();
        await config.update("defaultElapsedLimit", parseInt(limit), vscode9.ConfigurationTarget.Global);
        vscode9.window.showInformationMessage(`Default elapsed limit set to ${limit} minutes`);
      }
    };
    showWorkItemsCommand = (_ctx) => {
      vscode9.commands.executeCommand("azureDevOpsInt.workItemsView.focus");
    };
    refreshWorkItemsCommand = async (_ctx) => {
      dispatchApplicationEvent({ type: "REFRESH_DATA" });
      const { panel: panel2 } = await Promise.resolve().then(() => (init_activation(), activation_exports));
      if (panel2?.webview) {
        panel2.webview.postMessage({ type: "REFRESH_DATA" });
      }
    };
    createWorkItemCommand = (_ctx) => {
      dispatchApplicationEvent({ type: "CREATE_WORK_ITEM" });
    };
    startTimerCommand = (_ctx) => {
      dispatchApplicationEvent({ type: "START_TIMER" });
    };
    pauseTimerCommand = (_ctx) => {
      dispatchApplicationEvent({ type: "PAUSE_TIMER" });
    };
    resumeTimerCommand = (_ctx) => {
      dispatchApplicationEvent({ type: "RESUME_TIMER" });
    };
    stopTimerCommand = async (ctx) => {
      const result = await ctx.timer?.stop();
      if (result) {
        vscode9.window.showInformationMessage(`Timer stopped. Elapsed: ${result.elapsedTime}`);
      }
    };
    showTimeReportCommand = (_ctx) => {
      dispatchApplicationEvent({ type: "SHOW_TIME_REPORT" });
    };
    createBranchCommand = (_ctx) => {
      dispatchApplicationEvent({ type: "CREATE_BRANCH" });
    };
    createPullRequestCommand = (_ctx) => {
      dispatchApplicationEvent({ type: "CREATE_PULL_REQUEST" });
    };
    showPullRequestsCommand = (_ctx) => {
      dispatchApplicationEvent({ type: "SHOW_PULL_REQUESTS" });
    };
    showBuildStatusCommand = (_ctx) => {
      dispatchApplicationEvent({ type: "SHOW_BUILD_STATUS" });
    };
    toggleKanbanViewCommand = (_ctx) => {
      dispatchApplicationEvent({ type: "TOGGLE_VIEW" });
    };
    toggleDebugViewCommand = (_ctx) => {
      dispatchApplicationEvent({ type: "TOGGLE_DEBUG_VIEW" });
    };
    selectTeamCommand = (_ctx) => {
      dispatchApplicationEvent({ type: "SELECT_TEAM" });
    };
    resetPreferredRepositoriesCommand = (_ctx) => {
      dispatchApplicationEvent({ type: "RESET_PREFERRED_REPOSITORIES" });
    };
    selfTestWebviewCommand = (_ctx) => {
      dispatchApplicationEvent({ type: "SELF_TEST_WEBVIEW" });
    };
    clearPerformanceDataCommand = (_ctx) => {
      performanceMonitor.clear();
      vscode9.window.showInformationMessage("Performance data cleared successfully");
    };
    forceGCCommand = (_ctx) => {
      if (global.gc) {
        global.gc();
        vscode9.window.showInformationMessage("Garbage collection forced");
      } else {
        vscode9.window.showWarningMessage("Garbage collection not available");
      }
    };
    bulkAssignCommand = (_ctx) => {
      dispatchApplicationEvent({ type: "BULK_ASSIGN" });
    };
    setOpenAIApiKeyCommand = (ctx) => {
      return setOpenAIApiKey(ctx.context);
    };
    generateCopilotPromptCommand = async (_ctx) => {
      dispatchApplicationEvent({ type: "GENERATE_COPILOT_PROMPT" });
    };
    cycleAuthSignInCommand = (ctx) => {
      return cycleAuthSignIn(ctx.context);
    };
  }
});

// src/features/commands/registration.ts
function registerCommands(_context, commandContext) {
  const startTime = Date.now();
  const disposables = [];
  const errors = [];
  for (const registration of commandRegistrations) {
    try {
      const disposable = vscode10.commands.registerCommand(registration.command, (...args) => {
        logger9.debug(`[COMMAND INVOKED] ${registration.command}`, {
          args,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        logger9.info(`[Command Registration] Command invoked: ${registration.command}`, { args });
        try {
          const result = registration.handler(commandContext, ...args);
          if (result instanceof Promise) {
            result.then(() => {
              logger9.debug(`[COMMAND SUCCESS] ${registration.command}`);
            }).catch((error) => {
              logger9.debug(`[COMMAND ERROR] ${registration.command}`, { meta: error });
              logger9.error(`Error in command ${registration.command}`, { meta: error });
              vscode10.window.showErrorMessage(`Command failed: ${error.message}`);
            });
          }
        } catch (error) {
          logger9.debug(`[COMMAND SYNC ERROR] ${registration.command}`, { meta: error });
          logger9.error(`Error in command ${registration.command}`, { meta: error });
          vscode10.window.showErrorMessage(`Command failed: ${error.message}`);
        }
      });
      disposables.push(disposable);
      if (registration.command === "azureDevOpsInt.signOutEntra") {
        logger9.debug(
          `[COMMAND REGISTERED] ${registration.command} - handler:`,
          { handlerType: typeof registration.handler }
        );
        logger9.info(`[Command Registration] Registered signOutEntra command`, {
          handlerType: typeof registration.handler,
          handlerName: registration.handler?.name || "anonymous"
        });
      }
    } catch (error) {
      const errorMsg = error.message || String(error);
      errors.push({ command: registration.command, error: errorMsg });
      logger9.debug(`[REGISTRATION ERROR] Failed to register ${registration.command}`, { meta: error });
      logger9.error(`Failed to register command ${registration.command}`, { meta: error });
      if (registration.command === "azureDevOpsInt.signOutEntra") {
        vscode10.window.showErrorMessage(
          `Failed to register signOutEntra command: ${errorMsg}`
        );
      }
    }
  }
  const duration = Date.now() - startTime;
  if (errors.length > 0) {
    logger9.warn(
      `[Command Registration] Registered ${disposables.length}/${commandRegistrations.length} commands in ${duration}ms`,
      {
        errors: errors.map((e) => `${e.command}: ${e.error}`),
        failed: errors.length
      }
    );
  } else {
    logger9.info(
      `[Command Registration] Registered ${disposables.length} commands in ${duration}ms`
    );
  }
  return disposables;
}
var vscode10, logger9, commandRegistrations;
var init_registration = __esm({
  "src/features/commands/registration.ts"() {
    "use strict";
    vscode10 = __toESM(require("vscode"), 1);
    init_unifiedLogger();
    init_handlers();
    logger9 = createLogger("commands-registration");
    commandRegistrations = [
      { command: "azureDevOpsInt.setup", handler: setupCommand },
      { command: "azureDevOpsInt.signInWithEntra", handler: signInWithEntraCommand },
      { command: "azureDevOpsInt.signOutEntra", handler: signOutEntraCommand },
      { command: "azureDevOpsInt.openLogs", handler: openLogsCommand },
      { command: "azureDevOpsInt.copyLogsToClipboard", handler: copyLogsToClipboardCommand },
      { command: "azureDevOpsInt.diagnoseWorkItems", handler: diagnoseWorkItemsCommand },
      { command: "azureDevOpsInt.openLogsFolder", handler: openLogsFolderCommand },
      { command: "azureDevOpsInt.focusWorkItemsView", handler: focusWorkItemsViewCommand },
      { command: "azureDevOpsInt.setDefaultElapsedLimit", handler: setDefaultElapsedLimitCommand },
      { command: "azureDevOpsInt.showWorkItems", handler: showWorkItemsCommand },
      { command: "azureDevOpsInt.refreshWorkItems", handler: refreshWorkItemsCommand },
      { command: "azureDevOpsInt.createWorkItem", handler: createWorkItemCommand },
      { command: "azureDevOpsInt.startTimer", handler: startTimerCommand },
      { command: "azureDevOpsInt.pauseTimer", handler: pauseTimerCommand },
      { command: "azureDevOpsInt.resumeTimer", handler: resumeTimerCommand },
      { command: "azureDevOpsInt.stopTimer", handler: stopTimerCommand },
      { command: "azureDevOpsInt.showTimeReport", handler: showTimeReportCommand },
      { command: "azureDevOpsInt.createBranch", handler: createBranchCommand },
      { command: "azureDevOpsInt.createPullRequest", handler: createPullRequestCommand },
      { command: "azureDevOpsInt.showPullRequests", handler: showPullRequestsCommand },
      { command: "azureDevOpsInt.showBuildStatus", handler: showBuildStatusCommand },
      { command: "azureDevOpsInt.toggleKanbanView", handler: toggleKanbanViewCommand },
      { command: "azureDevOpsInt.toggleDebugView", handler: toggleDebugViewCommand },
      { command: "azureDevOpsInt.selectTeam", handler: selectTeamCommand },
      {
        command: "azureDevOpsInt.resetPreferredRepositories",
        handler: resetPreferredRepositoriesCommand
      },
      { command: "azureDevOpsInt.selfTestWebview", handler: selfTestWebviewCommand },
      { command: "azureDevOpsInt.clearPerformanceData", handler: clearPerformanceDataCommand },
      { command: "azureDevOpsInt.forceGC", handler: forceGCCommand },
      { command: "azureDevOpsInt.bulkAssign", handler: bulkAssignCommand },
      { command: "azureDevOpsInt.setOpenAIApiKey", handler: setOpenAIApiKeyCommand },
      { command: "azureDevOpsInt.generateCopilotPrompt", handler: generateCopilotPromptCommand },
      { command: "azureDevOpsInt.cycleAuthSignIn", handler: cycleAuthSignInCommand }
    ];
  }
});

// src/features/commands/index.ts
var init_commands = __esm({
  "src/features/commands/index.ts"() {
    "use strict";
    init_types();
    init_handlers();
    init_registration();
  }
});

// src/logging/TraceLogger.ts
var TraceLogger_exports = {};
__export(TraceLogger_exports, {
  TraceLogger: () => TraceLogger,
  analyzeCurrentTrace: () => analyzeCurrentTrace,
  exportCurrentTrace: () => exportCurrentTrace,
  instrumentActor: () => instrumentActor,
  startTraceSession: () => startTraceSession,
  stopTraceSession: () => stopTraceSession,
  traceLogger: () => traceLogger
});
function instrumentActor(actor, component2, machineId) {
  return traceLogger.instrumentActor(actor, component2, machineId);
}
function startTraceSession(description) {
  return traceLogger.startNewSession(description);
}
function stopTraceSession() {
  traceLogger.stopCurrentSession();
}
function exportCurrentTrace() {
  const currentSession = traceLogger.getCurrentSession();
  if (!currentSession) return void 0;
  return traceLogger.exportSession(currentSession.id);
}
function analyzeCurrentTrace() {
  const currentSession = traceLogger.getCurrentSession();
  if (!currentSession) return void 0;
  return traceLogger.analyzeSession(currentSession.id);
}
var TraceLogger, _traceLogger, traceLogger;
var init_TraceLogger = __esm({
  "src/logging/TraceLogger.ts"() {
    "use strict";
    init_ComponentLogger();
    TraceLogger = class _TraceLogger {
      static instance;
      sessions = /* @__PURE__ */ new Map();
      currentSession;
      isRecording = false;
      traceCounter = 0;
      maxEntriesPerSession = 1e4;
      subscribedActors = /* @__PURE__ */ new Map();
      constructor() {
        this.startNewSession("Praxis Extension Startup");
      }
      static getInstance() {
        if (!_TraceLogger.instance) {
          _TraceLogger.instance = new _TraceLogger();
        }
        return _TraceLogger.instance;
      }
      // ============================================================================
      // SESSION MANAGEMENT
      // ============================================================================
      startNewSession(description) {
        const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        if (this.currentSession) {
          this.currentSession.endTime = Date.now();
        }
        this.currentSession = {
          id: sessionId,
          startTime: Date.now(),
          description: description || "Praxis Trace Session",
          entries: [],
          metadata: {
            extensionVersion: process.env.npm_package_version,
            nodeVersion: process.version
          }
        };
        this.sessions.set(sessionId, this.currentSession);
        this.isRecording = true;
        componentLogger.info("MACHINE" /* MACHINE */, `New trace session started: ${sessionId}`, {
          component: "MACHINE" /* MACHINE */,
          machineId: sessionId
        });
        return sessionId;
      }
      stopCurrentSession() {
        if (this.currentSession) {
          this.currentSession.endTime = Date.now();
          this.isRecording = false;
          componentLogger.info(
            "MACHINE" /* MACHINE */,
            `Trace session ended: ${this.currentSession.id}`,
            {
              component: "MACHINE" /* MACHINE */,
              machineId: this.currentSession.id
            },
            {
              duration: this.currentSession.endTime - this.currentSession.startTime,
              entriesCount: this.currentSession.entries.length
            }
          );
        }
      }
      getCurrentSession() {
        return this.currentSession;
      }
      getSession(sessionId) {
        return this.sessions.get(sessionId);
      }
      getAllSessions() {
        return Array.from(this.sessions.values());
      }
      // ============================================================================
      // PRAXIS-COMPATIBLE ACTOR INSTRUMENTATION
      // ============================================================================
      /**
       * Instrument a Praxis manager or engine for tracing.
       * This is a no-op that returns a cleanup function for compatibility.
       * For actual tracing, use logEvent() directly.
       */
      instrumentActor(_actor, component2, machineId) {
        if (!this.isRecording || !this.currentSession) {
          return () => {
          };
        }
        const actorId = `${component2}_${machineId || "default"}_${Date.now()}`;
        componentLogger.debug("MACHINE" /* MACHINE */, `Actor registered for tracing: ${actorId}`, {
          component: component2,
          machineId
        });
        const cleanup = () => {
          this.subscribedActors.delete(actorId);
        };
        this.subscribedActors.set(actorId, cleanup);
        return cleanup;
      }
      /**
       * Log an event from a Praxis engine or manager.
       * This is the main method for recording events in Praxis-based systems.
       */
      logEvent(data) {
        if (!this.isRecording || !this.currentSession) return;
        const entry = {
          id: `trace_${++this.traceCounter}`,
          timestamp: data.timestamp,
          sessionId: this.currentSession.id,
          machineId: data.machineId,
          actorId: `${data.component}_${data.machineId}`,
          component: data.component,
          event: { type: data.eventType, payload: data.data },
          eventType: data.eventType,
          fromState: data.fromState || "unknown",
          toState: data.toState || "unknown",
          contextBefore: null,
          contextAfter: data.context,
          error: data.error
        };
        this.addTraceEntry(entry);
      }
      addTraceEntry(entry) {
        if (!this.currentSession) return;
        this.currentSession.entries.push(entry);
        if (this.currentSession.entries.length > this.maxEntriesPerSession) {
          this.currentSession.entries = this.currentSession.entries.slice(-this.maxEntriesPerSession);
        }
        if (entry.eventType !== "TICK" && entry.eventType !== "HEARTBEAT") {
          componentLogger.debug(
            "MACHINE" /* MACHINE */,
            `Praxis Event: ${entry.eventType}`,
            {
              component: entry.component,
              machineId: entry.machineId,
              state: entry.toState,
              event: entry.eventType
            },
            {
              fromState: entry.fromState,
              toState: entry.toState,
              contextChanged: JSON.stringify(entry.contextBefore) !== JSON.stringify(entry.contextAfter)
            }
          );
        }
      }
      // ============================================================================
      // REPLAY FUNCTIONALITY
      // ============================================================================
      async replaySession(sessionId, _targetActor, options = {}) {
        const session = this.sessions.get(sessionId);
        if (!session) {
          throw new Error(`Session not found: ${sessionId}`);
        }
        const {
          startFromEntry = 0,
          endAtEntry = session.entries.length - 1,
          stepMode = false,
          delayMs = 100,
          skipErrors = false,
          onStateChange,
          onError
        } = options;
        componentLogger.info(
          "MACHINE" /* MACHINE */,
          `Starting replay of session: ${sessionId}`,
          {
            component: "MACHINE" /* MACHINE */,
            machineId: sessionId
          },
          {
            totalEntries: session.entries.length,
            startFrom: startFromEntry,
            endAt: endAtEntry
          }
        );
        const entriesToReplay = session.entries.slice(startFromEntry, endAtEntry + 1);
        for (let i = 0; i < entriesToReplay.length; i++) {
          const entry = entriesToReplay[i];
          try {
            onStateChange?.(entry);
            if (!stepMode && delayMs > 0) {
              await new Promise((resolve) => setTimeout(resolve, delayMs));
            } else if (stepMode) {
              await this.waitForStep();
            }
          } catch (error) {
            if (skipErrors) {
              componentLogger.warn("MACHINE" /* MACHINE */, `Replay error skipped: ${error}`, {
                component: "MACHINE" /* MACHINE */,
                machineId: sessionId
              });
              onError?.(entry, error);
            } else {
              throw error;
            }
          }
        }
        componentLogger.info("MACHINE" /* MACHINE */, `Replay completed for session: ${sessionId}`);
      }
      async waitForStep() {
        return new Promise((resolve) => setTimeout(resolve, 1e3));
      }
      // ============================================================================
      // EXPORT/IMPORT FUNCTIONALITY
      // ============================================================================
      exportSession(sessionId) {
        const session = this.sessions.get(sessionId);
        if (!session) {
          throw new Error(`Session not found: ${sessionId}`);
        }
        return JSON.stringify(session, null, 2);
      }
      exportAllSessions() {
        const allSessions = Object.fromEntries(this.sessions);
        return JSON.stringify(allSessions, null, 2);
      }
      importSession(sessionData) {
        try {
          const session = JSON.parse(sessionData);
          if (!session.id || !session.entries || !Array.isArray(session.entries)) {
            throw new Error("Invalid session data format");
          }
          this.sessions.set(session.id, session);
          componentLogger.info(
            "MACHINE" /* MACHINE */,
            `Session imported: ${session.id}`,
            {
              component: "MACHINE" /* MACHINE */,
              machineId: session.id
            },
            {
              entriesCount: session.entries.length,
              originalStartTime: session.startTime
            }
          );
          return session.id;
        } catch (error) {
          throw new Error(`Failed to import session: ${error}`);
        }
      }
      // ============================================================================
      // ANALYSIS FUNCTIONALITY
      // ============================================================================
      analyzeSession(sessionId) {
        const session = this.sessions.get(sessionId);
        if (!session) {
          throw new Error(`Session not found: ${sessionId}`);
        }
        const entries = session.entries;
        const { eventFrequency, stateTransitions, uniqueStates, transitions, errors } = this.summarizeEntries(entries);
        const avgTransitionTime = transitions.length > 0 ? transitions.reduce((sum, t) => sum + t.duration, 0) / transitions.length : 0;
        const slowestTransitions = transitions.sort((a, b) => b.duration - a.duration).slice(0, 10);
        return {
          summary: {
            duration: (session.endTime || Date.now()) - session.startTime,
            totalEvents: entries.length,
            uniqueStates: uniqueStates.size,
            errors
          },
          eventFrequency,
          stateTransitions,
          performance: {
            avgTransitionTime,
            slowestTransitions
          }
        };
      }
      summarizeEntries(entries) {
        const eventFrequency = {};
        const stateTransitions = {};
        const uniqueStates = /* @__PURE__ */ new Set();
        const transitions = [];
        let errors = 0;
        entries.forEach((entry, index2) => {
          eventFrequency[entry.eventType] = (eventFrequency[entry.eventType] || 0) + 1;
          uniqueStates.add(entry.fromState);
          uniqueStates.add(entry.toState);
          if (!stateTransitions[entry.fromState]) {
            stateTransitions[entry.fromState] = [];
          }
          if (!stateTransitions[entry.fromState].includes(entry.toState)) {
            stateTransitions[entry.fromState].push(entry.toState);
          }
          if (entry.error) {
            errors++;
          }
          if (index2 > 0) {
            const duration = entry.timestamp - entries[index2 - 1].timestamp;
            transitions.push({
              from: entry.fromState,
              to: entry.toState,
              event: entry.eventType,
              duration
            });
          }
        });
        return { eventFrequency, stateTransitions, uniqueStates, transitions, errors };
      }
      // ============================================================================
      // UTILITY METHODS
      // ============================================================================
      cleanup() {
        this.subscribedActors.forEach((cleanup) => cleanup());
        this.subscribedActors.clear();
        this.stopCurrentSession();
        componentLogger.info("MACHINE" /* MACHINE */, "Trace Logger cleaned up");
      }
      getStats() {
        return {
          sessionsCount: this.sessions.size,
          totalEntries: Array.from(this.sessions.values()).reduce(
            (sum, session) => sum + session.entries.length,
            0
          ),
          currentSessionEntries: this.currentSession?.entries.length || 0,
          instrumentedActors: this.subscribedActors.size
        };
      }
    };
    _traceLogger = TraceLogger.getInstance();
    traceLogger = _traceLogger;
  }
});

// src/commands/traceCommands.ts
function registerTraceCommands(context) {
  context.subscriptions.push(
    vscode11.commands.registerCommand("azureDevOpsInt.showFSMTraceStatus", async () => {
      await showTraceStatus();
    })
  );
  context.subscriptions.push(
    vscode11.commands.registerCommand("azureDevOpsInt.exportFSMTrace", async () => {
      await exportTrace();
    })
  );
  context.subscriptions.push(
    vscode11.commands.registerCommand("azureDevOpsInt.importFSMTrace", async () => {
      await importTrace();
    })
  );
  context.subscriptions.push(
    vscode11.commands.registerCommand("azureDevOpsInt.analyzeFSMTrace", async () => {
      await analyzeTrace();
    })
  );
  context.subscriptions.push(
    vscode11.commands.registerCommand("azureDevOpsInt.startFSMTraceSession", async () => {
      await startTraceSession2();
    })
  );
  context.subscriptions.push(
    vscode11.commands.registerCommand("azureDevOpsInt.stopFSMTraceSession", async () => {
      await stopTraceSession2();
    })
  );
  context.subscriptions.push(
    vscode11.commands.registerCommand("azureDevOpsInt.showFSMTraceTimeline", async () => {
      await showTraceTimeline();
    })
  );
  componentLogger.info("MACHINE" /* MACHINE */, "Trace commands registered");
}
async function showTraceStatus() {
  try {
    const stats = traceLogger.getStats();
    const currentSession = traceLogger.getCurrentSession();
    const statusItems = [
      `\u{1F4CA} **Trace Status**`,
      ``,
      `**Current Session:**`,
      currentSession ? `- ID: \`${currentSession.id}\`` : `- No active session`,
      currentSession ? `- Description: ${currentSession.description}` : ``,
      currentSession ? `- Started: ${new Date(currentSession.startTime).toLocaleString()}` : ``,
      currentSession ? `- Events: ${currentSession.entries.length}` : ``,
      ``,
      `**Statistics:**`,
      `- Total Sessions: ${stats.sessionsCount}`,
      `- Total Events: ${stats.totalEntries}`,
      `- Instrumented Actors: ${stats.instrumentedActors}`,
      ``,
      `**Actions:**`,
      `- Export current trace for analysis`,
      `- Import trace file for replay`,
      `- Analyze performance patterns`,
      `- Start/stop trace sessions`
    ];
    const panel2 = vscode11.window.createWebviewPanel(
      "traceStatus",
      "Trace Status",
      vscode11.ViewColumn.One,
      { enableScripts: false }
    );
    panel2.webview.html = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <style>
          body { 
            font-family: var(--vscode-font-family); 
            color: var(--vscode-foreground);
            background: var(--vscode-editor-background);
            padding: 20px;
            line-height: 1.6;
          }
          code { 
            background: var(--vscode-textCodeBlock-background);
            padding: 2px 4px;
            border-radius: 3px;
          }
          pre {
            background: var(--vscode-textCodeBlock-background);
            padding: 10px;
            border-radius: 3px;
            overflow-x: auto;
          }
        </style>
      </head>
      <body>
        ${statusItems.map((item) => {
      if (item.startsWith("- ")) {
        return `<p style="margin-left: 20px;">${item}</p>`;
      } else if (item.startsWith("**") && item.endsWith("**")) {
        return `<h3>${item.slice(2, -2)}</h3>`;
      } else if (item.includes("`")) {
        return `<p>${item.replace(/`([^`]+)`/g, "<code>$1</code>")}</p>`;
      } else {
        return item ? `<p>${item}</p>` : "<br>";
      }
    }).join("")}
      </body>
      </html>
    `;
  } catch (error) {
    vscode11.window.showErrorMessage(`Failed to show trace status: ${error}`);
    componentLogger.error("MACHINE" /* MACHINE */, "Failed to show trace status", void 0, { error });
  }
}
async function exportTrace() {
  try {
    const traceData = exportCurrentTrace();
    if (!traceData) {
      vscode11.window.showWarningMessage("No active trace session to export");
      return;
    }
    const uri = await vscode11.window.showSaveDialog({
      defaultUri: vscode11.Uri.file(`fsm-trace-${Date.now()}.json`),
      filters: {
        "FSM Trace Files": ["json"],
        "All Files": ["*"]
      }
    });
    if (uri) {
      await vscode11.workspace.fs.writeFile(uri, Buffer.from(traceData, "utf8"));
      vscode11.window.showInformationMessage(`Trace exported to: ${uri.fsPath}`);
      const analyze = await vscode11.window.showInformationMessage(
        "Trace exported successfully. Would you like to analyze it now?",
        "Yes",
        "No"
      );
      if (analyze === "Yes") {
        await analyzeTrace();
      }
    }
  } catch (error) {
    vscode11.window.showErrorMessage(`Failed to export trace: ${error}`);
    componentLogger.error("MACHINE" /* MACHINE */, "Failed to export trace", void 0, { error });
  }
}
async function importTrace() {
  try {
    const uris = await vscode11.window.showOpenDialog({
      canSelectFiles: true,
      canSelectMany: false,
      filters: {
        "FSM Trace Files": ["json"],
        "All Files": ["*"]
      }
    });
    if (uris && uris.length > 0) {
      const content = await vscode11.workspace.fs.readFile(uris[0]);
      const traceData = Buffer.from(content).toString("utf8");
      const sessionId = traceLogger.importSession(traceData);
      vscode11.window.showInformationMessage(`Trace imported: ${sessionId}`);
      const analyze = await vscode11.window.showInformationMessage(
        "Trace imported successfully. Would you like to analyze it?",
        "Yes",
        "No"
      );
      if (analyze === "Yes") {
        const analysis = traceLogger.analyzeSession(sessionId);
        await showAnalysisResults(analysis, sessionId);
      }
    }
  } catch (error) {
    vscode11.window.showErrorMessage(`Failed to import trace: ${error}`);
    componentLogger.error("MACHINE" /* MACHINE */, "Failed to import trace", void 0, { error });
  }
}
async function analyzeTrace() {
  try {
    const analysis = analyzeCurrentTrace();
    if (!analysis) {
      vscode11.window.showWarningMessage("No active trace session to analyze");
      return;
    }
    const currentSession = traceLogger.getCurrentSession();
    await showAnalysisResults(analysis, currentSession?.id || "current");
  } catch (error) {
    vscode11.window.showErrorMessage(`Failed to analyze trace: ${error}`);
    componentLogger.error("MACHINE" /* MACHINE */, "Failed to analyze trace", void 0, { error });
  }
}
async function showAnalysisResults(analysis, sessionId) {
  const panel2 = vscode11.window.createWebviewPanel(
    "traceAnalysis",
    `Trace Analysis - ${sessionId}`,
    vscode11.ViewColumn.One,
    { enableScripts: false }
  );
  const durationMs = analysis.summary.duration;
  const durationFormatted = durationMs > 6e4 ? `${Math.round(durationMs / 6e4)} minutes` : `${Math.round(durationMs / 1e3)} seconds`;
  panel2.webview.html = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="UTF-8">
      <style>
        body { 
          font-family: var(--vscode-font-family); 
          color: var(--vscode-foreground);
          background: var(--vscode-editor-background);
          padding: 20px;
          line-height: 1.6;
        }
        .metric { 
          background: var(--vscode-textCodeBlock-background);
          padding: 10px;
          margin: 10px 0;
          border-radius: 5px;
          display: inline-block;
          min-width: 200px;
        }
        .metric-value { 
          font-size: 1.5em; 
          font-weight: bold; 
          color: var(--vscode-charts-blue);
        }
        .section {
          margin: 20px 0;
          padding: 10px;
          border-left: 3px solid var(--vscode-charts-blue);
          background: var(--vscode-editor-lineHighlightBackground);
        }
        .event-freq, .transitions {
          background: var(--vscode-textCodeBlock-background);
          padding: 10px;
          border-radius: 3px;
          margin: 10px 0;
        }
        .slow-transition {
          color: var(--vscode-charts-red);
          font-weight: bold;
        }
      </style>
    </head>
    <body>
      <h1>\u{1F50D} Trace Analysis</h1>
      <p><strong>Session:</strong> <code>${sessionId}</code></p>
      
      <div class="section">
        <h2>\u{1F4CA} Summary</h2>
        <div class="metric">
          <div>Duration</div>
          <div class="metric-value">${durationFormatted}</div>
        </div>
        <div class="metric">
          <div>Total Events</div>
          <div class="metric-value">${analysis.summary.totalEvents}</div>
        </div>
        <div class="metric">
          <div>Unique States</div>
          <div class="metric-value">${analysis.summary.uniqueStates}</div>
        </div>
        <div class="metric">
          <div>Errors</div>
          <div class="metric-value" style="color: ${analysis.summary.errors > 0 ? "var(--vscode-charts-red)" : "var(--vscode-charts-green)"}">
            ${analysis.summary.errors}
          </div>
        </div>
      </div>

      <div class="section">
        <h2>\u{1F4C8} Event Frequency</h2>
        <div class="event-freq">
          ${Object.entries(analysis.eventFrequency).sort(([, a], [, b]) => b - a).map(([event2, count]) => `<div>${event2}: <strong>${count}</strong></div>`).join("")}
        </div>
      </div>

      <div class="section">
        <h2>\u{1F504} State Transitions</h2>
        <div class="transitions">
          ${Object.entries(analysis.stateTransitions).map(
    ([from, toStates]) => `<div><strong>${from}</strong> \u2192 ${toStates.join(", ")}</div>`
  ).join("")}
        </div>
      </div>

      <div class="section">
        <h2>\u26A1 Performance</h2>
        <div class="metric">
          <div>Avg Transition Time</div>
          <div class="metric-value">${Math.round(analysis.performance.avgTransitionTime)}ms</div>
        </div>
        
        <h3>\u{1F40C} Slowest Transitions</h3>
        <div class="transitions">
          ${analysis.performance.slowestTransitions.slice(0, 5).map(
    (t) => `<div class="slow-transition">${t.from} \u2192 ${t.to} (${t.event}): ${t.duration}ms</div>`
  ).join("")}
        </div>
      </div>

      <div class="section">
        <h2>\u{1F4A1} Insights</h2>
        <ul>
          ${analysis.summary.errors > 0 ? `<li>\u26A0\uFE0F Found ${analysis.summary.errors} errors - investigate error patterns</li>` : ""}
          ${analysis.performance.avgTransitionTime > 100 ? `<li>\u{1F40C} Average transition time is high (${Math.round(analysis.performance.avgTransitionTime)}ms) - check for performance bottlenecks</li>` : ""}
          ${analysis.summary.uniqueStates > 20 ? `<li>\u{1F504} High number of unique states (${analysis.summary.uniqueStates}) - consider state machine simplification</li>` : ""}
          ${Object.keys(analysis.eventFrequency).length > 10 ? `<li>\u{1F4E2} Many event types (${Object.keys(analysis.eventFrequency).length}) - review event design</li>` : ""}
          <li>\u2705 Use this data to optimize FSM performance and reliability</li>
        </ul>
      </div>
    </body>
    </html>
  `;
}
async function startTraceSession2() {
  try {
    const description = await vscode11.window.showInputBox({
      prompt: "Enter a description for the new trace session",
      value: "Manual trace session"
    });
    if (description !== void 0) {
      const sessionId = traceLogger.startNewSession(description);
      vscode11.window.showInformationMessage(`Started new trace session: ${sessionId}`);
    }
  } catch (error) {
    vscode11.window.showErrorMessage(`Failed to start trace session: ${error}`);
    componentLogger.error("MACHINE" /* MACHINE */, "Failed to start trace session", void 0, { error });
  }
}
async function stopTraceSession2() {
  try {
    const currentSession = traceLogger.getCurrentSession();
    if (!currentSession) {
      vscode11.window.showWarningMessage("No active trace session to stop");
      return;
    }
    traceLogger.stopCurrentSession();
    const action2 = await vscode11.window.showInformationMessage(
      `Stopped trace session: ${currentSession.id}`,
      "Analyze",
      "Export",
      "Close"
    );
    if (action2 === "Analyze") {
      await analyzeTrace();
    } else if (action2 === "Export") {
      await exportTrace();
    }
  } catch (error) {
    vscode11.window.showErrorMessage(`Failed to stop trace session: ${error}`);
    componentLogger.error("MACHINE" /* MACHINE */, "Failed to stop trace session", void 0, { error });
  }
}
async function showTraceTimeline() {
  try {
    const currentSession = traceLogger.getCurrentSession();
    if (!currentSession) {
      vscode11.window.showWarningMessage("No active trace session");
      return;
    }
    const panel2 = vscode11.window.createWebviewPanel(
      "traceTimeline",
      `Trace Timeline - ${currentSession.id}`,
      vscode11.ViewColumn.One,
      { enableScripts: true }
    );
    const recentEntries = currentSession.entries.slice(-100);
    const timelineData = recentEntries.map((entry) => ({
      timestamp: new Date(entry.timestamp).toLocaleTimeString(),
      event: entry.eventType,
      fromState: entry.fromState,
      toState: entry.toState,
      component: entry.component,
      duration: entry.duration || 0,
      hasError: !!entry.error
    }));
    panel2.webview.html = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <style>
          body { 
            font-family: var(--vscode-font-family); 
            color: var(--vscode-foreground);
            background: var(--vscode-editor-background);
            padding: 20px;
          }
          .timeline-item {
            padding: 10px;
            margin: 5px 0;
            border-left: 3px solid var(--vscode-charts-blue);
            background: var(--vscode-editor-lineHighlightBackground);
            border-radius: 3px;
          }
          .timeline-item.error {
            border-color: var(--vscode-charts-red);
            background: var(--vscode-inputValidation-errorBackground);
          }
          .timestamp {
            font-size: 0.9em;
            color: var(--vscode-descriptionForeground);
          }
          .event-type {
            font-weight: bold;
            color: var(--vscode-charts-blue);
          }
          .state-transition {
            font-family: monospace;
            background: var(--vscode-textCodeBlock-background);
            padding: 2px 4px;
            border-radius: 3px;
          }
        </style>
      </head>
      <body>
        <h1>\u23F1\uFE0F Trace Timeline</h1>
        <p><strong>Session:</strong> <code>${currentSession.id}</code></p>
        <p><strong>Showing:</strong> Last ${recentEntries.length} events</p>
        <hr>
        
        ${timelineData.map(
      (item) => `
          <div class="timeline-item ${item.hasError ? "error" : ""}">
            <div class="timestamp">${item.timestamp}</div>
            <div>
              <span class="event-type">${item.event}</span>
              <span style="margin-left: 10px; color: var(--vscode-descriptionForeground);">[${item.component}]</span>
            </div>
            <div class="state-transition">${item.fromState} \u2192 ${item.toState}</div>
          </div>
        `
    ).join("")}
      </body>
      </html>
    `;
  } catch (error) {
    vscode11.window.showErrorMessage(`Failed to show trace timeline: ${error}`);
    componentLogger.error("MACHINE" /* MACHINE */, "Failed to show trace timeline", void 0, { error });
  }
}
var vscode11;
var init_traceCommands = __esm({
  "src/commands/traceCommands.ts"() {
    "use strict";
    vscode11 = __toESM(require("vscode"), 1);
    init_TraceLogger();
    init_ComponentLogger();
  }
});

// src/commands/quickDebugCommands.ts
function registerQuickDebugCommands(context) {
  context.subscriptions.push(
    vscode12.commands.registerCommand("azureDevOpsInt.quickDebug", async () => {
      await showInstantDebugPanel();
    })
  );
  context.subscriptions.push(
    vscode12.commands.registerCommand("azureDevOpsInt.showFSMLogs", async () => {
      showFSMLogsNow();
    })
  );
  context.subscriptions.push(
    vscode12.commands.registerCommand("azureDevOpsInt.triageBrokenFeature", async () => {
      await triageBrokenFeature();
    })
  );
  context.subscriptions.push(
    vscode12.commands.registerCommand("azureDevOpsInt.debug.simulateConnectionLoad", async () => {
      try {
        const { dispatchApplicationEvent: dispatchApplicationEvent2 } = await import("../../activation.js");
        const fakeConnection = {
          id: "simulated-" + Date.now(),
          organization: "SimulatedOrg",
          project: "SimulatedProject",
          label: "Simulated Connection " + (/* @__PURE__ */ new Date()).toLocaleTimeString(),
          authMethod: "pat"
        };
        vscode12.window.showInformationMessage(`Simulating connection load: ${fakeConnection.label}`);
        dispatchApplicationEvent2({
          type: "CONNECTIONS_LOADED",
          payload: {
            connections: [fakeConnection],
            activeId: fakeConnection.id
          }
        });
      } catch (error) {
        vscode12.window.showErrorMessage(`Simulation failed: ${error}`);
      }
    })
  );
  componentLogger.info("MACHINE" /* MACHINE */, "Quick debug commands registered");
}
async function showInstantDebugPanel() {
  try {
    showFSMLogsNow();
    const stats = traceLogger.getStats();
    const currentSession = traceLogger.getCurrentSession();
    const analysis = analyzeCurrentTrace();
    const panel2 = vscode12.window.createWebviewPanel(
      "instantDebug",
      "\u{1F6A8} Instant Debug Panel",
      vscode12.ViewColumn.Beside,
      // Open beside current editor
      { enableScripts: false }
    );
    const recentErrors = componentLogger.getLogBuffer().filter((entry) => entry.level >= 2).slice(-10).reverse();
    panel2.webview.html = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <style>
          body { 
            font-family: var(--vscode-font-family); 
            color: var(--vscode-foreground);
            background: var(--vscode-editor-background);
            padding: 20px;
            line-height: 1.6;
          }
          .status-ok { color: var(--vscode-charts-green); }
          .status-warn { color: var(--vscode-charts-orange); }
          .status-error { color: var(--vscode-charts-red); }
          .metric {
            background: var(--vscode-textCodeBlock-background);
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 3px solid var(--vscode-charts-blue);
          }
          .error-item {
            background: var(--vscode-inputValidation-errorBackground);
            padding: 8px;
            margin: 5px 0;
            border-radius: 3px;
            border-left: 3px solid var(--vscode-charts-red);
          }
          .command-button {
            background: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            padding: 8px 16px;
            border: none;
            border-radius: 3px;
            margin: 5px;
            cursor: pointer;
          }
          .section {
            margin: 20px 0;
            padding: 15px;
            background: var(--vscode-editor-lineHighlightBackground);
            border-radius: 5px;
          }
        </style>
      </head>
      <body>
        <h1>\u{1F6A8} Instant Debug Panel</h1>
        <p><strong>Generated:</strong> ${(/* @__PURE__ */ new Date()).toLocaleString()}</p>
        
        <div class="section">
          <h2>\u{1F4CA} Current Status</h2>
          <div class="metric">
            <strong>FSM Tracing:</strong> 
            <span class="${currentSession ? "status-ok" : "status-error"}">
              ${currentSession ? `Active (${currentSession.entries.length} events)` : "Inactive"}
            </span>
          </div>
          <div class="metric">
            <strong>Instrumented Actors:</strong> 
            <span class="${stats.instrumentedActors > 0 ? "status-ok" : "status-warn"}">
              ${stats.instrumentedActors}
            </span>
          </div>
          <div class="metric">
            <strong>Recent Errors:</strong> 
            <span class="${recentErrors.length === 0 ? "status-ok" : "status-error"}">
              ${recentErrors.length}
            </span>
          </div>
          ${analysis ? `
          <div class="metric">
            <strong>FSM Performance:</strong> 
            <span class="${analysis.performance.avgTransitionTime < 100 ? "status-ok" : "status-warn"}">
              ${Math.round(analysis.performance.avgTransitionTime)}ms avg
            </span>
          </div>
          ` : ""}
        </div>

        ${recentErrors.length > 0 ? `
        <div class="section">
          <h2>\u{1F534} Recent Errors</h2>
          ${recentErrors.map(
      (error) => `
            <div class="error-item">
              <strong>${new Date(error.timestamp).toLocaleTimeString()}</strong> 
              [${error.component}] ${error.message}
              ${error.data ? `<br><small>${JSON.stringify(error.data, null, 2)}</small>` : ""}
            </div>
          `
    ).join("")}
        </div>
        ` : ""}

        <div class="section">
          <h2>\u{1F527} Quick Actions</h2>
          <p>Use Command Palette (Ctrl+Shift+P) to run:</p>
          <ul>
            <li><code>Azure DevOps Int (Debug): Show FSM Logs</code> - View detailed logs</li>
            <li><code>Azure DevOps Int (Debug): Export Trace</code> - Save current trace</li>
            <li><code>Azure DevOps Int (Debug): Analyze Trace</code> - Performance analysis</li>
            <li><code>Azure DevOps Int (Debug): Show Trace Timeline</code> - Event timeline</li>
          </ul>
        </div>

        <div class="section">
          <h2>\u{1F4CB} System Info</h2>
          <div class="metric">
            <strong>Total Trace Sessions:</strong> ${stats.sessionsCount}<br>
            <strong>Total Trace Events:</strong> ${stats.totalEntries}<br>
            <strong>Current Session Events:</strong> ${stats.currentSessionEntries}
          </div>
        </div>

        <div class="section">
          <h2>\u{1F4A1} Debugging Tips</h2>
          <ul>
            <li>Check the <strong>Praxis Output Channel</strong> for real-time logs</li>
            <li>Look for <code>\u{1F534}</code> error symbols in the console output</li>
            <li>Export traces when issues occur for later analysis</li>
            <li>Use timeline view to see event sequences</li>
          </ul>
        </div>
      </body>
      </html>
    `;
    vscode12.window.showInformationMessage(
      "\u{1F6A8} Debug panel opened! Check the Praxis Output Channel for live logs.",
      "OK"
    );
  } catch (error) {
    vscode12.window.showErrorMessage(`Failed to show debug panel: ${error}`);
  }
}
function showFSMLogsNow() {
  try {
    componentLogger.showOutputChannel();
    vscode12.window.showInformationMessage(
      "\u{1F4FA} Output Channel opened. Also check Developer Console (Help > Toggle Developer Tools) for console.log output.",
      "Open Developer Tools"
    ).then((selection) => {
      if (selection === "Open Developer Tools") {
        vscode12.commands.executeCommand("workbench.action.toggleDevTools");
      }
    });
    componentLogger.info(
      "MACHINE" /* MACHINE */,
      "\u{1F50D} MANUAL DEBUG SESSION STARTED",
      {
        component: "MACHINE" /* MACHINE */,
        event: "DEBUG_SESSION_START"
      },
      {
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        reason: "User requested debug logs"
      }
    );
    componentLogger.info("APPLICATION" /* APPLICATION */, "Output Channel opened - logs are now visible");
  } catch (error) {
    vscode12.window.showErrorMessage(`Failed to show logs: ${error}`);
  }
}
async function triageBrokenFeature() {
  try {
    const featureName = await vscode12.window.showInputBox({
      prompt: 'What feature is broken? (e.g., "sign-in button", "query sync", "timer")',
      placeHolder: "Enter feature name..."
    });
    if (!featureName) return;
    const sessionId = traceLogger.startNewSession(`Triage: ${featureName}`);
    showFSMLogsNow();
    componentLogger.info(
      "MACHINE" /* MACHINE */,
      `\u{1F50D} FEATURE TRIAGE STARTED: ${featureName}`,
      {
        component: "MACHINE" /* MACHINE */,
        event: "TRIAGE_START"
      },
      {
        feature: featureName,
        sessionId,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }
    );
    const panel2 = vscode12.window.createWebviewPanel(
      "featureTriage",
      `\u{1F50D} Triaging: ${featureName}`,
      vscode12.ViewColumn.Beside,
      { enableScripts: false }
    );
    panel2.webview.html = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <style>
          body { 
            font-family: var(--vscode-font-family); 
            color: var(--vscode-foreground);
            background: var(--vscode-editor-background);
            padding: 20px;
            line-height: 1.6;
          }
          .step {
            background: var(--vscode-textCodeBlock-background);
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 3px solid var(--vscode-charts-blue);
          }
          .highlight {
            background: var(--vscode-editor-selectionBackground);
            padding: 2px 4px;
            border-radius: 3px;
          }
        </style>
      </head>
      <body>
        <h1>\u{1F50D} Feature Triage: ${featureName}</h1>
        <p><strong>Debug session started:</strong> ${sessionId}</p>
        
        <h2>\u{1F4CB} Triage Steps</h2>
        
        <div class="step">
          <h3>1. Reproduce the Issue</h3>
          <p>Try to use the <span class="highlight">${featureName}</span> feature now.</p>
          <p>The Output Channel is open and logging all activity.</p>
        </div>
        
        <div class="step">
          <h3>2. Watch for Errors</h3>
          <p>Look for <code>\u{1F534}</code> error messages in the Output Channel.</p>
          <p>Also check the Developer Console (Help > Toggle Developer Tools).</p>
        </div>
        
        <div class="step">
          <h3>3. Capture the Trace</h3>
          <p>After reproducing the issue, run:</p>
          <p><code>Azure DevOps Int (Debug): Export Trace</code></p>
        </div>
        
        <div class="step">
          <h3>4. Analyze Results</h3>
          <p>Run <code>Azure DevOps Int (Debug): Analyze Trace</code> to see patterns.</p>
          <p>Check the timeline with <code>Show Trace Timeline</code>.</p>
        </div>
        
        <h2>\u{1F3AF} What to Look For</h2>
        <ul>
          <li><strong>Missing Events:</strong> Expected events that don't appear</li>
          <li><strong>Error Messages:</strong> Red error logs with stack traces</li>
          <li><strong>State Transitions:</strong> Application getting stuck in wrong states</li>
          <li><strong>Message Flow:</strong> Webview \u2194 Extension communication issues</li>
        </ul>
        
        <p><strong>Pro tip:</strong> This triage session is being traced. Export it when done!</p>
      </body>
      </html>
    `;
    vscode12.window.showInformationMessage(
      `\u{1F50D} Triage started for "${featureName}". Try to reproduce the issue now - everything is being logged!`,
      "OK"
    );
  } catch (error) {
    vscode12.window.showErrorMessage(`Failed to start feature triage: ${error}`);
  }
}
var vscode12;
var init_quickDebugCommands = __esm({
  "src/commands/quickDebugCommands.ts"() {
    "use strict";
    vscode12 = __toESM(require("vscode"), 1);
    init_ComponentLogger();
    init_TraceLogger();
  }
});

// node_modules/@plures/praxis/dist/node/integrations/svelte.js
function createPraxisStore(engine) {
  let currentState = engine.getState();
  const subscribers = /* @__PURE__ */ new Set();
  const notify = () => {
    currentState = engine.getState();
    subscribers.forEach((sub) => sub(currentState));
  };
  return {
    subscribe(run3) {
      subscribers.add(run3);
      run3(currentState);
      return () => {
        subscribers.delete(run3);
      };
    },
    dispatch(events) {
      engine.step(events);
      notify();
    }
  };
}
function createContextStore(engine) {
  let currentContext = engine.getContext();
  const subscribers = /* @__PURE__ */ new Set();
  const notify = () => {
    currentContext = engine.getContext();
    subscribers.forEach((sub) => sub(currentContext));
  };
  return {
    subscribe(run3) {
      subscribers.add(run3);
      run3(currentContext);
      return () => {
        subscribers.delete(run3);
      };
    },
    dispatch(events) {
      engine.step(events);
      notify();
    }
  };
}
function createDerivedStore(engine, selector) {
  let currentValue = selector(engine.getContext());
  const subscribers = /* @__PURE__ */ new Set();
  const notify = () => {
    const newValue = selector(engine.getContext());
    if (newValue !== currentValue) {
      currentValue = newValue;
      subscribers.forEach((sub) => sub(currentValue));
    }
  };
  return {
    subscribe(run3) {
      subscribers.add(run3);
      run3(currentValue);
      return () => {
        subscribers.delete(run3);
      };
    },
    dispatch(events) {
      engine.step(events);
      notify();
    }
  };
}
function createHistoryEngine(engine, options = {}) {
  const history2 = new HistoryStateManager(options.maxHistorySize);
  history2.record(engine.getState(), [], options.initialLabel || "Initial");
  const dispatch = (events, label) => {
    engine.step(events);
    history2.record(engine.getState(), events, label);
  };
  const undo = () => {
    const entry = history2.back();
    if (entry) {
      return true;
    }
    return false;
  };
  const redo = () => {
    const entry = history2.forward();
    if (entry) {
      return true;
    }
    return false;
  };
  return {
    engine,
    dispatch,
    undo,
    redo,
    canUndo: () => history2.canGoBack(),
    canRedo: () => history2.canGoForward(),
    getHistory: () => history2.getHistory(),
    goToHistory: (index2) => history2.goTo(index2) !== null,
    clearHistory: () => history2.clear()
  };
}
var HistoryStateManager;
var init_svelte = __esm({
  "node_modules/@plures/praxis/dist/node/integrations/svelte.js"() {
    init_chunk_LE2ZJYFC();
    init_chunk_VOMLVI6V();
    init_chunk_QGM4M3NI();
    HistoryStateManager = class {
      history = [];
      currentIndex = -1;
      maxSize;
      idCounter = 0;
      constructor(maxSize = 50) {
        this.maxSize = maxSize;
      }
      /**
       * Record a new history entry
       */
      record(state2, events, label) {
        if (this.currentIndex < this.history.length - 1) {
          this.history = this.history.slice(0, this.currentIndex + 1);
        }
        this.history.push({
          id: `history-${++this.idCounter}`,
          timestamp: Date.now(),
          state: state2,
          events,
          label
        });
        if (this.history.length > this.maxSize) {
          this.history.shift();
        } else {
          this.currentIndex++;
        }
      }
      /**
       * Navigate to a specific history entry
       */
      goTo(index2) {
        if (index2 < 0 || index2 >= this.history.length) {
          return null;
        }
        this.currentIndex = index2;
        return this.history[index2];
      }
      /**
       * Go back to previous state
       */
      back() {
        if (!this.canGoBack()) {
          return null;
        }
        return this.goTo(this.currentIndex - 1);
      }
      /**
       * Go forward to next state
       */
      forward() {
        if (!this.canGoForward()) {
          return null;
        }
        return this.goTo(this.currentIndex + 1);
      }
      /**
       * Check if can go back
       */
      canGoBack() {
        return this.currentIndex > 0;
      }
      /**
       * Check if can go forward
       */
      canGoForward() {
        return this.currentIndex < this.history.length - 1;
      }
      /**
       * Get current history entry
       */
      current() {
        if (this.currentIndex < 0 || this.currentIndex >= this.history.length) {
          return null;
        }
        return this.history[this.currentIndex];
      }
      /**
       * Get all history entries
       */
      getHistory() {
        return [...this.history];
      }
      /**
       * Get current index in history
       */
      getCurrentIndex() {
        return this.currentIndex;
      }
      /**
       * Clear all history
       */
      clear() {
        this.history = [];
        this.currentIndex = -1;
      }
    };
  }
});

// src/praxis/application/features/timer.ts
function calculateTimerStatus(entries) {
  let accumulatedDuration = 0;
  let currentStartTimestamp;
  let activeWorkItemId;
  let isRunning = false;
  const sorted = [...entries].sort((a, b) => a.timestamp - b.timestamp);
  for (let i = 0; i < sorted.length; i++) {
    const entry = sorted[i];
    if (entry.type === "start") {
      currentStartTimestamp = entry.timestamp;
      activeWorkItemId = entry.workItemId;
      isRunning = true;
    } else if (entry.type === "pause" || entry.type === "stop") {
      if (currentStartTimestamp !== void 0) {
        accumulatedDuration += entry.timestamp - currentStartTimestamp;
        currentStartTimestamp = void 0;
      }
      isRunning = false;
      if (entry.type === "stop") {
        activeWorkItemId = void 0;
      }
    }
  }
  return {
    isRunning,
    activeWorkItemId,
    currentStartTimestamp,
    accumulatedDuration
  };
}
var TimerHistoryFact, StartTimerEvent, PauseTimerEvent, StopTimerEvent, RequestTimerHistoryEvent, TimerHistoryLoadedEvent, PersistTimerHistoryEvent, UpdateTimerStatusEvent, InitializeTimerRule, TimerHistoryLoadedRule, StartTimerRule, PauseTimerRule, StopTimerRule, timerRules;
var init_timer = __esm({
  "src/praxis/application/features/timer.ts"() {
    "use strict";
    init_node();
    init_facts2();
    TimerHistoryFact = defineFact(
      "TimerHistory"
    );
    StartTimerEvent = defineEvent(
      "StartTimer"
    );
    PauseTimerEvent = defineEvent(
      "PauseTimer"
    );
    StopTimerEvent = defineEvent(
      "StopTimer"
    );
    RequestTimerHistoryEvent = defineEvent(
      "RequestTimerHistory"
    );
    TimerHistoryLoadedEvent = defineEvent(
      "TimerHistoryLoaded"
    );
    PersistTimerHistoryEvent = defineEvent("PersistTimerHistory");
    UpdateTimerStatusEvent = defineEvent(
      "UpdateTimerStatus"
    );
    InitializeTimerRule = defineRule({
      id: "timer.initialize",
      description: "Request timer history on activation",
      meta: {
        triggers: ["ACTIVATE"]
      },
      impl: (_state, events) => {
        if (findEvent(events, ActivateEvent)) {
          return [RequestTimerHistoryEvent.create()];
        }
        return [];
      }
    });
    TimerHistoryLoadedRule = defineRule({
      id: "timer.loaded",
      description: "Update state with loaded history",
      meta: {
        triggers: ["TimerHistoryLoaded"]
      },
      impl: (state2, events) => {
        const event2 = findEvent(events, TimerHistoryLoadedEvent);
        if (!event2) return [];
        state2.context.timerHistory.entries = event2.payload.entries;
        const status = calculateTimerStatus(state2.context.timerHistory.entries);
        return [UpdateTimerStatusEvent.create(status)];
      }
    });
    StartTimerRule = defineRule({
      id: "timer.start",
      description: "Start the timer for a work item",
      meta: {
        triggers: ["StartTimer"]
      },
      impl: (state2, events) => {
        const event2 = findEvent(events, StartTimerEvent);
        if (!event2) return [];
        const { workItemId, timestamp: timestamp2 } = event2.payload;
        const workItemExists = state2.context.workItems.some((wi) => wi.id === workItemId);
        if (!workItemExists) {
          return [];
        }
        const history2 = state2.context.timerHistory.entries;
        const lastEntry = history2[history2.length - 1];
        if (lastEntry && lastEntry.type === "start") {
          return [];
        }
        const newEntry = {
          type: "start",
          timestamp: timestamp2,
          workItemId
        };
        state2.context.timerHistory.entries.push(newEntry);
        const status = calculateTimerStatus(state2.context.timerHistory.entries);
        return [
          PersistTimerHistoryEvent.create({ entries: state2.context.timerHistory.entries }),
          UpdateTimerStatusEvent.create(status)
        ];
      }
    });
    PauseTimerRule = defineRule({
      id: "timer.pause",
      description: "Pause the timer",
      meta: {
        triggers: ["PauseTimer"]
      },
      impl: (state2, events) => {
        const event2 = findEvent(events, PauseTimerEvent);
        if (!event2) return [];
        const { workItemId, timestamp: timestamp2 } = event2.payload;
        const history2 = state2.context.timerHistory.entries;
        const lastEntry = history2[history2.length - 1];
        if (!lastEntry || lastEntry.type !== "start") {
          return [];
        }
        const newEntry = {
          type: "pause",
          timestamp: timestamp2,
          workItemId
        };
        state2.context.timerHistory.entries.push(newEntry);
        const status = calculateTimerStatus(state2.context.timerHistory.entries);
        return [
          PersistTimerHistoryEvent.create({ entries: state2.context.timerHistory.entries }),
          UpdateTimerStatusEvent.create(status)
        ];
      }
    });
    StopTimerRule = defineRule({
      id: "timer.stop",
      description: "Stop the timer",
      meta: {
        triggers: ["StopTimer"]
      },
      impl: (state2, events) => {
        const event2 = findEvent(events, StopTimerEvent);
        if (!event2) return [];
        const { workItemId, timestamp: timestamp2 } = event2.payload;
        const history2 = state2.context.timerHistory.entries;
        const lastEntry = history2[history2.length - 1];
        if (!lastEntry || lastEntry.type === "stop") {
          return [];
        }
        const newEntry = {
          type: "stop",
          timestamp: timestamp2,
          workItemId
        };
        state2.context.timerHistory.entries.push(newEntry);
        const status = calculateTimerStatus(state2.context.timerHistory.entries);
        return [
          PersistTimerHistoryEvent.create({ entries: state2.context.timerHistory.entries }),
          UpdateTimerStatusEvent.create(status)
        ];
      }
    });
    timerRules = [
      InitializeTimerRule,
      TimerHistoryLoadedRule,
      StartTimerRule,
      PauseTimerRule,
      StopTimerRule
    ];
  }
});

// src/praxis/application/facts.ts
var ApplicationStateFact, IsActivatedFact, IsDeactivatingFact, ConnectionsFact, ActiveConnectionIdFact, ActiveQueryFact, ViewModeFact, PendingWorkItemsFact, DeviceCodeSessionFact, AuthCodeFlowSessionFact, ErrorRecoveryAttemptsFact, LastErrorFact, DebugLoggingEnabledFact, DebugViewVisibleFact, ActivateEvent, ActivationCompleteEvent, ActivationFailedEvent, DeactivateEvent, DeactivationCompleteEvent, ConnectionsLoadedEvent, ConnectionSelectedEvent, SelectConnectionEvent, QueryChangedEvent, ViewModeChangedEvent, WorkItemsLoadedEvent, WorkItemsErrorEvent, RefreshDataEvent, ConnectionStateUpdatedEvent, DeviceCodeStartedAppEvent, DeviceCodeCompletedAppEvent, DeviceCodeCancelledEvent, SyncStateEvent, ApplicationErrorEvent, DeviceCodeCopyFailedEvent, DeviceCodeBrowserOpenFailedEvent, DeviceCodeSessionNotFoundEvent, AuthCodeFlowBrowserOpenFailedEvent, AuthCodeFlowBrowserOpenedEvent, DeviceCodeBrowserOpenedEvent, RetryApplicationEvent, ResetApplicationEvent, ToggleDebugViewEvent, OpenSettingsEvent, AuthReminderRequestedEvent, AuthReminderClearedEvent, SignInEntraEvent, AuthCodeFlowStartedAppEvent, AuthCodeFlowCompletedAppEvent, AuthRedirectReceivedAppEvent, SignOutEntraEvent, AuthenticationSuccessEvent, AuthenticationFailedEvent, CreateWorkItemEvent, CreateBranchEvent, CreatePullRequestEvent, ShowPullRequestsEvent, ShowBuildStatusEvent, SelectTeamEvent, ResetPreferredRepositoriesEvent, SelfTestWebviewEvent, BulkAssignEvent, GenerateCopilotPromptEvent, ShowTimeReportEvent, WebviewReadyEvent;
var init_facts2 = __esm({
  "src/praxis/application/facts.ts"() {
    "use strict";
    init_node();
    init_timer();
    ApplicationStateFact = defineFact("ApplicationState");
    IsActivatedFact = defineFact("IsActivated");
    IsDeactivatingFact = defineFact("IsDeactivating");
    ConnectionsFact = defineFact("Connections");
    ActiveConnectionIdFact = defineFact(
      "ActiveConnectionId"
    );
    ActiveQueryFact = defineFact("ActiveQuery");
    ViewModeFact = defineFact("ViewMode");
    PendingWorkItemsFact = defineFact(
      "PendingWorkItems"
    );
    DeviceCodeSessionFact = defineFact(
      "DeviceCodeSession"
    );
    AuthCodeFlowSessionFact = defineFact(
      "AuthCodeFlowSession"
    );
    ErrorRecoveryAttemptsFact = defineFact(
      "ErrorRecoveryAttempts"
    );
    LastErrorFact = defineFact("LastError");
    DebugLoggingEnabledFact = defineFact(
      "DebugLoggingEnabled"
    );
    DebugViewVisibleFact = defineFact("DebugViewVisible");
    ActivateEvent = defineEvent("ACTIVATE");
    ActivationCompleteEvent = defineEvent(
      "ACTIVATION_COMPLETE"
    );
    ActivationFailedEvent = defineEvent(
      "APP_ACTIVATION_FAILED"
    );
    DeactivateEvent = defineEvent("DEACTIVATE");
    DeactivationCompleteEvent = defineEvent("DEACTIVATION_COMPLETE");
    ConnectionsLoadedEvent = defineEvent("CONNECTIONS_LOADED");
    ConnectionSelectedEvent = defineEvent(
      "CONNECTION_SELECTED"
    );
    SelectConnectionEvent = defineEvent(
      "SELECT_CONNECTION"
    );
    QueryChangedEvent = defineEvent("QUERY_CHANGED");
    ViewModeChangedEvent = defineEvent(
      "VIEW_MODE_CHANGED"
    );
    WorkItemsLoadedEvent = defineEvent("WORK_ITEMS_LOADED");
    WorkItemsErrorEvent = defineEvent("WORK_ITEMS_ERROR");
    RefreshDataEvent = defineEvent(
      "REFRESH_DATA"
    );
    ConnectionStateUpdatedEvent = defineEvent("CONNECTION_STATE_UPDATED");
    DeviceCodeStartedAppEvent = defineEvent("DEVICE_CODE_STARTED");
    DeviceCodeCompletedAppEvent = defineEvent("DEVICE_CODE_COMPLETED");
    DeviceCodeCancelledEvent = defineEvent("DEVICE_CODE_CANCELLED");
    SyncStateEvent = defineEvent("SyncState");
    ApplicationErrorEvent = defineEvent("APPLICATION_ERROR");
    DeviceCodeCopyFailedEvent = defineEvent("DEVICE_CODE_COPY_FAILED");
    DeviceCodeBrowserOpenFailedEvent = defineEvent("DEVICE_CODE_BROWSER_OPEN_FAILED");
    DeviceCodeSessionNotFoundEvent = defineEvent("DEVICE_CODE_SESSION_NOT_FOUND");
    AuthCodeFlowBrowserOpenFailedEvent = defineEvent("AUTH_CODE_FLOW_BROWSER_OPEN_FAILED");
    AuthCodeFlowBrowserOpenedEvent = defineEvent("AUTH_CODE_FLOW_BROWSER_OPENED");
    DeviceCodeBrowserOpenedEvent = defineEvent("DEVICE_CODE_BROWSER_OPENED");
    RetryApplicationEvent = defineEvent("RETRY");
    ResetApplicationEvent = defineEvent("RESET");
    ToggleDebugViewEvent = defineEvent("TOGGLE_DEBUG_VIEW");
    OpenSettingsEvent = defineEvent(
      "OPEN_SETTINGS"
    );
    AuthReminderRequestedEvent = defineEvent("AUTH_REMINDER_REQUESTED");
    AuthReminderClearedEvent = defineEvent("AUTH_REMINDER_CLEARED");
    SignInEntraEvent = defineEvent("SIGN_IN_ENTRA");
    AuthCodeFlowStartedAppEvent = defineEvent("AUTH_CODE_FLOW_STARTED");
    AuthCodeFlowCompletedAppEvent = defineEvent("AUTH_CODE_FLOW_COMPLETED");
    AuthRedirectReceivedAppEvent = defineEvent("AUTH_REDIRECT_RECEIVED");
    SignOutEntraEvent = defineEvent(
      "SIGN_OUT_ENTRA"
    );
    AuthenticationSuccessEvent = defineEvent("AUTHENTICATION_SUCCESS");
    AuthenticationFailedEvent = defineEvent("AUTHENTICATION_FAILED");
    CreateWorkItemEvent = defineEvent(
      "CREATE_WORK_ITEM"
    );
    CreateBranchEvent = defineEvent("CREATE_BRANCH");
    CreatePullRequestEvent = defineEvent("CREATE_PULL_REQUEST");
    ShowPullRequestsEvent = defineEvent(
      "SHOW_PULL_REQUESTS"
    );
    ShowBuildStatusEvent = defineEvent(
      "SHOW_BUILD_STATUS"
    );
    SelectTeamEvent = defineEvent("SELECT_TEAM");
    ResetPreferredRepositoriesEvent = defineEvent("RESET_PREFERRED_REPOSITORIES");
    SelfTestWebviewEvent = defineEvent(
      "SELF_TEST_WEBVIEW"
    );
    BulkAssignEvent = defineEvent("BULK_ASSIGN");
    GenerateCopilotPromptEvent = defineEvent("GENERATE_COPILOT_PROMPT");
    ShowTimeReportEvent = defineEvent(
      "SHOW_TIME_REPORT"
    );
    WebviewReadyEvent = defineEvent(
      "WEBVIEW_READY"
    );
  }
});

// src/praxis/application/rules/lifecycleRules.ts
var activateRule, activationCompleteRule, activationFailedRule, deactivateRule, deactivationCompleteRule, lifecycleRules;
var init_lifecycleRules = __esm({
  "src/praxis/application/rules/lifecycleRules.ts"() {
    "use strict";
    init_node();
    init_facts2();
    activateRule = defineRule({
      id: "application.activate",
      description: "Activate the application",
      meta: {
        triggers: ["ACTIVATE"],
        transition: { from: "inactive", to: "activating" }
      },
      impl: (state2, events) => {
        const activateEvent = findEvent(events, ActivateEvent);
        if (!activateEvent) return [];
        if (state2.context.applicationState !== "inactive") return [];
        state2.context.applicationState = "activating";
        state2.context.isActivated = false;
        state2.context.isDeactivating = false;
        state2.context.errorRecoveryAttempts = 0;
        state2.context.lastError = void 0;
        return [];
      }
    });
    activationCompleteRule = defineRule({
      id: "application.activationComplete",
      description: "Complete application activation",
      meta: {
        triggers: ["ACTIVATION_COMPLETE"],
        transition: { from: "activating", to: "active" }
      },
      impl: (state2, events) => {
        const completeEvent = findEvent(events, ActivationCompleteEvent);
        if (!completeEvent) return [];
        if (state2.context.applicationState !== "activating") return [];
        state2.context.applicationState = "active";
        state2.context.isActivated = true;
        return [];
      }
    });
    activationFailedRule = defineRule({
      id: "application.activationFailed",
      description: "Handle activation failure",
      meta: {
        triggers: ["APP_ACTIVATION_FAILED"],
        transition: { from: "activating", to: "activation_error" }
      },
      impl: (state2, events) => {
        const failedEvent = findEvent(events, ActivationFailedEvent);
        if (!failedEvent) return [];
        if (state2.context.applicationState !== "activating") return [];
        state2.context.applicationState = "activation_error";
        state2.context.lastError = { message: failedEvent.payload.error };
        state2.context.errorRecoveryAttempts++;
        return [];
      }
    });
    deactivateRule = defineRule({
      id: "application.deactivate",
      description: "Deactivate the application",
      meta: {
        triggers: ["DEACTIVATE"],
        transition: { from: ["inactive", "active", "activation_error"], to: "deactivating" }
      },
      impl: (state2, events) => {
        const deactivateEvent = findEvent(events, DeactivateEvent);
        if (!deactivateEvent) return [];
        if (state2.context.applicationState === "inactive") return [];
        if (state2.context.applicationState === "deactivating") return [];
        state2.context.applicationState = "deactivating";
        state2.context.isDeactivating = true;
        return [];
      }
    });
    deactivationCompleteRule = defineRule({
      id: "application.deactivationComplete",
      description: "Complete application deactivation",
      meta: {
        triggers: ["DEACTIVATION_COMPLETE"],
        transition: { from: "deactivating", to: "inactive" }
      },
      impl: (state2, events) => {
        const completeEvent = findEvent(events, DeactivationCompleteEvent);
        if (!completeEvent) return [];
        if (state2.context.applicationState !== "deactivating") return [];
        state2.context.applicationState = "inactive";
        state2.context.isActivated = false;
        state2.context.isDeactivating = false;
        return [];
      }
    });
    lifecycleRules = [
      activateRule,
      activationCompleteRule,
      activationFailedRule,
      deactivateRule,
      deactivationCompleteRule
    ];
  }
});

// src/praxis/application/rules/connectionRules.ts
var connectionsLoadedRule, connectionSelectedRule, queryChangedRule, viewModeChangedRule, authenticationFailedRule, connectionStateUpdatedRule, connectionRules;
var init_connectionRules = __esm({
  "src/praxis/application/rules/connectionRules.ts"() {
    "use strict";
    init_node();
    init_facts2();
    connectionsLoadedRule = defineRule({
      id: "application.connectionsLoaded",
      description: "Handle connections loaded",
      meta: {
        triggers: ["CONNECTIONS_LOADED"]
      },
      impl: (state2, events) => {
        const loadedEvent = findEvent(events, ConnectionsLoadedEvent);
        if (!loadedEvent) return [];
        state2.context.connections = loadedEvent.payload.connections;
        state2.context.connectionStates = new Map(state2.context.connectionStates);
        for (const connection of loadedEvent.payload.connections) {
          if (!state2.context.connectionStates.has(connection.id)) {
            state2.context.connectionStates.set(connection.id, {
              state: "disconnected",
              connectionId: connection.id,
              isConnected: false,
              authMethod: connection.authMethod || "pat",
              hasClient: false,
              hasProvider: false,
              retryCount: 0,
              error: void 0
            });
          }
        }
        if (!state2.context.activeConnectionId && state2.context.connections.length > 0) {
          state2.context.activeConnectionId = state2.context.connections[0].id;
        }
        return [];
      }
    });
    connectionSelectedRule = defineRule({
      id: "application.connectionSelected",
      description: "Handle connection selection",
      meta: {
        triggers: ["CONNECTION_SELECTED", "SELECT_CONNECTION"]
      },
      impl: (state2, events) => {
        const selectedEvent = findEvent(events, ConnectionSelectedEvent) || findEvent(events, SelectConnectionEvent);
        if (!selectedEvent) return [];
        const connectionId = selectedEvent.payload.connectionId;
        const connectionExists = state2.context.connections.some((c) => c.id === connectionId);
        if (!connectionExists) return [];
        state2.context.activeConnectionId = connectionId;
        const savedQuery = state2.context.connectionQueries.get(connectionId);
        if (savedQuery) {
          state2.context.activeQuery = savedQuery;
        }
        return [];
      }
    });
    queryChangedRule = defineRule({
      id: "application.queryChanged",
      description: "Handle query change",
      meta: {
        triggers: ["QUERY_CHANGED"]
      },
      impl: (state2, events) => {
        const queryEvent = findEvent(events, QueryChangedEvent);
        if (!queryEvent) return [];
        const { query, connectionId } = queryEvent.payload;
        const targetConnectionId = connectionId || state2.context.activeConnectionId;
        state2.context.activeQuery = query;
        if (targetConnectionId) {
          const existingQuery = state2.context.connectionQueries.get(targetConnectionId);
          if (existingQuery !== query) {
            state2.context.connectionQueries = new Map(state2.context.connectionQueries);
            state2.context.connectionQueries.set(targetConnectionId, query);
          }
        }
        return [];
      }
    });
    viewModeChangedRule = defineRule({
      id: "application.viewModeChanged",
      description: "Handle view mode change",
      meta: {
        triggers: ["VIEW_MODE_CHANGED"],
        transition: { from: "active", to: "active" }
      },
      impl: (state2, events) => {
        const modeEvent = findEvent(events, ViewModeChangedEvent);
        if (!modeEvent) return [];
        state2.context.viewMode = modeEvent.payload.viewMode;
        if (state2.context.activeConnectionId) {
          const existingMode = state2.context.connectionViewModes.get(state2.context.activeConnectionId);
          if (existingMode !== modeEvent.payload.viewMode) {
            state2.context.connectionViewModes = new Map(state2.context.connectionViewModes);
            state2.context.connectionViewModes.set(
              state2.context.activeConnectionId,
              modeEvent.payload.viewMode
            );
          }
        }
        return [];
      }
    });
    authenticationFailedRule = defineRule({
      id: "application.authenticationFailed",
      description: "Handle authentication failure",
      meta: {
        triggers: ["AUTHENTICATION_FAILED"]
      },
      impl: (state2, events) => {
        const failedEvent = findEvent(events, AuthenticationFailedEvent);
        if (!failedEvent) return [];
        const { connectionId, error } = failedEvent.payload;
        state2.context.lastError = {
          message: error,
          connectionId
        };
        const existingReminder = state2.context.pendingAuthReminders.get(connectionId);
        const newReminder = {
          connectionId,
          reason: error,
          status: "pending"
        };
        if (!existingReminder || existingReminder.reason !== newReminder.reason || existingReminder.status !== newReminder.status) {
          state2.context.pendingAuthReminders = new Map(state2.context.pendingAuthReminders);
          state2.context.pendingAuthReminders.set(connectionId, newReminder);
        }
        const existingState = state2.context.connectionStates.get(connectionId);
        if (existingState) {
          const updatedState = {
            ...existingState,
            state: "auth_failed",
            error,
            isConnected: false
          };
          if (existingState.state !== updatedState.state || existingState.error !== updatedState.error || existingState.isConnected !== updatedState.isConnected) {
            state2.context.connectionStates = new Map(state2.context.connectionStates);
            state2.context.connectionStates.set(connectionId, updatedState);
          }
        } else {
          const connection = state2.context.connections.find((c) => c.id === connectionId);
          if (connection) {
            state2.context.connectionStates = new Map(state2.context.connectionStates);
            state2.context.connectionStates.set(connectionId, {
              state: "auth_failed",
              connectionId,
              isConnected: false,
              authMethod: connection.authMethod || "pat",
              hasClient: false,
              hasProvider: false,
              error,
              retryCount: 0
            });
          }
        }
        return [];
      }
    });
    connectionStateUpdatedRule = defineRule({
      id: "application.connectionStateUpdated",
      description: "Update connection state from external source",
      meta: {
        triggers: ["CONNECTION_STATE_UPDATED"]
      },
      impl: (state2, events) => {
        const event2 = findEvent(events, ConnectionStateUpdatedEvent);
        if (!event2) return [];
        const { connectionId, state: connState } = event2.payload;
        const status = connState.status || "disconnected";
        const isConnected = status === "connected";
        const praxisState = isConnected ? "connected" : "disconnected";
        const snapshot2 = {
          state: praxisState,
          connectionId,
          isConnected,
          authMethod: connState.authMethod || "pat",
          hasClient: !!connState.client,
          hasProvider: !!connState.provider,
          retryCount: 0,
          error: void 0
        };
        const existingSnapshot = state2.context.connectionStates.get(connectionId);
        if (!existingSnapshot || JSON.stringify(existingSnapshot) !== JSON.stringify(snapshot2)) {
          state2.context.connectionStates = new Map(state2.context.connectionStates);
          state2.context.connectionStates.set(connectionId, snapshot2);
        }
        return [];
      }
    });
    connectionRules = [
      connectionsLoadedRule,
      connectionSelectedRule,
      queryChangedRule,
      viewModeChangedRule,
      connectionStateUpdatedRule,
      authenticationFailedRule
    ];
  }
});

// src/praxis/application/types.ts
var DEFAULT_APPLICATION_CONFIG;
var init_types3 = __esm({
  "src/praxis/application/types.ts"() {
    "use strict";
    DEFAULT_APPLICATION_CONFIG = {
      clock: { now: () => Date.now() },
      isActivated: false,
      isDeactivating: false,
      connections: [],
      connectionStates: /* @__PURE__ */ new Map(),
      connectionQueries: /* @__PURE__ */ new Map(),
      connectionWorkItems: /* @__PURE__ */ new Map(),
      connectionFilters: /* @__PURE__ */ new Map(),
      connectionViewModes: /* @__PURE__ */ new Map(),
      pendingAuthReminders: /* @__PURE__ */ new Map(),
      viewMode: "list",
      kanbanColumns: [],
      errorRecoveryAttempts: 0,
      debugLoggingEnabled: false,
      debugViewVisible: false,
      debugTraceLog: [],
      ui: {
        notification: null,
        dialog: null
      }
    };
  }
});

// src/praxis/application/tracing.ts
function wrapRuleWithTracing(rule, traceRecorder) {
  if (!traceRecorder) {
    return rule;
  }
  return {
    ...rule,
    when: rule.when ? (context, event2) => {
      const result = rule.when(context, event2);
      if (result) {
        traceRecorder.record({
          machineId: "application",
          actorId: "application",
          component: "APPLICATION",
          event: { type: event2?.type || "unknown", payload: event2 },
          eventType: event2?.type || "unknown",
          fromState: context?.applicationState || "unknown",
          toState: context?.applicationState || "unknown",
          contextBefore: context,
          contextAfter: context
        });
      }
      return result;
    } : void 0,
    then: rule.then ? (context, event2) => {
      const beforeState = context?.applicationState || "unknown";
      const result = rule.then(context, event2);
      const afterState = result?.applicationState || beforeState;
      traceRecorder.record({
        machineId: "application",
        actorId: "application",
        component: "APPLICATION",
        event: { type: event2?.type || "unknown", payload: event2 },
        eventType: event2?.type || "unknown",
        fromState: beforeState,
        toState: afterState,
        contextBefore: context,
        contextAfter: result
      });
      return result;
    } : void 0
  };
}
var TraceRecorder;
var init_tracing2 = __esm({
  "src/praxis/application/tracing.ts"() {
    "use strict";
    init_TraceLogger();
    TraceRecorder = class {
      entries = [];
      isRecording = false;
      constructor() {
        this.isRecording = true;
      }
      /**
       * Record a trace entry
       */
      record(entry) {
        if (!this.isRecording) {
          return;
        }
        const fullEntry = {
          ...entry,
          id: `trace_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          timestamp: Date.now(),
          sessionId: traceLogger.getCurrentSessionId() || "unknown"
        };
        this.entries.push(fullEntry);
        traceLogger.recordTrace(fullEntry);
      }
      /**
       * Get all recorded entries
       */
      getEntries() {
        return [...this.entries];
      }
      /**
       * Clear all recorded entries
       */
      clear() {
        this.entries = [];
      }
      /**
       * Start recording
       */
      start() {
        this.isRecording = true;
      }
      /**
       * Stop recording
       */
      stop() {
        this.isRecording = false;
      }
      /**
       * Check if recording is active
       */
      isActive() {
        return this.isRecording;
      }
    };
  }
});

// src/praxis/application/engine.ts
function getClock(_state) {
  return defaultClock;
}
function createInitialContext(config) {
  const merged = { ...DEFAULT_APPLICATION_CONFIG, ...config };
  const maps = _createConnectionMaps(merged);
  return {
    applicationState: "inactive",
    applicationData: merged,
    // Timer Feature
    timerHistory: { entries: [] },
    // Shortcut properties
    isActivated: merged.isActivated ?? false,
    isDeactivating: merged.isDeactivating ?? false,
    connections: merged.connections ?? [],
    activeConnectionId: merged.activeConnectionId,
    activeQuery: merged.activeQuery,
    viewMode: merged.viewMode ?? "list",
    pendingWorkItems: merged.pendingWorkItems,
    deviceCodeSession: merged.deviceCodeSession,
    lastError: merged.lastError,
    errorRecoveryAttempts: merged.errorRecoveryAttempts ?? 0,
    debugLoggingEnabled: merged.debugLoggingEnabled ?? false,
    debugViewVisible: merged.debugViewVisible ?? false,
    // Per-connection maps
    ...maps,
    // Auth reminders
    pendingAuthReminders: merged.pendingAuthReminders ?? /* @__PURE__ */ new Map(),
    // Timer snapshot
    timerSnapshot: void 0,
    // Kanban columns
    kanbanColumns: merged.kanbanColumns ?? []
  };
}
function _createConnectionMaps(merged) {
  return {
    connectionStates: merged.connectionStates ?? /* @__PURE__ */ new Map(),
    connectionQueries: merged.connectionQueries ?? /* @__PURE__ */ new Map(),
    connectionWorkItems: merged.connectionWorkItems ?? /* @__PURE__ */ new Map(),
    connectionFilters: merged.connectionFilters ?? /* @__PURE__ */ new Map(),
    connectionViewModes: merged.connectionViewModes ?? /* @__PURE__ */ new Map()
  };
}
function createApplicationEngine(config, traceRecorder) {
  const registry2 = new PraxisRegistry();
  const rules = traceRecorder ? applicationRules.map((rule) => wrapRuleWithTracing(rule, traceRecorder)) : applicationRules;
  for (const rule of rules) {
    registry2.registerRule(rule);
  }
  return createPraxisEngine({
    initialContext: createInitialContext(config),
    registry: registry2,
    initialFacts: []
  });
}
var defaultClock;
var init_engine2 = __esm({
  "src/praxis/application/engine.ts"() {
    "use strict";
    init_node();
    init_types3();
    init_rules2();
    init_tracing2();
    defaultClock = { now: () => Date.now() };
  }
});

// src/praxis/application/rules/workItemRules.ts
var workItemsLoadedRule, workItemsErrorRule, workItemRules;
var init_workItemRules = __esm({
  "src/praxis/application/rules/workItemRules.ts"() {
    "use strict";
    init_node();
    init_engine2();
    init_facts2();
    workItemsLoadedRule = defineRule({
      id: "application.workItemsLoaded",
      description: "Handle work items loaded",
      meta: {
        triggers: ["WORK_ITEMS_LOADED"]
      },
      impl: (state2, events) => {
        const loadedEvent = findEvent(events, WorkItemsLoadedEvent);
        if (!loadedEvent) return [];
        const { workItems, connectionId, query } = loadedEvent.payload;
        state2.context.pendingWorkItems = {
          workItems,
          connectionId,
          query,
          timestamp: getClock(state2).now()
        };
        const existingWorkItems = state2.context.connectionWorkItems.get(connectionId);
        if (existingWorkItems !== workItems) {
          state2.context.connectionWorkItems = new Map(state2.context.connectionWorkItems);
          state2.context.connectionWorkItems.set(connectionId, workItems);
        }
        if (state2.context.lastError?.connectionId === connectionId) {
          state2.context.lastError = void 0;
        }
        return [];
      }
    });
    workItemsErrorRule = defineRule({
      id: "application.workItemsError",
      description: "Handle work items error",
      meta: {
        triggers: ["WORK_ITEMS_ERROR"]
      },
      impl: (state2, events) => {
        const errorEvent = findEvent(events, WorkItemsErrorEvent);
        if (!errorEvent) return [];
        const { error, connectionId } = errorEvent.payload;
        state2.context.lastError = {
          message: error,
          connectionId
        };
        return [];
      }
    });
    workItemRules = [workItemsLoadedRule, workItemsErrorRule];
  }
});

// src/praxis/application/rules/miscRules.ts
var deviceCodeStartedRule, deviceCodeCompletedRule, deviceCodeCancelledRule, authCodeFlowStartedRule, authCodeFlowCompletedRule, applicationErrorRule, retryRule, resetRule, toggleDebugViewRule, authReminderRequestedRule, authReminderClearedRule, authenticationSuccessRule, miscRules;
var init_miscRules = __esm({
  "src/praxis/application/rules/miscRules.ts"() {
    "use strict";
    init_node();
    init_engine2();
    init_facts2();
    deviceCodeStartedRule = defineRule({
      id: "application.deviceCodeStarted",
      description: "Handle device code flow started",
      meta: {
        triggers: ["DEVICE_CODE_STARTED"]
      },
      impl: (state2, events) => {
        const startedEvent = findEvent(events, DeviceCodeStartedAppEvent);
        if (!startedEvent) return [];
        const { connectionId, userCode, verificationUri, expiresInSeconds } = startedEvent.payload;
        const now = getClock(state2).now();
        state2.context.deviceCodeSession = {
          connectionId,
          userCode,
          verificationUri,
          startedAt: now,
          expiresAt: now + expiresInSeconds * 1e3,
          expiresInSeconds
        };
        return [];
      }
    });
    deviceCodeCompletedRule = defineRule({
      id: "application.deviceCodeCompleted",
      description: "Handle device code flow completed",
      meta: {
        triggers: ["DEVICE_CODE_COMPLETED"]
      },
      impl: (state2, events) => {
        const completedEvent = findEvent(events, DeviceCodeCompletedAppEvent);
        if (!completedEvent) return [];
        if (state2.context.deviceCodeSession?.connectionId === completedEvent.payload.connectionId) {
          state2.context.deviceCodeSession = void 0;
        }
        return [];
      }
    });
    deviceCodeCancelledRule = defineRule({
      id: "application.deviceCodeCancelled",
      description: "Handle device code flow cancelled",
      meta: {
        triggers: ["DEVICE_CODE_CANCELLED"]
      },
      impl: (state2, events) => {
        const cancelledEvent = findEvent(events, DeviceCodeCancelledEvent);
        if (!cancelledEvent) return [];
        if (state2.context.deviceCodeSession?.connectionId === cancelledEvent.payload.connectionId) {
          state2.context.deviceCodeSession = void 0;
        }
        return [];
      }
    });
    authCodeFlowStartedRule = defineRule({
      id: "application.authCodeFlowStarted",
      description: "Handle authorization code flow with PKCE started",
      meta: {
        triggers: ["AUTH_CODE_FLOW_STARTED"]
      },
      impl: (state2, events) => {
        const startedEvent = findEvent(events, AuthCodeFlowStartedAppEvent);
        if (!startedEvent) return [];
        const { connectionId, authorizationUrl, expiresInSeconds } = startedEvent.payload;
        const now = getClock(state2).now();
        state2.context.authCodeFlowSession = {
          connectionId,
          authorizationUrl,
          startedAt: now,
          expiresAt: now + expiresInSeconds * 1e3,
          expiresInSeconds
        };
        return [];
      }
    });
    authCodeFlowCompletedRule = defineRule({
      id: "application.authCodeFlowCompleted",
      description: "Handle authorization code flow with PKCE completed",
      meta: {
        triggers: ["AUTH_CODE_FLOW_COMPLETED"]
      },
      impl: (state2, events) => {
        const completedEvent = findEvent(events, AuthCodeFlowCompletedAppEvent);
        if (!completedEvent) return [];
        if (state2.context.authCodeFlowSession?.connectionId === completedEvent.payload.connectionId) {
          state2.context.authCodeFlowSession = void 0;
        }
        return [];
      }
    });
    applicationErrorRule = defineRule({
      id: "application.error",
      description: "Handle application error",
      meta: {
        triggers: ["APPLICATION_ERROR"]
      },
      impl: (state2, events) => {
        const errorEvent = findEvent(events, ApplicationErrorEvent);
        if (!errorEvent) return [];
        state2.context.lastError = {
          message: errorEvent.payload.error,
          connectionId: errorEvent.payload.connectionId
        };
        return [];
      }
    });
    retryRule = defineRule({
      id: "application.retry",
      description: "Retry after error",
      meta: {
        triggers: ["RETRY"],
        transition: { from: ["error_recovery", "activation_error"], to: "active" }
      },
      impl: (state2, events) => {
        const retryEvent = findEvent(events, RetryApplicationEvent);
        if (!retryEvent) return [];
        if (state2.context.applicationState !== "error_recovery" && state2.context.applicationState !== "activation_error") return [];
        state2.context.lastError = void 0;
        state2.context.applicationState = "active";
        return [];
      }
    });
    resetRule = defineRule({
      id: "application.reset",
      description: "Reset application state",
      meta: {
        triggers: ["RESET"],
        transition: { from: "*", to: "inactive" }
      },
      impl: (state2, events) => {
        const resetEvent = findEvent(events, ResetApplicationEvent);
        if (!resetEvent) return [];
        state2.context.applicationState = "inactive";
        state2.context.isActivated = false;
        state2.context.isDeactivating = false;
        state2.context.lastError = void 0;
        state2.context.errorRecoveryAttempts = 0;
        state2.context.deviceCodeSession = void 0;
        state2.context.authCodeFlowSession = void 0;
        state2.context.pendingWorkItems = void 0;
        return [];
      }
    });
    toggleDebugViewRule = defineRule({
      id: "application.toggleDebugView",
      description: "Toggle debug view visibility",
      meta: {
        triggers: ["TOGGLE_DEBUG_VIEW"]
      },
      impl: (state2, events) => {
        const toggleEvent = findEvent(events, ToggleDebugViewEvent);
        if (!toggleEvent) return [];
        if (toggleEvent.payload.debugViewVisible !== void 0) {
          state2.context.debugViewVisible = toggleEvent.payload.debugViewVisible;
        } else {
          state2.context.debugViewVisible = !state2.context.debugViewVisible;
        }
        return [];
      }
    });
    authReminderRequestedRule = defineRule({
      id: "application.authReminderRequested",
      description: "Handle authentication reminder request",
      meta: {
        triggers: ["AUTH_REMINDER_REQUESTED"]
      },
      impl: (state2, events) => {
        const reminderEvent = findEvent(events, AuthReminderRequestedEvent);
        if (!reminderEvent) return [];
        const { connectionId, reason, detail } = reminderEvent.payload;
        const existing = state2.context.pendingAuthReminders.get(connectionId);
        const newValue = {
          connectionId,
          reason: detail || reason,
          status: "pending"
        };
        if (!existing || existing.reason !== newValue.reason || existing.status !== newValue.status) {
          state2.context.pendingAuthReminders = new Map(state2.context.pendingAuthReminders);
          state2.context.pendingAuthReminders.set(connectionId, newValue);
        }
        return [];
      }
    });
    authReminderClearedRule = defineRule({
      id: "application.authReminderCleared",
      description: "Handle authentication reminder cleared",
      meta: {
        triggers: ["AUTH_REMINDER_CLEARED"]
      },
      impl: (state2, events) => {
        const clearedEvent = findEvent(events, AuthReminderClearedEvent);
        if (!clearedEvent) return [];
        if (state2.context.pendingAuthReminders.has(clearedEvent.payload.connectionId)) {
          state2.context.pendingAuthReminders = new Map(state2.context.pendingAuthReminders);
          state2.context.pendingAuthReminders.delete(clearedEvent.payload.connectionId);
        }
        return [];
      }
    });
    authenticationSuccessRule = defineRule({
      id: "application.authenticationSuccess",
      description: "Handle authentication success",
      meta: {
        triggers: ["AUTHENTICATION_SUCCESS"]
      },
      impl: (state2, events) => {
        const successEvent = findEvent(events, AuthenticationSuccessEvent);
        if (!successEvent) return [];
        const { connectionId } = successEvent.payload;
        if (state2.context.pendingAuthReminders.has(connectionId)) {
          state2.context.pendingAuthReminders = new Map(state2.context.pendingAuthReminders);
          state2.context.pendingAuthReminders.delete(connectionId);
        }
        if (state2.context.deviceCodeSession?.connectionId === connectionId) {
          state2.context.deviceCodeSession = void 0;
        }
        if (state2.context.authCodeFlowSession?.connectionId === connectionId) {
          state2.context.authCodeFlowSession = void 0;
        }
        if (state2.context.lastError?.connectionId === connectionId) {
          state2.context.lastError = void 0;
        }
        return [];
      }
    });
    miscRules = [
      // Device code
      deviceCodeStartedRule,
      deviceCodeCompletedRule,
      deviceCodeCancelledRule,
      // Auth code flow
      authCodeFlowStartedRule,
      authCodeFlowCompletedRule,
      // Error handling
      applicationErrorRule,
      retryRule,
      resetRule,
      // Debug
      toggleDebugViewRule,
      // Auth reminders
      authReminderRequestedRule,
      authReminderClearedRule,
      authenticationSuccessRule
    ];
  }
});

// src/praxis/application/rules/index.ts
var applicationRules;
var init_rules2 = __esm({
  "src/praxis/application/rules/index.ts"() {
    "use strict";
    init_lifecycleRules();
    init_connectionRules();
    init_workItemRules();
    init_miscRules();
    init_lifecycleRules();
    init_connectionRules();
    init_workItemRules();
    init_miscRules();
    init_lifecycleRules();
    init_connectionRules();
    init_workItemRules();
    init_miscRules();
    init_timer();
    applicationRules = [
      ...lifecycleRules,
      ...connectionRules,
      ...workItemRules,
      ...miscRules,
      ...timerRules
    ];
  }
});

// src/webview/praxis/frontendEngine.ts
var initialContext, registry, frontendEngine;
var init_frontendEngine = __esm({
  "src/webview/praxis/frontendEngine.ts"() {
    "use strict";
    init_node();
    init_rules2();
    init_types3();
    initialContext = {
      ...DEFAULT_APPLICATION_CONFIG,
      applicationState: "inactive",
      applicationData: { ...DEFAULT_APPLICATION_CONFIG },
      timerHistory: { entries: [] },
      isActivated: false,
      isDeactivating: false,
      connections: [],
      viewMode: "list",
      errorRecoveryAttempts: 0,
      debugLoggingEnabled: false,
      debugViewVisible: false,
      connectionStates: /* @__PURE__ */ new Map(),
      connectionWorkItems: /* @__PURE__ */ new Map()
    };
    registry = new PraxisRegistry();
    for (const rule of applicationRules) {
      registry.registerRule(rule);
    }
    frontendEngine = createPraxisEngine({
      initialContext,
      registry
    });
  }
});

// src/webview/praxis/store.ts
var historyEngine, rawStore, dispatchWithSync, praxisStore, currentHistoryIndex, initHistory, history;
var init_store2 = __esm({
  "src/webview/praxis/store.ts"() {
    "use strict";
    init_svelte();
    init_frontendEngine();
    historyEngine = createHistoryEngine(frontendEngine, {
      maxHistorySize: 50
      // Keep last 50 state snapshots
    });
    rawStore = createPraxisStore(historyEngine.engine);
    dispatchWithSync = (events, label) => {
      historyEngine.dispatch(events, label);
      const historyEntries = historyEngine.getHistory();
      currentHistoryIndex = historyEntries.length - 1;
      if (typeof window.__historyTestRecorder !== "undefined") {
        const recorder = window.__historyTestRecorder;
        if (recorder && typeof recorder.recordEvent === "function") {
          for (const event2 of events) {
            recorder.recordEvent(event2, label);
          }
        }
      }
      const hasSyncState = events.some((e) => e.tag === "SyncState");
      if (hasSyncState) {
        return;
      }
      const vscode17 = window.__vscodeApi;
      if (vscode17) {
        vscode17.postMessage({ type: "PRAXIS_EVENT", events });
      } else {
      }
    };
    praxisStore = {
      subscribe: rawStore.subscribe,
      dispatch: dispatchWithSync
    };
    currentHistoryIndex = 0;
    initHistory = () => {
      const historyEntries = historyEngine.getHistory();
      if (historyEntries.length > 0) {
        currentHistoryIndex = historyEntries.length - 1;
      }
    };
    initHistory();
    history = {
      undo: () => {
        if (!historyEngine.canUndo()) {
          return false;
        }
        const historyEntries = historyEngine.getHistory();
        if (currentHistoryIndex > 0) {
          currentHistoryIndex--;
          const entry = historyEntries[currentHistoryIndex];
          if (entry && entry.state && entry.state.context) {
            if (typeof frontendEngine.updateContext === "function") {
              const contextToRestore = entry.state.context;
              frontendEngine.updateContext(() => contextToRestore);
              return true;
            }
          }
        }
        return false;
      },
      redo: () => {
        if (!historyEngine.canRedo()) {
          return false;
        }
        const historyEntries = historyEngine.getHistory();
        if (currentHistoryIndex < historyEntries.length - 1) {
          currentHistoryIndex++;
          const entry = historyEntries[currentHistoryIndex];
          if (entry && entry.state && entry.state.context) {
            if (typeof frontendEngine.updateContext === "function") {
              const contextToRestore = entry.state.context;
              frontendEngine.updateContext(() => contextToRestore);
              return true;
            }
          }
        }
        return false;
      },
      canUndo: () => currentHistoryIndex > 0,
      canRedo: () => {
        const historyEntries = historyEngine.getHistory();
        return currentHistoryIndex < historyEntries.length - 1;
      },
      getHistory: () => historyEngine.getHistory(),
      goToHistory: (index2) => {
        const historyEntries = historyEngine.getHistory();
        if (index2 >= 0 && index2 < historyEntries.length) {
          const entry = historyEntries[index2];
          if (entry && entry.state && entry.state.context) {
            currentHistoryIndex = index2;
            if (typeof frontendEngine.updateContext === "function") {
              const contextToRestore = entry.state.context;
              frontendEngine.updateContext(() => contextToRestore);
              return true;
            }
          }
        }
        return false;
      },
      clearHistory: () => {
        historyEngine.clearHistory();
        currentHistoryIndex = 0;
        initHistory();
      }
    };
  }
});

// src/debugging/historyExport.ts
function exportHistory(metadata) {
  const entries = history.getHistory();
  const exported = {
    version: "1.0.0",
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    engineType: "frontend",
    initialContext: entries[0]?.state.context || frontendEngine.getContext(),
    entries: entries.map((entry, index2) => ({
      index: index2,
      timestamp: entry.timestamp,
      label: entry.label,
      events: entry.events || [],
      state: {
        state: entry.state.state,
        context: entry.state.context
      }
    })),
    metadata: {
      extensionVersion: "2.12.5",
      // Could be dynamic
      platform: typeof navigator !== "undefined" ? navigator.platform : "unknown",
      userAgent: typeof navigator !== "undefined" ? navigator.userAgent : "unknown",
      ...metadata
    }
  };
  return exported;
}
function exportHistoryAsJSON(metadata) {
  const exported = exportHistory(metadata);
  return JSON.stringify(exported, null, 2);
}
function importHistory(exported) {
  frontendEngine.updateContext(() => exported.initialContext);
  history.clearHistory();
  for (const entry of exported.entries) {
    if (entry.events.length > 0) {
      frontendEngine.step(entry.events);
    }
  }
}
function importHistoryFromJSON(json2) {
  try {
    const exported = JSON.parse(json2);
    importHistory(exported);
  } catch (error) {
    throw new Error(`Failed to parse history JSON: ${error}`);
  }
}
function historyToTestScenario(exported, scenarioId, scenarioName, description) {
  return {
    id: scenarioId,
    name: scenarioName,
    description,
    timestamp: exported.timestamp,
    initialContext: exported.initialContext,
    events: exported.entries.flatMap(
      (entry) => entry.events.map((event2) => ({
        event: event2,
        label: entry.label,
        timestamp: entry.timestamp,
        stateAfter: entry.state.state
      }))
    ),
    finalContext: exported.entries[exported.entries.length - 1]?.state.context || exported.initialContext,
    metadata: {
      tags: ["imported", "history"],
      version: exported.version
    }
  };
}
async function copyHistoryToClipboard(metadata) {
  const json2 = exportHistoryAsJSON(metadata);
  if (typeof navigator !== "undefined" && navigator.clipboard) {
    await navigator.clipboard.writeText(json2);
  } else {
    throw new Error("Clipboard API not available");
  }
}
var init_historyExport = __esm({
  "src/debugging/historyExport.ts"() {
    "use strict";
    init_store2();
    init_frontendEngine();
  }
});

// src/testing/historyTestRecorder.ts
function getHistoryTestRecorder() {
  if (!globalRecorder) {
    globalRecorder = new HistoryTestRecorder();
  }
  return globalRecorder;
}
function startRecording(scenarioId, scenarioName, description, metadata) {
  const recorder = getHistoryTestRecorder();
  recorder.startRecording(scenarioId, scenarioName, description, metadata);
}
function stopRecording() {
  const recorder = getHistoryTestRecorder();
  return recorder.stopRecording();
}
function isRecording() {
  const recorder = getHistoryTestRecorder();
  return recorder.isRecording();
}
var HistoryTestRecorder, globalRecorder;
var init_historyTestRecorder = __esm({
  "src/testing/historyTestRecorder.ts"() {
    "use strict";
    init_store2();
    init_frontendEngine();
    HistoryTestRecorder = class {
      scenario = null;
      startTime = 0;
      options;
      eventLabels = /* @__PURE__ */ new Map();
      constructor(options = {}) {
        this.options = {
          autoLabel: true,
          captureExpectedState: true,
          ...options
        };
      }
      /**
       * Start recording a new test scenario
       */
      startRecording(scenarioId, scenarioName, description, metadata) {
        if (this.scenario) {
          throw new Error("Recording already in progress. Call stopRecording() first.");
        }
        history.clearHistory();
        const initialContext2 = frontendEngine.getContext();
        this.startTime = Date.now();
        this.scenario = {
          id: scenarioId,
          name: scenarioName,
          description,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          initialContext: this.deepClone(initialContext2),
          events: [],
          finalContext: initialContext2,
          metadata: metadata || {}
        };
      }
      /**
       * Stop recording and return the test scenario
       */
      stopRecording() {
        if (!this.scenario) {
          throw new Error("No active recording. Call startRecording() first.");
        }
        this.scenario.finalContext = this.deepClone(frontendEngine.getContext());
        const scenario = this.scenario;
        this.scenario = null;
        return scenario;
      }
      /**
       * Record an event (called automatically when events are dispatched)
       */
      recordEvent(event2, label) {
        if (!this.scenario) {
          return;
        }
        if (this.options.maxDuration) {
          const elapsed = Date.now() - this.startTime;
          if (elapsed > this.options.maxDuration) {
            this.stopRecording();
            return;
          }
        }
        const stateAfter = frontendEngine.getContext().applicationState;
        const eventLabel = label || (this.options.autoLabel ? this.generateLabel(event2) : void 0);
        let expectedState;
        if (this.options.captureExpectedState) {
          expectedState = this.extractRelevantState(frontendEngine.getContext());
        }
        this.scenario.events.push({
          event: event2,
          label: eventLabel,
          expectedState,
          timestamp: Date.now(),
          stateAfter
        });
      }
      /**
       * Check if currently recording
       */
      isRecording() {
        return this.scenario !== null;
      }
      /**
       * Get current scenario (if recording)
       */
      getCurrentScenario() {
        return this.scenario ? { ...this.scenario } : null;
      }
      /**
       * Add a label for a specific event type
       */
      setEventLabel(eventTag, label) {
        this.eventLabels.set(eventTag, label);
      }
      /**
       * Generate a human-readable label for an event
       */
      generateLabel(event2) {
        if (this.eventLabels.has(event2.tag)) {
          return this.eventLabels.get(event2.tag);
        }
        return event2.tag.replace(/_/g, " ").replace(/([A-Z])/g, " $1").trim().toLowerCase().replace(/\b\w/g, (l) => l.toUpperCase());
      }
      /**
       * Extract relevant state for expected state comparison
       */
      extractRelevantState(context) {
        return {
          applicationState: context.applicationState,
          isActivated: context.isActivated,
          isDeactivating: context.isDeactivating,
          connections: context.connections,
          activeConnectionId: context.activeConnectionId,
          errorRecoveryAttempts: context.errorRecoveryAttempts,
          lastError: context.lastError
          // Add more fields as needed
        };
      }
      /**
       * Deep clone context to avoid mutations
       */
      deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
      }
    };
    globalRecorder = null;
  }
});

// src/debugging/eventReplayDebugger.ts
function getEventReplayDebugger() {
  if (!globalDebugger) {
    globalDebugger = new EventReplayDebugger();
  }
  return globalDebugger;
}
var EventReplayDebugger, globalDebugger;
var init_eventReplayDebugger = __esm({
  "src/debugging/eventReplayDebugger.ts"() {
    "use strict";
    init_store2();
    init_frontendEngine();
    EventReplayDebugger = class {
      breakpoints = /* @__PURE__ */ new Set();
      paused = false;
      resumeCallbacks = [];
      /**
       * Set a breakpoint at a specific event index
       */
      setBreakpoint(index2) {
        this.breakpoints.add(index2);
      }
      /**
       * Remove a breakpoint
       */
      removeBreakpoint(index2) {
        this.breakpoints.delete(index2);
      }
      /**
       * Clear all breakpoints
       */
      clearBreakpoints() {
        this.breakpoints.clear();
      }
      /**
       * Get all breakpoints
       */
      getBreakpoints() {
        return Array.from(this.breakpoints).sort((a, b) => a - b);
      }
      /**
       * Replay a test scenario with breakpoint support
       */
      async replay(scenario, options = {}) {
        const {
          stepDelay = 0,
          pauseOnBreakpoint = true,
          onStep,
          onBreakpoint
        } = options;
        frontendEngine.updateContext(() => scenario.initialContext);
        history.clearHistory();
        for (let i = 0; i < scenario.events.length; i++) {
          const eventData = scenario.events[i];
          if (this.breakpoints.has(i) && pauseOnBreakpoint) {
            this.paused = true;
            if (onBreakpoint) {
              onBreakpoint(i, eventData.event);
            }
            await this.waitForResume();
          }
          frontendEngine.step([eventData.event]);
          if (onStep) {
            const context2 = frontendEngine.getContext();
            onStep(i, eventData.event, context2);
          }
          const context = frontendEngine.getContext();
          if (stepDelay > 0) {
            await new Promise((resolve) => setTimeout(resolve, stepDelay));
          }
        }
      }
      /**
       * Replay from history entries
       */
      async replayHistory(startIndex = 0, endIndex, options = {}) {
        const historyEntries = history.getHistory();
        const end = endIndex !== void 0 ? endIndex : historyEntries.length - 1;
        if (startIndex > 0 && historyEntries[startIndex - 1]) {
          const startEntry = historyEntries[startIndex - 1];
          frontendEngine.updateContext(() => startEntry.state.context);
        } else {
          frontendEngine.updateContext(() => historyEntries[0].state.context);
        }
        const {
          stepDelay = 0,
          pauseOnBreakpoint = true,
          onStep,
          onBreakpoint
        } = options;
        for (let i = startIndex; i <= end; i++) {
          const entry = historyEntries[i];
          if (!entry || !entry.events || entry.events.length === 0) {
            continue;
          }
          if (this.breakpoints.has(i) && pauseOnBreakpoint) {
            this.paused = true;
            if (onBreakpoint && entry.events[0]) {
              onBreakpoint(i, entry.events[0]);
            }
            await this.waitForResume();
          }
          for (const event2 of entry.events) {
            frontendEngine.step([event2]);
            if (onStep) {
              const context = frontendEngine.getContext();
              onStep(i, event2, context);
            }
          }
          if (stepDelay > 0) {
            await new Promise((resolve) => setTimeout(resolve, stepDelay));
          }
        }
      }
      /**
       * Step forward one event
       */
      async stepForward(scenario, currentIndex) {
        if (currentIndex >= scenario.events.length) {
          return currentIndex;
        }
        const eventData = scenario.events[currentIndex];
        frontendEngine.step([eventData.event]);
        const context = frontendEngine.getContext();
        return currentIndex + 1;
      }
      /**
       * Step backward one event
       */
      async stepBackward(scenario, currentIndex) {
        if (currentIndex <= 0) {
          return currentIndex;
        }
        history.goToHistory(currentIndex - 1);
        return currentIndex - 1;
      }
      /**
       * Resume from pause
       */
      resume() {
        if (this.paused) {
          this.paused = false;
          for (const callback of this.resumeCallbacks) {
            callback();
          }
          this.resumeCallbacks = [];
        }
      }
      /**
       * Pause replay
       */
      pause() {
        this.paused = true;
      }
      /**
       * Check if currently paused
       */
      isPaused() {
        return this.paused;
      }
      /**
       * Wait for resume signal
       */
      async waitForResume() {
        return new Promise((resolve) => {
          if (!this.paused) {
            resolve();
            return;
          }
          this.resumeCallbacks.push(() => {
            resolve();
          });
        });
      }
    };
    globalDebugger = null;
  }
});

// src/commands/historyDebugCommands.ts
async function handleExportHistory() {
  try {
    const json2 = exportHistoryAsJSON();
    const uri = await vscode13.window.showSaveDialog({
      defaultUri: vscode13.Uri.file("history-export.json"),
      filters: { "JSON Files": ["json"] }
    });
    if (uri) {
      await vscode13.workspace.fs.writeFile(uri, Buffer.from(json2, "utf-8"));
      vscode13.window.showInformationMessage("History exported successfully");
    }
  } catch (error) {
    vscode13.window.showErrorMessage(`Failed to export history: ${error}`);
  }
}
async function handleImportHistory() {
  try {
    const uri = await vscode13.window.showOpenDialog({
      filters: { "JSON Files": ["json"] },
      canSelectMany: false
    });
    if (uri && uri[0]) {
      const content = await vscode13.workspace.fs.readFile(uri[0]);
      importHistoryFromJSON(content.toString());
      vscode13.window.showInformationMessage("History imported successfully");
    }
  } catch (error) {
    vscode13.window.showErrorMessage(`Failed to import history: ${error}`);
  }
}
async function handleCopyHistory() {
  try {
    await copyHistoryToClipboard();
    vscode13.window.showInformationMessage("History copied to clipboard");
  } catch (error) {
    vscode13.window.showErrorMessage(`Failed to copy history: ${error}`);
  }
}
async function handleStartRecording() {
  try {
    const scenarioId = await vscode13.window.showInputBox({
      prompt: "Enter scenario ID",
      placeHolder: "test-001"
    });
    if (!scenarioId) return;
    const scenarioName = await vscode13.window.showInputBox({
      prompt: "Enter scenario name",
      placeHolder: "User workflow test"
    });
    if (!scenarioName) return;
    startRecording(scenarioId, scenarioName);
    vscode13.window.showInformationMessage(`Started recording: ${scenarioName}`);
  } catch (error) {
    vscode13.window.showErrorMessage(`Failed to start recording: ${error}`);
  }
}
async function handleStopRecording() {
  try {
    if (!isRecording()) {
      vscode13.window.showWarningMessage("No active recording");
      return;
    }
    const scenario = stopRecording();
    const uri = await vscode13.window.showSaveDialog({
      defaultUri: vscode13.Uri.file(`${scenario.id}.json`),
      filters: { "JSON Files": ["json"] }
    });
    if (uri) {
      await vscode13.workspace.fs.writeFile(uri, Buffer.from(JSON.stringify(scenario, null, 2), "utf-8"));
      vscode13.window.showInformationMessage(`Scenario saved: ${scenario.name}`);
    }
  } catch (error) {
    vscode13.window.showErrorMessage(`Failed to stop recording: ${error}`);
  }
}
function handleClearBreakpoints() {
  getEventReplayDebugger().clearBreakpoints();
  vscode13.window.showInformationMessage("All breakpoints cleared");
}
function registerHistoryDebugCommands(context) {
  context.subscriptions.push(
    vscode13.commands.registerCommand("azureDevOpsInt.debug.history.export", handleExportHistory),
    vscode13.commands.registerCommand("azureDevOpsInt.debug.history.import", handleImportHistory),
    vscode13.commands.registerCommand("azureDevOpsInt.debug.history.copy", handleCopyHistory),
    vscode13.commands.registerCommand("azureDevOpsInt.debug.history.startRecording", handleStartRecording),
    vscode13.commands.registerCommand("azureDevOpsInt.debug.history.stopRecording", handleStopRecording),
    vscode13.commands.registerCommand("azureDevOpsInt.debug.history.clearBreakpoints", handleClearBreakpoints)
  );
}
var vscode13;
var init_historyDebugCommands = __esm({
  "src/commands/historyDebugCommands.ts"() {
    "use strict";
    vscode13 = __toESM(require("vscode"), 1);
    init_historyExport();
    init_historyTestRecorder();
    init_eventReplayDebugger();
  }
});

// src/testing/testGenerator.ts
var testGenerator_exports = {};
__export(testGenerator_exports, {
  generateSnapshotTest: () => generateSnapshotTest,
  generateTestFromHistory: () => generateTestFromHistory,
  generateTestFromHistoryFile: () => generateTestFromHistoryFile,
  generateTestFromScenario: () => generateTestFromScenario,
  saveGeneratedTest: () => saveGeneratedTest
});
function generateTestFromScenario(scenario, options = {}) {
  const opts = { ...defaultOptions, ...options };
  const indent = " ".repeat(opts.indentSize);
  const lines = [];
  const eventImports = /* @__PURE__ */ new Set();
  for (const eventData of scenario.events) {
    const eventTag = eventData.event.tag || "UNKNOWN_EVENT";
    const eventName = convertEventTagToName(eventTag);
    eventImports.add(eventName);
  }
  lines.push(generateImports(opts.framework, eventImports));
  lines.push("");
  if (opts.includeComments) {
    lines.push("/**");
    lines.push(` * Generated test from scenario: ${scenario.name}`);
    lines.push(` * Original ID: ${scenario.id}`);
    lines.push(` * Generated: ${(/* @__PURE__ */ new Date()).toISOString()}`);
    lines.push(" */");
  }
  lines.push(`describe('${opts.describeName}', () => {`);
  if (opts.framework === "vitest") {
    lines.push(`${indent}beforeEach(() => {`);
    lines.push(`${indent}${indent}resetEngine();`);
    lines.push(`${indent}});`);
    lines.push("");
  }
  const testName = opts.testName || scenario.name.toLowerCase().replace(/\s+/g, "-");
  lines.push(`${indent}it('${testName}', async () => {`);
  for (let i = 0; i < scenario.events.length; i++) {
    const eventData = scenario.events[i];
    if (opts.includeComments && eventData.label) {
      lines.push(`${indent}${indent}// ${eventData.label}`);
    }
    const eventCode = generateEventCode(eventData.event, opts.indentSize * 2);
    lines.push(`${indent}${indent}dispatch([${eventCode}]);`);
    if (eventData.expectedState && eventData.expectedState.applicationState) {
      const expectedState = eventData.expectedState.applicationState;
      lines.push(`${indent}${indent}await waitForStateValue('${expectedState}');`);
    } else if (eventData.stateAfter) {
      lines.push(`${indent}${indent}await waitForStateValue('${eventData.stateAfter}');`);
    }
    lines.push("");
  }
  lines.push(`${indent}${indent}// Verify final state`);
  lines.push(`${indent}${indent}const context = getContext();`);
  if (scenario.finalContext.applicationState) {
    lines.push(`${indent}${indent}expect(context.applicationState).toBe('${scenario.finalContext.applicationState}');`);
  }
  if (scenario.finalContext.connections) {
    lines.push(`${indent}${indent}expect(context.connections.length).toBe(${scenario.finalContext.connections.length});`);
  }
  if (scenario.finalContext.activeConnectionId) {
    lines.push(`${indent}${indent}expect(context.activeConnectionId).toBe('${scenario.finalContext.activeConnectionId}');`);
  }
  if (opts.includeSnapshots && opts.framework === "vitest") {
    lines.push("");
    lines.push(`${indent}${indent}// Snapshot test`);
    lines.push(`${indent}${indent}expect(context).toMatchSnapshot();`);
  }
  lines.push(`${indent}});`);
  lines.push("});");
  return lines.join("\n");
}
function generateTestFromHistory(exported, options = {}) {
  const scenario = historyToTestScenario(
    exported,
    options.testName || "generated-from-history",
    options.testName || "Generated from History"
  );
  return generateTestFromScenario(scenario, options);
}
function generateImports(framework, eventImports = /* @__PURE__ */ new Set()) {
  const imports = [];
  if (framework === "vitest") {
    imports.push("import { describe, it, expect, beforeEach } from 'vitest';");
  } else if (framework === "jest") {
    imports.push("import { describe, it, expect, beforeEach } from '@jest/globals';");
  } else {
    imports.push("import { describe, it } from 'mocha';");
    imports.push("import { expect } from 'chai';");
  }
  imports.push("import { resetEngine, dispatch, waitForStateValue, getContext } from '../../../src/testing/helpers.js';");
  if (eventImports.size > 0) {
    const eventNames = Array.from(eventImports).sort();
    imports.push(`import { ${eventNames.join(", ")} } from '../../../src/praxis/application/facts.js';`);
  }
  return imports.join("\n");
}
function convertEventTagToName(eventTag) {
  const parts = eventTag.split("_");
  const camelCase = parts.map(
    (part) => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()
  ).join("");
  return camelCase + "Event";
}
function generateEventCode(event2, indent) {
  const eventTag = event2.tag || "UNKNOWN_EVENT";
  const payload = event2.payload || {};
  const eventName = convertEventTagToName(eventTag);
  const payloadCode = generatePayloadCode(payload, indent + 2);
  return `${eventName}.create(${payloadCode})`;
}
function generatePayloadCode(payload, indent) {
  if (!payload || Object.keys(payload).length === 0) {
    return "{}";
  }
  const indentStr = " ".repeat(indent);
  const lines = [];
  lines.push("{");
  for (const [key2, value] of Object.entries(payload)) {
    const valueCode = generateValueCode(value, indent);
    lines.push(`${indentStr}${key2}: ${valueCode},`);
  }
  lines.push(" ".repeat(indent - 2) + "}");
  return lines.join("\n");
}
function generateValueCode(value, indent) {
  if (value === null) return "null";
  if (value === void 0) return "undefined";
  if (typeof value === "string") {
    return `'${value.replace(/'/g, "\\'")}'`;
  }
  if (typeof value === "number" || typeof value === "boolean") {
    return String(value);
  }
  if (Array.isArray(value)) {
    if (value.length === 0) return "[]";
    const items = value.map((v) => generateValueCode(v, indent)).join(", ");
    return `[${items}]`;
  }
  if (typeof value === "object") {
    if (value instanceof Map) {
      const entries = Array.from(value.entries()).map(
        ([k, v]) => `['${k}', ${generateValueCode(v, indent)}]`
      ).join(", ");
      return `new Map([${entries}])`;
    }
    const keys = Object.keys(value);
    if (keys.length === 0) return "{}";
    const indentStr = " ".repeat(indent);
    const lines = [];
    lines.push("{");
    for (const [key2, val] of Object.entries(value)) {
      lines.push(`${indentStr}${key2}: ${generateValueCode(val, indent + 2)},`);
    }
    lines.push(" ".repeat(indent - 2) + "}");
    return lines.join("\n");
  }
  return JSON.stringify(value);
}
function generateSnapshotTest(scenario, options = {}) {
  const opts = { ...defaultOptions, ...options };
  const indent = " ".repeat(opts.indentSize);
  const lines = [];
  lines.push(generateImports(opts.framework));
  lines.push("import { createSnapshotTest } from '../../../src/testing/snapshotTesting.js';");
  lines.push("");
  const eventImports = /* @__PURE__ */ new Set();
  for (const eventData of scenario.events) {
    const eventTag = eventData.event.tag || "UNKNOWN_EVENT";
    const eventName = convertEventTagToName(eventTag);
    eventImports.add(eventName);
  }
  if (eventImports.size > 0) {
    const eventNames = Array.from(eventImports).sort();
    lines.push(`import { ${eventNames.join(", ")} } from '../../../src/praxis/application/facts.js';`);
    lines.push("");
  }
  lines.push(`describe('${opts.describeName}', () => {`);
  lines.push(`${indent}it('${opts.testName}', () => {`);
  lines.push(`${indent}${indent}const testFn = createSnapshotTest({`);
  lines.push(`${indent}${indent}${indent}name: '${scenario.name}',`);
  lines.push(`${indent}${indent}${indent}events: [`);
  for (const eventData of scenario.events) {
    const eventCode = generateEventCode(eventData.event, opts.indentSize * 3);
    lines.push(`${indent}${indent}${indent}${indent}${eventCode},`);
  }
  lines.push(`${indent}${indent}${indent}],`);
  lines.push(`${indent}${indent}${indent}expectedSnapshots: [`);
  for (let i = 0; i < scenario.events.length; i++) {
    const eventData = scenario.events[i];
    if (eventData.stateAfter) {
      lines.push(`${indent}${indent}${indent}${indent}{`);
      lines.push(`${indent}${indent}${indent}${indent}${indent}index: ${i + 1},`);
      lines.push(`${indent}${indent}${indent}${indent}${indent}state: '${eventData.stateAfter}',`);
      lines.push(`${indent}${indent}${indent}${indent}${indent}contextChecks: (ctx) => ctx.applicationState === '${eventData.stateAfter}',`);
      lines.push(`${indent}${indent}${indent}${indent}},`);
    }
  }
  lines.push(`${indent}${indent}${indent}],`);
  lines.push(`${indent}${indent}});`);
  lines.push("");
  lines.push(`${indent}${indent}expect(() => testFn()).not.toThrow();`);
  lines.push(`${indent}});`);
  lines.push("});");
  return lines.join("\n");
}
async function saveGeneratedTest(testCode, filepath) {
  const fs3 = await import("fs/promises");
  await fs3.writeFile(filepath, testCode, "utf-8");
}
async function generateTestFromHistoryFile(historyFile, outputFile, options = {}) {
  const fs3 = await import("fs/promises");
  const historyJson = await fs3.readFile(historyFile, "utf-8");
  const exported = JSON.parse(historyJson);
  const testCode = generateTestFromHistory(exported, options);
  await saveGeneratedTest(testCode, outputFile);
}
var defaultOptions;
var init_testGenerator = __esm({
  "src/testing/testGenerator.ts"() {
    "use strict";
    init_historyExport();
    defaultOptions = {
      framework: "vitest",
      includeSnapshots: true,
      includeComments: true,
      indentSize: 2,
      testName: "generated-test",
      describeName: "Generated Tests"
    };
  }
});

// src/commands/testGeneratorCommands.ts
function registerTestGeneratorCommands(context) {
  const generateFromHistoryCommand = vscode14.commands.registerCommand(
    "azureDevOpsInt.debug.test.generateFromHistory",
    async () => {
      try {
        const testName = await vscode14.window.showInputBox({
          prompt: "Enter test name",
          placeHolder: "connection-authentication-test"
        });
        if (!testName) {
          return;
        }
        const framework = await vscode14.window.showQuickPick(
          ["vitest", "jest", "mocha"],
          {
            placeHolder: "Select test framework"
          }
        );
        if (!framework) {
          return;
        }
        const historyJson = exportHistoryAsJSON();
        const { generateTestFromHistory: generateTestFromHistory3 } = await Promise.resolve().then(() => (init_testGenerator(), testGenerator_exports));
        const exported = JSON.parse(historyJson);
        const testCode = generateTestFromHistory3(exported, {
          framework,
          testName,
          includeSnapshots: true,
          includeComments: true
        });
        const uri = await vscode14.window.showSaveDialog({
          defaultUri: vscode14.Uri.file(`${testName}.test.ts`),
          filters: {
            "TypeScript Files": ["ts"]
          }
        });
        if (uri) {
          await fs.writeFile(uri.fsPath, testCode, "utf-8");
          vscode14.window.showInformationMessage(`Test generated: ${path.basename(uri.fsPath)}`);
        }
      } catch (error) {
        vscode14.window.showErrorMessage(`Failed to generate test: ${error}`);
      }
    }
  );
  const generateFromFileCommand = vscode14.commands.registerCommand(
    "azureDevOpsInt.debug.test.generateFromFile",
    async () => {
      try {
        const uri = await vscode14.window.showOpenDialog({
          filters: {
            "JSON Files": ["json"]
          },
          canSelectMany: false
        });
        if (!uri || !uri[0]) {
          return;
        }
        const testName = await vscode14.window.showInputBox({
          prompt: "Enter test name",
          placeHolder: "generated-test"
        });
        if (!testName) {
          return;
        }
        const framework = await vscode14.window.showQuickPick(
          ["vitest", "jest", "mocha"],
          {
            placeHolder: "Select test framework"
          }
        );
        if (!framework) {
          return;
        }
        const outputUri = await vscode14.window.showSaveDialog({
          defaultUri: vscode14.Uri.file(`${testName}.test.ts`),
          filters: {
            "TypeScript Files": ["ts"]
          }
        });
        if (outputUri) {
          await generateTestFromHistoryFile(
            uri[0].fsPath,
            outputUri.fsPath,
            {
              framework,
              testName,
              includeSnapshots: true,
              includeComments: true
            }
          );
          vscode14.window.showInformationMessage(`Test generated: ${path.basename(outputUri.fsPath)}`);
        }
      } catch (error) {
        vscode14.window.showErrorMessage(`Failed to generate test: ${error}`);
      }
    }
  );
  context.subscriptions.push(generateFromHistoryCommand, generateFromFileCommand);
}
var vscode14, path, fs;
var init_testGeneratorCommands = __esm({
  "src/commands/testGeneratorCommands.ts"() {
    "use strict";
    vscode14 = __toESM(require("vscode"), 1);
    path = __toESM(require("path"), 1);
    fs = __toESM(require("fs/promises"), 1);
    init_testGenerator();
    init_historyExport();
  }
});

// src/logging/MessageInterceptor.ts
function interceptWebviewMessages(webview, component2 = "webview") {
  const originalPostMessage = webview.postMessage.bind(webview);
  const originalOnDidReceiveMessage = webview.onDidReceiveMessage.bind(webview);
  const intercepted = {
    postMessage: (message) => {
      try {
        standardizedLogger.info(
          "message",
          component2,
          "postMessage",
          `host->webview: ${message?.type || "unknown"}`,
          { message }
        );
      } catch (err) {
      }
      return originalPostMessage(message);
    },
    onDidReceiveMessage: (callback) => {
      return originalOnDidReceiveMessage((message) => {
        try {
          standardizedLogger.info(
            "message",
            component2,
            "onDidReceiveMessage",
            `webview->host: ${message?.type || "unknown"}`,
            { message }
          );
        } catch (err) {
        }
        callback(message);
      });
    }
  };
  return intercepted;
}
var init_MessageInterceptor = __esm({
  "src/logging/MessageInterceptor.ts"() {
    "use strict";
    init_StandardizedAutomaticLogger();
  }
});

// node_modules/svelte/src/store/index-server.js
var init_index_server = __esm({
  "node_modules/svelte/src/store/index-server.js"() {
    init_shared2();
    init_shared2();
  }
});

// src/praxis/application/eventBus.ts
function getPraxisEventBus() {
  if (!eventBusInstance) {
    eventBusInstance = new PraxisEventBus();
  }
  return eventBusInstance;
}
var PraxisEventBus, eventBusInstance;
var init_eventBus = __esm({
  "src/praxis/application/eventBus.ts"() {
    "use strict";
    PraxisEventBus = class {
      subscribers = /* @__PURE__ */ new Map();
      allSubscribers = /* @__PURE__ */ new Set();
      messageHistory = [];
      maxHistorySize = 100;
      /**
       * Subscribe to specific message types
       */
      subscribe(type2, subscriber) {
        if (!this.subscribers.has(type2)) {
          this.subscribers.set(type2, /* @__PURE__ */ new Set());
        }
        this.subscribers.get(type2).add(subscriber);
        return () => {
          this.subscribers.get(type2)?.delete(subscriber);
        };
      }
      /**
       * Subscribe to all message types
       */
      subscribeAll(subscriber) {
        this.allSubscribers.add(subscriber);
        return () => {
          this.allSubscribers.delete(subscriber);
        };
      }
      /**
       * Publish a message to all relevant subscribers
       */
      publish(message) {
        if (!message.timestamp) {
          message.timestamp = Date.now();
        }
        this.messageHistory.push(message);
        if (this.messageHistory.length > this.maxHistorySize) {
          this.messageHistory.shift();
        }
        const typeSubscribers = this.subscribers.get(message.type);
        if (typeSubscribers) {
          for (const subscriber of typeSubscribers) {
            try {
              subscriber(message);
            } catch (error) {
            }
          }
        }
        for (const subscriber of this.allSubscribers) {
          try {
            subscriber(message);
          } catch (error) {
          }
        }
      }
      /**
       * Emit a timer event
       */
      emitTimerEvent(type2, payload, connectionId) {
        this.publish({
          type: type2,
          payload,
          timestamp: Date.now(),
          sourceEngine: "timer",
          connectionId
        });
      }
      /**
       * Emit an auth event
       */
      emitAuthEvent(type2, payload, connectionId) {
        this.publish({
          type: type2,
          payload,
          timestamp: Date.now(),
          sourceEngine: "auth",
          connectionId
        });
      }
      /**
       * Emit a connection event
       */
      emitConnectionEvent(type2, payload, connectionId) {
        this.publish({
          type: type2,
          payload,
          timestamp: Date.now(),
          sourceEngine: "connection",
          connectionId
        });
      }
      /**
       * Emit an application event
       */
      emitApplicationEvent(type2, payload, connectionId) {
        this.publish({
          type: type2,
          payload,
          timestamp: Date.now(),
          sourceEngine: "application",
          connectionId
        });
      }
      /**
       * Get message history
       */
      getHistory() {
        return [...this.messageHistory];
      }
      /**
       * Get history for a specific connection
       */
      getConnectionHistory(connectionId) {
        return this.messageHistory.filter((m) => m.connectionId === connectionId);
      }
      /**
       * Get history for a specific source engine
       */
      getEngineHistory(engine) {
        return this.messageHistory.filter((m) => m.sourceEngine === engine);
      }
      /**
       * Clear all subscribers
       */
      clear() {
        this.subscribers.clear();
        this.allSubscribers.clear();
        this.messageHistory = [];
      }
      /**
       * Get subscriber count for debugging
       */
      getSubscriberCount() {
        const byType = {};
        for (const [type2, subs] of this.subscribers) {
          byType[type2] = subs.size;
        }
        return {
          byType,
          all: this.allSubscribers.size
        };
      }
    };
  }
});

// src/praxis/timer/facts.ts
var TimerStateFact, TimerDataFact, TimerStartedFact, TimerPausedFact, TimerResumedFact, TimerStoppedFact, ActivityRecordedFact, StartTimerEvent2, PauseTimerEvent2, ResumeTimerEvent, StopTimerEvent2, ActivityPingEvent, InactivityTimeoutEvent, RestoreTimerEvent, PomodoroBreakEvent;
var init_facts3 = __esm({
  "src/praxis/timer/facts.ts"() {
    "use strict";
    init_node();
    TimerStateFact = defineFact("TimerState");
    TimerDataFact = defineFact("TimerData");
    TimerStartedFact = defineFact("TimerStarted");
    TimerPausedFact = defineFact(
      "TimerPaused"
    );
    TimerResumedFact = defineFact("TimerResumed");
    TimerStoppedFact = defineFact("TimerStopped");
    ActivityRecordedFact = defineFact(
      "ActivityRecorded"
    );
    StartTimerEvent2 = defineEvent("START_TIMER");
    PauseTimerEvent2 = defineEvent("PAUSE_TIMER");
    ResumeTimerEvent = defineEvent(
      "RESUME_TIMER"
    );
    StopTimerEvent2 = defineEvent("STOP_TIMER");
    ActivityPingEvent = defineEvent(
      "ACTIVITY_PING"
    );
    InactivityTimeoutEvent = defineEvent(
      "INACTIVITY_TIMEOUT"
    );
    RestoreTimerEvent = defineEvent("RESTORE_TIMER");
    PomodoroBreakEvent = defineEvent(
      "POMODORO_BREAK"
    );
  }
});

// src/praxis/timer/types.ts
var DEFAULT_TIMER_CONFIG;
var init_types4 = __esm({
  "src/praxis/timer/types.ts"() {
    "use strict";
    DEFAULT_TIMER_CONFIG = {
      inactivityTimeoutSec: 900,
      // 15 minutes
      defaultElapsedLimitHours: 3.5,
      pomodoroEnabled: false,
      pomodoroCount: 0
    };
  }
});

// src/praxis/timer/rules.ts
function calculateAdjustedStartTime(timerData, now) {
  const pauseDuration = timerData.pausedAt && timerData.startTime ? now - timerData.pausedAt : 0;
  return timerData.startTime ? timerData.startTime + pauseDuration : now;
}
var startTimerRule, pauseTimerRule, resumeTimerRule, stopTimerRule, activityPingRule, inactivityTimeoutRule, restoreTimerRule;
var init_rules3 = __esm({
  "src/praxis/timer/rules.ts"() {
    "use strict";
    init_node();
    init_types4();
    init_facts3();
    startTimerRule = defineRule({
      id: "timer.start",
      description: "Start a timer for a work item",
      impl: (state2, events) => {
        const startEvent = findEvent(events, StartTimerEvent2);
        if (!startEvent) return [];
        if (state2.context.timerState !== "idle") return [];
        const now = Date.now();
        state2.context.timerState = "running";
        state2.context.timerData = {
          ...state2.context.timerData,
          workItemId: startEvent.payload.workItemId,
          workItemTitle: startEvent.payload.workItemTitle,
          startTime: now,
          pausedAt: void 0,
          isPaused: false,
          lastActivity: now
        };
        return [];
      }
    });
    pauseTimerRule = defineRule({
      id: "timer.pause",
      description: "Pause the running timer",
      impl: (state2, events) => {
        const pauseEvent = findEvent(events, PauseTimerEvent2);
        if (!pauseEvent) return [];
        if (state2.context.timerState !== "running") return [];
        const now = Date.now();
        state2.context.timerState = "paused";
        state2.context.timerData = {
          ...state2.context.timerData,
          isPaused: true,
          pausedAt: now
        };
        return [];
      }
    });
    resumeTimerRule = defineRule({
      id: "timer.resume",
      description: "Resume a paused timer",
      impl: (state2, events) => {
        const resumeEvent = findEvent(events, ResumeTimerEvent);
        if (!resumeEvent) return [];
        if (state2.context.timerState !== "paused") return [];
        const now = Date.now();
        const timerData = state2.context.timerData;
        const adjustedStartTime = calculateAdjustedStartTime(timerData, now);
        state2.context.timerState = "running";
        state2.context.timerData = {
          ...timerData,
          isPaused: false,
          startTime: adjustedStartTime,
          pausedAt: void 0,
          lastActivity: now
        };
        return [];
      }
    });
    stopTimerRule = defineRule({
      id: "timer.stop",
      description: "Stop the timer",
      impl: (state2, events) => {
        const stopEvent = findEvent(events, StopTimerEvent2);
        if (!stopEvent) return [];
        if (state2.context.timerState === "idle") return [];
        state2.context.timerState = "idle";
        state2.context.timerData = {
          isPaused: false,
          lastActivity: Date.now(),
          ...DEFAULT_TIMER_CONFIG
        };
        return [];
      }
    });
    activityPingRule = defineRule({
      id: "timer.activity",
      description: "Record user activity",
      impl: (state2, events) => {
        const activityEvent = findEvent(events, ActivityPingEvent);
        if (!activityEvent) return [];
        const timerState = state2.context.timerState;
        const now = Date.now();
        const timerData = state2.context.timerData;
        if (timerState === "paused") {
          const adjustedStartTime = calculateAdjustedStartTime(timerData, now);
          state2.context.timerState = "running";
          state2.context.timerData = {
            ...timerData,
            isPaused: false,
            startTime: adjustedStartTime,
            pausedAt: void 0,
            lastActivity: now
          };
          return [];
        }
        if (timerState === "running") {
          state2.context.timerData = {
            ...timerData,
            lastActivity: now
          };
        }
        return [];
      }
    });
    inactivityTimeoutRule = defineRule({
      id: "timer.inactivity",
      description: "Pause timer due to inactivity",
      impl: (state2, events) => {
        const timeoutEvent = findEvent(events, InactivityTimeoutEvent);
        if (!timeoutEvent) return [];
        if (state2.context.timerState !== "running") return [];
        const now = Date.now();
        state2.context.timerState = "paused";
        state2.context.timerData = {
          ...state2.context.timerData,
          isPaused: true,
          pausedAt: now
        };
        return [];
      }
    });
    restoreTimerRule = defineRule({
      id: "timer.restore",
      description: "Restore timer from persisted state",
      impl: (state2, events) => {
        const restoreEvent = findEvent(events, RestoreTimerEvent);
        if (!restoreEvent) return [];
        if (state2.context.timerState !== "idle") return [];
        const now = Date.now();
        const { workItemId, workItemTitle, startTime, isPaused } = restoreEvent.payload;
        state2.context.timerState = isPaused ? "paused" : "running";
        state2.context.timerData = {
          ...state2.context.timerData,
          workItemId,
          workItemTitle,
          startTime,
          isPaused,
          pausedAt: isPaused ? now : void 0,
          lastActivity: now
        };
        return [];
      }
    });
  }
});

// src/praxis/timer/engine.ts
function createTimerEngine(initialConfig) {
  const registry2 = new PraxisRegistry();
  registry2.registerRule(startTimerRule);
  registry2.registerRule(pauseTimerRule);
  registry2.registerRule(resumeTimerRule);
  registry2.registerRule(stopTimerRule);
  registry2.registerRule(activityPingRule);
  registry2.registerRule(inactivityTimeoutRule);
  registry2.registerRule(restoreTimerRule);
  return createPraxisEngine({
    initialContext: {
      timerState: "idle",
      timerData: {
        isPaused: false,
        lastActivity: Date.now(),
        ...DEFAULT_TIMER_CONFIG,
        ...initialConfig
      }
    },
    registry: registry2,
    initialFacts: []
  });
}
var init_engine3 = __esm({
  "src/praxis/timer/engine.ts"() {
    "use strict";
    init_node();
    init_types4();
    init_rules3();
  }
});

// src/praxis/timer/manager.ts
var PraxisTimerManager;
var init_manager2 = __esm({
  "src/praxis/timer/manager.ts"() {
    "use strict";
    init_facts3();
    init_engine3();
    PraxisTimerManager = class {
      engine;
      isStarted = false;
      constructor(config) {
        this.engine = createTimerEngine(config);
      }
      start() {
        this.isStarted = true;
      }
      stop() {
        this.isStarted = false;
      }
      getTimerState() {
        return this.engine.getContext().timerState;
      }
      getTimerData() {
        return this.engine.getContext().timerData;
      }
      startTimer(workItemId, workItemTitle) {
        if (!this.isStarted) return false;
        if (this.getTimerState() !== "idle") return false;
        this.engine.step([StartTimerEvent2.create({ workItemId, workItemTitle })]);
        return this.getTimerState() === "running";
      }
      pauseTimer(manual = true) {
        if (!this.isStarted) return false;
        if (this.getTimerState() !== "running") return false;
        this.engine.step([PauseTimerEvent2.create({ manual })]);
        return this.getTimerState() === "paused";
      }
      resumeTimer(fromActivity = false) {
        if (!this.isStarted) return false;
        if (this.getTimerState() !== "paused") return false;
        this.engine.step([ResumeTimerEvent.create({ fromActivity })]);
        return this.getTimerState() === "running";
      }
      stopTimer() {
        if (!this.isStarted) return null;
        if (this.getTimerState() === "idle") return null;
        const timerData = this.getTimerData();
        if (!timerData?.workItemId || !timerData?.startTime) return null;
        const endTime = Date.now();
        const duration = endTime - timerData.startTime;
        const hoursDecimal = duration / (1e3 * 60 * 60);
        const limit = timerData.defaultElapsedLimitHours;
        const capApplied = hoursDecimal > limit;
        const cappedHours = capApplied ? limit : hoursDecimal;
        const cappedDuration = cappedHours * 60 * 60 * 1e3;
        this.engine.step([StopTimerEvent2.create({})]);
        return {
          workItemId: timerData.workItemId,
          startTime: timerData.startTime,
          endTime,
          duration: capApplied ? cappedDuration : duration,
          hoursDecimal: cappedHours,
          capApplied,
          capLimitHours: capApplied ? limit : void 0
        };
      }
      activityPing() {
        if (!this.isStarted) return;
        if (this.getTimerState() === "idle") return;
        this.engine.step([ActivityPingEvent.create({})]);
      }
      inactivityTimeout() {
        if (!this.isStarted) return;
        if (this.getTimerState() !== "running") return;
        this.engine.step([InactivityTimeoutEvent.create({})]);
      }
      restoreTimer(workItemId, workItemTitle, startTime, isPaused) {
        if (!this.isStarted) return false;
        if (this.getTimerState() !== "idle") return false;
        this.engine.step([
          RestoreTimerEvent.create({ workItemId, workItemTitle, startTime, isPaused })
        ]);
        return this.getTimerState() !== "idle";
      }
      getTimerSnapshot() {
        const timerState = this.getTimerState();
        if (timerState === "idle") return void 0;
        const timerData = this.getTimerData();
        if (!timerData) return void 0;
        const now = Date.now();
        let elapsedMs = 0;
        if (timerData.startTime) {
          if (timerData.isPaused && timerData.pausedAt) {
            elapsedMs = timerData.pausedAt - timerData.startTime;
          } else {
            elapsedMs = now - timerData.startTime;
          }
        }
        return {
          workItemId: timerData.workItemId,
          workItemTitle: timerData.workItemTitle,
          startTime: timerData.startTime,
          elapsedSeconds: Math.floor(elapsedMs / 1e3),
          isPaused: timerData.isPaused,
          running: timerState === "running",
          isPomodoro: timerData.pomodoroEnabled,
          pomodoroCount: timerData.pomodoroCount
        };
      }
      getStatus() {
        return {
          isStarted: this.isStarted,
          timerState: this.getTimerState(),
          timerContext: this.getTimerData()
        };
      }
      validateSync() {
        return this.isStarted;
      }
      getEngine() {
        return this.engine;
      }
    };
  }
});

// src/praxis/auth/types.ts
var DEFAULT_AUTH_CONFIG;
var init_types5 = __esm({
  "src/praxis/auth/types.ts"() {
    "use strict";
    DEFAULT_AUTH_CONFIG = {
      maxRetryCount: 3,
      retryDelayMs: 1e3
    };
  }
});

// src/praxis/auth/facts.ts
var AuthStateFact, AuthDataFact, AuthenticatedFact, AuthFailedFact, TokenExpiredFact, AuthenticateEvent, AuthSuccessEvent, AuthFailedEvent, LogoutEvent, TokenRefreshEvent, TokenExpiredEvent, DeviceCodeStartedEvent, DeviceCodeCompletedEvent, RetryAuthEvent, ResetAuthEvent;
var init_facts4 = __esm({
  "src/praxis/auth/facts.ts"() {
    "use strict";
    init_node();
    AuthStateFact = defineFact("AuthState");
    AuthDataFact = defineFact("AuthData");
    AuthenticatedFact = defineFact("Authenticated");
    AuthFailedFact = defineFact(
      "AuthFailed"
    );
    TokenExpiredFact = defineFact(
      "TokenExpired"
    );
    AuthenticateEvent = defineEvent("AUTHENTICATE");
    AuthSuccessEvent = defineEvent(
      "AUTH_SUCCESS"
    );
    AuthFailedEvent = defineEvent("AUTH_FAILED");
    LogoutEvent = defineEvent("LOGOUT");
    TokenRefreshEvent = defineEvent(
      "TOKEN_REFRESH"
    );
    TokenExpiredEvent = defineEvent(
      "TOKEN_EXPIRED"
    );
    DeviceCodeStartedEvent = defineEvent("DEVICE_CODE_STARTED");
    DeviceCodeCompletedEvent = defineEvent("DEVICE_CODE_COMPLETED");
    RetryAuthEvent = defineEvent("RETRY_AUTH");
    ResetAuthEvent = defineEvent("RESET_AUTH");
  }
});

// src/praxis/auth/rules.ts
var authenticateRule, authSuccessRule, authFailedRule, logoutRule, tokenExpiredRule, deviceCodeStartedRule2, deviceCodeCompletedRule2, retryAuthRule, resetAuthRule;
var init_rules4 = __esm({
  "src/praxis/auth/rules.ts"() {
    "use strict";
    init_node();
    init_types5();
    init_facts4();
    authenticateRule = defineRule({
      id: "auth.authenticate",
      description: "Initiate authentication for a connection",
      impl: (state2, events) => {
        const authEvent = findEvent(events, AuthenticateEvent);
        if (!authEvent) return [];
        if (state2.context.authState !== "idle" && state2.context.authState !== "failed") return [];
        const now = Date.now();
        state2.context.authState = "authenticating";
        state2.context.authData = {
          ...state2.context.authData,
          connectionId: authEvent.payload.connectionId,
          authMethod: authEvent.payload.authMethod,
          tenantId: authEvent.payload.tenantId,
          clientId: authEvent.payload.clientId,
          lastAuthAttempt: now,
          error: void 0
        };
        return [];
      }
    });
    authSuccessRule = defineRule({
      id: "auth.success",
      description: "Handle successful authentication",
      impl: (state2, events) => {
        const successEvent = findEvent(events, AuthSuccessEvent);
        if (!successEvent) return [];
        if (state2.context.authState !== "authenticating") return [];
        state2.context.authState = "authenticated";
        state2.context.authData = {
          ...state2.context.authData,
          token: successEvent.payload.token,
          expiresAt: successEvent.payload.expiresAt,
          error: void 0,
          retryCount: 0,
          deviceCodeSession: void 0
        };
        return [];
      }
    });
    authFailedRule = defineRule({
      id: "auth.failed",
      description: "Handle failed authentication",
      impl: (state2, events) => {
        const failedEvent = findEvent(events, AuthFailedEvent);
        if (!failedEvent) return [];
        if (state2.context.authState !== "authenticating") return [];
        state2.context.authState = "failed";
        state2.context.authData = {
          ...state2.context.authData,
          error: failedEvent.payload.error,
          retryCount: state2.context.authData.retryCount + 1,
          token: void 0,
          expiresAt: void 0,
          deviceCodeSession: void 0
        };
        return [];
      }
    });
    logoutRule = defineRule({
      id: "auth.logout",
      description: "Clear authentication state on logout",
      impl: (state2, events) => {
        const logoutEvent = findEvent(events, LogoutEvent);
        if (!logoutEvent) return [];
        if (state2.context.authState !== "authenticated") return [];
        state2.context.authState = "idle";
        state2.context.authData = {
          ...state2.context.authData,
          token: void 0,
          expiresAt: void 0,
          error: void 0,
          retryCount: 0,
          deviceCodeSession: void 0
        };
        return [];
      }
    });
    tokenExpiredRule = defineRule({
      id: "auth.tokenExpired",
      description: "Handle token expiration",
      impl: (state2, events) => {
        const expiredEvent = findEvent(events, TokenExpiredEvent);
        if (!expiredEvent) return [];
        if (state2.context.authState !== "authenticated") return [];
        state2.context.authState = "failed";
        state2.context.authData = {
          ...state2.context.authData,
          error: "Token expired",
          token: void 0,
          expiresAt: void 0
        };
        return [];
      }
    });
    deviceCodeStartedRule2 = defineRule({
      id: "auth.deviceCodeStarted",
      description: "Handle device code flow start",
      impl: (state2, events) => {
        const deviceCodeEvent = findEvent(events, DeviceCodeStartedEvent);
        if (!deviceCodeEvent) return [];
        if (state2.context.authState !== "authenticating") return [];
        state2.context.authData = {
          ...state2.context.authData,
          deviceCodeSession: {
            userCode: deviceCodeEvent.payload.userCode,
            verificationUri: deviceCodeEvent.payload.verificationUri,
            expiresInSeconds: deviceCodeEvent.payload.expiresInSeconds,
            startedAt: Date.now()
          }
        };
        return [];
      }
    });
    deviceCodeCompletedRule2 = defineRule({
      id: "auth.deviceCodeCompleted",
      description: "Handle device code flow completion",
      impl: (state2, events) => {
        const completedEvent = findEvent(events, DeviceCodeCompletedEvent);
        if (!completedEvent) return [];
        if (state2.context.authState !== "authenticating") return [];
        state2.context.authState = "authenticated";
        state2.context.authData = {
          ...state2.context.authData,
          token: completedEvent.payload.token,
          expiresAt: completedEvent.payload.expiresAt,
          error: void 0,
          retryCount: 0,
          deviceCodeSession: void 0
        };
        return [];
      }
    });
    retryAuthRule = defineRule({
      id: "auth.retry",
      description: "Retry authentication after failure",
      impl: (state2, events) => {
        const retryEvent = findEvent(events, RetryAuthEvent);
        if (!retryEvent) return [];
        if (state2.context.authState !== "failed") return [];
        if (state2.context.authData.retryCount >= DEFAULT_AUTH_CONFIG.maxRetryCount) {
          return [];
        }
        state2.context.authState = "authenticating";
        state2.context.authData = {
          ...state2.context.authData,
          lastAuthAttempt: Date.now(),
          error: void 0
        };
        return [];
      }
    });
    resetAuthRule = defineRule({
      id: "auth.reset",
      description: "Reset authentication state",
      impl: (state2, events) => {
        const resetEvent = findEvent(events, ResetAuthEvent);
        if (!resetEvent) return [];
        state2.context.authState = "idle";
        state2.context.authData = {
          connectionId: state2.context.authData.connectionId,
          authMethod: state2.context.authData.authMethod,
          retryCount: 0,
          token: void 0,
          expiresAt: void 0,
          error: void 0,
          deviceCodeSession: void 0
        };
        return [];
      }
    });
  }
});

// src/praxis/auth/engine.ts
function createAuthEngine(connectionId, authMethod, initialConfig) {
  const registry2 = new PraxisRegistry();
  registry2.registerRule(authenticateRule);
  registry2.registerRule(authSuccessRule);
  registry2.registerRule(authFailedRule);
  registry2.registerRule(logoutRule);
  registry2.registerRule(tokenExpiredRule);
  registry2.registerRule(deviceCodeStartedRule2);
  registry2.registerRule(deviceCodeCompletedRule2);
  registry2.registerRule(retryAuthRule);
  registry2.registerRule(resetAuthRule);
  return createPraxisEngine({
    initialContext: {
      authState: "idle",
      authData: {
        connectionId,
        authMethod,
        retryCount: 0,
        ...initialConfig
      }
    },
    registry: registry2,
    initialFacts: []
  });
}
var init_engine4 = __esm({
  "src/praxis/auth/engine.ts"() {
    "use strict";
    init_node();
    init_rules4();
  }
});

// src/praxis/auth/manager.ts
var PraxisAuthManager;
var init_manager3 = __esm({
  "src/praxis/auth/manager.ts"() {
    "use strict";
    init_types5();
    init_facts4();
    init_engine4();
    PraxisAuthManager = class {
      engine;
      isStarted = false;
      connectionId;
      authMethod;
      constructor(connectionId, authMethod, config) {
        this.connectionId = connectionId;
        this.authMethod = authMethod;
        this.engine = createAuthEngine(connectionId, authMethod, config);
      }
      start() {
        this.isStarted = true;
      }
      stop() {
        this.isStarted = false;
      }
      getAuthState() {
        return this.engine.getContext().authState;
      }
      getAuthData() {
        return this.engine.getContext().authData;
      }
      /**
       * Initiate authentication
       */
      authenticate(options) {
        if (!this.isStarted) return false;
        const currentState = this.getAuthState();
        if (currentState !== "idle" && currentState !== "failed") return false;
        this.engine.step([
          AuthenticateEvent.create({
            connectionId: this.connectionId,
            authMethod: this.authMethod,
            forceInteractive: options?.forceInteractive,
            tenantId: options?.tenantId,
            clientId: options?.clientId
          })
        ]);
        return this.getAuthState() === "authenticating";
      }
      /**
       * Handle successful authentication
       */
      authSuccess(token, expiresAt) {
        if (!this.isStarted) return false;
        if (this.getAuthState() !== "authenticating") return false;
        this.engine.step([AuthSuccessEvent.create({ token, expiresAt })]);
        return this.getAuthState() === "authenticated";
      }
      /**
       * Handle failed authentication
       */
      authFailed(error) {
        if (!this.isStarted) return false;
        if (this.getAuthState() !== "authenticating") return false;
        this.engine.step([AuthFailedEvent.create({ error })]);
        return this.getAuthState() === "failed";
      }
      /**
       * Logout and clear authentication
       */
      logout() {
        if (!this.isStarted) return false;
        if (this.getAuthState() !== "authenticated") return false;
        this.engine.step([LogoutEvent.create({})]);
        return this.getAuthState() === "idle";
      }
      /**
       * Handle token expiration
       */
      tokenExpired() {
        if (!this.isStarted) return false;
        if (this.getAuthState() !== "authenticated") return false;
        this.engine.step([TokenExpiredEvent.create({})]);
        return this.getAuthState() === "failed";
      }
      /**
       * Handle device code flow start
       */
      deviceCodeStarted(userCode, verificationUri, expiresInSeconds) {
        if (!this.isStarted) return false;
        if (this.getAuthState() !== "authenticating") return false;
        this.engine.step([
          DeviceCodeStartedEvent.create({
            userCode,
            verificationUri,
            expiresInSeconds
          })
        ]);
        return true;
      }
      /**
       * Handle device code flow completion
       */
      deviceCodeCompleted(token, expiresAt) {
        if (!this.isStarted) return false;
        if (this.getAuthState() !== "authenticating") return false;
        this.engine.step([DeviceCodeCompletedEvent.create({ token, expiresAt })]);
        return this.getAuthState() === "authenticated";
      }
      /**
       * Retry authentication after failure
       */
      retry() {
        if (!this.isStarted) return false;
        if (this.getAuthState() !== "failed") return false;
        const authData = this.getAuthData();
        if (authData.retryCount >= DEFAULT_AUTH_CONFIG.maxRetryCount) {
          return false;
        }
        this.engine.step([RetryAuthEvent.create({})]);
        return this.getAuthState() === "authenticating";
      }
      /**
       * Reset authentication state
       */
      reset() {
        if (!this.isStarted) return;
        this.engine.step([ResetAuthEvent.create({})]);
      }
      /**
       * Check if currently authenticated
       */
      isAuthenticated() {
        return this.getAuthState() === "authenticated";
      }
      /**
       * Check if authentication is in progress
       */
      isAuthenticating() {
        return this.getAuthState() === "authenticating";
      }
      /**
       * Check if there's an active device code session
       */
      hasDeviceCodeSession() {
        const authData = this.getAuthData();
        return !!authData.deviceCodeSession;
      }
      /**
       * Get the current token if authenticated
       */
      getToken() {
        if (!this.isAuthenticated()) return void 0;
        return this.getAuthData().token;
      }
      /**
       * Check if token is valid (not expired)
       */
      isTokenValid() {
        if (!this.isAuthenticated()) return false;
        const authData = this.getAuthData();
        if (!authData.expiresAt) return true;
        const bufferMs = 5 * 60 * 1e3;
        return Date.now() < authData.expiresAt - bufferMs;
      }
      /**
       * Get authentication snapshot
       */
      getSnapshot() {
        const authState = this.getAuthState();
        const authData = this.getAuthData();
        return {
          state: authState,
          connectionId: authData.connectionId,
          authMethod: authData.authMethod,
          isAuthenticated: authState === "authenticated",
          hasToken: !!authData.token,
          error: authData.error,
          lastAuthAttempt: authData.lastAuthAttempt
        };
      }
      /**
       * Get status information
       */
      getStatus() {
        return {
          isStarted: this.isStarted,
          authState: this.getAuthState(),
          authContext: this.getAuthData()
        };
      }
      /**
       * Validate that manager is in sync
       */
      validateSync() {
        return this.isStarted;
      }
      /**
       * Get the underlying engine for advanced operations
       */
      getEngine() {
        return this.engine;
      }
    };
  }
});

// src/praxis/application/manager.ts
var PraxisApplicationManager;
var init_manager4 = __esm({
  "src/praxis/application/manager.ts"() {
    "use strict";
    init_engine2();
    init_eventBus();
    init_manager2();
    init_manager3();
    init_manager();
    init_tracing2();
    init_TraceLogger();
    init_ComponentLogger();
    init_facts2();
    PraxisApplicationManager = class _PraxisApplicationManager {
      engine;
      traceRecorder;
      eventBus;
      isStarted = false;
      // Child engine managers (per connection)
      timerManager;
      authManagers = /* @__PURE__ */ new Map();
      connectionManagers = /* @__PURE__ */ new Map();
      // Event bus unsubscribe functions
      eventBusCleanup = [];
      // State change listeners
      listeners = [];
      static instance;
      static getInstance() {
        if (!_PraxisApplicationManager.instance) {
          _PraxisApplicationManager.instance = new _PraxisApplicationManager();
        }
        return _PraxisApplicationManager.instance;
      }
      static resetInstance() {
        if (_PraxisApplicationManager.instance) {
          _PraxisApplicationManager.instance.stop();
          _PraxisApplicationManager.instance = void 0;
        }
      }
      constructor(config) {
        if (_PraxisApplicationManager.instance) {
        } else {
          _PraxisApplicationManager.instance = this;
        }
        this.traceRecorder = new TraceRecorder();
        this.engine = createApplicationEngine(config, this.traceRecorder);
        this.eventBus = getPraxisEventBus();
        this.setupEventBusListeners();
      }
      /**
       * Set up event bus listeners for cross-engine coordination
       */
      setupEventBusListeners() {
        this.eventBusCleanup.push(
          this.eventBus.subscribe("timer:started", (_msg) => {
            this.syncTimerSnapshot();
          })
        );
        this.eventBusCleanup.push(
          this.eventBus.subscribe("timer:stopped", (_msg) => {
            this.syncTimerSnapshot();
          })
        );
        this.eventBusCleanup.push(
          this.eventBus.subscribe("timer:paused", () => {
            this.syncTimerSnapshot();
          })
        );
        this.eventBusCleanup.push(
          this.eventBus.subscribe("timer:resumed", () => {
            this.syncTimerSnapshot();
          })
        );
        this.eventBusCleanup.push(
          this.eventBus.subscribe("auth:success", (msg) => {
            if (msg.connectionId) {
              this.dispatch([AuthenticationSuccessEvent.create({ connectionId: msg.connectionId })]);
            }
          })
        );
        this.eventBusCleanup.push(
          this.eventBus.subscribe("auth:failed", (msg) => {
            if (msg.connectionId) {
              this.dispatch([
                AuthenticationFailedEvent.create({
                  connectionId: msg.connectionId,
                  error: String(msg.payload.error || "Authentication failed")
                })
              ]);
            }
          })
        );
        this.eventBusCleanup.push(
          this.eventBus.subscribe("connection:connected", (msg) => {
            this.syncConnectionSnapshot(msg.connectionId);
          })
        );
        this.eventBusCleanup.push(
          this.eventBus.subscribe("connection:disconnected", (msg) => {
            this.syncConnectionSnapshot(msg.connectionId);
          })
        );
        this.eventBusCleanup.push(
          this.eventBus.subscribe("connection:error", (msg) => {
            if (msg.connectionId) {
              this.dispatch([
                ApplicationErrorEvent.create({
                  error: String(msg.payload.error || "Connection error"),
                  connectionId: msg.connectionId
                })
              ]);
            }
          })
        );
      }
      /**
       * Sync timer snapshot to application context
       */
      syncTimerSnapshot() {
        if (!this.timerManager) return;
        const snapshot2 = this.timerManager.getTimerSnapshot();
        const ctx = this.engine.getContext();
        ctx.timerSnapshot = snapshot2;
      }
      /**
       * Sync connection snapshot to application context
       */
      syncConnectionSnapshot(connectionId) {
        const manager = this.connectionManagers.get(connectionId);
        if (!manager) return;
        const snapshot2 = manager.getSnapshot();
        const ctx = this.engine.getContext();
        ctx.connectionStates.set(connectionId, snapshot2);
      }
      handleEvent(event2) {
        this.dispatch([event2]);
      }
      /**
       * Dispatch typed events to the engine
       */
      dispatch(events) {
        const contextBefore = this.engine.getContext();
        const traceEnabled = Boolean(contextBefore.debugLoggingEnabled);
        if (traceEnabled) {
          this.traceRecorder.beginDispatch(events, contextBefore);
        }
        const result = this.engine.step(events);
        const contextAfter = this.engine.getContext();
        if (traceEnabled) {
          const entry = this.traceRecorder.completeDispatch(contextAfter, result?.diagnostics);
          if (entry) {
            this.engine.updateContext((ctx) => ({ ...ctx, debugTraceLog: this.traceRecorder.getEntries() }));
          }
        }
        if (!contextAfter.debugLoggingEnabled && this.traceRecorder.getEntries().length > 0) {
          this.traceRecorder.reset();
          this.engine.updateContext((ctx) => ({ ...ctx, debugTraceLog: [] }));
        }
        this.notifyListeners();
      }
      notifyListeners() {
        const context = this.engine.getContext();
        for (const listener of this.listeners) {
          try {
            listener(context);
          } catch (error) {
          }
        }
      }
      /**
       * Start the application orchestrator
       */
      start() {
        if (this.isStarted) return;
        this.isStarted = true;
        this.instrumentTracing();
        this.timerManager = new PraxisTimerManager();
        this.timerManager.start();
      }
      /**
       * Subscribe to state changes
       */
      subscribe(listener) {
        this.listeners.push(listener);
        return () => {
          this.listeners = this.listeners.filter((l) => l !== listener);
        };
      }
      /**
       * Instrument tracing
       */
      instrumentTracing() {
        instrumentActor(this.engine, "APPLICATION" /* APPLICATION */, "applicationMachine");
      }
      /**
       * Stop the application orchestrator
       */
      stop() {
        if (!this.isStarted) return;
        this.timerManager?.stop();
        for (const authManager of this.authManagers.values()) {
          authManager.stop();
        }
        this.authManagers.clear();
        for (const connManager of this.connectionManagers.values()) {
          connManager.stop();
        }
        this.connectionManagers.clear();
        for (const cleanup of this.eventBusCleanup) {
          cleanup();
        }
        this.eventBusCleanup = [];
        this.isStarted = false;
      }
      // =========================================================================
      // Lifecycle Methods
      // =========================================================================
      /**
       * Activate the application
       */
      activate(extensionContext) {
        if (!this.isStarted) return false;
        if (this.getApplicationState() !== "inactive") return false;
        this.dispatch([ActivateEvent.create({ extensionContext })]);
        return this.getApplicationState() === "activating";
      }
      /**
       * Complete activation
       */
      activationComplete() {
        if (!this.isStarted) return false;
        if (this.getApplicationState() !== "activating") return false;
        this.dispatch([ActivationCompleteEvent.create({})]);
        this.eventBus.emitApplicationEvent("app:activated", {});
        return this.getApplicationState() === "active";
      }
      /**
       * Handle activation failure
       */
      activationFailed(error) {
        if (!this.isStarted) return false;
        if (this.getApplicationState() !== "activating") return false;
        this.dispatch([ActivationFailedEvent.create({ error })]);
        return this.getApplicationState() === "activation_error";
      }
      /**
       * Deactivate the application
       */
      deactivate() {
        if (!this.isStarted) return false;
        const state2 = this.getApplicationState();
        if (state2 === "inactive" || state2 === "deactivating") return false;
        this.dispatch([DeactivateEvent.create({})]);
        return this.getApplicationState() === "deactivating";
      }
      /**
       * Complete deactivation
       */
      deactivationComplete() {
        if (!this.isStarted) return false;
        if (this.getApplicationState() !== "deactivating") return false;
        this.dispatch([DeactivationCompleteEvent.create({})]);
        this.eventBus.emitApplicationEvent("app:deactivated", {});
        return this.getApplicationState() === "inactive";
      }
      // =========================================================================
      // Connection Methods
      // =========================================================================
      /**
       * Load connections
       */
      loadConnections(connections3) {
        if (!this.isStarted) return;
        this.dispatch([ConnectionsLoadedEvent.create({ connections: connections3 })]);
        for (const conn of connections3) {
          if (!this.authManagers.has(conn.id)) {
            const authManager = new PraxisAuthManager(conn.id, conn.authMethod || "pat");
            authManager.start();
            this.authManagers.set(conn.id, authManager);
          }
          if (!this.connectionManagers.has(conn.id)) {
            const connManager = new PraxisConnectionManager(conn);
            connManager.start();
            this.connectionManagers.set(conn.id, connManager);
          }
        }
      }
      /**
       * Select a connection
       */
      selectConnection(connectionId) {
        if (!this.isStarted) return false;
        const ctx = this.engine.getContext();
        const exists = ctx.connections.some((c) => c.id === connectionId);
        if (!exists) return false;
        this.dispatch([ConnectionSelectedEvent.create({ connectionId })]);
        return this.getActiveConnectionId() === connectionId;
      }
      /**
       * Get the active connection ID
       */
      getActiveConnectionId() {
        return this.engine.getContext().activeConnectionId;
      }
      /**
       * Get all connections
       */
      getConnections() {
        return this.engine.getContext().connections;
      }
      /**
       * Get auth manager for a connection
       */
      getAuthManager(connectionId) {
        return this.authManagers.get(connectionId);
      }
      /**
       * Get connection manager for a connection
       */
      getConnectionManager(connectionId) {
        return this.connectionManagers.get(connectionId);
      }
      // =========================================================================
      // Query and View Methods
      // =========================================================================
      /**
       * Change the active query
       */
      setQuery(query, connectionId) {
        if (!this.isStarted) return;
        this.dispatch([QueryChangedEvent.create({ query, connectionId })]);
      }
      /**
       * Get the active query
       */
      getActiveQuery() {
        return this.engine.getContext().activeQuery;
      }
      /**
       * Change the view mode
       */
      setViewMode(viewMode) {
        if (!this.isStarted) return;
        this.dispatch([ViewModeChangedEvent.create({ viewMode })]);
      }
      /**
       * Toggle view mode
       */
      toggleViewMode() {
        if (!this.isStarted) return;
        const current = this.getViewMode();
        const next2 = current === "list" ? "board" : "list";
        this.setViewMode(next2);
      }
      /**
       * Get the current view mode
       */
      getViewMode() {
        return this.engine.getContext().viewMode;
      }
      // =========================================================================
      // Work Items Methods
      // =========================================================================
      /**
       * Handle work items loaded
       */
      workItemsLoaded(workItems, connectionId, query) {
        if (!this.isStarted) return;
        this.dispatch([WorkItemsLoadedEvent.create({ workItems, connectionId, query })]);
        this.eventBus.emitApplicationEvent(
          "workitems:loaded",
          { count: workItems.length, query },
          connectionId
        );
      }
      /**
       * Handle work items error
       */
      workItemsError(error, connectionId) {
        if (!this.isStarted) return;
        this.dispatch([WorkItemsErrorEvent.create({ error, connectionId })]);
        this.eventBus.emitApplicationEvent("workitems:error", { error }, connectionId);
      }
      /**
       * Handle device code flow
       */
      handleDeviceCode(connectionId, userCode, verificationUri, expiresIn) {
        if (!this.isStarted) return;
        this.dispatch([
          DeviceCodeStartedAppEvent.create({
            connectionId,
            userCode,
            verificationUri,
            expiresInSeconds: expiresIn
          })
        ]);
      }
      /**
       * Get work items for a connection
       */
      getWorkItems(connectionId) {
        const ctx = this.engine.getContext();
        const targetId = connectionId || ctx.activeConnectionId;
        if (!targetId) return [];
        return ctx.connectionWorkItems.get(targetId) || [];
      }
      // =========================================================================
      // Timer Methods (delegated to timer manager)
      // =========================================================================
      /**
       * Start timer for a work item
       */
      startTimer(workItemId, workItemTitle) {
        if (!this.timerManager) return false;
        const success = this.timerManager.startTimer(workItemId, workItemTitle);
        if (success) {
          this.eventBus.emitTimerEvent("timer:started", { workItemId, workItemTitle });
        }
        return success;
      }
      /**
       * Pause the timer
       */
      pauseTimer(manual = true) {
        if (!this.timerManager) return false;
        const success = this.timerManager.pauseTimer(manual);
        if (success) {
          this.eventBus.emitTimerEvent("timer:paused", { manual });
        }
        return success;
      }
      /**
       * Resume the timer
       */
      resumeTimer(fromActivity = false) {
        if (!this.timerManager) return false;
        const success = this.timerManager.resumeTimer(fromActivity);
        if (success) {
          this.eventBus.emitTimerEvent("timer:resumed", { fromActivity });
        }
        return success;
      }
      /**
       * Stop the timer
       */
      stopTimer() {
        if (!this.timerManager) return null;
        const result = this.timerManager.stopTimer();
        if (result) {
          this.eventBus.emitTimerEvent("timer:stopped", {
            workItemId: result.workItemId,
            hoursDecimal: result.hoursDecimal
          });
        }
        return result;
      }
      /**
       * Get timer manager
       */
      getTimerManager() {
        return this.timerManager;
      }
      // =========================================================================
      // Device Code Flow Methods
      // =========================================================================
      /**
       * Handle device code started
       */
      deviceCodeStarted(connectionId, userCode, verificationUri, expiresInSeconds) {
        if (!this.isStarted) return;
        this.dispatch([
          DeviceCodeStartedAppEvent.create({
            connectionId,
            userCode,
            verificationUri,
            expiresInSeconds
          })
        ]);
      }
      /**
       * Handle device code received
       */
      deviceCodeReceived(connectionId, userCode, verificationUri, expiresInSeconds) {
        if (!this.isStarted) return;
        this.dispatch([
          DeviceCodeStartedAppEvent.create({
            connectionId,
            userCode,
            verificationUri,
            expiresInSeconds
          })
        ]);
      }
      /**
       * Handle device code completed
       */
      deviceCodeCompleted(connectionId) {
        if (!this.isStarted) return;
        this.dispatch([DeviceCodeCompletedAppEvent.create({ connectionId })]);
      }
      /**
       * Get device code session
       */
      getDeviceCodeSession() {
        return this.engine.getContext().deviceCodeSession;
      }
      // =========================================================================
      // Error Handling Methods
      // =========================================================================
      /**
       * Report an error
       */
      reportError(error, connectionId) {
        if (!this.isStarted) return;
        this.dispatch([ApplicationErrorEvent.create({ error, connectionId })]);
        this.eventBus.emitApplicationEvent("app:error", { error }, connectionId);
      }
      /**
       * Retry after error
       */
      retry() {
        if (!this.isStarted) return false;
        if (this.getApplicationState() !== "activation_error") return false;
        this.dispatch([RetryApplicationEvent.create({})]);
        return this.getApplicationState() === "active";
      }
      /**
       * Reset application state
       */
      reset() {
        if (!this.isStarted) return;
        this.dispatch([ResetApplicationEvent.create({})]);
      }
      /**
       * Get last error
       */
      getLastError() {
        return this.engine.getContext().lastError;
      }
      // =========================================================================
      // Auth Reminder Methods
      // =========================================================================
      /**
       * Request auth reminder
       */
      requestAuthReminder(connectionId, reason, detail) {
        if (!this.isStarted) return;
        this.dispatch([AuthReminderRequestedEvent.create({ connectionId, reason, detail })]);
      }
      /**
       * Clear auth reminder
       */
      clearAuthReminder(connectionId) {
        if (!this.isStarted) return;
        this.dispatch([AuthReminderClearedEvent.create({ connectionId })]);
      }
      /**
       * Get pending auth reminders
       */
      getPendingAuthReminders() {
        return this.engine.getContext().pendingAuthReminders;
      }
      // =========================================================================
      // Debug Methods
      // =========================================================================
      /**
       * Toggle debug view
       */
      toggleDebugView(visible) {
        if (!this.isStarted) return;
        this.dispatch([ToggleDebugViewEvent.create({ debugViewVisible: visible })]);
      }
      /**
       * Get debug view visibility
       */
      isDebugViewVisible() {
        return this.engine.getContext().debugViewVisible;
      }
      // =========================================================================
      // State Access Methods
      // =========================================================================
      /**
       * Get the current application state
       */
      getApplicationState() {
        return this.engine.getContext().applicationState;
      }
      /**
       * Get the full application context
       */
      getContext() {
        return this.engine.getContext();
      }
      /**
       * Get application snapshot
       */
      getSnapshot() {
        const ctx = this.engine.getContext();
        const currentState = this.getApplicationState();
        return {
          state: currentState,
          // Expose the full context for compatibility with consumers that expect
          // an XState-style snapshot shape (activation bridge, webview handlers).
          context: ctx,
          isActivated: ctx.isActivated,
          connections: ctx.connections,
          activeConnectionId: ctx.activeConnectionId,
          hasActiveTimer: !!ctx.timerSnapshot?.running,
          connectionCount: ctx.connections.length,
          errorRecoveryAttempts: ctx.errorRecoveryAttempts,
          // Compatibility with XState consumers
          matches: (state2) => {
            if (typeof state2 !== "string") return false;
            if (state2 === currentState) return true;
            if (state2 === "activation_failed" && currentState === "activation_error") return true;
            if (currentState === "active" && state2.startsWith("active.")) return false;
            if (currentState === "active" && state2 === "active") return true;
            return false;
          }
        };
      }
      /**
       * Get status information
       */
      getStatus() {
        return {
          isStarted: this.isStarted,
          applicationState: this.getApplicationState(),
          connectionCount: this.getConnections().length,
          authManagerCount: this.authManagers.size,
          connectionManagerCount: this.connectionManagers.size,
          hasTimerManager: !!this.timerManager,
          eventBusSubscribers: this.eventBus.getSubscriberCount()
        };
      }
      /**
       * Validate that manager is in sync
       */
      validateSync() {
        return this.isStarted;
      }
      /**
       * Get the underlying engine for advanced operations
       */
      getEngine() {
        return this.engine;
      }
      /**
       * Get the event bus for external subscriptions
       */
      getEventBus() {
        return this.eventBus;
      }
      /**
       * Refresh data
       */
      refreshData(connectionId) {
        if (!this.isStarted) return;
        this.dispatch([RefreshDataEvent.create({ connectionId })]);
      }
      /**
       * Sign in with Entra
       */
      signInEntra(connectionId, forceInteractive) {
        if (!this.isStarted) return;
        this.dispatch([SignInEntraEvent.create({ connectionId, forceInteractive })]);
      }
      /**
       * Sign out Entra
       */
      signOutEntra(connectionId) {
        if (!this.isStarted) return;
        this.dispatch([SignOutEntraEvent.create({ connectionId })]);
      }
      // =========================================================================
      // UI Action Methods
      // =========================================================================
      /**
       * Create work item
       */
      createWorkItem(connectionId) {
        if (!this.isStarted) return;
        this.dispatch([CreateWorkItemEvent.create({ connectionId })]);
      }
      /**
       * Create branch
       */
      createBranch(connectionId, workItemId) {
        if (!this.isStarted) return;
        this.dispatch([CreateBranchEvent.create({ connectionId, workItemId })]);
      }
      /**
       * Create pull request
       */
      createPullRequest(connectionId, workItemId) {
        if (!this.isStarted) return;
        this.dispatch([CreatePullRequestEvent.create({ connectionId, workItemId })]);
      }
      /**
       * Show pull requests
       */
      showPullRequests(connectionId) {
        if (!this.isStarted) return;
        this.dispatch([ShowPullRequestsEvent.create({ connectionId })]);
      }
      /**
       * Show build status
       */
      showBuildStatus(connectionId) {
        if (!this.isStarted) return;
        this.dispatch([ShowBuildStatusEvent.create({ connectionId })]);
      }
      /**
       * Select team
       */
      selectTeam(connectionId) {
        if (!this.isStarted) return;
        this.dispatch([SelectTeamEvent.create({ connectionId })]);
      }
      /**
       * Reset preferred repositories
       */
      resetPreferredRepositories(connectionId) {
        if (!this.isStarted) return;
        this.dispatch([ResetPreferredRepositoriesEvent.create({ connectionId })]);
      }
      /**
       * Self test webview
       */
      selfTestWebview() {
        if (!this.isStarted) return;
        this.dispatch([SelfTestWebviewEvent.create({})]);
      }
      /**
       * Bulk assign
       */
      bulkAssign(connectionId, workItemIds) {
        if (!this.isStarted) return;
        this.dispatch([BulkAssignEvent.create({ connectionId, workItemIds })]);
      }
      /**
       * Generate Copilot prompt
       */
      generateCopilotPrompt(connectionId, workItemId) {
        if (!this.isStarted) return;
        this.dispatch([GenerateCopilotPromptEvent.create({ connectionId, workItemId })]);
      }
      /**
       * Show time report
       */
      showTimeReport(connectionId) {
        if (!this.isStarted) return;
        this.dispatch([ShowTimeReportEvent.create({ connectionId })]);
      }
      /**
       * Webview ready
       */
      webviewReady() {
        if (!this.isStarted) return;
        this.dispatch([WebviewReadyEvent.create({})]);
      }
      /**
       * Update connection state from external source
       */
      updateConnectionState(connectionId, state2) {
        if (!this.isStarted) return;
        this.dispatch([ConnectionStateUpdatedEvent.create({ connectionId, state: state2 })]);
      }
      /**
       * Authentication success
       */
      authenticationSuccess(connectionId) {
        if (!this.isStarted) return;
        this.dispatch([AuthenticationSuccessEvent.create({ connectionId })]);
        this.dispatch([AuthReminderClearedEvent.create({ connectionId })]);
      }
      /**
       * Authentication failed
       */
      authenticationFailed(connectionId, error) {
        if (!this.isStarted) return;
        this.dispatch([AuthenticationFailedEvent.create({ connectionId, error })]);
      }
      // =========================================================================
      // Timer Adapter Support Methods
      // =========================================================================
      /**
       * Record activity ping
       */
      activityPing() {
        this.timerManager?.activityPing();
      }
      /**
       * Get timer snapshot
       */
      getTimerSnapshot() {
        return this.timerManager?.getTimerSnapshot();
      }
      /**
       * Restore timer state
       */
      restoreTimer(workItemId, workItemTitle, startTime, isPaused) {
        return this.timerManager?.restoreTimer(workItemId, workItemTitle, startTime, isPaused) ?? false;
      }
      /**
       * Update elapsed limit
       */
      updateElapsedLimit(_hours) {
      }
      /**
       * Subscribe to timer updates
       */
      subscribeToTimer(callback) {
        const unsubscribe = this.eventBus.subscribeAll((message) => {
          if (message.type.startsWith("timer:")) {
            callback(this.getTimerSnapshot() ?? null);
          }
        });
        callback(this.getTimerSnapshot() ?? null);
        return unsubscribe;
      }
    };
  }
});

// src/stores/eventHandlers.ts
var eventHandlers;
var init_eventHandlers = __esm({
  "src/stores/eventHandlers.ts"() {
    "use strict";
    eventHandlers = {
      ACTIVATE: (manager) => manager.activate(),
      ACTIVATION_COMPLETE: (manager) => manager.activationComplete(),
      DEACTIVATE: (manager) => manager.deactivate(),
      EXTENSION_DEACTIVATED: (manager) => manager.deactivate(),
      CONNECTIONS_LOADED: (manager, event2) => {
        if (event2.connections && Array.isArray(event2.connections)) {
          manager.loadConnections(event2.connections);
        }
      },
      CONNECTION_SELECTED: (manager, event2) => {
        if (event2.connectionId) {
          manager.selectConnection(event2.connectionId);
        }
      },
      SELECT_CONNECTION: (manager, event2) => {
        if (event2.connectionId) {
          manager.selectConnection(event2.connectionId);
        }
      },
      AUTHENTICATION_REQUIRED: (manager, event2) => {
        if (event2.connectionId) {
          manager.requestAuthReminder(event2.connectionId, "Authentication required");
        }
      },
      AUTHENTICATION_SUCCESS: (manager, event2) => {
        if (event2.connectionId) {
          manager.authenticationSuccess(event2.connectionId);
        }
      },
      AUTHENTICATION_FAILED: (manager, event2) => {
        if (event2.connectionId && event2.error) {
          manager.authenticationFailed(event2.connectionId, event2.error);
        }
      },
      AUTH_REMINDER_CLEARED: (manager, event2) => {
        if (event2.connectionId) {
          manager.clearAuthReminder(event2.connectionId);
        }
      },
      CONNECTION_ESTABLISHED: (manager, event2) => {
        if (event2.connectionId) {
          if (event2.connectionState) {
            manager.updateConnectionState(event2.connectionId, event2.connectionState);
          }
          manager.selectConnection(event2.connectionId);
          manager.refreshData(event2.connectionId);
        }
      },
      WEBVIEW_READY: (manager) => {
        manager.webviewReady();
      },
      UPDATE_WEBVIEW_PANEL: (_manager, _event) => {
      },
      ERROR: (manager, event2) => {
        if (event2.error) {
          const err = event2.error;
          manager.reportError(err.message);
        }
      },
      RETRY: (manager) => manager.retry(),
      RESET: (manager) => manager.reset(),
      REFRESH_DATA: (manager, event2) => manager.refreshData(event2.connectionId),
      SIGN_IN_ENTRA: (manager, event2) => manager.signInEntra(event2.connectionId, event2.forceInteractive),
      SIGN_OUT_ENTRA: (manager, event2) => manager.signOutEntra(event2.connectionId),
      WORK_ITEMS_LOADED: (manager, event2) => {
        const connectionId = typeof event2.connectionId === "string" ? event2.connectionId : manager.getContext().activeConnectionId;
        if (!connectionId) {
          return;
        }
        const workItems = Array.isArray(event2.workItems) ? event2.workItems : [];
        const query = typeof event2.query === "string" ? event2.query : void 0;
        manager.workItemsLoaded(workItems, connectionId, query);
        if (event2.kanbanView === true) {
          manager.setViewMode("kanban");
        }
      },
      WORK_ITEMS_ERROR: (manager, event2) => {
        const connectionId = typeof event2.connectionId === "string" ? event2.connectionId : manager.getContext().activeConnectionId;
        if (!connectionId) {
          return;
        }
        const error = typeof event2.error === "string" ? event2.error : "Unknown error";
        manager.workItemsError(error, connectionId);
      },
      COMMENT_RESULT: (manager, event2) => {
        if (event2.success === false) {
          const errorMessage = typeof event2.error === "string" ? event2.error : "Comment operation failed";
          manager.reportError(errorMessage, event2.connectionId);
        }
      },
      TOGGLE_DEBUG_VIEW: (manager) => manager.toggleDebugView(),
      TOGGLE_VIEW: (manager) => manager.toggleViewMode(),
      PAUSE_TIMER: (manager) => manager.pauseTimer(),
      RESUME_TIMER: (manager) => manager.resumeTimer(),
      STOP_TIMER: (manager) => manager.stopTimer(),
      START_TIMER: (manager, event2) => {
        if (event2.workItemId && event2.title) {
          manager.startTimer(event2.workItemId, event2.title);
        }
      },
      // UI Events handled by activation.ts or webview, but passed through for tracing
      CREATE_WORK_ITEM: (manager, event2) => {
        if (event2.connectionId) {
          manager.createWorkItem(event2.connectionId);
        }
      },
      CREATE_BRANCH: (manager, event2) => {
        if (event2.connectionId) {
          manager.createBranch(event2.connectionId, event2.workItemId);
        }
      },
      CREATE_PULL_REQUEST: (manager, event2) => {
        if (event2.connectionId) {
          manager.createPullRequest(event2.connectionId, event2.workItemId);
        }
      },
      SHOW_PULL_REQUESTS: (manager, event2) => {
        if (event2.connectionId) {
          manager.showPullRequests(event2.connectionId);
        }
      },
      SHOW_BUILD_STATUS: (manager, event2) => {
        if (event2.connectionId) {
          manager.showBuildStatus(event2.connectionId);
        }
      },
      SELECT_TEAM: (manager, event2) => {
        if (event2.connectionId) {
          manager.selectTeam(event2.connectionId);
        }
      },
      RESET_PREFERRED_REPOSITORIES: (manager, event2) => {
        if (event2.connectionId) {
          manager.resetPreferredRepositories(event2.connectionId);
        }
      },
      SELF_TEST_WEBVIEW: (manager) => {
        manager.selfTestWebview();
      },
      BULK_ASSIGN: (manager, event2) => {
        if (event2.connectionId && Array.isArray(event2.workItemIds)) {
          manager.bulkAssign(event2.connectionId, event2.workItemIds);
        }
      },
      GENERATE_COPILOT_PROMPT: (manager, event2) => {
        if (event2.connectionId && event2.workItemId) {
          manager.generateCopilotPrompt(event2.connectionId, event2.workItemId);
        }
      },
      SHOW_TIME_REPORT: (manager, event2) => {
        if (event2.connectionId) {
          manager.showTimeReport(event2.connectionId);
        }
      },
      SET_CONNECTION_QUERY: (manager, event2) => {
        if (event2.query && typeof event2.query === "string") {
          manager.setQuery(event2.query, event2.connectionId);
        }
      },
      RESET_AUTH: (manager, event2) => {
        const connectionId = typeof event2.connectionId === "string" ? event2.connectionId : manager.getContext().activeConnectionId;
        if (connectionId) {
          manager.signOutEntra(connectionId);
        }
      },
      OPEN_SETTINGS: (_manager, _event) => {
      }
    };
  }
});

// src/webview/selection.writer.internal.ts
var selection_writer_internal_exports = {};
__export(selection_writer_internal_exports, {
  createSelectConnection: () => createSelectConnection,
  webviewOwner: () => webviewOwner
});
function createSelectConnection(_owner, id) {
  return {
    type: "SELECT_CONNECTION",
    origin: "webview",
    payload: {
      id,
      timestamp: Date.now(),
      correlationId: createCorrelationId()
    }
  };
}
function createCorrelationId() {
  return Math.random().toString(36).slice(2) + Date.now().toString(36);
}
var webviewOwner;
var init_selection_writer_internal = __esm({
  "src/webview/selection.writer.internal.ts"() {
    "use strict";
    webviewOwner = {};
  }
});

// src/stores/applicationStore.ts
var applicationStore_exports = {};
__export(applicationStore_exports, {
  actions: () => actions,
  activeConnectionId: () => activeConnectionId,
  applicationState: () => applicationState,
  applicationStore: () => applicationStore,
  connectionStates: () => connectionStates,
  connections: () => connections,
  dataError: () => dataError,
  debug: () => storeDebug,
  default: () => applicationStore_default,
  isActivated: () => isActivated,
  isDataLoading: () => isDataLoading,
  isDataSynced: () => isDataSynced,
  isDeactivating: () => isDeactivating,
  isInErrorRecovery: () => isInErrorRecovery,
  isInitializing: () => isInitializing,
  lastError: () => lastError,
  pendingAuthReminders: () => pendingAuthReminders,
  selectors: () => selectors,
  storeDebug: () => storeDebug,
  uiError: () => uiError,
  webviewReady: () => webviewReady
});
function handleApplicationEvent(manager, event2) {
  const handler = eventHandlers[event2.type];
  if (handler) {
    handler(manager, event2);
  } else {
    logger10.warn(
      `[applicationStore] Unknown event type: ${event2.type}`,
      { event: event2.type },
      event2
    );
  }
}
function createDerivedStores(engine) {
  return {
    connections: createDerivedStore(engine, (ctx) => ctx.connections || []),
    activeConnectionId: createDerivedStore(engine, (ctx) => ctx.activeConnectionId),
    connectionStates: createDerivedStore(engine, (ctx) => ctx.connectionStates || /* @__PURE__ */ new Map()),
    pendingAuthReminders: createDerivedStore(engine, (ctx) => ctx.pendingAuthReminders || /* @__PURE__ */ new Map()),
    isActivated: createDerivedStore(engine, (ctx) => ctx.isActivated ?? false),
    isDeactivating: createDerivedStore(engine, (ctx) => ctx.isDeactivating ?? false),
    lastError: createDerivedStore(engine, (ctx) => ctx.lastError)
  };
}
function createStateWrapper(manager) {
  return {
    value: manager.getApplicationState(),
    context: manager.getContext(),
    matches: (stateValue) => {
      const appState = manager.getApplicationState();
      if (appState === stateValue) return true;
      if (appState.includes(stateValue)) return true;
      if (stateValue === "activation_failed" && appState === "activation_error") return true;
      return false;
    },
    can: (_event) => true
  };
}
function createApplicationStore() {
  const applicationManager = PraxisApplicationManager.getInstance();
  applicationManager.start();
  const engine = applicationManager.getEngine();
  const praxisStore2 = createPraxisStore(engine);
  const contextStore = createContextStore(engine);
  const derivedStores = createDerivedStores(engine);
  const currentState = writable(null);
  const managerUnsubscribe = applicationManager.subscribe(() => {
    currentState.set(createStateWrapper(applicationManager));
  });
  const praxisUnsubscribe = praxisStore2.subscribe((praxisState) => {
    if (!praxisState) {
      currentState.set(null);
      return;
    }
    currentState.set(createStateWrapper(applicationManager));
  });
  const applicationState2 = readable(null, (set3) => {
    const unsubscribe = currentState.subscribe(set3);
    return () => {
      unsubscribe();
      praxisUnsubscribe();
      managerUnsubscribe();
      applicationManager.stop();
    };
  });
  function send(event2) {
    handleApplicationEvent(applicationManager, event2);
  }
  return {
    applicationState: applicationState2,
    send,
    get actor() {
      return applicationManager;
    },
    get praxisStore() {
      return praxisStore2;
    },
    get contextStore() {
      return contextStore;
    },
    get derivedStores() {
      return derivedStores;
    }
  };
}
var logger10, applicationStore, bridgeActor, isActivated, isInitializing, isDeactivating, connections, activeConnectionId, connectionStates, pendingAuthReminders, webviewReady, uiError, isDataLoading, isDataSynced, dataError, lastError, isInErrorRecovery, actions, selectors, storeDebug, applicationState, applicationStore_default;
var init_applicationStore = __esm({
  "src/stores/applicationStore.ts"() {
    "use strict";
    init_index_server();
    init_svelte();
    init_manager4();
    init_extensionHostBridge();
    init_eventHandlers();
    init_ComponentLogger();
    logger10 = createComponentLogger("APPLICATION" /* APPLICATION */, "applicationStore");
    applicationStore = createApplicationStore();
    bridgeActor = {
      // Delegate Praxis methods to the manager
      getApplicationState: () => applicationStore.actor.getApplicationState(),
      getContext: () => applicationStore.actor.getContext(),
      getSnapshot: () => applicationStore.actor.getSnapshot(),
      start: () => applicationStore.actor.start(),
      stop: () => applicationStore.actor.stop(),
      // Implement XState-compatible subscribe using the Svelte store
      subscribe: (callback) => {
        const unsubscribe = applicationStore.applicationState.subscribe((state2) => {
          if (state2) {
            callback(state2);
          }
        });
        return { unsubscribe };
      },
      // Delegate send
      send: (event2) => applicationStore.send(event2)
    };
    setApplicationStoreBridge({
      getActor: () => bridgeActor,
      send: (event2) => applicationStore.send(event2)
    });
    isActivated = applicationStore.derivedStores.isActivated;
    isInitializing = derived2(
      applicationStore.applicationState,
      ($state) => $state?.matches("activating") ?? false
    );
    isDeactivating = applicationStore.derivedStores.isDeactivating;
    connections = applicationStore.derivedStores.connections;
    activeConnectionId = applicationStore.derivedStores.activeConnectionId;
    connectionStates = applicationStore.derivedStores.connectionStates;
    pendingAuthReminders = applicationStore.derivedStores.pendingAuthReminders;
    webviewReady = derived2(
      applicationStore.applicationState,
      ($state) => $state?.matches("active.ui.ready") ?? false
    );
    uiError = derived2(
      applicationStore.applicationState,
      ($state) => $state?.matches("active.ui.ui_error") ?? false
    );
    isDataLoading = derived2(
      applicationStore.applicationState,
      ($state) => $state?.matches("active.data.loading") ?? false
    );
    isDataSynced = derived2(
      applicationStore.applicationState,
      ($state) => $state?.matches("active.data.synced") ?? false
    );
    dataError = derived2(
      applicationStore.applicationState,
      ($state) => $state?.matches("active.data.sync_error") ?? false
    );
    lastError = applicationStore.derivedStores.lastError;
    isInErrorRecovery = derived2(
      applicationStore.applicationState,
      ($state) => $state?.matches("error_recovery") ?? false
    );
    actions = {
      // Extension Lifecycle
      activate: (context) => applicationStore.send({ type: "ACTIVATE", context }),
      deactivate: () => applicationStore.send({ type: "DEACTIVATE" }),
      // Connection Management
      loadConnections: (connections3) => applicationStore.send({ type: "CONNECTIONS_LOADED", connections: connections3 }),
      selectConnection: async (connectionId) => {
        const vscodeApi = globalThis.__vscodeApi || globalThis.acquireVsCodeApi?.();
        if (vscodeApi && typeof vscodeApi.postMessage === "function") {
          try {
            const mod = await Promise.resolve().then(() => (init_selection_writer_internal(), selection_writer_internal_exports));
            const evt = mod.createSelectConnection(mod.webviewOwner, connectionId);
            vscodeApi.postMessage({ type: "appEvent", event: evt });
            return;
          } catch {
          }
        }
        applicationStore.send({ type: "CONNECTION_SELECTED", connectionId });
      },
      // Authentication
      requireAuthentication: (connectionId) => applicationStore.send({ type: "AUTHENTICATION_REQUIRED", connectionId }),
      authenticationSuccess: (connectionId) => applicationStore.send({ type: "AUTHENTICATION_SUCCESS", connectionId }),
      authenticationFailed: (connectionId, error) => applicationStore.send({ type: "AUTHENTICATION_FAILED", connectionId, error }),
      // UI Events
      webviewReady: () => applicationStore.send({ type: "WEBVIEW_READY" }),
      webviewMessage: (message) => applicationStore.send({ type: "WEBVIEW_MESSAGE", message }),
      // Error Handling
      reportError: (error) => applicationStore.send({ type: "ERROR", error }),
      retry: () => applicationStore.send({ type: "RETRY" }),
      reset: () => applicationStore.send({ type: "RESET" })
    };
    selectors = {
      // Get initialization status with detailed sub-state
      getInitializationStatus: derived2(applicationStore.applicationState, ($state) => {
        if (!$state) return { phase: "inactive", progress: 0 };
        if ($state.matches("inactive")) {
          return { phase: "inactive", progress: 0 };
        }
        if ($state.matches("activating")) {
          return { phase: "activating", progress: 25 };
        }
        if ($state.matches("active.ui.initializing")) {
          return { phase: "ui-setup", progress: 50 };
        }
        if ($state.matches("active.ui.ready") && !$state.matches("active.data.synced")) {
          return { phase: "loading-data", progress: 75 };
        }
        if ($state.matches("active.data.synced")) {
          return { phase: "ready", progress: 100 };
        }
        return { phase: "unknown", progress: 0 };
      }),
      // Get connection by ID
      getConnectionById: (connectionId) => derived2([connections, connectionStates], ([$connections, $connectionStates]) => {
        const config = $connections.find((c) => c.id === connectionId);
        const state2 = $connectionStates.get(connectionId);
        return config ? { ...config, state: state2 } : null;
      }),
      // Get auth reminders as array
      getAuthRemindersArray: derived2(
        pendingAuthReminders,
        ($reminders) => Array.from($reminders.values())
      ),
      // Check if can perform actions
      canActivate: derived2(
        applicationStore.applicationState,
        ($state) => $state?.can({ type: "ACTIVATE", context: null }) ?? false
      ),
      canDeactivate: derived2(
        applicationStore.applicationState,
        ($state) => $state?.can({ type: "DEACTIVATE" }) ?? false
      ),
      canRetry: derived2(
        applicationStore.applicationState,
        ($state) => $state?.can({ type: "RETRY" }) ?? false
      )
    };
    storeDebug = {
      // Get current state snapshot
      getSnapshot: () => {
        const manager = applicationStore.actor;
        return manager ? {
          value: manager.getApplicationState(),
          context: manager.getContext()
        } : null;
      },
      // Get state as string for logging
      getStateString: () => {
        const snapshot2 = storeDebug.getSnapshot();
        return snapshot2 ? JSON.stringify(snapshot2.value) : "not-started";
      },
      // Send arbitrary event (for testing)
      send: (event2) => applicationStore.send(event2),
      // Get full context (for debugging)
      getContext: () => {
        const snapshot2 = storeDebug.getSnapshot();
        return snapshot2 ? snapshot2.context : null;
      }
    };
    applicationState = applicationStore.applicationState;
    applicationStore_default = applicationStore;
  }
});

// src/commands/outputChannelReader.ts
var outputChannelReader_exports = {};
__export(outputChannelReader_exports, {
  OutputChannelReader: () => OutputChannelReader,
  getFSMLogsForDebugging: () => getFSMLogsForDebugging,
  registerOutputChannelReader: () => registerOutputChannelReader
});
async function getFSMLogsForDebugging(_context) {
  const reader = OutputChannelReader.getInstance();
  const recentLogs = reader.getRecentLogs(100);
  const stats = reader.getLogStats();
  const report = `
=== FSM Debug Log Report ===
Generated: ${(/* @__PURE__ */ new Date()).toISOString()}

=== Statistics ===
Total Logs: ${stats.totalLogs}
Active Components: ${stats.componentsActive.join(", ")}
Last Log: ${stats.lastLogTime || "None"}
Errors: ${stats.errorCount}
Warnings: ${stats.warningCount}

=== Recent Logs (Last 100) ===
${recentLogs.join("\n")}

=== End Report ===
`;
  return report;
}
function registerOutputChannelReader(context) {
  const reader = OutputChannelReader.getInstance();
  const disposable = vscode15.commands.registerCommand(
    "azureDevOpsInt.getFSMLogs",
    async (options) => {
      try {
        if (options?.format === "json") {
          return {
            logs: reader.getAllLogs(),
            stats: reader.getLogStats(),
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
        } else {
          return await getFSMLogsForDebugging(context);
        }
      } catch (error) {
        return `Error retrieving FSM logs: ${error}`;
      }
    }
  );
  context.subscriptions.push(disposable);
  const debugCommand = vscode15.commands.registerCommand("azureDevOpsInt.exportFSMLogs", async () => {
    try {
      const logs = await getFSMLogsForDebugging(context);
      const doc = await vscode15.workspace.openTextDocument({
        content: logs,
        language: "log"
      });
      await vscode15.window.showTextDocument(doc);
      vscode15.window.showInformationMessage("FSM logs exported to new document");
    } catch (error) {
      vscode15.window.showErrorMessage(`Failed to export FSM logs: ${error}`);
    }
  });
  context.subscriptions.push(debugCommand);
}
var vscode15, OutputChannelReader;
var init_outputChannelReader = __esm({
  "src/commands/outputChannelReader.ts"() {
    "use strict";
    vscode15 = __toESM(require("vscode"), 1);
    init_ComponentLogger();
    OutputChannelReader = class _OutputChannelReader {
      static instance;
      logBuffer = [];
      maxBufferSize = 1e3;
      // Keep last 1000 log entries
      constructor() {
        this.setupLogCapture();
      }
      static getInstance() {
        if (!_OutputChannelReader.instance) {
          _OutputChannelReader.instance = new _OutputChannelReader();
        }
        return _OutputChannelReader.instance;
      }
      /**
       * Setup log capture by intercepting FSM logger output
       */
      setupLogCapture() {
        const originalAppendLine = componentLogger.outputChannel?.appendLine?.bind(
          componentLogger.outputChannel
        );
        if (componentLogger.outputChannel && originalAppendLine) {
          componentLogger.outputChannel.appendLine = (value) => {
            this.logBuffer.push(`${(/* @__PURE__ */ new Date()).toISOString()} ${value}`);
            if (this.logBuffer.length > this.maxBufferSize) {
              this.logBuffer = this.logBuffer.slice(-this.maxBufferSize);
            }
            return originalAppendLine(value);
          };
        }
      }
      /**
       * Get recent logs
       */
      getRecentLogs(count = 50) {
        return this.logBuffer.slice(-count);
      }
      /**
       * Get all captured logs
       */
      getAllLogs() {
        return [...this.logBuffer];
      }
      /**
       * Get logs matching a pattern
       */
      getLogsMatching(pattern) {
        const regex = typeof pattern === "string" ? new RegExp(pattern, "i") : pattern;
        return this.logBuffer.filter((log2) => regex.test(log2));
      }
      /**
       * Get logs from the last N minutes
       */
      getLogsFromLastMinutes(minutes) {
        const cutoffTime = new Date(Date.now() - minutes * 60 * 1e3);
        return this.logBuffer.filter((log2) => {
          const timestamp2 = log2.substring(0, 24);
          try {
            const logTime = new Date(timestamp2);
            return logTime >= cutoffTime;
          } catch {
            return false;
          }
        });
      }
      /**
       * Export logs as formatted text
       */
      exportLogsAsText(filter2) {
        let logs = this.logBuffer;
        if (filter2) {
          if (filter2.lastMinutes) {
            logs = this.getLogsFromLastMinutes(filter2.lastMinutes);
          }
          if (filter2.component) {
            logs = logs.filter((log2) => log2.includes(`[${filter2.component}]`));
          }
          if (filter2.level) {
            const level = filter2.level;
            logs = logs.filter((log2) => log2.includes(level));
          }
          if (filter2.pattern) {
            const regex = typeof filter2.pattern === "string" ? new RegExp(filter2.pattern, "i") : filter2.pattern;
            logs = logs.filter((log2) => regex.test(log2));
          }
        }
        return logs.join("\n");
      }
      /**
       * Clear the log buffer
       */
      clearBuffer() {
        this.logBuffer = [];
      }
      /**
       * Get summary statistics about captured logs
       */
      getLogStats() {
        const components = /* @__PURE__ */ new Set();
        let errorCount = 0;
        let warningCount = 0;
        let lastLogTime;
        this.logBuffer.forEach((log2) => {
          const componentMatch = log2.match(/\[FSM\]\[([^\]]+)\]/);
          if (componentMatch) {
            components.add(componentMatch[1]);
          }
          if (log2.includes("ERROR")) errorCount++;
          if (log2.includes("WARN")) warningCount++;
          const timestamp2 = log2.substring(0, 24);
          if (timestamp2.includes("T")) {
            lastLogTime = timestamp2;
          }
        });
        return {
          totalLogs: this.logBuffer.length,
          componentsActive: Array.from(components),
          lastLogTime,
          errorCount,
          warningCount
        };
      }
    };
  }
});

// node_modules/ws/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
    var hasBlob = typeof Blob !== "undefined";
    if (hasBlob) BINARY_TYPES.push("blob");
    module2.exports = {
      BINARY_TYPES,
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      hasBlob,
      kForOnEventAttribute: /* @__PURE__ */ Symbol("kIsForOnEventAttribute"),
      kListener: /* @__PURE__ */ Symbol("kListener"),
      kStatusCode: /* @__PURE__ */ Symbol("status-code"),
      kWebSocket: /* @__PURE__ */ Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants2();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source2, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source2[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data)) return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source2, mask, output, offset, length) {
          if (length < 48) _mask(source2, mask, output, offset, length);
          else bufferUtil.mask(source2, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = /* @__PURE__ */ Symbol("kDone");
    var kRun = /* @__PURE__ */ Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib2 = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants2();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = /* @__PURE__ */ Symbol("permessage-deflate");
    var kTotalLength = /* @__PURE__ */ Symbol("total-length");
    var kCallback = /* @__PURE__ */ Symbol("callback");
    var kBuffers = /* @__PURE__ */ Symbol("buffers");
    var kError = /* @__PURE__ */ Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key2) => {
            let value = params[key2];
            if (value.length > 1) {
              throw new Error(`Parameter "${key2}" must have only a single value`);
            }
            value = value[0];
            if (key2 === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key2}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key2}": ${value}`
                );
              }
            } else if (key2 === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key2}": ${value}`
                );
              }
              value = num;
            } else if (key2 === "client_no_context_takeover" || key2 === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key2}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key2}"`);
            }
            params[key2] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key2 = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key2] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key2];
          this._inflate = zlib2.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key2 = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key2] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key2];
          this._deflate = zlib2.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib2.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      if (this[kError]) {
        this[kCallback](this[kError]);
        return;
      }
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var { hasBlob } = require_constants2();
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    function isBlob2(value) {
      return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
    }
    module2.exports = {
      isBlob: isBlob2,
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants2();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver2 = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length) return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored) cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
          cb(error);
          return;
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error);
            return;
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO) this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else if (this._binaryType === "blob") {
            data = new Blob(fragments);
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
              cb(error);
              return;
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(
          prefix ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module2.exports = Receiver2;
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants2();
    var { isBlob: isBlob2, isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = /* @__PURE__ */ Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var DEFAULT = 0;
    var DEFLATING = 1;
    var GET_BLOB_DATA = 2;
    var Sender2 = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions2, generateMask) {
        this._extensions = extensions2 || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._queue = [];
        this._state = DEFAULT;
        this.onerror = NOOP;
        this[kWebSocket] = void 0;
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge3 = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge3 = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge3 ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask) return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [target, data];
        if (merge3) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob2(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (isBlob2(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob2(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (isBlob2(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob2(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (isBlob2(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
          } else {
            this.getBlobData(data, this._compress, opts, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      }
      /**
       * Gets the contents of a blob as binary data.
       *
       * @param {Blob} blob The blob
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     the data
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      getBlobData(blob, compress, options, cb) {
        this._bufferedBytes += options[kByteLength];
        this._state = GET_BLOB_DATA;
        blob.arrayBuffer().then((arrayBuffer) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while the blob was being read"
            );
            process.nextTick(callCallbacks, this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          const data = toBuffer(arrayBuffer);
          if (!compress) {
            this._state = DEFAULT;
            this.sendFrame(_Sender.frame(data, options), cb);
            this.dequeue();
          } else {
            this.dispatch(data, compress, options, cb);
          }
        }).catch((err) => {
          process.nextTick(onError, this, err, cb);
        });
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._state = DEFLATING;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            callCallbacks(this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._state = DEFAULT;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (this._state === DEFAULT && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {(Buffer | String)[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender2;
    function callCallbacks(sender, err, cb) {
      if (typeof cb === "function") cb(err);
      for (let i = 0; i < sender._queue.length; i++) {
        const params = sender._queue[i];
        const callback = params[params.length - 1];
        if (typeof callback === "function") callback(err);
      }
    }
    function onError(sender, err, cb) {
      callCallbacks(sender, err, cb);
      sender.onerror(err);
    }
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants2();
    var kCode = /* @__PURE__ */ Symbol("kCode");
    var kData = /* @__PURE__ */ Symbol("kData");
    var kError = /* @__PURE__ */ Symbol("kError");
    var kMessage = /* @__PURE__ */ Symbol("kMessage");
    var kReason = /* @__PURE__ */ Symbol("kReason");
    var kTarget = /* @__PURE__ */ Symbol("kTarget");
    var kType = /* @__PURE__ */ Symbol("kType");
    var kWasClean = /* @__PURE__ */ Symbol("kWasClean");
    var Event2 = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type2) {
        this[kTarget] = null;
        this[kType] = type2;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event2.prototype, "target", { enumerable: true });
    Object.defineProperty(Event2.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event2 {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type2, options = {}) {
        super(type2);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event2 {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type2, options = {}) {
        super(type2);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event2 {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type2, options = {}) {
        super(type2);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget2 = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type2, handler, options = {}) {
        for (const listener of this.listeners(type2)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type2 === "message") {
          wrapper = function onMessage(data, isBinary2) {
            const event2 = new MessageEvent("message", {
              data: isBinary2 ? data : data.toString()
            });
            event2[kTarget] = this;
            callListener(handler, this, event2);
          };
        } else if (type2 === "close") {
          wrapper = function onClose(code, message) {
            const event2 = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event2[kTarget] = this;
            callListener(handler, this, event2);
          };
        } else if (type2 === "error") {
          wrapper = function onError(error) {
            const event2 = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event2[kTarget] = this;
            callListener(handler, this, event2);
          };
        } else if (type2 === "open") {
          wrapper = function onOpen() {
            const event2 = new Event2("open");
            event2[kTarget] = this;
            callListener(handler, this, event2);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type2, wrapper);
        } else {
          this.on(type2, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type2, handler) {
        for (const listener of this.listeners(type2)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type2, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event: Event2,
      EventTarget: EventTarget2,
      MessageEvent
    };
    function callListener(listener, thisArg, event2) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event2);
      } else {
        listener.call(thisArg, event2);
      }
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push2(dest, name3, elem) {
      if (dest[name3] === void 0) dest[name3] = [elem];
      else dest[name3].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            const name3 = header.slice(start, end);
            if (code === 44) {
              push2(offers, name3, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name3;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            push2(params, header.slice(start, end), true);
            if (code === 44) {
              push2(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1) start = i;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1) start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push2(params, paramName, value);
            if (code === 44) {
              push2(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push2(offers, token, params);
      } else {
        if (paramName === void 0) {
          push2(params, token, true);
        } else if (mustUnescape) {
          push2(params, paramName, token.replace(/\\/g, ""));
        } else {
          push2(params, paramName, token);
        }
        push2(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions2) {
      return Object.keys(extensions2).map((extension) => {
        let configurations = extensions2[extension];
        if (!Array.isArray(configurations)) configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values)) values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var https3 = require("https");
    var http5 = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes: randomBytes2, createHash: createHash2 } = require("crypto");
    var { Duplex, Readable: Readable2 } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver2 = require_receiver();
    var Sender2 = require_sender();
    var { isBlob: isBlob2 } = require_validation();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants2();
    var {
      EventTarget: { addEventListener: addEventListener2, removeEventListener: removeEventListener2 }
    } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = /* @__PURE__ */ Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class _WebSocket extends EventEmitter2 {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._errorEmitted = false;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._isServer = true;
        }
      }
      /**
       * For historical reasons, the custom "nodebuffer" type is used by the default
       * instead of "blob".
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type2) {
        if (!BINARY_TYPES.includes(type2)) return;
        this._binaryType = type2;
        if (this._receiver) this._receiver._binaryType = type2;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head2, options) {
        const receiver = new Receiver2({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        const sender = new Sender2(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._sender = sender;
        this._socket = socket;
        receiver[kWebSocket] = this;
        sender[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        sender.onerror = senderOnError;
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();
        if (head2.length > 0) socket.unshift(head2);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        setCloseTimer(this);
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener2;
    WebSocket2.prototype.removeEventListener = removeEventListener2;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      websocket._autoPong = opts.autoPong;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }
      if (parsedUrl.protocol === "http:") {
        parsedUrl.protocol = "ws:";
      } else if (parsedUrl.protocol === "https:") {
        parsedUrl.protocol = "wss:";
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key2 = randomBytes2(16).toString("base64");
      const request = isSecure ? https3.request : http5.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key2,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key3, value] of Object.entries(headers)) {
              options.headers[key3.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost) delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted]) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head2) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING) return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash2("sha1").update(key2 + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions2;
          try {
            extensions2 = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions2);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions2[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head2, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket._errorEmitted = true;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream4, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream4.setHeader) {
        stream4[kAborted] = true;
        stream4.abort();
        if (stream4.socket && !stream4.socket.destroyed) {
          stream4.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream4.destroy(err);
        stream4.once("error", websocket.emit.bind(websocket, "error"));
        stream4.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = isBlob2(data) ? data.size : toBuffer(data).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005) websocket.close();
      else websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused) websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary2) {
      this[kWebSocket].emit("message", data, isBinary2);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream4) {
      stream4.resume();
    }
    function senderOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket.readyState === WebSocket2.CLOSED) return;
      if (websocket.readyState === WebSocket2.OPEN) {
        websocket._readyState = WebSocket2.CLOSING;
        setCloseTimer(websocket);
      }
      this._socket.end();
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function setCloseTimer(websocket) {
      websocket._closeTimer = setTimeout(
        websocket._socket.destroy.bind(websocket._socket),
        closeTimeout
      );
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var WebSocket2 = require_websocket();
    var { Duplex } = require("stream");
    function emitClose(stream4) {
      stream4.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream2(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary2) {
        const data = !isBinary2 && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data)) ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused) ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream2;
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1) end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1) end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var http5 = require("http");
    var { Duplex } = require("stream");
    var { createHash: createHash2 } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket();
    var { GUID, kWebSocket } = require_constants2();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer2 = class extends EventEmitter2 {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http5.createServer((req, res) => {
            const body = http5.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head2) => {
              this.handleUpgrade(req, socket, head2, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index2 = req.url.indexOf("?");
          const pathname = index2 !== -1 ? req.url.slice(0, index2) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head2, cb) {
        socket.on("error", socketOnError);
        const key2 = req.headers["sec-websocket-key"];
        const upgrade = req.headers.upgrade;
        const version3 = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key2 === void 0 || !keyRegex.test(key2)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version3 !== 13 && version3 !== 8) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
            "Sec-WebSocket-Version": "13, 8"
          });
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions2 = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions2[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version3 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions2,
                key2,
                protocols,
                req,
                socket,
                head2,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions2, key2, protocols, req, socket, head2, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions2, key2, protocols, req, socket, head2, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash2("sha1").update(key2 + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions2[PerMessageDeflate.extensionName]) {
          const params = extensions2[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions2;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head2, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer2;
    function addListeners(server, map2) {
      for (const event2 of Object.keys(map2)) server.on(event2, map2[event2]);
      return function removeListeners() {
        for (const event2 of Object.keys(map2)) {
          server.removeListener(event2, map2[event2]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http5.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http5.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message, headers);
      }
    }
  }
});

// node_modules/ws/wrapper.mjs
var import_stream5, import_receiver, import_sender, import_websocket, import_websocket_server, wrapper_default;
var init_wrapper = __esm({
  "node_modules/ws/wrapper.mjs"() {
    import_stream5 = __toESM(require_stream(), 1);
    import_receiver = __toESM(require_receiver(), 1);
    import_sender = __toESM(require_sender(), 1);
    import_websocket = __toESM(require_websocket(), 1);
    import_websocket_server = __toESM(require_websocket_server(), 1);
    wrapper_default = import_websocket.default;
  }
});

// src/logging/LiveCanvasBridge.ts
var LiveCanvasBridge_exports = {};
__export(LiveCanvasBridge_exports, {
  LiveCanvasBridge: () => LiveCanvasBridge
});
var LiveCanvasBridge;
var init_LiveCanvasBridge = __esm({
  "src/logging/LiveCanvasBridge.ts"() {
    "use strict";
    init_wrapper();
    init_ComponentLogger();
    init_eventHandlers();
    LiveCanvasBridge = class {
      ws = null;
      reconnectTimer = null;
      isDisposed = false;
      url = "ws://localhost:3001";
      dispatcher;
      constructor(dispatcher) {
        this.dispatcher = dispatcher;
        this.connect();
        componentLogger.onLogEntry(this.handleLogEntry.bind(this));
      }
      connect() {
        if (this.isDisposed) return;
        try {
          this.ws = new wrapper_default(this.url);
          this.ws.on("open", () => {
            this.sendLogicInspection();
          });
          this.ws.on("error", (_err) => {
          });
          this.ws.on("close", () => {
            this.ws = null;
            if (!this.isDisposed) {
              this.scheduleReconnect();
            }
          });
          this.ws.on("message", (data) => {
            try {
              const msg = JSON.parse(data.toString());
              if (msg.type === "TRIGGER_EVENT") {
                this.handleTriggerEvent(msg);
              }
            } catch (e) {
            }
          });
        } catch {
          this.scheduleReconnect();
        }
      }
      scheduleReconnect() {
        if (this.reconnectTimer) clearTimeout(this.reconnectTimer);
        this.reconnectTimer = setTimeout(() => this.connect(), 5e3);
      }
      handleLogEntry(entry) {
        if (!this.ws || this.ws.readyState !== wrapper_default.OPEN) return;
        if (entry.message.startsWith("Event:")) {
          this.sendFsmEvent(entry);
        } else if (entry.message.startsWith("State transition:")) {
          this.sendStateChange(entry);
        } else {
          this.sendLogEntry(entry);
        }
      }
      sendFsmEvent(entry) {
        this.send({
          type: "FSM_EVENT",
          event: entry.context?.event || "unknown",
          payload: entry.data
        });
      }
      sendStateChange(entry) {
        this.send({
          type: "FSM_STATE_CHANGE",
          from: entry.message.split("\u2192")[0].replace("State transition:", "").trim(),
          to: entry.context?.state || "unknown",
          machine: entry.context?.machineId || entry.component
        });
      }
      sendLogEntry(entry) {
        this.send({
          type: "LOG_ENTRY",
          level: entry.level,
          component: entry.component,
          message: entry.message
        });
      }
      handleTriggerEvent(msg) {
        componentLogger.info(
          "APPLICATION" /* APPLICATION */,
          `Received remote trigger: ${msg.event}`,
          void 0,
          msg.payload
        );
        if (this.dispatcher) {
          this.dispatcher({
            type: msg.event,
            ...msg.payload
          });
        }
      }
      send(msg) {
        if (this.ws && this.ws.readyState === wrapper_default.OPEN) {
          this.ws.send(JSON.stringify(msg));
        }
      }
      sendLogicInspection() {
        const inspection = Object.entries(eventHandlers).map(([type2, handler]) => {
          const code = handler.toString();
          const cleanCode = code.replace(/\/\/.*$/gm, "").replace(/\/\*[\s\S]*?\*\//g, "").replace(/\s/g, "");
          const isUnhandled = cleanCode.endsWith("{}") || cleanCode.endsWith("{return;}") || cleanCode.endsWith("{returnundefined;}");
          return {
            type: type2,
            status: isUnhandled ? "unhandled" : "handled",
            snippet: code.length > 100 ? code.substring(0, 100) + "..." : code
          };
        });
        this.send({
          type: "LOGIC_INSPECTION",
          events: inspection
        });
      }
      dispose() {
        this.isDisposed = true;
        if (this.reconnectTimer) clearTimeout(this.reconnectTimer);
        if (this.ws) {
          this.ws.close();
          this.ws = null;
        }
      }
    };
  }
});

// src/services/router/stamp.ts
var stamp_exports = {};
__export(stamp_exports, {
  isConnectionShapedEvent: () => isConnectionShapedEvent,
  stampConnectionMeta: () => stampConnectionMeta
});
function isConnectionShapedEvent(type2) {
  return Boolean(type2 && CONNECTION_EVENT_TYPES.has(type2));
}
function stampConnectionMeta(event2, activeConnectionId3) {
  if (!event2 || !isConnectionShapedEvent(event2.type) || !activeConnectionId3) return event2;
  const meta = event2.meta ?? {};
  return {
    ...event2,
    meta: {
      ...meta,
      atConnectionId: activeConnectionId3,
      timestamp: Date.now(),
      correlationId: meta.correlationId ?? Math.random().toString(36).slice(2) + Date.now().toString(36)
    }
  };
}
var CONNECTION_EVENT_TYPES;
var init_stamp = __esm({
  "src/services/router/stamp.ts"() {
    "use strict";
    CONNECTION_EVENT_TYPES = /* @__PURE__ */ new Set([
      "AUTHENTICATION_REQUIRED",
      "TOKEN_EXPIRED",
      "RUN_QUERY",
      "DELETE_CONNECTION",
      "REFRESH",
      "REFRESH_DATA"
    ]);
  }
});

// src/activation.ts
var activation_exports = {};
__export(activation_exports, {
  __setTestContext: () => __setTestContext,
  activate: () => activate,
  buildMinimalWebviewHtml: () => buildMinimalWebviewHtml,
  clearConnectionState: () => clearConnectionState,
  clearSignedOutFlag: () => clearSignedOutFlag,
  deactivate: () => deactivate,
  dispatchApplicationEvent: () => dispatchApplicationEvent,
  forwardProviderMessage: () => forwardProviderMessage2,
  handleMessage: () => handleMessage,
  loadConnectionsFromConfig: () => loadConnectionsFromConfig2,
  markConnectionSignedOut: () => markConnectionSignedOut,
  migrateLegacyPAT: () => migrateLegacyPAT,
  panel: () => panel,
  resolveDefaultQuery: () => resolveDefaultQuery,
  updateAuthStatusBar: () => updateAuthStatusBar
});
module.exports = __toCommonJS(activation_exports);
function markConnectionSignedOut(connectionId) {
  recentlySignedOutConnections.add(connectionId);
  setTimeout(() => {
    recentlySignedOutConnections.delete(connectionId);
  }, 3e4);
}
function clearSignedOutFlag(connectionId) {
  recentlySignedOutConnections.delete(connectionId);
}
function clearConnectionState(connectionId) {
  connectionStates2.delete(connectionId);
  initialRefreshedConnections.delete(connectionId);
}
function shouldLogDebug2() {
  try {
    return Boolean(getConfig2().get("debugLogging"));
  } catch {
    return false;
  }
}
function __setTestContext(ctx) {
  if (ctx.panel) panel = ctx.panel;
  if (ctx.provider) provider = ctx.provider;
  if (ctx.client) client = ctx.client;
  if (ctx.activeConnectionId) activeConnectionId2 = ctx.activeConnectionId;
}
function handleMessage(message) {
  switch (message?.type) {
    case "openExternal": {
      if (message.url) {
        vscode16.env.openExternal(vscode16.Uri.parse(message.url));
      }
      break;
    }
    case "createBranch": {
      if (message.suggestedName) {
        vscode16.window.showInputBox({
          prompt: "Enter branch name",
          value: message.suggestedName,
          placeHolder: "feature/123-my-work-item"
        }).then((name3) => {
          if (name3) {
            vscode16.commands.executeCommand("git.branch", name3);
          }
        });
      }
      break;
    }
    case "getWorkItems": {
      const items = provider?.getWorkItems?.() || [];
      dispatchProviderMessage({
        type: "workItemsLoaded",
        workItems: items,
        connectionId: activeConnectionId2,
        query: getStoredQueryForConnection(activeConnectionId2)
      });
      break;
    }
    case "refresh": {
      try {
        if (activeConnectionId2) {
          const actor = getApplicationActor();
          const snapshot2 = actor?.getSnapshot?.();
          const connectionStates3 = snapshot2?.context?.connectionStates;
          const connectionState = connectionStates3?.get(activeConnectionId2);
          const activeProvider = connectionState?.provider;
          if (activeProvider && typeof activeProvider.refresh === "function") {
            const query = getStoredQueryForConnection(activeConnectionId2);
            activeProvider.refresh(query);
          } else if (provider) {
            provider.refresh(getStoredQueryForConnection(activeConnectionId2));
          } else {
          }
        }
      } catch (error) {
      }
      break;
    }
    case "addComment": {
      if (!message.comment) {
        dispatchApplicationEvent({
          type: "SHOW_COMPOSE_COMMENT",
          mode: "addComment",
          workItemId: message.workItemId
        });
        break;
      }
      handleMessage({ ...message, type: "submitComposeComment" });
      break;
    }
    case "submitComposeComment": {
      const { workItemId, comment: comment2, mode, timerData } = message;
      if (!client) {
        dispatchApplicationEvent({
          type: "COMMENT_RESULT",
          success: false,
          mode,
          workItemId,
          error: "No active client"
        });
        break;
      }
      const hoursDecimal = timerData?.hoursDecimal;
      (async () => {
        try {
          if (mode === "timerStop" && typeof hoursDecimal === "number") {
            const wi = await client.getWorkItemById?.(workItemId);
            const completed = Number(wi?.fields?.["Microsoft.VSTS.Scheduling.CompletedWork"] || 0);
            const remaining = Number(wi?.fields?.["Microsoft.VSTS.Scheduling.RemainingWork"] || 0);
            const newCompleted = completed + hoursDecimal;
            const newRemaining = Math.max(remaining - hoursDecimal, 0);
            await client.updateWorkItem?.(workItemId, [
              {
                op: "add",
                path: "/fields/Microsoft.VSTS.Scheduling.CompletedWork",
                value: newCompleted
              },
              {
                op: "add",
                path: "/fields/Microsoft.VSTS.Scheduling.RemainingWork",
                value: newRemaining
              }
            ]);
            const hoursStr = hoursDecimal.toFixed(2);
            const composed = comment2 ? `${comment2} (Logged ${hoursStr}h)` : `Logged ${hoursStr}h via timer stop.`;
            await client.addWorkItemComment?.(workItemId, composed);
            dispatchApplicationEvent({
              type: "COMMENT_RESULT",
              success: true,
              mode,
              workItemId,
              message: `Logged ${hoursStr}h and added comment`
            });
            return;
          }
          if (mode === "addComment") {
            if (comment2) {
              await client.addWorkItemComment?.(workItemId, comment2);
              dispatchApplicationEvent({
                type: "COMMENT_RESULT",
                success: true,
                mode,
                workItemId,
                message: "Comment added successfully"
              });
            } else {
              dispatchApplicationEvent({
                type: "SHOW_COMPOSE_COMMENT",
                mode: "addComment",
                workItemId
              });
            }
            return;
          }
          if (comment2) {
            await client.addWorkItemComment?.(workItemId, comment2);
          }
          dispatchApplicationEvent({
            type: "COMMENT_RESULT",
            success: true,
            mode,
            workItemId,
            message: "Comment added"
          });
        } catch (err) {
          dispatchApplicationEvent({
            type: "COMMENT_RESULT",
            success: false,
            mode,
            workItemId,
            error: String(err)
          });
        }
      })().catch((err) => {
        dispatchApplicationEvent({
          type: "COMMENT_RESULT",
          success: false,
          mode,
          workItemId,
          error: String(err)
        });
      });
      break;
    }
    default:
      break;
  }
}
async function migrateLegacyPAT(context) {
  try {
    const legacy = context.globalState.get("azureDevOpsInt.pat");
    if (legacy && legacy.trim().length > 0) {
      await context.secrets.store("azureDevOpsInt.pat", legacy);
      try {
        await context.globalState.update("azureDevOpsInt.pat", void 0);
      } catch {
      }
    }
  } catch {
  }
}
function buildMinimalWebviewHtml(context, webview, nonce) {
  const cfg = vscode16.workspace.getConfiguration("azureDevOpsIntegration");
  const enableSvelte = !!cfg.get("experimentalSvelteUI");
  const basePath = context.extensionPath;
  const sveltePath = path2.join(basePath, "media", "webview", "svelte-main.js");
  const scriptFile = enableSvelte && fs2.existsSync(sveltePath) ? "svelte-main.js" : "main.js";
  const scriptUri = webview.asWebviewUri(
    vscode16.Uri.joinPath(context.extensionUri, "media", "webview", scriptFile)
  );
  const mainCssUri = webview.asWebviewUri(
    vscode16.Uri.joinPath(context.extensionUri, "media", "webview", "main.css")
  );
  const csp = `default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; script-src 'nonce-${nonce}' 'unsafe-eval'; img-src ${webview.cspSource} data:; connect-src 'self';`;
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy" content="${csp}" />
  <link href="${mainCssUri}" rel="stylesheet" />
  <title>Work Items</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="azure-devops-integration" content="minimal-webview" />
</head>
<body>
  <div id="svelte-root"></div>
  <script type="module" nonce="${nonce}" src="${scriptUri}"></script>
</body>
</html>`;
}
function getApplicationActor() {
  const actor = getApplicationStoreActor();
  if (!actor || typeof actor !== "object") {
    return void 0;
  }
  return actor;
}
async function showEditDialog(item, client2, provider2) {
  const editableFields = [
    {
      id: "System.Title",
      label: "Title",
      value: item.fields?.["System.Title"] || "",
      type: "text"
    },
    {
      id: "System.State",
      label: "State",
      value: item.fields?.["System.State"] || "",
      type: "picklist",
      options: ["New", "Active", "Resolved", "Closed", "Removed"]
    },
    {
      id: "System.AssignedTo",
      label: "Assigned To",
      value: item.fields?.["System.AssignedTo"]?.displayName || item.fields?.["System.AssignedTo"] || "",
      type: "text"
    },
    {
      id: "System.Tags",
      label: "Tags",
      value: item.fields?.["System.Tags"] || "",
      type: "text"
    },
    {
      id: "System.Description",
      label: "Description",
      value: item.fields?.["System.Description"] || "",
      type: "multiline"
    }
  ];
  const fieldItems = editableFields.map((field2) => ({
    label: field2.label,
    description: `Current: ${field2.value}`,
    field: field2
  }));
  const selectedField = await vscode16.window.showQuickPick(fieldItems, {
    placeHolder: "Select field to edit",
    title: `Edit Work Item #${item.id}`
  });
  if (!selectedField) return;
  const field = selectedField.field;
  let newValue;
  if (field.type === "picklist") {
    const stateItems = (field.options || []).map((option) => ({
      label: option,
      picked: option === field.value
    }));
    const selectedState = await vscode16.window.showQuickPick(stateItems, {
      placeHolder: "Select new state",
      title: `Edit ${field.label}`
    });
    if (!selectedState) return;
    newValue = selectedState.label;
  } else if (field.type === "multiline") {
    newValue = await vscode16.window.showInputBox({
      prompt: `Enter new ${field.label}`,
      value: field.value,
      ignoreFocusOut: true
    });
  } else {
    newValue = await vscode16.window.showInputBox({
      prompt: `Enter new ${field.label}`,
      value: field.value,
      ignoreFocusOut: true
    });
  }
  if (newValue === void 0) return;
  try {
    const patches = [
      {
        op: "replace",
        path: `/fields/${field.id}`,
        value: newValue
      }
    ];
    const updatedItem = await client2.updateWorkItem(item.id, patches);
    if (updatedItem) {
      vscode16.window.showInformationMessage(
        `Successfully updated ${field.label} for work item #${item.id}`
      );
      provider2.refresh?.(getStoredQueryForConnection(activeConnectionId2));
    } else {
      vscode16.window.showErrorMessage(`Failed to update ${field.label} for work item #${item.id}`);
    }
  } catch (error) {
    vscode16.window.showErrorMessage(
      `Error updating work item: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
async function showCreateWorkItemDialog(client2, provider2, connectionId) {
  try {
    let workItemTypes = [];
    try {
      const types = await client2.getWorkItemTypes();
      workItemTypes = types.map((t) => t.name).filter((n) => n);
    } catch (error) {
    }
    if (workItemTypes.length === 0) {
      workItemTypes = ["Task", "Bug", "User Story", "Feature", "Epic"];
    }
    const selectedType = await vscode16.window.showQuickPick(workItemTypes, {
      placeHolder: "Select work item type",
      title: "Create Work Item"
    });
    if (!selectedType) return;
    const title = await vscode16.window.showInputBox({
      prompt: "Enter work item title",
      placeHolder: "Title",
      ignoreFocusOut: true,
      validateInput: (value) => {
        if (!value || value.trim().length === 0) {
          return "Title is required";
        }
        return null;
      }
    });
    if (!title) return;
    const description = await vscode16.window.showInputBox({
      prompt: "Enter work item description (optional)",
      placeHolder: "Description",
      ignoreFocusOut: true
    });
    const assignTo = await vscode16.window.showInputBox({
      prompt: "Assign to (optional, leave empty for unassigned)",
      placeHolder: "Email or display name",
      ignoreFocusOut: true
    });
    let iterationPath;
    try {
      if (typeof client2.getIterations === "function") {
        const iterations = await client2.getIterations();
        if (Array.isArray(iterations) && iterations.length > 0) {
          const iterationItems = iterations.map((i) => ({
            label: i.name,
            description: i.path,
            detail: i.attributes?.startDate ? `Start: ${new Date(i.attributes.startDate).toLocaleDateString()}` : void 0
          }));
          const selectedIteration = await vscode16.window.showQuickPick(iterationItems, {
            placeHolder: "Select Iteration (optional)",
            title: "Iteration"
          });
          if (selectedIteration) {
            iterationPath = selectedIteration.description;
          }
        }
      }
    } catch (error) {
    }
    const extraFields = {};
    if (iterationPath) {
      extraFields["System.IterationPath"] = iterationPath;
    }
    const createdItem = await client2.createWorkItem(
      selectedType,
      title.trim(),
      description?.trim(),
      assignTo?.trim() || void 0,
      extraFields
    );
    if (createdItem) {
      vscode16.window.showInformationMessage(
        `Successfully created ${selectedType} #${createdItem.id}: ${title}`
      );
      provider2.refresh?.(getStoredQueryForConnection(connectionId || activeConnectionId2));
    } else {
      vscode16.window.showErrorMessage(`Failed to create ${selectedType}`);
    }
  } catch (error) {
    vscode16.window.showErrorMessage(
      `Error creating work item: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
function dispatchApplicationEvent(event2) {
  if (event2 && typeof event2 === "object" && "type" in event2) {
    const evt = event2;
    switch (evt.type) {
      case "STOP_TIMER":
        (async () => {
          try {
            const appActor = getApplicationStoreActor();
            const snapshot2 = appActor?.getSnapshot?.();
            const timerState = snapshot2?.context?.timerState;
            if (!timerState?.workItemId || !timerState?.startTime) {
              vscode16.window.showWarningMessage("No active timer to stop");
              return;
            }
            const elapsed = Math.floor((Date.now() - timerState.startTime) / 1e3);
            const hours = (elapsed / 3600).toFixed(2);
            const comment2 = await vscode16.window.showInputBox({
              prompt: `Add comment for ${hours} hours logged on work item #${timerState.workItemId}`,
              placeHolder: "Optional: describe what you worked on..."
            });
            const timerActor = snapshot2?.context?.timerActor;
            if (timerActor && typeof timerActor.send === "function") {
              timerActor.send({ type: "STOP" });
            }
            if (client && timerState.workItemId) {
              try {
                const wi = await client.getWorkItemById(timerState.workItemId);
                const completed = Number(
                  wi?.fields?.["Microsoft.VSTS.Scheduling.CompletedWork"] || 0
                );
                const remaining = Number(
                  wi?.fields?.["Microsoft.VSTS.Scheduling.RemainingWork"] || 0
                );
                const hoursDecimal = Number(hours);
                await client.updateWorkItem(timerState.workItemId, [
                  {
                    op: "add",
                    path: "/fields/Microsoft.VSTS.Scheduling.CompletedWork",
                    value: completed + hoursDecimal
                  },
                  {
                    op: "add",
                    path: "/fields/Microsoft.VSTS.Scheduling.RemainingWork",
                    value: Math.max(remaining - hoursDecimal, 0)
                  }
                ]);
                const finalComment = comment2 ? `${comment2} (Logged ${hours}h)` : `Logged ${hours}h via timer stop.`;
                await client.addWorkItemComment(timerState.workItemId, finalComment);
                vscode16.window.showInformationMessage(
                  `Timer stopped. Logged ${hours} hours to work item #${timerState.workItemId}`
                );
              } catch (error) {
                vscode16.window.showErrorMessage(
                  `Timer stopped but failed to log time: ${error instanceof Error ? error.message : String(error)}`
                );
              }
            } else {
              vscode16.window.showInformationMessage(`Timer stopped. ${hours} hours elapsed.`);
            }
            if (snapshot2?.context?.extensionContext) {
              await snapshot2.context.extensionContext.globalState.update(
                "azureDevOpsInt.timer.state",
                void 0
              );
            }
          } catch (error) {
            vscode16.window.showErrorMessage(
              `Failed to stop timer: ${error instanceof Error ? error.message : String(error)}`
            );
          }
        })();
        break;
      case "EDIT_WORK_ITEM":
        try {
          if (evt.workItemId && client && provider) {
            const items = provider.getWorkItems?.() || [];
            const item = items.find((i) => i.id === evt.workItemId);
            if (item) {
              showEditDialog(item, client, provider);
            } else {
              vscode16.window.showErrorMessage("Work item not found");
            }
          } else {
            vscode16.window.showErrorMessage("Unable to edit work item: missing client or provider");
          }
        } catch (error) {
          vscode16.window.showErrorMessage(
            `Failed to edit work item: ${error instanceof Error ? error.message : String(error)}`
          );
        }
        break;
      case "CREATE_WORK_ITEM":
        try {
          if (client && provider) {
            showCreateWorkItemDialog(client, provider, activeConnectionId2);
          } else {
            vscode16.window.showErrorMessage(
              "Unable to create work item: missing client or provider"
            );
          }
        } catch (error) {
          vscode16.window.showErrorMessage(
            `Failed to create work item: ${error instanceof Error ? error.message : String(error)}`
          );
        }
        break;
      case "OPEN_IN_BROWSER":
      case "OPEN_WORK_ITEM":
        if (evt.workItemId && client) {
          const url2 = client.getBrowserUrl(`/_workitems/edit/${evt.workItemId}`);
          vscode16.env.clipboard.writeText(url2).then(
            () => {
              vscode16.window.showInformationMessage(`Work item URL copied to clipboard`);
            },
            (error) => {
            }
          );
          vscode16.env.openExternal(vscode16.Uri.parse(url2));
        }
        break;
      case "CREATE_BRANCH":
        (async () => {
          try {
            if (evt.workItemId) {
              const items = provider?.getWorkItems?.() || [];
              const item = items.find((i) => i.id === evt.workItemId);
              if (item) {
                const title = item.fields?.["System.Title"] || "";
                const branchName = `feature/${evt.workItemId}-${title.toLowerCase().replace(/[^a-z0-9]+/g, "-")}`;
                const name3 = await vscode16.window.showInputBox({
                  prompt: "Enter branch name",
                  value: branchName
                });
                if (name3) {
                  try {
                    await vscode16.commands.executeCommand("git.branch", name3);
                    if (client) {
                      const comment2 = `Created branch: ${name3}`;
                      const success = await client.addWorkItemComment(evt.workItemId, comment2);
                      if (success) {
                        vscode16.window.showInformationMessage(
                          `Branch "${name3}" created and linked to work item #${evt.workItemId}`
                        );
                      } else {
                        vscode16.window.showWarningMessage(
                          `Branch "${name3}" created but failed to link to work item #${evt.workItemId}`
                        );
                      }
                    } else {
                      vscode16.window.showInformationMessage(`Branch "${name3}" created`);
                    }
                  } catch (error) {
                    vscode16.window.showErrorMessage(
                      `Failed to create branch: ${error instanceof Error ? error.message : String(error)}`
                    );
                  }
                }
              } else {
                vscode16.window.showErrorMessage("Work item not found");
              }
            } else {
              vscode16.window.showErrorMessage("No work item ID provided for branch creation");
            }
          } catch (error) {
            vscode16.window.showErrorMessage(
              `Failed to create branch: ${error instanceof Error ? error.message : String(error)}`
            );
          }
        })();
        break;
    }
  }
  sendApplicationStoreEvent(event2);
}
async function ensureSharedContextBridge(context) {
  if (!sharedContextBridge) {
    if (!getApplicationActor()) {
      await Promise.resolve().then(() => (init_applicationStore(), applicationStore_exports));
    }
    const actor = getApplicationActor();
    if (!actor) {
      throw new Error("Application store actor not available");
    }
    sharedContextBridge = createSharedContextBridge({
      actor,
      logger: (message, meta) => {
      }
    });
    context.subscriptions.push(sharedContextBridge);
    context.subscriptions.push(
      new vscode16.Disposable(() => {
        sharedContextBridge = void 0;
      })
    );
  }
  return sharedContextBridge;
}
function getPendingAuthReminderMap() {
  const actor = getApplicationActor();
  if (!actor?.getSnapshot) {
    return /* @__PURE__ */ new Map();
  }
  try {
    const snapshot2 = actor.getSnapshot?.();
    const pending2 = snapshot2?.context?.pendingAuthReminders;
    if (pending2 instanceof Map) {
      return new Map(pending2);
    }
    if (Array.isArray(pending2)) {
      const normalized = pending2.filter(
        (entry) => Boolean(
          entry && typeof entry.connectionId === "string" && entry.connectionId.trim().length > 0
        )
      ).map((entry) => [entry.connectionId, entry]);
      return new Map(normalized);
    }
  } catch (error) {
  }
  return /* @__PURE__ */ new Map();
}
function describeConnection(connection) {
  if (connection.label && connection.label.trim().length > 0) {
    return connection.label;
  }
  const parts = [];
  if (connection.organization) parts.push(connection.organization);
  if (connection.project) parts.push(connection.project);
  if (parts.length > 0) {
    return parts.join("/");
  }
  return connection.id;
}
async function updateAuthStatusBar() {
  if (!authStatusBarItem) return;
  if (!activeConnectionId2) {
    try {
      const actor = getApplicationActor();
      const snapshot2 = actor?.getSnapshot?.();
      const numConnections = Array.isArray(snapshot2?.context?.connections) ? snapshot2.context.connections.length : 0;
      if (numConnections === 0) {
        authStatusBarItem.text = "$(plug) No connections";
        authStatusBarItem.tooltip = "Click to add an Azure DevOps connection";
        authStatusBarItem.backgroundColor = void 0;
        authStatusBarItem.command = "azureDevOpsInt.setup";
        authStatusBarItem.show();
      } else {
        authStatusBarItem.text = "$(plug) Select a connection";
        authStatusBarItem.tooltip = "Select an active connection";
        authStatusBarItem.backgroundColor = void 0;
        authStatusBarItem.command = "azureDevOpsInt.setup";
        authStatusBarItem.show();
      }
    } catch {
      authStatusBarItem.text = "$(plug) Azure DevOps";
      authStatusBarItem.tooltip = "Azure DevOps Integration";
      authStatusBarItem.backgroundColor = void 0;
      authStatusBarItem.command = "azureDevOpsInt.setup";
      authStatusBarItem.show();
    }
    return;
  }
  const state2 = connectionStates2.get(activeConnectionId2);
  let authMethod;
  let connectionConfig;
  if (!state2) {
    try {
      const actor = getApplicationActor();
      const snapshot2 = actor?.getSnapshot?.();
      const praxisConnectionStates = snapshot2?.context?.connectionStates;
      const praxisConnectionState = praxisConnectionStates?.get(activeConnectionId2);
      const connections3 = snapshot2?.context?.connections || [];
      connectionConfig = connections3.find((c) => c.id === activeConnectionId2);
      if (praxisConnectionState) {
        authMethod = praxisConnectionState.authMethod || praxisConnectionState.config?.authMethod || "pat";
      } else if (connectionConfig) {
        authMethod = connectionConfig.authMethod || "pat";
      } else {
        authStatusBarItem.hide();
        return;
      }
    } catch (error) {
      authStatusBarItem.hide();
      return;
    }
  } else {
    authMethod = state2.authMethod || state2.config?.authMethod || "pat";
    connectionConfig = state2.config;
  }
  authStatusBarItem.command = {
    title: "Sign in with Microsoft Entra",
    command: "azureDevOpsInt.signInWithEntra",
    arguments: [activeConnectionId2]
  };
  try {
    if (!connectionConfig) {
      try {
        const actor2 = getApplicationActor();
        const snapshot3 = actor2?.getSnapshot?.();
        const connections3 = snapshot3?.context?.connections || [];
        connectionConfig = connections3.find((c) => c.id === activeConnectionId2);
      } catch {
        authStatusBarItem.hide();
        return;
      }
    }
    if (!connectionConfig) {
      authStatusBarItem.hide();
      return;
    }
    const connectionLabel = describeConnection(connectionConfig);
    const actor = getApplicationActor();
    const snapshot2 = actor?.getSnapshot?.();
    const praxisConnectionStates = snapshot2?.context?.connectionStates;
    const praxisConnectionState = praxisConnectionStates?.get(activeConnectionId2);
    let connectionMachineState = null;
    try {
      const connectionService = ConnectionService.getInstance();
      const manager = connectionService.getConnectionManager(activeConnectionId2);
      connectionMachineState = manager?.getConnectionState() || null;
    } catch (error) {
    }
    const actualStateConnected = connectionMachineState === "connected";
    const hasClientAndProvider = Boolean(
      praxisConnectionState?.client || praxisConnectionState?.provider || state2?.client && state2?.provider
    );
    const isConnected = actualStateConnected && hasClientAndProvider;
    const stateMachineAuthFailed = connectionMachineState === "auth_failed" || connectionMachineState === "client_failed" || connectionMachineState === "provider_failed" || connectionMachineState === "connection_error";
    const remainingRetries = (typeof praxisConnectionState?.retryCount === "number" ? praxisConnectionState.retryCount : 0) < 3;
    const hasActiveDeviceCode = Boolean(
      snapshot2?.context?.deviceCodeSession?.connectionId === activeConnectionId2 && snapshot2?.context?.deviceCodeSession?.expiresAt > Date.now()
    );
    const hasActiveAuthCodeFlow = Boolean(
      snapshot2?.context?.authCodeFlowSession?.connectionId === activeConnectionId2 && snapshot2?.context?.authCodeFlowSession?.expiresAt > Date.now()
    );
    const isInteractiveAuth = connectionMachineState === "interactive_auth" || connectionMachineState === "checking_token" || connectionMachineState === "authenticating";
    const isConnecting = connectionMachineState === "authenticating" || connectionMachineState === "checking_token" || connectionMachineState === "interactive_auth" || connectionMachineState === "creating_client" || connectionMachineState === "creating_provider" || praxisConnectionState?.reauthInProgress === true;
    const isDisconnected = !connectionMachineState || connectionMachineState === "disconnected" || connectionMachineState === "idle";
    const treatAsConnecting = !isConnected && (isConnecting || stateMachineAuthFailed && remainingRetries || isDisconnected);
    if (treatAsConnecting) {
      if (authMethod === "entra") {
        authStatusBarItem.text = "$(sync~spin) Entra: Connecting...";
        authStatusBarItem.tooltip = `Connecting to ${connectionLabel}...`;
        authStatusBarItem.backgroundColor = new vscode16.ThemeColor(
          "statusBarItem.warningBackground"
        );
        authStatusBarItem.command = "azureDevOpsInt.signInWithEntra";
        authStatusBarItem.show();
        return;
      } else {
        authStatusBarItem.text = "$(sync~spin) PAT: Connecting...";
        authStatusBarItem.tooltip = `Connecting to ${connectionLabel}...`;
        authStatusBarItem.backgroundColor = new vscode16.ThemeColor(
          "statusBarItem.warningBackground"
        );
        authStatusBarItem.command = "azureDevOpsInt.setup";
        authStatusBarItem.show();
        return;
      }
    }
    if (hasActiveAuthCodeFlow && authMethod === "entra") {
      const remainingMs = Math.max(
        (snapshot2?.context?.authCodeFlowSession?.expiresAt || Date.now()) - Date.now(),
        0
      );
      const remainingMinutes = Math.ceil(remainingMs / 6e4);
      authStatusBarItem.text = "$(sync~spin) Entra: Signing In...";
      authStatusBarItem.tooltip = `Authorization code flow in progress for ${connectionLabel}. Complete sign-in in browser (${remainingMinutes}m remaining).`;
      authStatusBarItem.backgroundColor = new vscode16.ThemeColor("statusBarItem.warningBackground");
      authStatusBarItem.command = "azureDevOpsInt.signInWithEntra";
      authStatusBarItem.show();
    } else if (hasActiveDeviceCode || isInteractiveAuth && authMethod === "entra") {
      authStatusBarItem.text = "$(sync~spin) Entra: Device Code Active";
      authStatusBarItem.tooltip = `Device code authentication in progress for ${connectionLabel}`;
      authStatusBarItem.backgroundColor = new vscode16.ThemeColor("statusBarItem.warningBackground");
      authStatusBarItem.command = "azureDevOpsInt.signInWithEntra";
      authStatusBarItem.show();
    } else if (isConnected && !hasActiveDeviceCode && !hasActiveAuthCodeFlow) {
      if (authMethod === "entra") {
        authStatusBarItem.text = "$(pass) Entra: Connected";
        authStatusBarItem.tooltip = `Microsoft Entra ID authentication active for ${connectionLabel}`;
        authStatusBarItem.command = void 0;
      } else {
        authStatusBarItem.text = "$(key) PAT: Connected";
        authStatusBarItem.tooltip = `Personal Access Token authentication active for ${connectionLabel}`;
        authStatusBarItem.command = "azureDevOpsInt.setup";
      }
      authStatusBarItem.backgroundColor = void 0;
      authStatusBarItem.show();
    } else {
      if (stateMachineAuthFailed && !remainingRetries) {
        const authLabel = authMethod === "entra" ? "Entra" : "PAT";
        const errorMessage = praxisConnectionState?.lastError || state2?.lastError || (connectionMachineState === "auth_failed" ? "Authentication failed" : "Connection error");
        if (authMethod === "entra") {
          authStatusBarItem.text = "$(warning) Entra: Sign In Required";
          authStatusBarItem.tooltip = `${errorMessage}

Connection: ${connectionLabel}
Click to sign in.`;
          authStatusBarItem.command = "azureDevOpsInt.signInWithEntra";
          authStatusBarItem.backgroundColor = new vscode16.ThemeColor(
            "statusBarItem.warningBackground"
          );
          authStatusBarItem.show();
        } else {
          authStatusBarItem.text = `$(error) ${authLabel}: Auth Failed`;
          authStatusBarItem.tooltip = `${errorMessage}

Connection: ${connectionLabel}
Click to manage connections.`;
          authStatusBarItem.backgroundColor = new vscode16.ThemeColor(
            "statusBarItem.errorBackground"
          );
          authStatusBarItem.command = "azureDevOpsInt.setup";
          authStatusBarItem.show();
        }
      } else {
        if (authMethod === "entra") {
          authStatusBarItem.text = "$(sync~spin) Entra: Connecting...";
          authStatusBarItem.tooltip = `Connecting to ${connectionLabel}...`;
          authStatusBarItem.backgroundColor = new vscode16.ThemeColor(
            "statusBarItem.warningBackground"
          );
          authStatusBarItem.command = "azureDevOpsInt.signInWithEntra";
          authStatusBarItem.show();
        } else {
          authStatusBarItem.text = "$(warning) PAT: Auth Required";
          authStatusBarItem.tooltip = `Personal Access Token required for ${connectionLabel}. Click to manage connections.`;
          authStatusBarItem.command = "azureDevOpsInt.setup";
          authStatusBarItem.backgroundColor = new vscode16.ThemeColor(
            "statusBarItem.warningBackground"
          );
          authStatusBarItem.show();
        }
      }
    }
  } catch (error) {
    authStatusBarItem.hide();
  }
}
function notifyConnectionsList() {
  const actor = getApplicationActor();
  const send = actor?.send;
  if (!send) {
    return;
  }
  send({
    type: "CONNECTIONS_LOADED",
    connections: connections2.slice()
  });
  if (activeConnectionId2) {
    send({ type: "CONNECTION_SELECTED", connectionId: activeConnectionId2 });
  }
}
function clearAuthReminder(connectionId) {
  if (!connectionId) {
    return;
  }
  dispatchApplicationEvent({ type: "AUTH_REMINDER_CLEARED", connectionId });
  if (getPendingAuthReminderMap().size === 0) {
  }
}
function normalizeQuery(value) {
  if (typeof value !== "string") return void 0;
  const trimmed = value.trim();
  return trimmed.length > 0 ? trimmed : void 0;
}
function getStoredQueryForConnection(connectionId, fallback2) {
  const resolved = fallback2 ?? getDefaultQuery(getConfig2());
  const base = resolved && resolved.trim().length > 0 ? resolved : DEFAULT_QUERY2;
  if (!connectionId) {
    return base;
  }
  const stored = activeQueryByConnection.get(connectionId);
  if (stored && stored.trim().length > 0) {
    return stored;
  }
  try {
    const ctx = extensionContextRef2;
    const persisted = ctx?.globalState.get(ACTIVE_QUERY_STATE_KEY) || {};
    const persistedForConn = typeof persisted[connectionId] === "string" ? persisted[connectionId] : void 0;
    const normalized = normalizeQuery(persistedForConn);
    if (normalized) {
      activeQueryByConnection.set(connectionId, normalized);
      return normalized;
    }
  } catch {
  }
  activeQueryByConnection.set(connectionId, base);
  return base;
}
function setStoredQueryForConnection(connectionId, query) {
  const resolvedDefault = getDefaultQuery(getConfig2());
  const normalized = normalizeQuery(query) ?? resolvedDefault ?? DEFAULT_QUERY2;
  activeQueryByConnection.set(connectionId, normalized);
  try {
    const ctx = extensionContextRef2;
    if (ctx) {
      const current = ctx.globalState.get(ACTIVE_QUERY_STATE_KEY) || {};
      const next2 = { ...current, [connectionId]: normalized };
      void ctx.globalState.update(ACTIVE_QUERY_STATE_KEY, next2);
    }
  } catch {
  }
  return normalized;
}
async function ensureActiveConnection(context, connectionId, options = {}) {
  const prepared = await resolveActiveConnectionTarget(context, connectionId, options);
  if (!prepared) {
    return void 0;
  }
  const { connection } = prepared;
  if (recentlySignedOutConnections.has(connection.id)) {
    return void 0;
  }
  const connectionService = ConnectionService.getInstance();
  connectionService.setContext(context);
  const result = await connectionService.connect(connection, {
    refresh: options.refresh,
    interactive: options.interactive
  });
  if (result.success && result.client && result.provider) {
    const state2 = result.state;
    state2.id = connection.id;
    state2.config = connection;
    state2.authMethod = connection.authMethod || "pat";
    const settings = getConfig2();
    await finalizeConnectionSuccess(connection, state2, options, settings);
    return state2;
  }
  if (options.notify !== false && result.error) {
    const isAuthError = result.error.includes("invalid_grant") || result.error.includes("interaction_required") || result.error.includes("sign_in_required") || result.error.includes("Entra ID token acquisition failed");
    if (isAuthError) {
      const message = `Authentication failed for ${connection.label || connection.id}: ${result.error}`;
      vscode16.window.showErrorMessage(message);
    } else {
      vscode16.window.showErrorMessage(
        `Connection failed for ${connection.label || connection.id}: ${result.error}`
      );
    }
  }
  return void 0;
}
async function resolveActiveConnectionTarget(context, connectionId, options = {}) {
  await ensureConnectionsInitialized(context);
  const availableConnections = getLoadedConnections() || connections2;
  const targetId = connectionId ?? activeConnectionId2 ?? availableConnections[0]?.id;
  if (!targetId) {
    if (options.notify !== false) {
      notifyConnectionsList();
    }
    await vscode16.commands.executeCommand("setContext", "azureDevOpsInt.connected", false);
    provider = void 0;
    client = void 0;
    return void 0;
  }
  if (targetId !== activeConnectionId2) {
    activeConnectionId2 = targetId;
    await context.globalState.update(ACTIVE_CONNECTION_STATE_KEY, targetId);
    if (options.notify !== false) {
      notifyConnectionsList();
    }
  }
  const connection = availableConnections.find((item) => item.id === targetId);
  if (!connection) {
    return void 0;
  }
  return { connection, connectionId: targetId };
}
function configureProviderForConnection(connection, state2) {
  if (!state2.provider) {
    return;
  }
  const branchSource = { id: connection.id, client: state2.client };
  if (typeof state2.provider.updateClient === "function" && state2.client) {
    state2.provider.updateClient(state2.client);
  }
  state2.provider.setPostMessage?.((msg) => forwardProviderMessage2(connection.id, msg));
  state2.provider.setTransformWorkItems?.(createBranchAwareTransform(branchSource));
}
async function finalizeConnectionSuccess(connection, state2, options, settings) {
  connectionStates2.set(connection.id, state2);
  configureProviderForConnection(connection, state2);
  client = state2.client;
  provider = state2.provider;
  await vscode16.commands.executeCommand("setContext", "azureDevOpsInt.connected", true);
  await updateAuthStatusBar();
  if (options.refresh !== false && state2.provider) {
    const fallbackQuery = getDefaultQuery(settings);
    const selectedQuery = getStoredQueryForConnection(connection.id, fallbackQuery);
    if (!initialRefreshedConnections.has(connection.id)) {
      initialRefreshedConnections.add(connection.id);
    }
    state2.provider.refresh(selectedQuery);
  }
  const hadReminder = getPendingAuthReminderMap().has(connection.id);
  clearAuthReminder(connection.id);
  if ((state2.authMethod ?? "pat") === "entra" || hadReminder) {
    dispatchApplicationEvent({ type: "AUTHENTICATION_SUCCESS", connectionId: connection.id });
  }
  dispatchApplicationEvent({
    type: "CONNECTION_ESTABLISHED",
    connectionId: connection.id,
    connectionState: state2
  });
  return state2;
}
async function loadConnectionsFromConfig2(context) {
  const settings = getConfig2();
  const rawConnections = settings.get(CONNECTIONS_CONFIG_KEY) ?? [];
  const legacyOrganization = String(settings.get("organization") ?? "").trim();
  const legacyProject = String(settings.get("project") ?? "").trim();
  const legacyTeam = String(settings.get("team") ?? "").trim();
  const legacyFallback = legacyOrganization && legacyProject ? {
    organization: legacyOrganization,
    project: legacyProject,
    team: legacyTeam || void 0,
    label: void 0
  } : void 0;
  const {
    connections: normalized,
    requiresSave,
    summary
  } = normalizeConnections(rawConnections, legacyFallback);
  connections2 = normalized;
  if (requiresSave) {
    try {
      await settings.update(
        CONNECTIONS_CONFIG_KEY,
        normalized.map((entry) => ({ ...entry })),
        vscode16.ConfigurationTarget.Global
      );
    } catch (error) {
    }
  }
  if (connections2.length > 0) {
    try {
      await migrateGlobalPATToConnections(context, connections2);
    } catch (error) {
    }
  }
  const validIds = new Set(connections2.map((item) => item.id));
  for (const [id, state2] of connectionStates2.entries()) {
    if (!validIds.has(id)) {
      connectionStates2.delete(id);
      initialRefreshedConnections.delete(id);
      clearConnectionCaches(id);
    } else {
      const updated = connections2.find((item) => item.id === id);
      if (updated) {
        state2.config = updated;
      }
    }
  }
  for (const key2 of Array.from(activeQueryByConnection.keys())) {
    if (!validIds.has(key2)) {
      activeQueryByConnection.delete(key2);
    }
  }
  const persistedActive = context.globalState.get(ACTIVE_CONNECTION_STATE_KEY);
  const { activeConnectionId: resolvedActiveId, requiresPersistence } = resolveActiveConnectionId(
    persistedActive,
    connections2
  );
  activeConnectionId2 = resolvedActiveId;
  if (requiresPersistence) {
    await context.globalState.update(ACTIVE_CONNECTION_STATE_KEY, resolvedActiveId);
  }
  setLoadedConnectionsReader(() => connections2);
  setActiveConnectionIdReader(() => activeConnectionId2);
  setGetSecretPAT(async (extensionContext, connectionId) => {
    if (!connectionId) {
      return void 0;
    }
    const connection = connections2.find((c) => c.id === connectionId);
    if (!connection || !connection.patKey) {
      return void 0;
    }
    return await extensionContext.secrets.get(connection.patKey);
  });
  notifyConnectionsList();
  return connections2;
}
async function ensureConnectionsInitialized(context) {
  if (connections2.length === 0) await loadConnectionsFromConfig2(context);
  return connections2;
}
async function showDeviceCodeNotification(session) {
  const connection = connections2.find((c) => c.id === session.connectionId);
  const connectionLabel = connection ? describeConnection(connection) : "Microsoft Entra ID";
  const expiresMinutes = session.expiresInSeconds ? Math.max(1, Math.floor(session.expiresInSeconds / 60)) : void 0;
  const message = `Sign in to ${connectionLabel} with Microsoft Entra ID.

Use \u201CCopy Code\u201D to copy the code, \u201COpen Browser\u201D to launch the verification page, or \u201CCopy & Open\u201D to do both at once.

Go to ${session.verificationUri} and enter code:

${session.userCode}` + (expiresMinutes ? `

Code expires in ${expiresMinutes} minute${expiresMinutes === 1 ? "" : "s"}.` : "");
  const copyAndOpen = "Copy & Open";
  const openBrowser = "Open Browser";
  const copyCode = "Copy Code";
  const action2 = await vscode16.window.showInformationMessage(
    message,
    { modal: false },
    copyAndOpen,
    openBrowser,
    copyCode
  );
  try {
    if (action2 === "Copy & Open") {
      try {
        await vscode16.env.clipboard.writeText(session.userCode);
      } catch (error) {
      }
      await vscode16.env.openExternal(vscode16.Uri.parse(session.verificationUri));
      vscode16.window.showInformationMessage(
        `Device code ${session.userCode} copied to clipboard. Paste it into the browser to finish signing in.`
      );
      return;
    }
    if (action2 === "Copy Code") {
      await vscode16.env.clipboard.writeText(session.userCode);
      vscode16.window.showInformationMessage("Device code copied to clipboard.");
    }
    if (action2 === "Open Browser") {
      try {
        await vscode16.env.clipboard.writeText(session.userCode);
      } catch (error) {
      }
      await vscode16.env.openExternal(vscode16.Uri.parse(session.verificationUri));
      vscode16.window.showInformationMessage(
        `Device code ${session.userCode} copied to clipboard. Paste it into the browser to finish signing in.`
      );
    }
  } catch (error) {
  }
}
function isVSCodeTestRun() {
  try {
    return (process.argv || []).some(
      (a) => typeof a === "string" && (a.includes("--extensionTestsPath") || a.includes("integration-tests"))
    );
  } catch {
    return false;
  }
}
function getConfig2() {
  return vscode16.workspace.getConfiguration(CONFIG_NS);
}
function dispatchProviderMessage(message) {
  const messageType = message?.type;
  if (messageType === "workItemsLoaded") {
    const items = Array.isArray(message.workItems) ? [...message.workItems] : [];
    dispatchApplicationEvent({
      type: "WORK_ITEMS_LOADED",
      workItems: items,
      connectionId: typeof message.connectionId === "string" ? message.connectionId : void 0,
      query: typeof message.query === "string" ? message.query : void 0,
      kanbanView: !!message.kanbanView,
      types: Array.isArray(message.types) ? [...message.types] : void 0
    });
    setImmediate(() => {
      if (panel?.webview) {
        const appActor = getApplicationStoreActor();
        if (appActor) {
          let snapshot2 = void 0;
          if (typeof appActor.getApplicationState === "function") {
            const manager = appActor;
            const state2 = manager.getApplicationState();
            const context = manager.getContext();
            snapshot2 = { value: state2, context };
          } else if (typeof appActor.getSnapshot === "function") {
            snapshot2 = appActor.getSnapshot();
          }
          if (snapshot2) {
            const serializableState = {
              praxisState: snapshot2.value,
              context: getSerializableContext(snapshot2.context),
              matches: {}
              // Simplified matches for immediate sync
            };
            panel.webview.postMessage({
              type: "syncState",
              payload: serializableState
            });
          }
        }
      }
    });
    return;
  }
  if (messageType === "workItemsError") {
    try {
      const errorText = String(message.error ?? "");
      const connectionId = typeof message.connectionId === "string" ? message.connectionId : activeConnectionId2;
      if (connectionId) {
        const looksAuthFailure = /\b401\b/.test(errorText) || /authentication failed/i.test(errorText);
        if (looksAuthFailure) {
          dispatchApplicationEvent({
            type: "AUTHENTICATION_FAILED",
            connectionId,
            error: errorText
          });
        }
      }
    } catch {
    }
    return;
  }
}
function forwardProviderMessage2(connectionId, message) {
  if (message && typeof message === "object" && "type" in message) {
    dispatchProviderMessage({
      ...message,
      connectionId
    });
  } else {
    dispatchProviderMessage({
      type: "providerMessage",
      connectionId,
      message
    });
  }
}
function hasConfigOverride(metadata) {
  if (!metadata) return false;
  const overrideValues = [
    metadata.globalValue,
    metadata.workspaceValue,
    metadata.workspaceFolderValue,
    metadata.globalLanguageValue,
    metadata.workspaceLanguageValue,
    metadata.workspaceFolderLanguageValue
  ];
  return overrideValues.some((value) => value !== void 0);
}
function resolveDefaultQuery(_config) {
  const getValue = (key2) => {
    try {
      const raw = _config?.get(key2);
      if (typeof raw !== "string") return void 0;
      const trimmed = raw.trim();
      return trimmed.length > 0 ? trimmed : void 0;
    } catch {
      return void 0;
    }
  };
  const explicitDefault = getValue("defaultQuery");
  if (explicitDefault) return explicitDefault;
  const workItemQuery = getValue("workItemQuery");
  if (workItemQuery) {
    const inspectFn = typeof _config?.inspect === "function" ? _config.inspect.bind(_config) : void 0;
    if (!inspectFn) return workItemQuery;
    try {
      const metadata = inspectFn("workItemQuery");
      if (hasConfigOverride(metadata)) return workItemQuery;
    } catch {
      return workItemQuery;
    }
  }
  return DEFAULT_QUERY2;
}
function getDefaultQuery(config) {
  const target = config ?? getConfig2();
  return resolveDefaultQuery(target);
}
async function applyStartupPatches(context) {
  try {
    const patchState = context.globalState;
    const PATCH_VERSION_KEY = "azureDevOpsInt.appliedPatches";
    const appliedPatches = patchState.get(PATCH_VERSION_KEY, []);
    if (!appliedPatches.includes("1.0.0-clientid-removal")) {
      await applyClientIdRemovalPatch();
      appliedPatches.push("1.0.0-clientid-removal");
      await patchState.update(PATCH_VERSION_KEY, appliedPatches);
    }
  } catch (error) {
  }
}
async function applyClientIdRemovalPatch() {
  const config = vscode16.workspace.getConfiguration("azureDevOpsIntegration");
  const connections3 = config.get("connections", []);
  let patchedCount = 0;
  const patchedConnections = connections3.map((conn) => {
    if ("clientId" in conn) {
      patchedCount++;
      const { clientId, ...connWithoutClientId } = conn;
      return connWithoutClientId;
    }
    return conn;
  });
  if (patchedCount > 0) {
    await config.update("connections", patchedConnections, vscode16.ConfigurationTarget.Global);
  }
}
function getNonce() {
  let text2 = "";
  const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (let i = 0; i < 32; i++) {
    text2 += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text2;
}
async function activate(context) {
  rejectionHandler = (reason, promise) => {
    const isFromOurExtension = reason && typeof reason === "object" && "stack" in reason && typeof reason.stack === "string" && (reason.stack.includes("azuredevops-integration-extension") || reason.stack.includes("azureDevOpsInt") || reason.stack.includes("activation.ts") || reason.stack.includes("src\\praxis\\") || reason.stack.includes("src/praxis/"));
    if (!isFromOurExtension) {
      return;
    }
    if (reason && typeof reason === "object") {
      const isCancellation = "name" in reason && reason.name === "Canceled" || "message" in reason && reason.message === "Canceled" || reason.toString && reason.toString().includes("Canceled") || "stack" in reason && typeof reason.stack === "string" && reason.stack.includes("Canceled");
      if (isCancellation) {
        return;
      }
    }
    let errorInfo = reason;
    if (reason && typeof reason === "object") {
      errorInfo = {
        message: reason.message || reason.toString(),
        name: reason.name,
        stack: reason.stack,
        code: reason.code,
        errorCode: reason.errorCode,
        ...reason
      };
    } else if (reason !== void 0 && reason !== null) {
      errorInfo = { value: String(reason) };
    }
  };
  process.on("unhandledRejection", rejectionHandler);
  process.on("uncaughtException", (error) => {
  });
  extensionContextRef2 = context;
  setExtensionContextRef(context);
  ConnectionService.getInstance().setContext(context);
  try {
    const persistedQueries = context.globalState.get(ACTIVE_QUERY_STATE_KEY) || {};
    for (const [connId, q] of Object.entries(persistedQueries)) {
      if (typeof connId === "string" && typeof q === "string" && q.trim().length > 0) {
        activeQueryByConnection.set(connId, q.trim());
      }
    }
  } catch {
  }
  await applyStartupPatches(context);
  if (IS_SMOKE) {
    try {
      vscode16.commands.executeCommand("setContext", "azureDevOpsInt.connected", false).then(
        () => {
        },
        () => {
        }
      );
    } catch {
    }
    return void 0;
  }
  const cfg = getConfig2();
  if (cfg.get("debugLogging")) {
    const channel = getOutputChannel() ?? vscode16.window.createOutputChannel("Azure DevOps Integration");
    setOutputChannel(channel);
    standardizedLogger.info(
      "activation",
      "activation",
      "enableDebugLogging",
      "Debug logging enabled"
    );
    bridgeConsoleToOutputChannel();
  }
  statusBarItem = vscode16.window.createStatusBarItem(vscode16.StatusBarAlignment.Left, 100);
  statusBarItem.command = "azureDevOpsInt.stopTimer";
  context.subscriptions.push(statusBarItem);
  authStatusBarItem = vscode16.window.createStatusBarItem(vscode16.StatusBarAlignment.Left, 99);
  authStatusBarItem.command = "azureDevOpsInt.signInWithEntra";
  context.subscriptions.push(authStatusBarItem);
  authStatusBarItem.text = "$(plug) Azure DevOps";
  authStatusBarItem.tooltip = "Azure DevOps Integration";
  authStatusBarItem.backgroundColor = void 0;
  authStatusBarItem.command = "azureDevOpsInt.setup";
  authStatusBarItem.show();
  globalThis.__updateAuthStatusBar = updateAuthStatusBar;
  const pendingAuthProviders = /* @__PURE__ */ new Map();
  globalThis.__pendingAuthProviders = pendingAuthProviders;
  const uriHandler = vscode16.window.registerUriHandler({
    handleUri: async (uri) => {
      try {
        if (uri.scheme !== "vscode-azuredevops-int") {
          return;
        }
        if (uri.path === "/auth/callback") {
          await handleAuthRedirect(uri, context, pendingAuthProviders);
        }
      } catch (error) {
        vscode16.window.showErrorMessage(`Authentication error: ${error.message}`);
      }
    }
  });
  context.subscriptions.push(uriHandler);
  await ensureSharedContextBridge(context);
  if (!viewProviderRegistered) {
    context.subscriptions.push(
      vscode16.window.registerWebviewViewProvider(
        "azureDevOpsWorkItems",
        new AzureDevOpsIntViewProvider(context),
        { webviewOptions: { retainContextWhenHidden: true } }
      )
    );
    viewProviderRegistered = true;
  }
  registerTraceCommands(context);
  registerQuickDebugCommands(context);
  registerHistoryDebugCommands(context);
  registerTestGeneratorCommands(context);
  Promise.resolve().then(() => (init_outputChannelReader(), outputChannelReader_exports)).then(({ registerOutputChannelReader: registerOutputChannelReader2 }) => {
    registerOutputChannelReader2(context);
  }).catch((error) => {
  });
  Promise.resolve().then(() => (init_TraceLogger(), TraceLogger_exports)).then(({ startTraceSession: startTraceSession3 }) => {
    try {
      const sessionId = startTraceSession3("Extension Activation - Auto Debug Session");
      Promise.resolve().then(() => (init_ComponentLogger(), ComponentLogger_exports)).then(({ componentLogger: componentLogger3, Component: Component2 }) => {
        componentLogger3.showOutputChannel();
        componentLogger3.info(Component2.APPLICATION, "Extension activation started", {
          component: Component2.APPLICATION,
          event: "ACTIVATE",
          state: "activating"
        });
      }).catch((error) => {
      });
    } catch (error) {
    }
  }).catch((error) => {
  });
  Promise.resolve().then(() => (init_LiveCanvasBridge(), LiveCanvasBridge_exports)).then(({ LiveCanvasBridge: LiveCanvasBridge2 }) => {
    try {
      const bridge = new LiveCanvasBridge2(dispatchApplicationEvent);
      context.subscriptions.push({ dispose: () => bridge.dispose() });
    } catch (error) {
    }
  }).catch((error) => {
  });
  const appActor = getApplicationStoreActor();
  if (appActor && typeof appActor.send === "function") {
    appActor.send({ type: "ACTIVATE", context });
    loadConnectionsFromConfig2(context).then((loadedConnections) => {
      appActor.send({ type: "CONNECTIONS_LOADED", connections: loadedConnections });
      if (activeConnectionId2) {
        appActor.send({ type: "CONNECTION_SELECTED", connectionId: activeConnectionId2 });
        ensureActiveConnection(context, activeConnectionId2, {
          refresh: true,
          notify: true
          // Ensure errors are shown on startup
        }).catch((err) => {
        });
      }
      appActor.send({ type: "ACTIVATION_COMPLETE" });
    }).catch((error) => {
      appActor.send({ type: "ERROR", error });
    });
  }
  let previousDeviceCodeSession = void 0;
  let lastDeviceCodeNotificationKey = void 0;
  if (appActor && typeof appActor.subscribe === "function") {
    appActor.subscribe((snapshot2) => {
      const praxisActiveConnectionId = snapshot2?.context?.activeConnectionId;
      if (praxisActiveConnectionId !== activeConnectionId2) {
        const previousActiveConnectionId = activeConnectionId2;
        activeConnectionId2 = praxisActiveConnectionId;
        setImmediate(() => {
          updateAuthStatusBar().catch((err) => {
          });
        });
        try {
          if (extensionContextRef2 && activeConnectionId2) {
            if (recentlySignedOutConnections.has(activeConnectionId2)) {
            } else {
              const connectionService = ConnectionService.getInstance();
              const manager = connectionService.getConnectionManager(activeConnectionId2);
              const stateValue = manager?.getConnectionState() || null;
              const targetState = connectionStates2.get(activeConnectionId2);
              const hasProvider = !!targetState?.provider;
              const isConnected = stateValue === "connected" || targetState && targetState.isConnected === true;
              if (!hasProvider || !isConnected) {
                ensureActiveConnection(extensionContextRef2, activeConnectionId2, {
                  refresh: true,
                  interactive: true
                }).catch((err) => {
                });
              }
            }
          }
        } catch (err) {
        }
      }
      const currentDeviceCodeSession = snapshot2?.context?.deviceCodeSession;
      const deviceCodeSessionChanged = currentDeviceCodeSession?.connectionId !== previousDeviceCodeSession?.connectionId || currentDeviceCodeSession?.expiresAt !== previousDeviceCodeSession?.expiresAt;
      if (deviceCodeSessionChanged && currentDeviceCodeSession) {
        setImmediate(() => {
          updateAuthStatusBar().catch((err) => {
            dispatchApplicationEvent(
              ApplicationErrorEvent.create({
                error: `Failed to update status bar after device code session change: ${err instanceof Error ? err.message : String(err)}`
              })
            );
          });
        });
        const sessionKey = `${currentDeviceCodeSession.connectionId}:${currentDeviceCodeSession.expiresAt}`;
        if (sessionKey !== lastDeviceCodeNotificationKey) {
          lastDeviceCodeNotificationKey = sessionKey;
          setImmediate(() => {
            showDeviceCodeNotification({
              connectionId: currentDeviceCodeSession.connectionId,
              userCode: currentDeviceCodeSession.userCode,
              verificationUri: currentDeviceCodeSession.verificationUri,
              expiresInSeconds: currentDeviceCodeSession.expiresInSeconds
            }).catch((err) => {
            });
          });
        }
      }
      previousDeviceCodeSession = currentDeviceCodeSession ? {
        connectionId: currentDeviceCodeSession.connectionId,
        expiresAt: currentDeviceCodeSession.expiresAt
      } : void 0;
      if (!currentDeviceCodeSession) {
        lastDeviceCodeNotificationKey = void 0;
      }
      if (panel && snapshot2) {
        const state2 = snapshot2.value;
        const matchesFn = (stateValue) => {
          if (typeof stateValue === "string") {
            return state2 === stateValue || typeof state2 === "string" && state2.includes(stateValue);
          }
          if (typeof stateValue === "object" && stateValue !== null) {
            const key2 = Object.keys(stateValue)[0];
            const subValue = stateValue[key2];
            if (typeof state2 === "string") {
              if (state2 === key2) return false;
              if (typeof subValue === "string") {
                return state2 === `${key2}.${subValue}` || state2.startsWith(`${key2}.${subValue}.`);
              }
              return false;
            }
            if (typeof state2 === "object" && state2 !== null) {
              const stateSubValue = state2[key2];
              if (stateSubValue === subValue) return true;
              if (typeof subValue === "string" && typeof stateSubValue === "object" && stateSubValue !== null) {
                return Object.keys(stateSubValue)[0] === subValue;
              }
              return false;
            }
          }
          return false;
        };
        const matches = {
          // Top-level states
          inactive: matchesFn("inactive"),
          activating: matchesFn("activating"),
          activation_failed: matchesFn("activation_failed"),
          active: matchesFn("active"),
          error_recovery: matchesFn("error_recovery"),
          deactivating: matchesFn("deactivating"),
          // Active sub-states
          "active.setup": matchesFn({ active: "setup" }),
          "active.setup.loading_connections": matchesFn({
            active: { setup: "loading_connections" }
          }),
          "active.setup.waiting_for_panel": matchesFn({
            active: { setup: "waiting_for_panel" }
          }),
          "active.setup.panel_ready": matchesFn({ active: { setup: "panel_ready" } }),
          "active.setup.setup_error": matchesFn({ active: { setup: "setup_error" } }),
          // Active.ready sub-states
          "active.ready": matchesFn({ active: "ready" }),
          "active.ready.idle": matchesFn({ active: { ready: "idle" } }),
          "active.ready.loadingData": matchesFn({ active: { ready: "loadingData" } }),
          "active.ready.managingConnections": matchesFn({
            active: { ready: "managingConnections" }
          }),
          "active.ready.error": matchesFn({ active: { ready: "error" } })
        };
        const serializableState = {
          praxisState: snapshot2.value,
          context: getSerializableContext(snapshot2.context),
          matches
          // Include pre-computed state matches
        };
        const signature = JSON.stringify(serializableState);
        if (signature === lastStateSignature) {
          return;
        }
        lastStateSignature = signature;
        if (shouldLogDebug2()) {
        }
        panel.webview.postMessage({
          type: "syncState",
          payload: serializableState
        });
        try {
          const snapCtx = snapshot2.context;
          const newQuery = snapCtx?.activeQuery;
          const newConn = snapCtx?.activeConnectionId;
          if (newConn && typeof newQuery === "string") {
            const changed = newConn !== lastQueriedActiveConnectionId || newQuery !== lastQueriedQuery;
            if (changed) {
              setStoredQueryForConnection(newConn, newQuery);
              const targetState = connectionStates2.get(newConn);
              const targetProvider = targetState?.provider;
              if (targetProvider && typeof targetProvider.refresh === "function") {
                try {
                  targetProvider.refresh(newQuery);
                } catch (e) {
                }
              } else if (extensionContextRef2) {
                ensureActiveConnection(extensionContextRef2, newConn, { refresh: true }).catch(
                  (err) => {
                  }
                );
              }
              lastQueriedActiveConnectionId = newConn;
              lastQueriedQuery = newQuery;
            }
          }
        } catch (e) {
        }
        try {
          vscode16.commands.executeCommand(
            "setContext",
            "azureDevOpsInt.debugViewVisible",
            !!snapshot2.context?.debugViewVisible
          ).then(
            () => {
            },
            () => {
            }
          );
        } catch {
        }
      }
    });
  }
  const commandContext = {
    context,
    panel,
    provider,
    sessionTelemetry,
    client,
    statusBarItem,
    authStatusBarItem
  };
  const commandDisposables = registerCommands(context, commandContext);
  context.subscriptions.push(...commandDisposables);
  context.subscriptions.push(
    vscode16.workspace.onDidChangeConfiguration(async (e) => {
      if (e.affectsConfiguration(CONFIG_NS)) {
        await loadConnectionsFromConfig2(context);
        ensureActiveConnection(context, activeConnectionId2, { refresh: true }).catch((error) => {
        });
      }
    })
  );
  ensureActiveConnection(context, activeConnectionId2, { refresh: true }).then(() => {
    setTimeout(() => {
      updateAuthStatusBar().catch((error) => {
      });
    }, 500);
  }).catch((error) => {
    setTimeout(() => {
      updateAuthStatusBar().catch((err) => {
      });
    }, 500);
  });
  setTimeout(() => {
    updateAuthStatusBar().catch((err) => {
    });
  }, 1e3);
  startCacheCleanup();
  if (tokenRefreshInterval) clearInterval(tokenRefreshInterval);
  tokenRefreshInterval = setInterval(
    () => {
      for (const connectionId of connectionStates2.keys()) {
        dispatchApplicationEvent({ type: "REFRESH_TOKEN", connectionId });
      }
    },
    15 * 60 * 1e3
  );
  for (const connectionId of connectionStates2.keys()) {
    updateBuildRefreshTimer(connectionId, connectionStates2.get(connectionId)?.provider, true);
  }
  if (global.gc) {
    if (gcInterval) clearInterval(gcInterval);
    gcInterval = setInterval(
      () => {
        global.gc?.();
      },
      5 * 60 * 1e3
    );
  }
}
function deactivate() {
  stopCacheCleanup();
  for (const connectionId of connectionStates2.keys()) {
    updateBuildRefreshTimer(connectionId, void 0, false);
  }
  if (tokenRefreshInterval) {
    clearInterval(tokenRefreshInterval);
    tokenRefreshInterval = void 0;
  }
  if (gcInterval) {
    clearInterval(gcInterval);
    gcInterval = void 0;
  }
  connectionStates2.clear();
  activeQueryByConnection.clear();
  dispatchApplicationEvent({ type: "EXTENSION_DEACTIVATED" });
  return Promise.resolve();
}
function getSerializableContext(context) {
  if (!context) {
    return {};
  }
  if (shouldLogDebug2()) {
  }
  let workItemsError = void 0;
  let workItemsErrorConnectionId = void 0;
  if (context.activeConnectionId) {
    try {
      const connectionStatesMap = context.connectionStates instanceof Map ? context.connectionStates : context.connectionStates ? new Map(Object.entries(context.connectionStates)) : /* @__PURE__ */ new Map();
      const praxisConnectionState = connectionStatesMap.get(context.activeConnectionId);
      if (praxisConnectionState && (!praxisConnectionState.isConnected || praxisConnectionState.state === "disconnected" || praxisConnectionState.state === "auth_failed")) {
        const activeConnection = context.connections?.find(
          (c) => c.id === context.activeConnectionId
        );
        const isEntraAuth = activeConnection?.authMethod === "entra";
        if (praxisConnectionState.state === "auth_failed") {
          workItemsError = isEntraAuth ? "Entra ID authentication failed. Start a new sign-in to choose PAT or begin device code again." : "Authentication failed. Please check your credentials and try again.";
        } else if (!praxisConnectionState.isConnected || praxisConnectionState.state === "disconnected") {
          workItemsError = isEntraAuth ? "Connection not authenticated. Sign in to continue." : "Connection not authenticated. Please configure your credentials.";
        }
        if (workItemsError) {
          workItemsErrorConnectionId = context.activeConnectionId;
        }
      }
      const connectionService = ConnectionService.getInstance();
      const connectionManager = connectionService.getConnectionManager(context.activeConnectionId);
      if (connectionManager) {
        const connectionData = connectionManager.getConnectionData();
        if (connectionData.lastError) {
          workItemsError = connectionData.lastError;
          workItemsErrorConnectionId = context.activeConnectionId;
        }
      }
    } catch (e) {
      if (shouldLogDebug2()) {
      }
    }
  }
  const serialized = {
    isActivated: context.isActivated,
    isDeactivating: context.isDeactivating,
    connections: context.connections || [],
    activeConnectionId: context.activeConnectionId,
    activeQuery: context.activeQuery,
    connectionStates: context.connectionStates ? Object.fromEntries(context.connectionStates) : {},
    pendingAuthReminders: context.pendingAuthReminders ? Object.fromEntries(context.pendingAuthReminders) : {},
    pendingWorkItems: context.pendingWorkItems,
    workItems: context.pendingWorkItems?.workItems || [],
    timerState: context.timerState,
    lastError: context.lastError ? { message: context.lastError.message, stack: context.lastError.stack } : void 0,
    errorRecoveryAttempts: context.errorRecoveryAttempts,
    viewMode: context.viewMode,
    kanbanColumns: context.kanbanColumns,
    workItemsError,
    workItemsErrorConnectionId,
    debugLoggingEnabled: context.debugLoggingEnabled,
    debugViewVisible: context.debugViewVisible,
    // Serialize per-connection Maps to plain objects for webview
    connectionQueries: context.connectionQueries ? Object.fromEntries(context.connectionQueries) : {},
    connectionWorkItems: context.connectionWorkItems ? Object.fromEntries(context.connectionWorkItems) : {},
    connectionFilters: context.connectionFilters ? Object.fromEntries(context.connectionFilters) : {},
    connectionViewModes: context.connectionViewModes ? Object.fromEntries(context.connectionViewModes) : {},
    deviceCodeSession: context.deviceCodeSession ? {
      connectionId: context.deviceCodeSession.connectionId,
      userCode: context.deviceCodeSession.userCode,
      verificationUri: context.deviceCodeSession.verificationUri,
      startedAt: context.deviceCodeSession.startedAt,
      expiresAt: context.deviceCodeSession.expiresAt,
      expiresInSeconds: context.deviceCodeSession.expiresInSeconds,
      remainingMs: Math.max(context.deviceCodeSession.expiresAt - Date.now(), 0)
    } : void 0,
    authCodeFlowSession: context.authCodeFlowSession ? {
      connectionId: context.authCodeFlowSession.connectionId,
      authorizationUrl: context.authCodeFlowSession.authorizationUrl,
      startedAt: context.authCodeFlowSession.startedAt,
      expiresAt: context.authCodeFlowSession.expiresAt,
      expiresInSeconds: context.authCodeFlowSession.expiresInSeconds,
      remainingMs: Math.max(context.authCodeFlowSession.expiresAt - Date.now(), 0)
    } : void 0
  };
  if (shouldLogDebug2()) {
  }
  return serialized;
}
async function handleAuthRedirect(uri, context, pendingAuthProviders) {
  try {
    const params = new URLSearchParams(uri.query);
    const authorizationCode = params.get("code");
    const state2 = params.get("state");
    const error = params.get("error");
    const errorDescription = params.get("error_description");
    if (error) {
      const errorMsg = errorDescription || error;
      vscode16.window.showErrorMessage(`Authentication failed: ${errorMsg}`);
      return;
    }
    if (!authorizationCode || !state2) {
      vscode16.window.showErrorMessage("Invalid authentication response");
      return;
    }
    let connectionId;
    let provider2;
    for (const [connId, prov] of pendingAuthProviders.entries()) {
      const pendingState = prov.getPendingAuthState?.();
      if (pendingState === state2) {
        connectionId = connId;
        provider2 = prov;
        break;
      }
    }
    if (!provider2 || !connectionId) {
      vscode16.window.showErrorMessage("Authentication session expired. Please try again.");
      return;
    }
    dispatchApplicationEvent(
      AuthRedirectReceivedAppEvent.create({
        connectionId,
        authorizationCode,
        state: state2
      })
    );
    const result = await provider2.handleRedirectUri(uri);
    if (result.success) {
      dispatchApplicationEvent(
        AuthCodeFlowCompletedAppEvent.create({
          connectionId,
          success: true
        })
      );
      pendingAuthProviders.delete(connectionId);
      vscode16.window.showInformationMessage("Authentication successful!");
    } else {
      dispatchApplicationEvent(
        AuthCodeFlowCompletedAppEvent.create({
          connectionId,
          success: false,
          error: result.error
        })
      );
      vscode16.window.showErrorMessage(`Authentication failed: ${result.error}`);
    }
  } catch (error) {
    vscode16.window.showErrorMessage(`Authentication error: ${error.message}`);
  }
}
var vscode16, fs2, path2, CONFIG_NS, CONNECTIONS_CONFIG_KEY, ACTIVE_CONNECTION_STATE_KEY, panel, lastStateSignature, lastResetAuthTime, RESET_AUTH_DEBOUNCE_MS, provider, sessionTelemetry, client, statusBarItem, authStatusBarItem, viewProviderRegistered, initialRefreshedConnections, connections2, connectionStates2, activeConnectionId2, recentlySignedOutConnections, tokenRefreshInterval, gcInterval, rejectionHandler, sharedContextBridge, extensionContextRef2, lastQueriedActiveConnectionId, lastQueriedQuery, DEFAULT_QUERY2, activeQueryByConnection, ACTIVE_QUERY_STATE_KEY, IS_SMOKE, AzureDevOpsIntViewProvider;
var init_activation = __esm({
  "src/activation.ts"() {
    vscode16 = __toESM(require("vscode"), 1);
    fs2 = __toESM(require("fs"), 1);
    path2 = __toESM(require("path"), 1);
    init_branchEnrichment();
    init_providerFactory();
    init_sharedContextBridge();
    init_logging();
    init_cache();
    init_connectionNormalization();
    init_patMigration();
    init_extensionHostBridge();
    init_commands();
    init_traceCommands();
    init_quickDebugCommands();
    init_historyDebugCommands();
    init_testGeneratorCommands();
    init_service();
    init_facts2();
    init_MessageInterceptor();
    init_StandardizedAutomaticLogger();
    CONFIG_NS = "azureDevOpsIntegration";
    CONNECTIONS_CONFIG_KEY = "connections";
    ACTIVE_CONNECTION_STATE_KEY = "azureDevOpsInt.activeConnectionId";
    lastStateSignature = void 0;
    lastResetAuthTime = 0;
    RESET_AUTH_DEBOUNCE_MS = 2e3;
    viewProviderRegistered = false;
    initialRefreshedConnections = /* @__PURE__ */ new Set();
    connections2 = [];
    connectionStates2 = /* @__PURE__ */ new Map();
    recentlySignedOutConnections = /* @__PURE__ */ new Set();
    DEFAULT_QUERY2 = "My Activity";
    activeQueryByConnection = /* @__PURE__ */ new Map();
    ACTIVE_QUERY_STATE_KEY = "azureDevOpsInt.activeQueryByConnection";
    IS_SMOKE = process.env.VSCODE_INTEGRATION_SMOKE === "1" || isVSCodeTestRun();
    AzureDevOpsIntViewProvider = class {
      view;
      extensionUri;
      appActor;
      constructor(_context) {
        this.extensionUri = _context.extensionUri;
        this.appActor = getApplicationActor();
      }
      resolveWebviewView(webviewView, _context, _token) {
        this.view = webviewView;
        panel = webviewView;
        const webview = webviewView.webview;
        let interceptedWebview;
        try {
          interceptedWebview = interceptWebviewMessages(webview, "webview-provider");
        } catch (err) {
        }
        webview.options = {
          enableScripts: true,
          localResourceRoots: [vscode16.Uri.joinPath(this.extensionUri, "media")]
        };
        const nonce = getNonce();
        const scriptUri = webview.asWebviewUri(
          vscode16.Uri.joinPath(this.extensionUri, "media", "webview", "main.js")
        );
        const mainCssUri = webview.asWebviewUri(
          vscode16.Uri.joinPath(this.extensionUri, "media", "webview", "main.css")
        );
        const csp = `default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; script-src 'nonce-${nonce}' 'unsafe-eval'; img-src ${webview.cspSource} data:; connect-src 'self';`;
        webview.html = `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="Content-Security-Policy" content="${csp}">
        <link href="${mainCssUri}" rel="stylesheet">
        <title>Work Items</title>
      </head>
      <body>
        <div id="svelte-root" style="padding:12px;font-family:var(--vscode-font-family,sans-serif);color:var(--vscode-foreground);">
          <div style="opacity:0.8">Loading Azure DevOps Integration\u2026</div>
        </div>
        <script nonce="${nonce}">
          // Early error trap before module loads
          (function() {
            const vscode = typeof acquireVsCodeApi === 'function' ? acquireVsCodeApi() : undefined;
            const post = (payload) => {
              try { vscode?.postMessage({ type: 'webviewPreError', payload }); } catch {}
            };
            window.addEventListener('error', (event) => {
              post({ kind: 'error', message: String(event.message), filename: event.filename, lineno: event.lineno, colno: event.colno, stack: event.error?.stack });
            });
            window.addEventListener('unhandledrejection', (event) => {
              post({ kind: 'unhandledrejection', reason: String((event as any)?.reason) });
            });
            post({ kind: 'preload_ready', readyState: document.readyState });
          })();
        </script>
        <script type="module" nonce="${nonce}" src="${scriptUri}"></script>
      </body>
      </html>
    `;
        const bridge = sharedContextBridge;
        if (bridge?.attachWebview) {
          try {
            bridge.attachWebview(webview);
          } catch (error) {
          }
          webviewView.onDidDispose(() => {
            try {
              bridge?.detachWebview();
            } catch (error) {
            }
            if (panel === webviewView) {
              panel = void 0;
            }
          });
        }
        const sendCurrentState = () => {
          const appActor = getApplicationStoreActor();
          if (appActor) {
            let snapshot2 = void 0;
            let matchesFn = void 0;
            if (typeof appActor.getApplicationState === "function") {
              const manager = appActor;
              const state2 = manager.getApplicationState();
              const context = manager.getContext();
              snapshot2 = {
                value: state2,
                context
              };
              matchesFn = (stateValue) => {
                if (typeof stateValue === "string") {
                  return state2 === stateValue || typeof state2 === "string" && state2.includes(stateValue);
                }
                if (typeof stateValue === "object" && stateValue !== null) {
                  const key2 = Object.keys(stateValue)[0];
                  const subValue = stateValue[key2];
                  if (typeof state2 === "string") {
                    if (state2 === key2) {
                      return false;
                    }
                    if (typeof subValue === "string") {
                      return state2 === `${key2}.${subValue}` || state2.startsWith(`${key2}.${subValue}.`);
                    }
                    return false;
                  }
                  if (typeof state2 === "object" && state2 !== null) {
                    const stateSubValue = state2[key2];
                    if (stateSubValue === subValue) return true;
                    if (typeof subValue === "string" && typeof stateSubValue === "object" && stateSubValue !== null) {
                      return Object.keys(stateSubValue)[0] === subValue;
                    }
                    return false;
                  }
                }
                return false;
              };
            } else if (typeof appActor.getSnapshot === "function") {
              snapshot2 = appActor.getSnapshot();
              matchesFn = snapshot2?.matches ? snapshot2.matches.bind(snapshot2) : () => false;
            }
            if (snapshot2 && matchesFn) {
              const allMatches = {
                inactive: matchesFn("inactive"),
                activating: matchesFn("activating"),
                activation_failed: matchesFn("activation_failed"),
                active: matchesFn("active"),
                error_recovery: matchesFn("error_recovery"),
                deactivating: matchesFn("deactivating"),
                "active.setup": matchesFn({ active: "setup" }),
                "active.setup.loading_connections": matchesFn({
                  active: { setup: "loading_connections" }
                }),
                "active.setup.waiting_for_panel": matchesFn({
                  active: { setup: "waiting_for_panel" }
                }),
                "active.setup.panel_ready": matchesFn({ active: { setup: "panel_ready" } }),
                "active.setup.setup_error": matchesFn({ active: { setup: "setup_error" } }),
                "active.ready": matchesFn({ active: "ready" }),
                "active.ready.idle": matchesFn({ active: { ready: "idle" } }),
                "active.ready.loadingData": matchesFn({ active: { ready: "loadingData" } }),
                "active.ready.managingConnections": matchesFn({
                  active: { ready: "managingConnections" }
                }),
                "active.ready.error": matchesFn({ active: { ready: "error" } })
              };
              const matches = {};
              for (const [key2, value] of Object.entries(allMatches)) {
                if (value === true) {
                  matches[key2] = true;
                }
              }
              const serializableState = {
                praxisState: snapshot2.value,
                context: getSerializableContext(snapshot2.context),
                matches
              };
              const signature = JSON.stringify(serializableState);
              if (signature === lastStateSignature) {
                return;
              }
              lastStateSignature = signature;
              const webviewToUse2 = interceptedWebview || webview;
              webviewToUse2.postMessage({
                type: "syncState",
                payload: serializableState
              });
            }
          }
        };
        const webviewToUse = interceptedWebview || webview;
        webviewToUse.onDidReceiveMessage(async (message) => {
          if (sharedContextBridge?.handleWebviewMessage?.(message)) {
            return;
          }
          if (message?.type === "getContext") {
            sendCurrentState();
            return;
          }
          if (message?.type === "webviewPreError") {
            return;
          }
          if (message?.type === "webviewLog") {
            return;
          }
          if (message.type === "webviewReady" || message.type === "ready") {
            sendCurrentState();
            return;
          }
          if (message.type === "PRAXIS_EVENT" && Array.isArray(message.events)) {
            return;
          }
          if (message.type === "appEvent" && message.event) {
            try {
              const actor = getApplicationActor();
              const snapshot2 = actor?.getSnapshot?.();
              const currentActiveId = snapshot2?.context?.activeConnectionId;
              const evtType = message.event.type;
              try {
                const { stampConnectionMeta: stampConnectionMeta2 } = await Promise.resolve().then(() => (init_stamp(), stamp_exports));
                message.event = stampConnectionMeta2(message.event, currentActiveId);
              } catch {
              }
              if (evtType === "SELECT_CONNECTION") {
                if (message.event.origin !== "webview") {
                  return;
                }
                const targetId = message.event?.payload?.id ?? null;
                if (typeof targetId === "string") {
                  dispatchApplicationEvent({
                    type: "SELECT_CONNECTION",
                    connectionId: targetId
                  });
                  return;
                } else if (targetId === null) {
                  dispatchApplicationEvent({
                    type: "CONNECTION_SELECTED",
                    connectionId: null
                  });
                  return;
                }
              }
            } catch {
            }
            if (message.event.type === "OPEN_SETTINGS") {
              vscode16.commands.executeCommand("azureDevOpsInt.setup").then(() => {
              }).then(void 0, (err) => {
              });
              return;
            }
            if (message.event.type === "RESET_AUTH") {
              const now = Date.now();
              const timeSinceLastReset = now - lastResetAuthTime;
              if (timeSinceLastReset < RESET_AUTH_DEBOUNCE_MS) {
                return;
              }
              lastResetAuthTime = now;
              const connectionId = message.event.connectionId;
              if (connectionId) {
                dispatchApplicationEvent({
                  type: "SIGN_OUT_ENTRA",
                  connectionId
                });
              }
              vscode16.commands.executeCommand("azureDevOpsInt.setup").then(() => {
              }).then(void 0, (err) => {
              });
              return;
            }
            if (message.event.type === "OPEN_DEVICE_CODE_BROWSER") {
              const actor = getApplicationActor();
              const snapshot2 = actor?.getSnapshot?.();
              const deviceCodeSession = snapshot2?.context?.deviceCodeSession;
              if (deviceCodeSession && deviceCodeSession.connectionId === message.event.connectionId) {
                if (!deviceCodeSession.userCode || deviceCodeSession.userCode.trim() === "") {
                  vscode16.window.showErrorMessage(
                    "Device code is not available. Please try signing in again."
                  );
                  dispatchApplicationEvent(
                    ApplicationErrorEvent.create({
                      error: "Device code is empty or missing",
                      connectionId: message.event.connectionId
                    })
                  );
                  return;
                }
                vscode16.env.clipboard.writeText(deviceCodeSession.userCode).then(() => {
                  const uri = vscode16.Uri.parse(
                    deviceCodeSession.verificationUri || "https://microsoft.com/devicelogin"
                  );
                  vscode16.env.openExternal(uri).then(() => {
                    vscode16.window.showInformationMessage(
                      `Device code ${deviceCodeSession.userCode} copied to clipboard. Paste it into the browser to finish signing in.`
                    );
                    dispatchApplicationEvent(
                      DeviceCodeBrowserOpenedEvent.create({
                        connectionId: message.event.connectionId,
                        userCode: deviceCodeSession.userCode
                      })
                    );
                  }).then(void 0, (err) => {
                    dispatchApplicationEvent(
                      DeviceCodeBrowserOpenFailedEvent.create({
                        connectionId: message.event.connectionId,
                        error: err instanceof Error ? err.message : String(err)
                      })
                    );
                    vscode16.window.showErrorMessage(
                      "Failed to open browser. Code was copied to clipboard."
                    );
                  });
                }).then(void 0, (err) => {
                  dispatchApplicationEvent(
                    DeviceCodeCopyFailedEvent.create({
                      connectionId: message.event.connectionId,
                      error: err instanceof Error ? err.message : String(err)
                    })
                  );
                  vscode16.window.showErrorMessage(
                    `Failed to copy device code to clipboard: ${err instanceof Error ? err.message : String(err)}`
                  );
                  const uri = vscode16.Uri.parse(
                    deviceCodeSession.verificationUri || "https://microsoft.com/devicelogin"
                  );
                  vscode16.env.openExternal(uri).then(void 0, () => {
                  });
                });
              } else {
                dispatchApplicationEvent(
                  DeviceCodeSessionNotFoundEvent.create({
                    connectionId: message.event.connectionId
                  })
                );
                vscode16.window.showWarningMessage(
                  "Device code session not found. Please try signing in again."
                );
              }
              return;
            }
            if (message.event.type === "OPEN_AUTH_CODE_FLOW_BROWSER") {
              const actor = getApplicationActor();
              const snapshot2 = actor?.getSnapshot?.();
              const authCodeFlowSession = snapshot2?.context?.authCodeFlowSession;
              if (authCodeFlowSession && authCodeFlowSession.connectionId === message.event.connectionId) {
                const uri = vscode16.Uri.parse(authCodeFlowSession.authorizationUrl);
                vscode16.env.openExternal(uri).then(() => {
                  dispatchApplicationEvent(
                    AuthCodeFlowBrowserOpenedEvent.create({
                      connectionId: message.event.connectionId,
                      url: authCodeFlowSession.authorizationUrl
                    })
                  );
                }).then(void 0, (err) => {
                  dispatchApplicationEvent(
                    AuthCodeFlowBrowserOpenFailedEvent.create({
                      connectionId: message.event.connectionId,
                      error: err instanceof Error ? err.message : String(err)
                    })
                  );
                });
              } else {
                dispatchApplicationEvent(
                  ApplicationErrorEvent.create({
                    error: "Auth code flow session not found for connection",
                    connectionId: message.event.connectionId
                  })
                );
              }
              return;
            }
            dispatchApplicationEvent(message.event);
          } else {
            if (message.event && message.event.type === "COPY_DEVICE_CODE") {
              const actor = getApplicationActor();
              const snapshot2 = actor?.getSnapshot?.();
              const deviceCodeSession = snapshot2?.context?.deviceCodeSession;
              if (deviceCodeSession && deviceCodeSession.connectionId === message.event.connectionId) {
                if (!deviceCodeSession.userCode || deviceCodeSession.userCode.trim() === "") {
                  vscode16.window.showErrorMessage(
                    "Device code is not available. Please try signing in again."
                  );
                  return;
                }
                vscode16.env.clipboard.writeText(deviceCodeSession.userCode).then(() => {
                  vscode16.window.showInformationMessage(
                    `Device code ${deviceCodeSession.userCode} copied to clipboard`
                  );
                }).then(void 0, (err) => {
                  vscode16.window.showErrorMessage(
                    `Failed to copy device code to clipboard: ${err instanceof Error ? err.message : String(err)}`
                  );
                });
              } else {
                vscode16.window.showWarningMessage(
                  "Device code session not found. Please try signing in again."
                );
              }
              return;
            }
          }
        });
        this.appActor?.send?.({ type: "UPDATE_WEBVIEW_PANEL", webviewPanel: webviewView });
        sendCurrentState();
      }
    };
  }
});
init_activation();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  __setTestContext,
  activate,
  buildMinimalWebviewHtml,
  clearConnectionState,
  clearSignedOutFlag,
  deactivate,
  dispatchApplicationEvent,
  forwardProviderMessage,
  handleMessage,
  loadConnectionsFromConfig,
  markConnectionSignedOut,
  migrateLegacyPAT,
  panel,
  resolveDefaultQuery,
  updateAuthStatusBar
});
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.1 https://github.com/nodeca/js-yaml @license MIT *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

@azure/msal-node/dist/cache/serializer/Serializer.mjs:
@azure/msal-node/dist/cache/serializer/Deserializer.mjs:
@azure/msal-node/dist/internals.mjs:
@azure/msal-node/dist/utils/Constants.mjs:
@azure/msal-node/dist/utils/NetworkUtils.mjs:
@azure/msal-node/dist/packageMetadata.mjs:
@azure/msal-node/dist/network/HttpClient.mjs:
@azure/msal-node/dist/error/ManagedIdentityErrorCodes.mjs:
@azure/msal-node/dist/error/ManagedIdentityError.mjs:
@azure/msal-node/dist/config/ManagedIdentityId.mjs:
@azure/msal-node/dist/error/NodeAuthError.mjs:
@azure/msal-node/dist/config/Configuration.mjs:
@azure/msal-node/dist/crypto/GuidGenerator.mjs:
@azure/msal-node/dist/utils/EncodingUtils.mjs:
@azure/msal-node/dist/crypto/HashUtils.mjs:
@azure/msal-node/dist/crypto/PkceGenerator.mjs:
@azure/msal-node/dist/crypto/CryptoProvider.mjs:
@azure/msal-node/dist/cache/CacheHelpers.mjs:
@azure/msal-node/dist/cache/NodeStorage.mjs:
@azure/msal-node/dist/cache/TokenCache.mjs:
@azure/msal-node/dist/client/ClientAssertion.mjs:
@azure/msal-node/dist/client/UsernamePasswordClient.mjs:
@azure/msal-node/dist/protocol/Authorize.mjs:
@azure/msal-node/dist/client/ClientApplication.mjs:
@azure/msal-node/dist/network/LoopbackClient.mjs:
@azure/msal-node/dist/client/DeviceCodeClient.mjs:
@azure/msal-node/dist/client/PublicClientApplication.mjs:
@azure/msal-node/dist/client/ClientCredentialClient.mjs:
@azure/msal-node/dist/client/OnBehalfOfClient.mjs:
@azure/msal-node/dist/client/ConfidentialClientApplication.mjs:
@azure/msal-node/dist/utils/TimeUtils.mjs:
@azure/msal-node/dist/network/HttpClientWithRetries.mjs:
@azure/msal-node/dist/client/ManagedIdentitySources/BaseManagedIdentitySource.mjs:
@azure/msal-node/dist/retry/LinearRetryStrategy.mjs:
@azure/msal-node/dist/retry/DefaultManagedIdentityRetryPolicy.mjs:
@azure/msal-node/dist/config/ManagedIdentityRequestParameters.mjs:
@azure/msal-node/dist/client/ManagedIdentitySources/AppService.mjs:
@azure/msal-node/dist/client/ManagedIdentitySources/AzureArc.mjs:
@azure/msal-node/dist/client/ManagedIdentitySources/CloudShell.mjs:
@azure/msal-node/dist/retry/ExponentialRetryStrategy.mjs:
@azure/msal-node/dist/retry/ImdsRetryPolicy.mjs:
@azure/msal-node/dist/client/ManagedIdentitySources/Imds.mjs:
@azure/msal-node/dist/client/ManagedIdentitySources/ServiceFabric.mjs:
@azure/msal-node/dist/client/ManagedIdentitySources/MachineLearning.mjs:
@azure/msal-node/dist/client/ManagedIdentityClient.mjs:
@azure/msal-node/dist/client/ManagedIdentityApplication.mjs:
@azure/msal-node/dist/cache/distributed/DistributedCachePlugin.mjs:
@azure/msal-node/dist/index.mjs:
  (*! @azure/msal-node v3.8.4 2025-12-04 *)

@azure/msal-common/dist/utils/Constants.mjs:
@azure/msal-common/dist/error/AuthErrorCodes.mjs:
@azure/msal-common/dist/error/AuthError.mjs:
@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs:
@azure/msal-common/dist/error/ClientAuthError.mjs:
@azure/msal-common/dist/crypto/ICrypto.mjs:
@azure/msal-common/dist/logger/Logger.mjs:
@azure/msal-common/dist/packageMetadata.mjs:
@azure/msal-common/dist/authority/AuthorityOptions.mjs:
@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs:
@azure/msal-common/dist/error/ClientConfigurationError.mjs:
@azure/msal-common/dist/utils/StringUtils.mjs:
@azure/msal-common/dist/request/ScopeSet.mjs:
@azure/msal-common/dist/account/ClientInfo.mjs:
@azure/msal-common/dist/account/AccountInfo.mjs:
@azure/msal-common/dist/authority/AuthorityType.mjs:
@azure/msal-common/dist/account/TokenClaims.mjs:
@azure/msal-common/dist/authority/ProtocolMode.mjs:
@azure/msal-common/dist/cache/entities/AccountEntity.mjs:
@azure/msal-common/dist/account/AuthToken.mjs:
@azure/msal-common/dist/utils/UrlUtils.mjs:
@azure/msal-common/dist/url/UrlString.mjs:
@azure/msal-common/dist/authority/AuthorityMetadata.mjs:
@azure/msal-common/dist/error/CacheErrorCodes.mjs:
@azure/msal-common/dist/error/CacheError.mjs:
@azure/msal-common/dist/cache/CacheManager.mjs:
@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs:
@azure/msal-common/dist/telemetry/performance/StubPerformanceClient.mjs:
@azure/msal-common/dist/config/ClientConfiguration.mjs:
@azure/msal-common/dist/account/CcsCredential.mjs:
@azure/msal-common/dist/constants/AADServerParamKeys.mjs:
@azure/msal-common/dist/request/RequestParameterBuilder.mjs:
@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs:
@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs:
@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs:
@azure/msal-common/dist/utils/FunctionWrappers.mjs:
@azure/msal-common/dist/authority/RegionDiscovery.mjs:
@azure/msal-common/dist/utils/TimeUtils.mjs:
@azure/msal-common/dist/cache/utils/CacheHelpers.mjs:
@azure/msal-common/dist/authority/Authority.mjs:
@azure/msal-common/dist/authority/AuthorityFactory.mjs:
@azure/msal-common/dist/error/ServerError.mjs:
@azure/msal-common/dist/network/RequestThumbprint.mjs:
@azure/msal-common/dist/network/ThrottlingUtils.mjs:
@azure/msal-common/dist/error/NetworkError.mjs:
@azure/msal-common/dist/client/BaseClient.mjs:
@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs:
@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs:
@azure/msal-common/dist/utils/ProtocolUtils.mjs:
@azure/msal-common/dist/crypto/PopTokenGenerator.mjs:
@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs:
@azure/msal-common/dist/response/ResponseHandler.mjs:
@azure/msal-common/dist/utils/ClientAssertionUtils.mjs:
@azure/msal-common/dist/client/AuthorizationCodeClient.mjs:
@azure/msal-common/dist/client/RefreshTokenClient.mjs:
@azure/msal-common/dist/client/SilentFlowClient.mjs:
@azure/msal-common/dist/protocol/Authorize.mjs:
@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs:
@azure/msal-common/dist/index-node.mjs:
@azure/msal-common/dist/index.mjs:
  (*! @azure/msal-common v15.13.3 2025-12-04 *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=extension.cjs.map

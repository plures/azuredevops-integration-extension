# Migrating xstate-svelte to Svelte 5 rune-native helpers

This document explains how to migrate from the prior xstate/svelte helpers (svelte/store-based) to the new Svelte‑5 rune‑native helpers we added (rune-first API + pub/sub remote-machine helpers, optimistic updates, and subseq/pubseq reconciliation). It covers the reasoning, concrete code changes, configuration tips, and a migration checklist so you can adopt the new pattern incrementally.

Audience

- Svelte 5 app teams who want native rune semantics in their webviews and components.
- VS Code extension authors that run authoritative XState machines in the extension host and render UI in a webview.
- Teams who want deterministic UI (machine-owned context) and optional optimistic UI behavior.

Goals

- Make Svelte 5 runes the default developer experience for Svelte 5 projects.
- Keep a svelte/store fallback for non‑Svelte‑5 contexts (webviews, tests).
- Provide a pub/sub broker pattern that treats webviews as appendages of the authoritative application machine.
- Provide optional optimistic updates (deterministic reducer) with robust reconciliation using subseq (subscriber sequence) and pubseq (publisher sequence) semantics.

Files added (where to import from)

- packages/xstate-svelte/src/useRemoteMachine.runes.ts — Rune-first helper (recommended for Svelte 5)
- packages/xstate-svelte/src/useRemoteMachine.ts — svelte/store fallback
- packages/xstate-svelte/src/useRemoteMachinePubSub.ts — pub/sub adapter helper
- examples/... (broker, example machine, webview adapter, rune-first example component)

High-level migration strategy

1. Decide whether the web UI will be rune-first (Svelte 5) or must use the fallback store API.
   - Svelte 5 components: migrate to the rune-first helpers.
   - Legacy webviews, tests: keep using the store-based fallback.
2. Prefer moving UI logic into the authoritative machine’s context (recommended). UI components should assertively render data from the context and only emit events (with sender ids) back to the machine.
3. Adopt the pub/sub broker if you need multiple webviews or want retained snapshots on subscribe and simplified host ↔ webview wiring.
4. Optionally add an optimized optimistic reducer for snappy UX; reconcile on authoritative snapshots using subseq/pubseq.

Important naming: subseq and pubseq

- subseq: the monotonic sequence number generated by subscribers (webviews) for their outgoing events. Equivalent of "client sequence" in previous doc.
- pubseq: the monotonic sequence number from the publisher (host/broker) attached to retained snapshots.
- echoSubseq: value placed in retained snapshot payload to acknowledge subseq(s) the host consumed — used to clear pending optimistic entries.

Migration details & examples

1. Replace svelte/store helpers with rune-first helpers

Old (store-based)

```ts
import { useMachine } from 'xstate-svelte';
const { state, send } = useMachine(machine);
```

New (rune-first)

```ts
// Svelte 5 runtimes vary—adjust import to your environment
import { state as $state, derived as $derived, effect as $effect } from 'svelte/runes';
import { useRemoteMachineRunes } from 'xstate-svelte';

const runes = { state: $state, derived: $derived, effect: $effect };
const { state, send, requestSnapshot, connected } = useRemoteMachineRunes('machine-id', runes);

// read in template with rune extraction
// $state(state) -> authoritative snapshot JS value
```

Notes:

- The rune helper returns `state` as a rune, not a svelte/store Readable. In Svelte templates you typically use $state(state) (or your runtime’s preferred extraction) to get the JS value. Adjust access to match your Svelte runtime.
- `useRemoteMachineRunes` wires handshake & lifecycle using `runes.effect` so setup/cleanup are native.

2. Deterministic UIs — use machine context for button labels

Old approach (UI derived logic):

- UI derives whether to show "ON"/"OFF" from state.matches('on')

New recommended approach (authoritative context):

- The authoritative machine stores UI fields in `context`, e.g.:
  ```ts
  context: {
    buttons: {
      btn1: { label: { value: 'OFF' } },
      btn2: { label: { value: 'OFF' } }
    }
  }
  ```
- The webview simply renders the label from snapshot.context and sends events:
  ```ts
  function onClick(buttonId) {
    send({ type: 'click', sender: buttonId });
  }
  ```

This retains determinism and makes reasoning about UI simple and testable.

3. Pub/Sub broker and topics

Adopt the broker pattern where the host publishes to topics and webviews subscribe.

Common topic patterns:

- `machine:<id>:snapshot` — retained authoritative snapshot topic (host publishes, retained by broker)
- `machine:<id>:events` — webviews publish events here (payloads include subseq)
- `machine:<id>:requestSnapshot` — webview asks for immediate replay

Message envelopes (canonical)

- Webview -> publish event:
  ```json
  {
    "type": "pubsub:publish",
    "topic": "machine:appToggle-1:events",
    "payload": { "event": { "type": "click", "sender": "btn1" }, "subseq": 4 },
    "retain": false
  }
  ```
- Broker -> subscribers (retained snapshot message):
  ```json
  {
    "type": "pubsub:message",
    "topic": "machine:appToggle-1:snapshot",
    "payload": {
      "state": {
        "value": "ready",
        "context": {
          /* ... */
        }
      },
      "echoSubseq": 4
    },
    "pubseq": 123
  }
  ```

4. Optimistic updates (webview-side)

Purpose: make UI feel instant while host remains authoritative.

API (webview helper):

- Provide `optimistic.reducer(snapshot, event, subseq)` to the helper (useRemoteMachinePubSub or useRemoteMachineRunes opts).
- Behavior:
  - When sending an event, the helper increments `subseq`, stores pending[subseq] = { event, ts, optimisticSnapshot }, applies optimisticSnapshot to local state.
  - The event is published to the `events` topic with `subseq`.
  - When a snapshot arrives from broker (with `pubseq` and payload.state):
    - If `pubseq` ≤ lastSeenPubseq: ignore (stale)
    - Apply authoritative snapshot (payload.state)
    - If payload.echoSubseq present: drop pending entries ≤ echoSubseq
    - If pending entries remain, replay them (in subseq order) using optimistic.reducer on top of authoritative state and set local state to replay result.

Example optimistic reducer (only UI transient changes)

```ts
function optimisticReducer(snapshot, event, subseq) {
  if (event.type === 'click') {
    const ctx = JSON.parse(JSON.stringify(snapshot.context || {}));
    ctx.buttons = ctx.buttons || {};
    ctx.buttons[event.sender] = ctx.buttons[event.sender] || { label: { value: 'OFF' } };
    ctx.buttons[event.sender].optimistic = { subseq, loading: true };
    return { ...snapshot, context: ctx };
  }
  return snapshot;
}
```

Keep reducer small and deterministic; do not attempt to mirror full machine logic.

5. subseq/pubseq naming and reconciliation details

- subseq: generated by the webview per outgoing event. Monotonic, per-webview (or per-subject) counter.
- pubseq: generated by broker/host for every publish retained message. Monotonic global publisher counter.
- echoSubseq: included in retained snapshot payload to acknowledge that the host processed events up to subseq N.

Reconciliation:

- When webview receives `payload.echoSubseq = N`, it removes pending entries ≤ N and considers those acknowledged.
- Replay rules: for pending entries > N, reapply optimistic.reducer onto authoritative snapshot so local intent persists.

6. Import and bundling rules

Two recommended ways to adopt rune-first file in Svelte 5 builds:

Option A — explicit import (safe)

- Svelte 5 components explicitly import rune-first helper:
  ```ts
  import { useRemoteMachineRunes } from 'xstate-svelte';
  ```
  or
  ```ts
  import { useRemoteMachineRunes } from 'xstate-svelte/src/useRemoteMachine.runes';
  ```

Option B — package exports / build-time aliasing (automated)

- Configure conditional exports in package.json so Svelte builds resolve `useRemoteMachine` to `useRemoteMachine.runes.js`.
- If your bundler supports custom resolve (Vite/Rollup), add an alias:
  ```js
  // vite.config.js
  resolve: {
    alias: {
      'xstate-svelte/useRemoteMachine': 'xstate-svelte/src/useRemoteMachine.runes.ts'
    }
  }
  ```
- Alternatively, maintain explicit imports to avoid bundler config complexity.

7. Fallback for tests and legacy contexts

If you need svelte/store semantics (tests or non-Svelte-5 contexts), import the fallback:

```ts
import { useRemoteMachine } from 'xstate-svelte';
```

It exposes the same API shape but state is a svelte/store Readable and you manage cleanup with `onDestroy` or supply a manual cleanup when runes.effect is not available.

8. Example conversion (full flow)

Old component (store approach):

```svelte
<script>
  import { useMachine } from 'xstate-svelte';
  const { state, send } = useMachine(toggleMachine);
  function onClick() { send('TOGGLE'); }
</script>
<button on:click={onClick}>{$state.matches('on') ? 'ON' : 'OFF'}</button>
```

New rune-first + deterministic context:

- Host machine ensures `context.button.label.value` holds 'ON' | 'OFF'
- Webview:

```svelte
<script lang="ts">
  import { state as $state, effect as $effect } from 'svelte/runes';
  import { useRemoteMachineRunes } from 'xstate-svelte';
  const runes = { state: $state, effect: $effect };
  const { state, send } = useRemoteMachineRunes('toggle-1', runes);
  $effect(() => { requestSnapshot(); });
  function onClick() { send({ type: 'click', sender: 'btn1' }); }
</script>
<button on:click={onClick}>
  {#if $state(state)}
    { $state(state).context.button.label.value }
  {:else}
    Loading…
  {/if}
</button>
```

9. Broker and extension host wiring

Host responsibilities:

- Run the authoritative XState machines.
- Attach them to the PubSubBroker:
  - On every transition: publish snapshot to `machine:<id>:snapshot`. Include `pubseq`.
  - When handling events published to `machine:<id>:events`, forward payload.event into the machine. When snapshot published as result of handling subseq N, include `echoSubseq: N` in snapshot payload so clients can clear pending entries.

Example host publish shape:

```ts
broker.publish(`machine:${id}:snapshot`, {
  state: { value: state.value, context: state.context },
  echoSubseq: maybeSubseqToEcho, // e.g., the subseq from the event that caused this snapshot
});
```

10. Testing & debugging

- Validate subseq echoing: send events with subseq, inspect retained snapshot payloads for `echoSubseq` so pending entries are correctly cleared.
- Inspect pubseq monotonic increments on broker publishes to detect reordering.
- Log pending map on the webview helper to debug stuck optimistic entries.
- If snapshots appear stale, confirm the webview subscribed successfully (broker replay) and that retained snapshot includes current state.

11. Common pitfalls & troubleshooting

- Not echoing subseq: webview pending entries never get cleared → pendingCount grows. Fix: host must echo subseq in a snapshot that reflects handling of the event.
- Overambitious optimistic reducer: trying to mirror full machine logic locally is brittle — keep reducer small and UI-only.
- Rune write semantics: some rune factories may not expose `.set`. The rune-first helpers try `.set` but if your runtime expects a different API, wrap or adapt write calls in a tiny adapter.
- Bundler alias mismatch: ensure imports resolve the rune file for Svelte 5 builds, otherwise you’ll get store-based semantics.

12. Migration checklist (practical)

- [ ] Add runes import lines to Svelte 5 components: `import { state as $state, derived as $derived, effect as $effect } from 'svelte/runes'`.
- [ ] Replace svelte/store helpers with `useRemoteMachineRunes(machineId, runes[, options])`.
- [ ] Move UI decision logic into machine context (e.g., `context.buttons[id].label.value`).
- [ ] If using optimistic UI: implement and pass `optimistic.reducer` to the helper.
- [ ] Ensure host broker echoes `subseq` (as `echoSubseq`) in snapshots that correspond to handled subscriber events.
- [ ] Wire your extension host to publish to `machine:<id>:snapshot` and listen on `machine:<id>:events`.
- [ ] (Optional) Configure bundler alias or package exports to prefer rune file for Svelte 5 builds.
- [ ] Smoke test: open webview, ensure the retained snapshot arrives and UI renders authoritative context immediately, click a button and see event flow and UI update.

13. Example reference snippets & commands

- Example rune import (adjust to your Svelte runtime):
  ```ts
  import { state as $state, derived as $derived, effect as $effect } from 'svelte/runes';
  ```
- Example import in a Svelte 5 project:
  ```ts
  import { useRemoteMachineRunes } from 'xstate-svelte';
  // or explicit path
  // import { useRemoteMachineRunes } from 'xstate-svelte/src/useRemoteMachine.runes';
  ```

14. Recommended follow-ups

- Add a small README in `packages/xstate-svelte/examples` showing the full host + webview run locally (scaffold a minimal VS Code extension example).
- Provide a tiny adapter for runes that unifies `.set` semantics across runtimes (if you have multiple Svelte runtime variants).
- Add a small test harness (node) that simulates broker and webview for integration tests of subseq/pubseq reconciliation.

Questions you might have

- Q: Should I always use runes.effect for setup/cleanup?
  - A: Yes — it gives native lifecycle semantics. If your runtime lacks effect, pass a channel and cleanup manually or use fallback store version.
- Q: When should I use optimistic updates?
  - A: For actions where local transient feedback improves UX (e.g., button shows spinner or adds a temporary item). Keep optimistic reducer small.
- Q: How do I handle multi-client conflicts?
  - A: The authoritative host snapshot wins. You can design reconciliation policies in the optimistic helper but expect authoritative updates to overwrite local state — replay remaining pending events if desired.

Concluding notes

- The rune-first helpers give Svelte 5 apps a native developer experience while the pub/sub broker + subseq/pubseq protocol makes webviews first-class, deterministic appendages of your application machines.
- Keep UI logic in the authoritative machine context and use runes purely for rendering and lifecycle management.
- The provided helpers (rune-first and fallback) let you migrate gradually and keep test and webview contexts working.
